(() => {
    var __webpack_modules__ = {
        4374: function (module, exports) {
            eval(
                'var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * DrawSVGPlugin 3.6.1\n * https://greensock.com\n * \n * @license Copyright 2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n */\n!function (e, t) {\n  "object" == ( false ? 0 : _typeof(exports)) && "undefined" != "object" ? t(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n}(this, function (e) {\n  "use strict";\n\n  function i() {\n    return "undefined" != typeof window;\n  }\n\n  function j() {\n    return a || i() && (a = window.gsap) && a.registerPlugin && a;\n  }\n\n  function m(e) {\n    return Math.round(1e4 * e) / 1e4;\n  }\n\n  function n(e) {\n    return parseFloat(e) || 0;\n  }\n\n  function o(e, t) {\n    var r = n(e);\n    return ~e.indexOf("%") ? r / 100 * t : r;\n  }\n\n  function p(e, t) {\n    return n(e.getAttribute(t));\n  }\n\n  function r(e, t, r, i, s, o) {\n    return P(Math.pow((n(r) - n(e)) * s, 2) + Math.pow((n(i) - n(t)) * o, 2));\n  }\n\n  function s(e) {\n    return console.warn(e);\n  }\n\n  function t(e) {\n    return "non-scaling-stroke" === e.getAttribute("vector-effect");\n  }\n\n  function w(e) {\n    if (!(e = v(e)[0])) return 0;\n    var n,\n        i,\n        o,\n        a,\n        f,\n        h,\n        d,\n        l = e.tagName.toLowerCase(),\n        u = e.style,\n        c = 1,\n        g = 1;\n    t(e) && (g = e.getScreenCTM(), c = P(g.a * g.a + g.b * g.b), g = P(g.d * g.d + g.c * g.c));\n\n    try {\n      i = e.getBBox();\n    } catch (e) {\n      s("Some browsers won\'t measure invisible elements (like display:none or masks inside defs).");\n    }\n\n    var _ = i || {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    },\n        y = _.x,\n        w = _.y,\n        x = _.width,\n        m = _.height;\n\n    if (i && (x || m) || !k[l] || (x = p(e, k[l][0]), m = p(e, k[l][1]), "rect" !== l && "line" !== l && (x *= 2, m *= 2), "line" === l && (y = p(e, "x1"), w = p(e, "y1"), x = Math.abs(x - y), m = Math.abs(m - w))), "path" === l) a = u.strokeDasharray, u.strokeDasharray = "none", n = e.getTotalLength() || 0, c !== g && s("Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn\'t proportionally scaled."), n *= (c + g) / 2, u.strokeDasharray = a;else if ("rect" === l) n = 2 * x * c + 2 * m * g;else if ("line" === l) n = r(y, w, y + x, w + m, c, g);else if ("polyline" === l || "polygon" === l) for (o = e.getAttribute("points").match(b) || [], "polygon" === l && o.push(o[0], o[1]), n = 0, f = 2; f < o.length; f += 2) {\n      n += r(o[f - 2], o[f - 1], o[f], o[f + 1], c, g) || 0;\n    } else "circle" !== l && "ellipse" !== l || (h = x / 2 * c, d = m / 2 * g, n = Math.PI * (3 * (h + d) - P((3 * h + d) * (h + 3 * d))));\n    return n || 0;\n  }\n\n  function x(e, t) {\n    if (!(e = v(e)[0])) return [0, 0];\n    t = t || w(e) + 1;\n    var r = h.getComputedStyle(e),\n        i = r.strokeDasharray || "",\n        s = n(r.strokeDashoffset),\n        o = i.indexOf(",");\n    return o < 0 && (o = i.indexOf(" ")), t < (i = o < 0 ? t : n(i.substr(0, o))) && (i = t), [-s || 0, i - s || 0];\n  }\n\n  function y() {\n    i() && (h = window, l = a = j(), v = a.utils.toArray, d = -1 !== ((h.navigator || {}).userAgent || "").indexOf("Edge"));\n  }\n\n  var a,\n      v,\n      h,\n      d,\n      l,\n      b = /[-+=\\.]*\\d+[\\.e\\-\\+]*\\d*[e\\-\\+]*\\d*/gi,\n      k = {\n    rect: ["width", "height"],\n    circle: ["r", "r"],\n    ellipse: ["rx", "ry"],\n    line: ["x2", "y2"]\n  },\n      P = Math.sqrt,\n      f = {\n    version: "3.6.1",\n    name: "drawSVG",\n    register: function register(e) {\n      a = e, y();\n    },\n    init: function init(e, r) {\n      if (!e.getBBox) return !1;\n      l || y();\n      var i,\n          s,\n          a,\n          f = w(e);\n      return this._style = e.style, this._target = e, r + "" == "true" ? r = "0 100%" : r ? -1 === (r + "").indexOf(" ") && (r = "0 " + r) : r = "0 0", s = function _parse(e, t, n) {\n        var r,\n            i,\n            s = e.indexOf(" ");\n        return i = s < 0 ? (r = void 0 !== n ? n + "" : e, e) : (r = e.substr(0, s), e.substr(s + 1)), r = o(r, t), (i = o(i, t)) < r ? [i, r] : [r, i];\n      }(r, f, (i = x(e, f))[0]), this._length = m(f), this._dash = m(i[1] - i[0]), this._offset = m(-i[0]), this._dashPT = this.add(this, "_dash", this._dash, m(s[1] - s[0])), this._offsetPT = this.add(this, "_offset", this._offset, m(-s[0])), d && (a = h.getComputedStyle(e)).strokeLinecap !== a.strokeLinejoin && (s = n(a.strokeMiterlimit), this.add(e.style, "strokeMiterlimit", s, s + .01)), this._live = t(e) || ~(r + "").indexOf("live"), this._nowrap = ~(r + "").indexOf("nowrap"), this._props.push("drawSVG"), 1;\n    },\n    render: function render(e, t) {\n      var n,\n          r,\n          i,\n          s,\n          o = t._pt,\n          a = t._style;\n\n      if (o) {\n        for (t._live && (n = w(t._target)) !== t._length && (r = n / t._length, t._length = n, t._offsetPT && (t._offsetPT.s *= r, t._offsetPT.c *= r), t._dashPT ? (t._dashPT.s *= r, t._dashPT.c *= r) : t._dash *= r); o;) {\n          o.r(e, o.d), o = o._next;\n        }\n\n        i = t._dash || e && 1 !== e && 1e-4 || 0, n = t._length - i + .1, s = t._offset, i && s && i + Math.abs(s % t._length) > t._length - .2 && (s += s < 0 ? .1 : -.1) && (n += .1), a.strokeDashoffset = i ? s : s + .001, a.strokeDasharray = n < .2 ? "none" : i ? i + "px," + (t._nowrap ? 999999 : n) + "px" : "0px, 999999px";\n      }\n    },\n    getLength: w,\n    getPosition: x\n  };\n  j() && a.registerPlugin(f), e.DrawSVGPlugin = f, e["default"] = f;\n\n  if (typeof window === "undefined" || window !== e) {\n    Object.defineProperty(e, "__esModule", {\n      value: !0\n    });\n  } else {\n    delete e["default"];\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDM3NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvY2xhc3Nlcy9EcmF3U1ZHUGx1Z2luLm1pbi5qcz8xOWUyIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyohXG4gKiBEcmF3U1ZHUGx1Z2luIDMuNi4xXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqIFxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvciBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICovXG4hZnVuY3Rpb24gKGUsIHQpIHtcbiAgXCJvYmplY3RcIiA9PSAodHlwZW9mIGV4cG9ydHMgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihleHBvcnRzKSkgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgbW9kdWxlID8gdChleHBvcnRzKSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoW1wiZXhwb3J0c1wiXSwgdCkgOiB0KChlID0gZSB8fCBzZWxmKS53aW5kb3cgPSBlLndpbmRvdyB8fCB7fSk7XG59KHRoaXMsIGZ1bmN0aW9uIChlKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGZ1bmN0aW9uIGkoKSB7XG4gICAgcmV0dXJuIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdztcbiAgfVxuXG4gIGZ1bmN0aW9uIGooKSB7XG4gICAgcmV0dXJuIGEgfHwgaSgpICYmIChhID0gd2luZG93LmdzYXApICYmIGEucmVnaXN0ZXJQbHVnaW4gJiYgYTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG0oZSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKDFlNCAqIGUpIC8gMWU0O1xuICB9XG5cbiAgZnVuY3Rpb24gbihlKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoZSkgfHwgMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG8oZSwgdCkge1xuICAgIHZhciByID0gbihlKTtcbiAgICByZXR1cm4gfmUuaW5kZXhPZihcIiVcIikgPyByIC8gMTAwICogdCA6IHI7XG4gIH1cblxuICBmdW5jdGlvbiBwKGUsIHQpIHtcbiAgICByZXR1cm4gbihlLmdldEF0dHJpYnV0ZSh0KSk7XG4gIH1cblxuICBmdW5jdGlvbiByKGUsIHQsIHIsIGksIHMsIG8pIHtcbiAgICByZXR1cm4gUChNYXRoLnBvdygobihyKSAtIG4oZSkpICogcywgMikgKyBNYXRoLnBvdygobihpKSAtIG4odCkpICogbywgMikpO1xuICB9XG5cbiAgZnVuY3Rpb24gcyhlKSB7XG4gICAgcmV0dXJuIGNvbnNvbGUud2FybihlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHQoZSkge1xuICAgIHJldHVybiBcIm5vbi1zY2FsaW5nLXN0cm9rZVwiID09PSBlLmdldEF0dHJpYnV0ZShcInZlY3Rvci1lZmZlY3RcIik7XG4gIH1cblxuICBmdW5jdGlvbiB3KGUpIHtcbiAgICBpZiAoIShlID0gdihlKVswXSkpIHJldHVybiAwO1xuICAgIHZhciBuLFxuICAgICAgICBpLFxuICAgICAgICBvLFxuICAgICAgICBhLFxuICAgICAgICBmLFxuICAgICAgICBoLFxuICAgICAgICBkLFxuICAgICAgICBsID0gZS50YWdOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIHUgPSBlLnN0eWxlLFxuICAgICAgICBjID0gMSxcbiAgICAgICAgZyA9IDE7XG4gICAgdChlKSAmJiAoZyA9IGUuZ2V0U2NyZWVuQ1RNKCksIGMgPSBQKGcuYSAqIGcuYSArIGcuYiAqIGcuYiksIGcgPSBQKGcuZCAqIGcuZCArIGcuYyAqIGcuYykpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGkgPSBlLmdldEJCb3goKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzKFwiU29tZSBicm93c2VycyB3b24ndCBtZWFzdXJlIGludmlzaWJsZSBlbGVtZW50cyAobGlrZSBkaXNwbGF5Om5vbmUgb3IgbWFza3MgaW5zaWRlIGRlZnMpLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgXyA9IGkgfHwge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH0sXG4gICAgICAgIHkgPSBfLngsXG4gICAgICAgIHcgPSBfLnksXG4gICAgICAgIHggPSBfLndpZHRoLFxuICAgICAgICBtID0gXy5oZWlnaHQ7XG5cbiAgICBpZiAoaSAmJiAoeCB8fCBtKSB8fCAha1tsXSB8fCAoeCA9IHAoZSwga1tsXVswXSksIG0gPSBwKGUsIGtbbF1bMV0pLCBcInJlY3RcIiAhPT0gbCAmJiBcImxpbmVcIiAhPT0gbCAmJiAoeCAqPSAyLCBtICo9IDIpLCBcImxpbmVcIiA9PT0gbCAmJiAoeSA9IHAoZSwgXCJ4MVwiKSwgdyA9IHAoZSwgXCJ5MVwiKSwgeCA9IE1hdGguYWJzKHggLSB5KSwgbSA9IE1hdGguYWJzKG0gLSB3KSkpLCBcInBhdGhcIiA9PT0gbCkgYSA9IHUuc3Ryb2tlRGFzaGFycmF5LCB1LnN0cm9rZURhc2hhcnJheSA9IFwibm9uZVwiLCBuID0gZS5nZXRUb3RhbExlbmd0aCgpIHx8IDAsIGMgIT09IGcgJiYgcyhcIldhcm5pbmc6IDxwYXRoPiBsZW5ndGggY2Fubm90IGJlIG1lYXN1cmVkIHdoZW4gdmVjdG9yLWVmZmVjdCBpcyBub24tc2NhbGluZy1zdHJva2UgYW5kIHRoZSBlbGVtZW50IGlzbid0IHByb3BvcnRpb25hbGx5IHNjYWxlZC5cIiksIG4gKj0gKGMgKyBnKSAvIDIsIHUuc3Ryb2tlRGFzaGFycmF5ID0gYTtlbHNlIGlmIChcInJlY3RcIiA9PT0gbCkgbiA9IDIgKiB4ICogYyArIDIgKiBtICogZztlbHNlIGlmIChcImxpbmVcIiA9PT0gbCkgbiA9IHIoeSwgdywgeSArIHgsIHcgKyBtLCBjLCBnKTtlbHNlIGlmIChcInBvbHlsaW5lXCIgPT09IGwgfHwgXCJwb2x5Z29uXCIgPT09IGwpIGZvciAobyA9IGUuZ2V0QXR0cmlidXRlKFwicG9pbnRzXCIpLm1hdGNoKGIpIHx8IFtdLCBcInBvbHlnb25cIiA9PT0gbCAmJiBvLnB1c2gob1swXSwgb1sxXSksIG4gPSAwLCBmID0gMjsgZiA8IG8ubGVuZ3RoOyBmICs9IDIpIHtcbiAgICAgIG4gKz0gcihvW2YgLSAyXSwgb1tmIC0gMV0sIG9bZl0sIG9bZiArIDFdLCBjLCBnKSB8fCAwO1xuICAgIH0gZWxzZSBcImNpcmNsZVwiICE9PSBsICYmIFwiZWxsaXBzZVwiICE9PSBsIHx8IChoID0geCAvIDIgKiBjLCBkID0gbSAvIDIgKiBnLCBuID0gTWF0aC5QSSAqICgzICogKGggKyBkKSAtIFAoKDMgKiBoICsgZCkgKiAoaCArIDMgKiBkKSkpKTtcbiAgICByZXR1cm4gbiB8fCAwO1xuICB9XG5cbiAgZnVuY3Rpb24geChlLCB0KSB7XG4gICAgaWYgKCEoZSA9IHYoZSlbMF0pKSByZXR1cm4gWzAsIDBdO1xuICAgIHQgPSB0IHx8IHcoZSkgKyAxO1xuICAgIHZhciByID0gaC5nZXRDb21wdXRlZFN0eWxlKGUpLFxuICAgICAgICBpID0gci5zdHJva2VEYXNoYXJyYXkgfHwgXCJcIixcbiAgICAgICAgcyA9IG4oci5zdHJva2VEYXNob2Zmc2V0KSxcbiAgICAgICAgbyA9IGkuaW5kZXhPZihcIixcIik7XG4gICAgcmV0dXJuIG8gPCAwICYmIChvID0gaS5pbmRleE9mKFwiIFwiKSksIHQgPCAoaSA9IG8gPCAwID8gdCA6IG4oaS5zdWJzdHIoMCwgbykpKSAmJiAoaSA9IHQpLCBbLXMgfHwgMCwgaSAtIHMgfHwgMF07XG4gIH1cblxuICBmdW5jdGlvbiB5KCkge1xuICAgIGkoKSAmJiAoaCA9IHdpbmRvdywgbCA9IGEgPSBqKCksIHYgPSBhLnV0aWxzLnRvQXJyYXksIGQgPSAtMSAhPT0gKChoLm5hdmlnYXRvciB8fCB7fSkudXNlckFnZW50IHx8IFwiXCIpLmluZGV4T2YoXCJFZGdlXCIpKTtcbiAgfVxuXG4gIHZhciBhLFxuICAgICAgdixcbiAgICAgIGgsXG4gICAgICBkLFxuICAgICAgbCxcbiAgICAgIGIgPSAvWy0rPVxcLl0qXFxkK1tcXC5lXFwtXFwrXSpcXGQqW2VcXC1cXCtdKlxcZCovZ2ksXG4gICAgICBrID0ge1xuICAgIHJlY3Q6IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCJdLFxuICAgIGNpcmNsZTogW1wiclwiLCBcInJcIl0sXG4gICAgZWxsaXBzZTogW1wicnhcIiwgXCJyeVwiXSxcbiAgICBsaW5lOiBbXCJ4MlwiLCBcInkyXCJdXG4gIH0sXG4gICAgICBQID0gTWF0aC5zcXJ0LFxuICAgICAgZiA9IHtcbiAgICB2ZXJzaW9uOiBcIjMuNi4xXCIsXG4gICAgbmFtZTogXCJkcmF3U1ZHXCIsXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGUpIHtcbiAgICAgIGEgPSBlLCB5KCk7XG4gICAgfSxcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KGUsIHIpIHtcbiAgICAgIGlmICghZS5nZXRCQm94KSByZXR1cm4gITE7XG4gICAgICBsIHx8IHkoKTtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIHMsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBmID0gdyhlKTtcbiAgICAgIHJldHVybiB0aGlzLl9zdHlsZSA9IGUuc3R5bGUsIHRoaXMuX3RhcmdldCA9IGUsIHIgKyBcIlwiID09IFwidHJ1ZVwiID8gciA9IFwiMCAxMDAlXCIgOiByID8gLTEgPT09IChyICsgXCJcIikuaW5kZXhPZihcIiBcIikgJiYgKHIgPSBcIjAgXCIgKyByKSA6IHIgPSBcIjAgMFwiLCBzID0gZnVuY3Rpb24gX3BhcnNlKGUsIHQsIG4pIHtcbiAgICAgICAgdmFyIHIsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcyA9IGUuaW5kZXhPZihcIiBcIik7XG4gICAgICAgIHJldHVybiBpID0gcyA8IDAgPyAociA9IHZvaWQgMCAhPT0gbiA/IG4gKyBcIlwiIDogZSwgZSkgOiAociA9IGUuc3Vic3RyKDAsIHMpLCBlLnN1YnN0cihzICsgMSkpLCByID0gbyhyLCB0KSwgKGkgPSBvKGksIHQpKSA8IHIgPyBbaSwgcl0gOiBbciwgaV07XG4gICAgICB9KHIsIGYsIChpID0geChlLCBmKSlbMF0pLCB0aGlzLl9sZW5ndGggPSBtKGYpLCB0aGlzLl9kYXNoID0gbShpWzFdIC0gaVswXSksIHRoaXMuX29mZnNldCA9IG0oLWlbMF0pLCB0aGlzLl9kYXNoUFQgPSB0aGlzLmFkZCh0aGlzLCBcIl9kYXNoXCIsIHRoaXMuX2Rhc2gsIG0oc1sxXSAtIHNbMF0pKSwgdGhpcy5fb2Zmc2V0UFQgPSB0aGlzLmFkZCh0aGlzLCBcIl9vZmZzZXRcIiwgdGhpcy5fb2Zmc2V0LCBtKC1zWzBdKSksIGQgJiYgKGEgPSBoLmdldENvbXB1dGVkU3R5bGUoZSkpLnN0cm9rZUxpbmVjYXAgIT09IGEuc3Ryb2tlTGluZWpvaW4gJiYgKHMgPSBuKGEuc3Ryb2tlTWl0ZXJsaW1pdCksIHRoaXMuYWRkKGUuc3R5bGUsIFwic3Ryb2tlTWl0ZXJsaW1pdFwiLCBzLCBzICsgLjAxKSksIHRoaXMuX2xpdmUgPSB0KGUpIHx8IH4ociArIFwiXCIpLmluZGV4T2YoXCJsaXZlXCIpLCB0aGlzLl9ub3dyYXAgPSB+KHIgKyBcIlwiKS5pbmRleE9mKFwibm93cmFwXCIpLCB0aGlzLl9wcm9wcy5wdXNoKFwiZHJhd1NWR1wiKSwgMTtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGUsIHQpIHtcbiAgICAgIHZhciBuLFxuICAgICAgICAgIHIsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBzLFxuICAgICAgICAgIG8gPSB0Ll9wdCxcbiAgICAgICAgICBhID0gdC5fc3R5bGU7XG5cbiAgICAgIGlmIChvKSB7XG4gICAgICAgIGZvciAodC5fbGl2ZSAmJiAobiA9IHcodC5fdGFyZ2V0KSkgIT09IHQuX2xlbmd0aCAmJiAociA9IG4gLyB0Ll9sZW5ndGgsIHQuX2xlbmd0aCA9IG4sIHQuX29mZnNldFBUICYmICh0Ll9vZmZzZXRQVC5zICo9IHIsIHQuX29mZnNldFBULmMgKj0gciksIHQuX2Rhc2hQVCA/ICh0Ll9kYXNoUFQucyAqPSByLCB0Ll9kYXNoUFQuYyAqPSByKSA6IHQuX2Rhc2ggKj0gcik7IG87KSB7XG4gICAgICAgICAgby5yKGUsIG8uZCksIG8gPSBvLl9uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgaSA9IHQuX2Rhc2ggfHwgZSAmJiAxICE9PSBlICYmIDFlLTQgfHwgMCwgbiA9IHQuX2xlbmd0aCAtIGkgKyAuMSwgcyA9IHQuX29mZnNldCwgaSAmJiBzICYmIGkgKyBNYXRoLmFicyhzICUgdC5fbGVuZ3RoKSA+IHQuX2xlbmd0aCAtIC4yICYmIChzICs9IHMgPCAwID8gLjEgOiAtLjEpICYmIChuICs9IC4xKSwgYS5zdHJva2VEYXNob2Zmc2V0ID0gaSA/IHMgOiBzICsgLjAwMSwgYS5zdHJva2VEYXNoYXJyYXkgPSBuIDwgLjIgPyBcIm5vbmVcIiA6IGkgPyBpICsgXCJweCxcIiArICh0Ll9ub3dyYXAgPyA5OTk5OTkgOiBuKSArIFwicHhcIiA6IFwiMHB4LCA5OTk5OTlweFwiO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0TGVuZ3RoOiB3LFxuICAgIGdldFBvc2l0aW9uOiB4XG4gIH07XG4gIGooKSAmJiBhLnJlZ2lzdGVyUGx1Z2luKGYpLCBlLkRyYXdTVkdQbHVnaW4gPSBmLCBlW1wiZGVmYXVsdFwiXSA9IGY7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgd2luZG93ICE9PSBlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogITBcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgZVtcImRlZmF1bHRcIl07XG4gIH1cbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4374\n'
            );
        },
        6495: (__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {
            "use strict";
            eval(
                '\n;// CONCATENATED MODULE: ./app/src/js/app/appStore.js\n/* harmony default export */ const appStore = ({\n  main: null,\n  rootUrl: null,\n  isDesktop: null,\n  firstNavigation: null,\n  from: null,\n  to: null,\n  current: null,\n  currentSection: null,\n  client: {\n    browser: \'\',\n    device: \'\',\n    lang: \'es\',\n    os: \'\',\n    sizes: {\n      width: window.innerWidth,\n      height: window.innerHeight\n    },\n    mousePosition: {\n      x: window.innerWidth / 2,\n      y: window.innerHeight / 2\n    }\n  },\n  vars: {\n    vh: 0,\n    vho: 0,\n    vhr: 0,\n    vhd: 0\n  }\n});\n;// CONCATENATED MODULE: ./app/src/js/utils/string.js\n//Copyright 2018 Vicente Lucendo - vicen@vlucendo.com\nvar string = {\n  //converts a string number \'#FFFFFF\' to hex 0xffffff - it gets used on pixi\n  toHex: function toHex(str) {\n    return parseInt(str.substring(1), 16);\n  },\n  //true or false if text is on the string\n  contains: function contains(str, text) {\n    return str.indexOf(text) > -1;\n  }\n};\n;// CONCATENATED MODULE: ./app/src/js/utils/is.js\n//Copyright 2018 Vicente Lucendo - vicen@vlucendo.com\n\nvar is = {\n  array: function array(a) {\n    return Array.isArray(a);\n  },\n  object: function object(a) {\n    return string.contains(Object.prototype.toString.call(a), \'Object\');\n  },\n  path: function path(a) {\n    return is.obj(a) && a.hasOwnProperty(\'totalLength\');\n  },\n  //eslint-disable-line\n  svg: function svg(a) {\n    return a instanceof SVGElement;\n  },\n  node: function node(a) {\n    return a.nodeType || is.svg(a);\n  },\n  nodeList: function nodeList(a) {\n    return a instanceof NodeList || a instanceof HTMLCollection;\n  },\n  string: function string(a) {\n    return typeof a === \'string\';\n  },\n  number: function number(a) {\n    return !isNaN(parseFloat(a)) && isFinite(a);\n  },\n  "function": function _function(a) {\n    return typeof a === \'function\';\n  },\n  undefined: function undefined(a) {\n    return typeof a === \'undefined\';\n  },\n  hex: function hex(a) {\n    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a);\n  },\n  rgb: function rgb(a) {\n    return /^rgb/.test(a);\n  },\n  hsl: function hsl(a) {\n    return /^hsl/.test(a);\n  },\n  color: function color(a) {\n    return is.hex(a) || is.rgb(a) || is.hsl(a);\n  }\n};\n;// CONCATENATED MODULE: ./app/src/js/classes/domEvents.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n//Copyright 2018 Vicente Lucendo - vicen@vlucendo.com\n\n\nvar domEvents_default = /*#__PURE__*/function () {\n  function _default() {\n    _classCallCheck(this, _default);\n\n    this._eventCache = [];\n  }\n\n  _createClass(_default, [{\n    key: "_removeEvent",\n    value: function _removeEvent(index) {\n      //remove event listener\n      this._eventCache[index].node.removeEventListener(this._eventCache[index].action, this._eventCache[index].cb); //remove element from eventcache\n\n\n      this._eventCache.splice(index, 1);\n    }\n  }, {\n    key: "add",\n    value: function add(node, eventName, _func) {\n      var _this = this;\n\n      var context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var arg = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var rLink = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n      //nodelist or single node?\n      var _nodes = is.nodeList(node) || is.array(node) ? node : [node]; //loop though the nodes\n\n\n      var _loop = function _loop(i) {\n        //create callback passing the event, argument and source node\n        var _cb = context !== false ? function (e) {\n          _func.call(context, e, arg, _nodes[i]);\n        } : function (e) {\n          _func(e, arg, _nodes[i]);\n        }; //add the event to the node event cache\n\n\n        _this._eventCache.push({\n          node: _nodes[i],\n          action: eventName,\n          func: _func,\n          cb: _cb,\n          routerLink: rLink\n        }); //add the event to the node\n\n\n        _nodes[i].addEventListener(eventName, _cb);\n      };\n\n      for (var i = 0; i < _nodes.length; i++) {\n        _loop(i);\n      }\n    } //this function removes non router events meeting the criteria\n\n  }, {\n    key: "remove",\n    value: function remove(node, eventName, func) {\n      //nodelist or single node?\n      var _nodes = is.nodeList(node) || is.array(node) ? node : [node]; //loop though the nodes\n\n\n      for (var k = 0; k < _nodes.length; k++) {\n        var i = 0;\n\n        while (i < this._eventCache.length) {\n          //check if it is the same node and is not a router link\n          if (this._eventCache[i].node === _nodes[k] && !this._eventCache[i].routerLink) {\n            if (eventName && func) {\n              if (this._eventCache[i].action === eventName && this._eventCache[i].func === func) this._removeEvent(i);else i++;\n            } else if (eventName) {\n              if (this._eventCache[i].action === eventName) this._removeEvent(i);else i++;\n            } else if (func) {\n              if (this._eventCache[i].func === func) this._removeEvent(i);else i++;\n            } else {\n              this._removeEvent(i);\n            }\n          } else {\n            i++;\n          }\n        }\n      }\n    } //this function removes all non router links\n\n  }, {\n    key: "removeAll",\n    value: function removeAll() {\n      var i = 0;\n\n      while (i < this._eventCache.length) {\n        if (!this._eventCache[i].routerLink) this._removeEvent(i);else i++;\n      }\n    } //this function removes everything, it must only be used by component classes after elements are removed\n    //from the dom so there are not problems with unbound router links clicked by the user refreshing the page\n\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      while (this._eventCache.length > 0) {\n        this._removeEvent(0);\n      }\n    }\n  }]);\n\n  return _default;\n}();\n\n\n// EXTERNAL MODULE: ./node_modules/gsap/index.js + 2 modules\nvar node_modules_gsap = __webpack_require__(6358);\n;// CONCATENATED MODULE: ./app/src/js/utils/strings.js\n/*!\n * strings: 3.2.6\n * https://greensock.com\n *\n * Copyright 2008-2020, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar _trimExp = /(^\\s+|\\s+$)/g;\nvar emojiExp = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF](?:[\\u200D\\uFE0F][\\uD800-\\uDBFF][\\uDC00-\\uDFFF]){2,}|\\uD83D\\uDC69(?:\\u200D(?:(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC67|(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC66)|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]\\uFE0F|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC6F\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3C-\\uDD3E\\uDDD6-\\uDDDF])\\u200D[\\u2640\\u2642]\\uFE0F|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642])\\uFE0F|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\uD83D\\uDC69\\u200D[\\u2695\\u2696\\u2708]|\\uD83D\\uDC68(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708]))\\uFE0F|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83D\\uDC69\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|\\uD83D\\uDC68(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92])|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]))|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDD1-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\u200D(?:(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC67|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC66)|\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC69\\uDC6E\\uDC70-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3D\\uDD3E\\uDDD1-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])?|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDEEB\\uDEEC\\uDEF4-\\uDEF8]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD4C\\uDD50-\\uDD6B\\uDD80-\\uDD97\\uDDC0\\uDDD0-\\uDDE6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEF8]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD4C\\uDD50-\\uDD6B\\uDD80-\\uDD97\\uDDC0\\uDDD0-\\uDDE6])\\uFE0F)/;\nfunction getText(e) {\n  var type = e.nodeType,\n      result = "";\n\n  if (type === 1 || type === 9 || type === 11) {\n    if (typeof e.textContent === "string") {\n      return e.textContent;\n    } else {\n      for (e = e.firstChild; e; e = e.nextSibling) {\n        result += getText(e);\n      }\n    }\n  } else if (type === 3 || type === 4) {\n    return e.nodeValue;\n  }\n\n  return result;\n}\nfunction splitInnerHTML(element, delimiter, trim) {\n  var node = element.firstChild,\n      result = [];\n\n  while (node) {\n    if (node.nodeType === 3) {\n      result.push.apply(result, emojiSafeSplit((node.nodeValue + "").replace(/^\\n+/g, "").replace(/\\s+/g, " "), delimiter, trim));\n    } else if ((node.nodeName + "").toLowerCase() === "br") {\n      result[result.length - 1] += "<br>";\n    } else {\n      result.push(node.outerHTML);\n    }\n\n    node = node.nextSibling;\n  }\n\n  return result;\n}\n/*\n//smaller kb version that only handles the simpler emoji\'s, which is often perfectly adequate.\n\nlet _emoji = "[\\uE000-\\uF8FF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDFFF]|[\\u2694-\\u2697]|\\uD83E[\\uDD10-\\uDD5D]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]",\n\t_emojiExp = new RegExp(_emoji),\n\t_emojiAndCharsExp = new RegExp(_emoji + "|.", "g"),\n\t_emojiSafeSplit = (text, delimiter, trim) => {\n\t\tif (trim) {\n\t\t\ttext = text.replace(_trimExp, "");\n\t\t}\n\t\treturn ((delimiter === "" || !delimiter) && _emojiExp.test(text)) ? text.match(_emojiAndCharsExp) : text.split(delimiter || "");\n\t};\n */\n\nfunction emojiSafeSplit(text, delimiter, trim) {\n  text += ""; // make sure it\'s cast as a string. Someone may pass in a number.\n\n  if (trim) {\n    text = text.replace(_trimExp, "");\n  }\n\n  if (delimiter && delimiter !== "") {\n    return text.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(delimiter);\n  }\n\n  var result = [],\n      l = text.length,\n      i = 0,\n      j,\n      character;\n\n  for (; i < l; i++) {\n    character = text.charAt(i);\n\n    if (character.charCodeAt(0) >= 0xD800 && character.charCodeAt(0) <= 0xDBFF || text.charCodeAt(i + 1) >= 0xFE00 && text.charCodeAt(i + 1) <= 0xFE0F) {\n      //special emoji characters use 2 or 4 unicode characters that we must keep together.\n      j = ((text.substr(i, 12).split(emojiExp) || [])[1] || "").length || 2;\n      character = text.substr(i, j);\n      result.emoji = 1;\n      i += j - 1;\n    }\n\n    result.push(character === ">" ? "&gt;" : character === "<" ? "&lt;" : character);\n  }\n\n  return result;\n}\n;// CONCATENATED MODULE: ./app/src/js/classes/splitText.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * SplitText: 3.2.6\n * https://greensock.com\n *\n * @license Copyright 2008-2020, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\n\n\nvar _doc,\n    _win,\n    _coreInitted,\n    _stripExp = /(?:\\r|\\n|\\t\\t)/g,\n    //find carriage returns, new line feeds and double-tabs.\n_multipleSpacesExp = /(?:\\s\\s+)/g,\n    _initCore = function _initCore() {\n  _doc = document;\n  _win = window;\n  _coreInitted = 1;\n},\n    _bonusValidated = 1,\n    //<name>SplitText</name>\n_getComputedStyle = function _getComputedStyle(element) {\n  return _win.getComputedStyle(element);\n},\n    _isArray = Array.isArray,\n    _slice = [].slice,\n    _toArray = function _toArray(value, leaveStrings) {\n  //takes any value and returns an array. If it\'s a string (and leaveStrings isn\'t true), it\'ll use document.querySelectorAll() and convert that to an array. It\'ll also accept iterables like jQuery objects.\n  var type;\n  return _isArray(value) ? value : (type = _typeof(value)) === "string" && !leaveStrings && value ? _slice.call(_doc.querySelectorAll(value), 0) : value && type === "object" && "length" in value ? _slice.call(value, 0) : value ? [value] : [];\n},\n    _isAbsolute = function _isAbsolute(vars) {\n  return vars.position === "absolute" || vars.absolute === true;\n},\n    //some characters are combining marks (think diacritics/accents in European languages) which involve 2 or 4 characters that combine in the browser to form a single character. Pass in the remaining text and an array of the special characters to search for and if the text starts with one of those special characters, it\'ll spit back the number of characters to retain (often 2 or 4). Used in the specialChars features that was introduced in 0.6.0.\n_findSpecialChars = function _findSpecialChars(text, chars) {\n  var i = chars.length,\n      s;\n\n  while (--i > -1) {\n    s = chars[i];\n\n    if (text.substr(0, s.length) === s) {\n      return s.length;\n    }\n  }\n},\n    _divStart = " style=\'position:relative;display:inline-block;\'",\n    _cssClassFunc = function _cssClassFunc(cssClass, tag) {\n  if (cssClass === void 0) {\n    cssClass = "";\n  }\n\n  var iterate = ~cssClass.indexOf("++"),\n      num = 1;\n\n  if (iterate) {\n    cssClass = cssClass.split("++").join("");\n  }\n\n  return function () {\n    return "<" + tag + _divStart + (cssClass ? " class=\'" + cssClass + (iterate ? num++ : "") + "\'>" : ">");\n  };\n},\n    _swapText = function _swapText(element, oldText, newText) {\n  var type = element.nodeType;\n\n  if (type === 1 || type === 9 || type === 11) {\n    for (element = element.firstChild; element; element = element.nextSibling) {\n      _swapText(element, oldText, newText);\n    }\n  } else if (type === 3 || type === 4) {\n    element.nodeValue = element.nodeValue.split(oldText).join(newText);\n  }\n},\n    _pushReversed = function _pushReversed(a, merge) {\n  var i = merge.length;\n\n  while (--i > -1) {\n    a.push(merge[i]);\n  }\n},\n    _isBeforeWordDelimiter = function _isBeforeWordDelimiter(e, root, wordDelimiter) {\n  var next;\n\n  while (e && e !== root) {\n    next = e._next || e.nextSibling;\n\n    if (next) {\n      return next.textContent.charAt(0) === wordDelimiter;\n    }\n\n    e = e.parentNode || e._parent;\n  }\n},\n    _deWordify = function _deWordify(e) {\n  var children = _toArray(e.childNodes),\n      l = children.length,\n      i,\n      child;\n\n  for (i = 0; i < l; i++) {\n    child = children[i];\n\n    if (child._isSplit) {\n      _deWordify(child);\n    } else {\n      if (i && child.previousSibling.nodeType === 3) {\n        child.previousSibling.nodeValue += child.nodeType === 3 ? child.nodeValue : child.firstChild.nodeValue;\n      } else if (child.nodeType !== 3) {\n        e.insertBefore(child.firstChild, child);\n      }\n\n      e.removeChild(child);\n    }\n  }\n},\n    _getStyleAsNumber = function _getStyleAsNumber(name, computedStyle) {\n  return parseFloat(computedStyle[name]) || 0;\n},\n    _setPositionsAfterSplit = function _setPositionsAfterSplit(element, vars, allChars, allWords, allLines, origWidth, origHeight) {\n  var cs = _getComputedStyle(element),\n      paddingLeft = _getStyleAsNumber("paddingLeft", cs),\n      lineOffsetY = -999,\n      borderTopAndBottom = _getStyleAsNumber("borderBottomWidth", cs) + _getStyleAsNumber("borderTopWidth", cs),\n      borderLeftAndRight = _getStyleAsNumber("borderLeftWidth", cs) + _getStyleAsNumber("borderRightWidth", cs),\n      padTopAndBottom = _getStyleAsNumber("paddingTop", cs) + _getStyleAsNumber("paddingBottom", cs),\n      padLeftAndRight = _getStyleAsNumber("paddingLeft", cs) + _getStyleAsNumber("paddingRight", cs),\n      lineThreshold = _getStyleAsNumber("fontSize", cs) * 0.2,\n      textAlign = cs.textAlign,\n      charArray = [],\n      wordArray = [],\n      lineArray = [],\n      wordDelimiter = vars.wordDelimiter || " ",\n      tag = vars.tag ? vars.tag : vars.span ? "span" : "div",\n      types = vars.type || vars.split || "chars,words,lines",\n      lines = allLines && ~types.indexOf("lines") ? [] : null,\n      words = ~types.indexOf("words"),\n      chars = ~types.indexOf("chars"),\n      absolute = _isAbsolute(vars),\n      linesClass = vars.linesClass,\n      iterateLine = ~(linesClass || "").indexOf("++"),\n      spaceNodesToRemove = [],\n      i,\n      j,\n      l,\n      node,\n      nodes,\n      isChild,\n      curLine,\n      addWordSpaces,\n      style,\n      lineNode,\n      lineWidth,\n      offset;\n\n  if (iterateLine) {\n    linesClass = linesClass.split("++").join("");\n  } //copy all the descendant nodes into an array (we can\'t use a regular nodeList because it\'s live and we may need to renest things)\n\n\n  j = element.getElementsByTagName("*");\n  l = j.length;\n  nodes = [];\n\n  for (i = 0; i < l; i++) {\n    nodes[i] = j[i];\n  } //for absolute positioning, we need to record the x/y offsets and width/height for every <div>. And even if we\'re not positioning things absolutely, in order to accommodate lines, we must figure out where the y offset changes so that we can sense where the lines break, and we populate the lines array.\n\n\n  if (lines || absolute) {\n    for (i = 0; i < l; i++) {\n      node = nodes[i];\n      isChild = node.parentNode === element;\n\n      if (isChild || absolute || chars && !words) {\n        offset = node.offsetTop;\n\n        if (lines && isChild && Math.abs(offset - lineOffsetY) > lineThreshold && (node.nodeName !== "BR" || i === 0)) {\n          //we found some rare occasions where a certain character like &#8209; could cause the offsetTop to be off by 1 pixel, so we build in a threshold.\n          curLine = [];\n          lines.push(curLine);\n          lineOffsetY = offset;\n        }\n\n        if (absolute) {\n          //record offset x and y, as well as width and height so that we can access them later for positioning. Grabbing them at once ensures we don\'t trigger a browser paint & we maximize performance.\n          node._x = node.offsetLeft;\n          node._y = offset;\n          node._w = node.offsetWidth;\n          node._h = node.offsetHeight;\n        }\n\n        if (lines) {\n          if (node._isSplit && isChild || !chars && isChild || words && isChild || !words && node.parentNode.parentNode === element && !node.parentNode._isSplit) {\n            curLine.push(node);\n            node._x -= paddingLeft;\n\n            if (_isBeforeWordDelimiter(node, element, wordDelimiter)) {\n              node._wordEnd = true;\n            }\n          }\n\n          if (node.nodeName === "BR" && (node.nextSibling && node.nextSibling.nodeName === "BR" || i === 0)) {\n            //two consecutive <br> tags signify a new [empty] line. Also, if the entire block of content STARTS with a <br>, add a line.\n            lines.push([]);\n          }\n        }\n      }\n    }\n  }\n\n  for (i = 0; i < l; i++) {\n    node = nodes[i];\n    isChild = node.parentNode === element;\n\n    if (node.nodeName === "BR") {\n      if (lines || absolute) {\n        if (node.parentNode) {\n          node.parentNode.removeChild(node);\n        }\n\n        nodes.splice(i--, 1);\n        l--;\n      } else if (!words) {\n        element.appendChild(node);\n      }\n\n      continue;\n    }\n\n    if (absolute) {\n      style = node.style;\n\n      if (!words && !isChild) {\n        node._x += node.parentNode._x;\n        node._y += node.parentNode._y;\n      }\n\n      style.left = node._x + "px";\n      style.top = node._y + "px";\n      style.position = "absolute";\n      style.display = "block"; //if we don\'t set the width/height, things collapse in older versions of IE and the origin for transforms is thrown off in all browsers.\n\n      style.width = node._w + 1 + "px"; //IE is 1px short sometimes. Avoid wrapping\n\n      style.height = node._h + "px";\n    }\n\n    if (!words && chars) {\n      //we always start out wrapping words in their own <div> so that line breaks happen correctly, but here we\'ll remove those <div> tags if necessary and renest the characters directly into the element rather than inside the word <div>\n      if (node._isSplit) {\n        node._next = node.nextSibling;\n        node.parentNode.appendChild(node); //put it at the end to keep the order correct.\n      } else if (node.parentNode._isSplit) {\n        node._parent = node.parentNode;\n\n        if (!node.previousSibling && node.firstChild) {\n          node.firstChild._isFirst = true;\n        }\n\n        if (node.nextSibling && node.nextSibling.textContent === " " && !node.nextSibling.nextSibling) {\n          //if the last node inside a nested element is just a space (like T<span>nested </span>), remove it otherwise it\'ll get placed in the wrong order. Don\'t remove it right away, though, because we need to sense when words/characters are before a space like _isBeforeWordDelimiter(). Removing it now would make that a false negative.\n          spaceNodesToRemove.push(node.nextSibling);\n        }\n\n        node._next = node.nextSibling && node.nextSibling._isFirst ? null : node.nextSibling;\n        node.parentNode.removeChild(node);\n        nodes.splice(i--, 1);\n        l--;\n      } else if (!isChild) {\n        offset = !node.nextSibling && _isBeforeWordDelimiter(node.parentNode, element, wordDelimiter); //if this is the last letter in the word (and we\'re not breaking by lines and not positioning things absolutely), we need to add a space afterwards so that the characters don\'t just mash together\n\n        if (node.parentNode._parent) {\n          node.parentNode._parent.appendChild(node);\n        }\n\n        if (offset) {\n          node.parentNode.appendChild(_doc.createTextNode(" "));\n        }\n\n        if (tag === "span") {\n          node.style.display = "inline"; //so that word breaks are honored properly.\n        }\n\n        charArray.push(node);\n      }\n    } else if (node.parentNode._isSplit && !node._isSplit && node.innerHTML !== "") {\n      wordArray.push(node);\n    } else if (chars && !node._isSplit) {\n      if (tag === "span") {\n        node.style.display = "inline";\n      }\n\n      charArray.push(node);\n    }\n  }\n\n  i = spaceNodesToRemove.length;\n\n  while (--i > -1) {\n    spaceNodesToRemove[i].parentNode.removeChild(spaceNodesToRemove[i]);\n  }\n\n  if (lines) {\n    //the next 7 lines just give us the line width in the most reliable way and figure out the left offset (if position isn\'t relative or absolute). We must set the width along with text-align to ensure everything works properly for various alignments.\n    if (absolute) {\n      lineNode = _doc.createElement(tag);\n      element.appendChild(lineNode);\n      lineWidth = lineNode.offsetWidth + "px";\n      offset = lineNode.offsetParent === element ? 0 : element.offsetLeft;\n      element.removeChild(lineNode);\n    }\n\n    style = element.style.cssText;\n    element.style.cssText = "display:none;"; //to improve performance, set display:none on the element so that the browser doesn\'t have to worry about reflowing or rendering while we\'re renesting things. We\'ll revert the cssText later.\n    //we can\'t use element.innerHTML = "" because that causes IE to literally delete all the nodes and their content even though we\'ve stored them in an array! So we must loop through the children and remove them.\n\n    while (element.firstChild) {\n      element.removeChild(element.firstChild);\n    }\n\n    addWordSpaces = wordDelimiter === " " && (!absolute || !words && !chars);\n\n    for (i = 0; i < lines.length; i++) {\n      curLine = lines[i];\n      lineNode = _doc.createElement(tag);\n      lineNode.style.cssText = "display:block;text-align:" + textAlign + ";position:" + (absolute ? "absolute;" : "relative;");\n\n      if (linesClass) {\n        lineNode.className = linesClass + (iterateLine ? i + 1 : "");\n      }\n\n      lineArray.push(lineNode);\n      l = curLine.length;\n\n      for (j = 0; j < l; j++) {\n        if (curLine[j].nodeName !== "BR") {\n          node = curLine[j];\n          lineNode.appendChild(node);\n\n          if (addWordSpaces && node._wordEnd) {\n            lineNode.appendChild(_doc.createTextNode(" "));\n          }\n\n          if (absolute) {\n            if (j === 0) {\n              lineNode.style.top = node._y + "px";\n              lineNode.style.left = paddingLeft + offset + "px";\n            }\n\n            node.style.top = "0px";\n\n            if (offset) {\n              node.style.left = node._x - offset + "px";\n            }\n          }\n        }\n      }\n\n      if (l === 0) {\n        //if there are no nodes in the line (typically meaning there were two consecutive <br> tags, just add a non-breaking space so that things display properly.\n        lineNode.innerHTML = "&nbsp;";\n      } else if (!words && !chars) {\n        _deWordify(lineNode);\n\n        _swapText(lineNode, String.fromCharCode(160), " ");\n      }\n\n      if (absolute) {\n        lineNode.style.width = lineWidth;\n        lineNode.style.height = node._h + "px";\n      }\n\n      element.appendChild(lineNode);\n    }\n\n    element.style.cssText = style;\n  } //if everything shifts to being position:absolute, the container can collapse in terms of height or width, so fix that here.\n\n\n  if (absolute) {\n    if (origHeight > element.clientHeight) {\n      element.style.height = origHeight - padTopAndBottom + "px";\n\n      if (element.clientHeight < origHeight) {\n        //IE8 and earlier use a different box model - we must include padding and borders\n        element.style.height = origHeight + borderTopAndBottom + "px";\n      }\n    }\n\n    if (origWidth > element.clientWidth) {\n      element.style.width = origWidth - padLeftAndRight + "px";\n\n      if (element.clientWidth < origWidth) {\n        //IE8 and earlier use a different box model - we must include padding and borders\n        element.style.width = origWidth + borderLeftAndRight + "px";\n      }\n    }\n  }\n\n  _pushReversed(allChars, charArray);\n\n  if (words) {\n    _pushReversed(allWords, wordArray);\n  }\n\n  _pushReversed(allLines, lineArray);\n},\n    _splitRawText = function _splitRawText(element, vars, wordStart, charStart) {\n  var tag = vars.tag ? vars.tag : vars.span ? "span" : "div",\n      types = vars.type || vars.split || "chars,words,lines",\n      //words = (types.indexOf("words") !== -1),\n  chars = ~types.indexOf("chars"),\n      absolute = _isAbsolute(vars),\n      wordDelimiter = vars.wordDelimiter || " ",\n      space = wordDelimiter !== " " ? "" : absolute ? "&#173; " : " ",\n      wordEnd = "</" + tag + ">",\n      wordIsOpen = 1,\n      specialChars = vars.specialChars ? typeof vars.specialChars === "function" ? vars.specialChars : _findSpecialChars : null,\n      //specialChars can be an array or a function. For performance reasons, we always set this local "specialChars" to a function to which we pass the remaining text and whatever the original vars.specialChars was so that if it\'s an array, it works with the _findSpecialChars() function.\n  text,\n      splitText,\n      i,\n      j,\n      l,\n      character,\n      hasTagStart,\n      testResult,\n      container = _doc.createElement("div"),\n      parent = element.parentNode;\n\n  parent.insertBefore(container, element);\n  container.textContent = element.nodeValue;\n  parent.removeChild(element);\n  element = container;\n  text = getText(element);\n  hasTagStart = text.indexOf("<") !== -1;\n\n  if (vars.reduceWhiteSpace !== false) {\n    text = text.replace(_multipleSpacesExp, " ").replace(_stripExp, "");\n  }\n\n  if (hasTagStart) {\n    text = text.split("<").join("{{LT}}"); //we can\'t leave "<" in the string, or when we set the innerHTML, it can be interpreted as a node\n  }\n\n  l = text.length;\n  splitText = (text.charAt(0) === " " ? space : "") + wordStart();\n\n  for (i = 0; i < l; i++) {\n    character = text.charAt(i);\n\n    if (specialChars && (testResult = specialChars(text.substr(i), vars.specialChars))) {\n      // look for any specialChars that were declared. Remember, they can be passed in like {specialChars:["मी", "पा", "है"]} or a function could be defined instead. Either way, the function should return the number of characters that should be grouped together for this "character".\n      character = text.substr(i, testResult || 1);\n      splitText += chars && character !== " " ? charStart() + character + "</" + tag + ">" : character;\n      i += testResult - 1;\n    } else if (character === wordDelimiter && text.charAt(i - 1) !== wordDelimiter && i) {\n      splitText += wordIsOpen ? wordEnd : "";\n      wordIsOpen = 0;\n\n      while (text.charAt(i + 1) === wordDelimiter) {\n        //skip over empty spaces (to avoid making them words)\n        splitText += space;\n        i++;\n      }\n\n      if (i === l - 1) {\n        splitText += space;\n      } else if (text.charAt(i + 1) !== ")") {\n        splitText += space + wordStart();\n        wordIsOpen = 1;\n      }\n    } else if (character === "{" && text.substr(i, 6) === "{{LT}}") {\n      splitText += chars ? charStart() + "{{LT}}" + "</" + tag + ">" : "{{LT}}";\n      i += 5;\n    } else if (character.charCodeAt(0) >= 0xD800 && character.charCodeAt(0) <= 0xDBFF || text.charCodeAt(i + 1) >= 0xFE00 && text.charCodeAt(i + 1) <= 0xFE0F) {\n      //special emoji characters use 2 or 4 unicode characters that we must keep together.\n      j = ((text.substr(i, 12).split(emojiExp) || [])[1] || "").length || 2;\n      splitText += chars && character !== " " ? charStart() + text.substr(i, j) + "</" + tag + ">" : text.substr(i, j);\n      i += j - 1;\n    } else {\n      splitText += chars && character !== " " ? charStart() + character + "</" + tag + ">" : character;\n    }\n  }\n\n  element.outerHTML = splitText + (wordIsOpen ? wordEnd : "");\n\n  if (hasTagStart) {\n    _swapText(parent, "{{LT}}", "<"); //note: don\'t perform this on "element" because that gets replaced with all new elements when we set element.outerHTML.\n\n  }\n},\n    _split = function _split(element, vars, wordStart, charStart) {\n  var children = _toArray(element.childNodes),\n      l = children.length,\n      absolute = _isAbsolute(vars),\n      i,\n      child;\n\n  if (element.nodeType !== 3 || l > 1) {\n    vars.absolute = false;\n\n    for (i = 0; i < l; i++) {\n      child = children[i];\n\n      if (child.nodeType !== 3 || /\\S+/.test(child.nodeValue)) {\n        if (absolute && child.nodeType !== 3 && _getComputedStyle(child).display === "inline") {\n          //if there\'s a child node that\'s display:inline, switch it to inline-block so that absolute positioning works properly (most browsers don\'t report offsetTop/offsetLeft properly inside a <span> for example)\n          child.style.display = "inline-block";\n          child.style.position = "relative";\n        }\n\n        child._isSplit = true;\n\n        _split(child, vars, wordStart, charStart); //don\'t split lines on child elements\n\n      }\n    }\n\n    vars.absolute = absolute;\n    element._isSplit = true;\n    return;\n  }\n\n  _splitRawText(element, vars, wordStart, charStart);\n};\n\nvar SplitText = /*#__PURE__*/function () {\n  function SplitText(element, vars) {\n    if (!_coreInitted) {\n      _initCore();\n    }\n\n    this.elements = _toArray(element);\n    this.chars = [];\n    this.words = [];\n    this.lines = [];\n    this._originals = [];\n    this.vars = vars || {};\n\n    if (_bonusValidated) {\n      this.split(vars);\n    }\n  }\n\n  var _proto = SplitText.prototype;\n\n  _proto.split = function split(vars) {\n    if (this.isSplit) {\n      this.revert();\n    }\n\n    this.vars = vars = vars || this.vars;\n    this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;\n\n    var i = this.elements.length,\n        tag = vars.tag ? vars.tag : vars.span ? "span" : "div",\n        wordStart = _cssClassFunc(vars.wordsClass, tag),\n        charStart = _cssClassFunc(vars.charsClass, tag),\n        origHeight,\n        origWidth,\n        e; //we split in reversed order so that if/when we position:absolute elements, they don\'t affect the position of the ones after them in the document flow (shifting them up as they\'re taken out of the document flow).\n\n\n    while (--i > -1) {\n      e = this.elements[i];\n      this._originals[i] = e.innerHTML;\n      origHeight = e.clientHeight;\n      origWidth = e.clientWidth;\n\n      _split(e, vars, wordStart, charStart);\n\n      _setPositionsAfterSplit(e, vars, this.chars, this.words, this.lines, origWidth, origHeight);\n    }\n\n    this.chars.reverse();\n    this.words.reverse();\n    this.lines.reverse();\n    this.isSplit = true;\n    return this;\n  };\n\n  _proto.revert = function revert() {\n    var originals = this._originals;\n\n    if (!originals) {\n      throw "revert() call wasn\'t scoped properly.";\n    }\n\n    this.elements.forEach(function (e, i) {\n      return e.innerHTML = originals[i];\n    });\n    this.chars = [];\n    this.words = [];\n    this.lines = [];\n    this.isSplit = false;\n    return this;\n  };\n\n  SplitText.create = function create(element, vars) {\n    return new SplitText(element, vars);\n  };\n\n  return SplitText;\n}();\nSplitText.version = "3.2.6";\n\n// EXTERNAL MODULE: ./node_modules/prevent-scrolling/dist/index.js\nvar dist = __webpack_require__(2912);\n;// CONCATENATED MODULE: ./app/src/js/app/appUi.js\nfunction appUi_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction appUi_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction appUi_createClass(Constructor, protoProps, staticProps) { if (protoProps) appUi_defineProperties(Constructor.prototype, protoProps); if (staticProps) appUi_defineProperties(Constructor, staticProps); return Constructor; }\n\n// App\n\n // Classes\n\n // GSAP Library\n\n\n\n\nvar _singleton = null;\n\nvar appUi = /*#__PURE__*/function () {\n  function appUi(data) {\n    appUi_classCallCheck(this, appUi);\n\n    if (!_singleton) {\n      this.data = data;\n      _singleton = this;\n    } else {\n      return _singleton;\n    } // Store\n\n\n    this.appStore = appStore; // App references\n\n    this.appCore = new app_appCore(); // Events\n\n    this.domEvents = new domEvents_default();\n    this.menu = null;\n    this.guides = null;\n    this.background = null;\n    this.isAnimating = false;\n    this.isOpen = false;\n    this.appStore.firstNavigation = this.appStore.currentSection === null;\n  }\n\n  appUi_createClass(appUi, [{\n    key: "selectors",\n    value: function selectors() {\n      // Default\n      this.$app = document.getElementById(\'app\');\n      this.$mask = document.getElementById(\'mask\');\n      this.$header = document.getElementById(\'header\');\n      this.$trigger = document.getElementById(\'trigger\');\n      this.$logo = document.getElementById(\'logo\');\n      this.$requestButton = document.getElementById(\'button--request\');\n      this.$circleButton = document.getElementById(\'button--circle\'); // Menu\n\n      this.$menu = document.getElementById(\'menu\');\n\n      if (this.$menu) {\n        this.$menuMask = this.$menu.querySelector(\'.menu__mask\');\n        this.$menuContent = this.$menu.querySelector(\'.menu__content\');\n        this.$menuLinks = this.$menu.querySelectorAll(\'li\');\n      } // Guides\n\n\n      this.$guides = document.getElementById(\'guides\');\n\n      if (this.$guides) {\n        this.$guidesSwitcher = this.$guides.querySelector(\'.guides__switcher\');\n        this.$guidesSwitcher2 = this.$guides.querySelector(\'.guides__switcher2\');\n        this.$guidesHr = this.$guides.querySelector(\'.guides__horizontal\');\n        this.$guidesVr = this.$guides.querySelector(\'.guides__vertical\');\n        this.$guidesHr2 = this.$guides.querySelector(\'.guides__horizontal2\');\n        this.$guidesVr2 = this.$guides.querySelector(\'.guides__vertical2\');\n      } // Loader\n      // this.$loader = document.getElementById(\'loader\');\n      // if(this.$loader)\n      // {\n      //     this.$loaderInner = this.$loader.querySelector(\'.inner\');\n      //     this.$loaderProgress = this.$loader.querySelector(\'.inner .progress\');\n      // }\n      // Cookies\n\n\n      this.$cookies = document.getElementById(\'cookie-law-info-bar\');\n\n      if (this.$cookies) {\n        this.$cookiesButton = document.querySelectorAll(\'a.medium\');\n        this.$cookiesModal = document.querySelector(\'.cli-modal\');\n        this.$cookiesSave = this.$cookiesModal.querySelector(\'a#wt-cli-privacy-save-btn\');\n        this.$cookiesCategory = this.$cookiesModal.querySelectorAll(\'a.cli-nav-link\');\n      } // Notice\n\n\n      this.$notice = document.getElementById(\'notice\');\n    }\n  }, {\n    key: "events",\n    value: function events() {\n      var _this = this;\n\n      if (this.$guides) {\n        this.domEvents.add(this.$guidesSwitcher, \'click\', function () {\n          _this.guidesSwitcher();\n        });\n        this.domEvents.add(this.$guidesSwitcher2, \'click\', function () {\n          _this.guidesSwitcher2();\n        });\n      }\n    }\n  }, {\n    key: "init",\n    value: function init() {\n      if (this.$menuLinks) {\n        for (var i = 0; i < this.$menuLinks.length; i++) {\n          // eslint-disable-next-line no-new\n          new SplitText(this.$menuLinks[i], {\n            type: \'lines words chars\',\n            linesClass: \'line line--++\',\n            wordsClass: \'word word--++\',\n            charsClass: \'char char--++\'\n          });\n          var chars = this.$menuLinks[i].querySelectorAll(\'.char\');\n\n          for (var j = 0; j < chars.length; j++) {\n            node_modules_gsap/* default.set */.ZP.set(chars[j], {\n              opacity: 0.0001,\n              y: \'-100%\',\n              rotation: \'3deg\'\n            });\n          }\n        }\n      }\n\n      if (this.$cookies) {\n        // Cookies\n        if (this.$cookiesButton) {\n          // eslint-disable-next-line no-script-url\n          var disabled = \'javascript: void(0)\';\n\n          for (var _i = 0; _i < this.$cookiesButton.length; _i++) {\n            this.$cookiesButton[_i].setAttribute(\'href\', disabled);\n          }\n        }\n\n        if (this.$cookiesModal) {\n          // eslint-disable-next-line no-script-url\n          var _disabled = \'javascript: void(0)\';\n          this.$cookiesSave.setAttribute(\'href\', _disabled);\n\n          for (var _i2 = 0; _i2 < this.$cookiesCategory.length; _i2++) {\n            this.$cookiesCategory[_i2].setAttribute(\'href\', _disabled);\n          }\n        }\n      }\n    }\n  }, {\n    key: "hideLoader",\n    value: function hideLoader() {\n      var _this2 = this;\n\n      // Opacity\n      if (this.appStore.current !== \'home\') {\n        node_modules_gsap/* default.to */.ZP.to(this.appStore.currentSection.wrap, {\n          opacity: 1,\n          duration: 1,\n          ease: \'power2.out\',\n          onComplete: function onComplete() {\n            if (_this2.$cookies) node_modules_gsap/* default.to */.ZP.to(_this2.$cookies, {\n              opacity: 1,\n              duration: 1,\n              ease: \'power2.out\'\n            });\n          }\n        });\n      } else {\n        node_modules_gsap/* default.to */.ZP.to(this.appStore.currentSection.wrap, {\n          opacity: 1,\n          duration: 1,\n          ease: \'power2.out\',\n          onComplete: function onComplete() {\n            if (!_this2.appStore.isDesktop) node_modules_gsap/* default.to */.ZP.to(_this2.$cookies, {\n              opacity: 1,\n              duration: 1,\n              ease: \'power2.out\'\n            });\n          }\n        });\n      }\n    }\n  }, {\n    key: "showHeader",\n    value: function showHeader() {\n      if (this.appStore.isDesktop) node_modules_gsap/* default.to */.ZP.to(this.$header, {\n        opacity: 1,\n        duration: 1.2,\n        ease: \'power2.out\'\n      });else node_modules_gsap/* default.to */.ZP.to(this.$header, {\n        opacity: 1,\n        duration: 0.8,\n        ease: \'power2.out\'\n      });\n    }\n  }, {\n    key: "hideHeader",\n    value: function hideHeader() {\n      node_modules_gsap/* default.to */.ZP.to(this.$header, {\n        opacity: 0.0001,\n        duration: 0.4,\n        ease: \'power2.out\'\n      });\n    }\n  }, {\n    key: "goLight",\n    value: function goLight() {// gsap.to(document.body, { backgroundColor: \'#FFFFFF\', duration: 1.2, ease: \'power2.out\' });\n    }\n  }, {\n    key: "goDark",\n    value: function goDark() {// gsap.to(document.body, { backgroundColor: \'#000A33\', duration: 1.2, ease: \'power2.out\' });\n    }\n  }, {\n    key: "enterTrigger",\n    value: function enterTrigger() {\n      if (this.isOpen) return;\n      node_modules_gsap/* default.killTweensOf */.ZP.killTweensOf(this.$trigger.children[0].children[0], this.$trigger.children[0].children[1]);\n      node_modules_gsap/* default.to */.ZP.to(this.$trigger.children[0].children[0], {\n        y: \'-200%\',\n        duration: 0.6,\n        ease: \'expo.out\'\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$trigger.children[0].children[1], {\n        y: \'110%\',\n        duration: 0.6,\n        ease: \'expo.out\'\n      });\n    }\n  }, {\n    key: "leaveTrigger",\n    value: function leaveTrigger() {\n      if (this.isOpen) return;\n      node_modules_gsap/* default.killTweensOf */.ZP.killTweensOf(this.$trigger.children[0].children[0], this.$trigger.children[0].children[1]);\n      node_modules_gsap/* default.to */.ZP.to(this.$trigger.children[0].children[0], {\n        y: \'-350%\',\n        duration: 0.6,\n        ease: \'expo.out\'\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$trigger.children[0].children[1], {\n        y: \'260%\',\n        duration: 0.6,\n        ease: \'expo.out\'\n      });\n    }\n  }, {\n    key: "openMenu",\n    value: function openMenu() {\n      var _this3 = this;\n\n      if (this.isAnimating) return;\n      this.isAnimating = true;\n      this.isOpen = true;\n      if (this.appStore.isDesktop) this.appStore.currentSection.superScroller._scroll.enable = false;else this.disableScroll();\n\n      if (!this.appStore.isDesktop) {\n        node_modules_gsap/* default.to */.ZP.to(this.$logo, {\n          opacity: 0.0001,\n          duration: 0.2,\n          ease: \'power2.out\',\n          onComplete: function onComplete() {\n            node_modules_gsap/* default.set */.ZP.set(_this3.$logo, {\n              display: \'none\'\n            });\n          }\n        });\n      }\n\n      node_modules_gsap/* default.set */.ZP.set(this.$menu, {\n        display: \'block\'\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$trigger.children[0].children[0], {\n        y: \'-50%\',\n        rotation: 45,\n        duration: 1.2,\n        ease: \'expo.out\'\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$trigger.children[0].children[1], {\n        y: \'-50%\',\n        rotation: -45,\n        duration: 1.2,\n        ease: \'expo.out\'\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$menuMask, {\n        opacity: 1,\n        duration: 0.4,\n        ease: \'power2.out\'\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$menuContent, {\n        scaleY: 1,\n        duration: 1,\n        ease: \'expo.inOut\'\n      });\n      if (!this.appStore.isDesktop) node_modules_gsap/* default.to */.ZP.to(this.$requestButton, {\n        opacity: 1,\n        duration: 0.8,\n        ease: \'power2.out\',\n        delay: 1\n      });\n\n      for (var i = 0; i < this.$menuLinks.length; i++) {\n        var chars = this.$menuLinks[i].querySelectorAll(\'.char\');\n\n        for (var j = 0; j < chars.length; j++) {\n          node_modules_gsap/* default.to */.ZP.to(chars[j], {\n            opacity: 1,\n            y: \'0%\',\n            rotation: 0,\n            ease: \'expo.inOut\',\n            duration: 1,\n            delay: 0.3 + j * 0.01\n          });\n        }\n      }\n    }\n  }, {\n    key: "closeMenu",\n    value: function closeMenu() {\n      var _this4 = this;\n\n      if (!this.appStore.isDesktop) node_modules_gsap/* default.set */.ZP.set(this.$logo, {\n        display: \'block\'\n      });\n\n      for (var i = 0; i < this.$menuLinks.length; i++) {\n        var chars = this.$menuLinks[i].querySelectorAll(\'.char\');\n        node_modules_gsap/* default.to */.ZP.to(chars, {\n          opacity: 0.0001,\n          y: \'-100%\',\n          rotation: \'3deg\',\n          stagger: 0.01,\n          ease: \'expo.inOut\',\n          duration: 0.5\n        });\n      }\n\n      node_modules_gsap/* default.to */.ZP.to(this.$menuContent, {\n        scaleY: 0,\n        duration: 0.6,\n        ease: \'expo.inOut\',\n        delay: 0.6\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$trigger.children[0].children[0], {\n        y: this.appStore.isDesktop ? \'-350%\' : \'-500%\',\n        rotation: 0,\n        duration: 1.2,\n        ease: \'expo.out\'\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$trigger.children[0].children[1], {\n        y: this.appStore.isDesktop ? \'260%\' : \'400%\',\n        rotation: 0,\n        duration: 1.2,\n        ease: \'expo.out\'\n      });\n\n      if (!this.appStore.isDesktop) {\n        node_modules_gsap/* default.to */.ZP.to(this.$requestButton, {\n          opacity: 0.0001,\n          duration: 0.6,\n          ease: \'power2.out\',\n          delay: 0.4\n        });\n        if (document.documentElement.scrollTop === 0) node_modules_gsap/* default.to */.ZP.to(this.$logo, {\n          opacity: 1,\n          duration: 0.1,\n          ease: \'power2.out\',\n          delay: 1.2\n        });\n      }\n\n      node_modules_gsap/* default.to */.ZP.to(this.$menuMask, {\n        opacity: 0.0001,\n        duration: 0.6,\n        ease: \'power2.out\',\n        delay: 0.6,\n        onComplete: function onComplete() {\n          if (_this4.appStore.isDesktop) _this4.appStore.currentSection.superScroller._scroll.enable = true;else _this4.enableScroll();\n          node_modules_gsap/* default.set */.ZP.set(_this4.$menu, {\n            display: \'none\'\n          }); // gsap.set(this.$trigger, { pointerEvents: \'initial\' });\n\n          _this4.isAnimating = false;\n          _this4.isOpen = false;\n        }\n      });\n    }\n  }, {\n    key: "closeMenuOpacity",\n    value: function closeMenuOpacity() {\n      var _this5 = this;\n\n      if (!this.appStore.isDesktop) node_modules_gsap/* default.set */.ZP.set(this.$logo, {\n        display: \'block\'\n      });\n\n      for (var i = 0; i < this.$menuLinks.length; i++) {\n        var chars = this.$menuLinks[i].querySelectorAll(\'.char\');\n        node_modules_gsap/* default.to */.ZP.to(chars, {\n          opacity: 0.0001,\n          y: \'-100%\',\n          rotation: \'3deg\',\n          stagger: 0.01,\n          ease: \'expo.inOut\',\n          duration: 0.5\n        });\n      }\n\n      node_modules_gsap/* default.to */.ZP.to(this.$menuContent, {\n        scaleY: 0,\n        duration: 0.6,\n        ease: \'expo.inOut\',\n        delay: 0.6\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$trigger.children[0].children[0], {\n        y: this.appStore.isDesktop ? \'-350%\' : \'-500%\',\n        rotation: 0,\n        duration: 1.2,\n        ease: \'expo.out\'\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$trigger.children[0].children[1], {\n        y: this.appStore.isDesktop ? \'260%\' : \'400%\',\n        rotation: 0,\n        duration: 1.2,\n        ease: \'expo.out\'\n      });\n\n      if (!this.appStore.isDesktop) {\n        node_modules_gsap/* default.to */.ZP.to(this.$requestButton, {\n          opacity: 0.0001,\n          duration: 0.6,\n          ease: \'power2.out\',\n          delay: 0.4\n        });\n        if (document.documentElement.scrollTop === 0) node_modules_gsap/* default.to */.ZP.to(this.$logo, {\n          opacity: 1,\n          duration: 0.1,\n          ease: \'power2.out\',\n          delay: 1.2\n        });\n      }\n\n      node_modules_gsap/* default.to */.ZP.to(this.$menu, {\n        opacity: 0.0001,\n        duration: 0.4,\n        ease: \'power2.out\',\n        onComplete: function onComplete() {\n          if (_this5.appStore.isDesktop) _this5.appStore.currentSection.superScroller._scroll.enable = true;\n          node_modules_gsap/* default.set */.ZP.set(_this5.$menu, {\n            display: \'none\'\n          });\n          _this5.isAnimating = false;\n          _this5.isOpen = false;\n        }\n      });\n    }\n  }, {\n    key: "enableScroll",\n    value: function enableScroll() {\n      document.documentElement.classList.remove(\'noscroll\');\n      (0,dist/* ReEnableScrolling */.A_)();\n    }\n  }, {\n    key: "disableScroll",\n    value: function disableScroll() {\n      document.documentElement.classList.add(\'noscroll\');\n      (0,dist/* PreventScrolling */.Kh)(Array.from(document.querySelectorAll(\'[prevent-scrolling-disabled]\')));\n    }\n  }, {\n    key: "guidesSwitcher",\n    value: function guidesSwitcher() {\n      if (this.$guidesHr.style.display === \'block\') {\n        node_modules_gsap/* default.set */.ZP.set(this.$guidesHr, {\n          display: \'none\'\n        });\n        node_modules_gsap/* default.set */.ZP.set(this.$guidesVr, {\n          display: \'none\'\n        });\n      } else {\n        node_modules_gsap/* default.set */.ZP.set(this.$guidesHr, {\n          display: \'block\'\n        });\n        node_modules_gsap/* default.set */.ZP.set(this.$guidesVr, {\n          display: \'block\'\n        });\n      }\n    }\n  }, {\n    key: "guidesSwitcher2",\n    value: function guidesSwitcher2() {\n      if (this.$guidesHr2.style.display === \'block\') {\n        node_modules_gsap/* default.set */.ZP.set(this.$guidesHr2, {\n          display: \'none\'\n        });\n        node_modules_gsap/* default.set */.ZP.set(this.$guidesVr2, {\n          display: \'none\'\n        });\n      } else {\n        node_modules_gsap/* default.set */.ZP.set(this.$guidesHr2, {\n          display: \'block\'\n        });\n        node_modules_gsap/* default.set */.ZP.set(this.$guidesVr2, {\n          display: \'block\'\n        });\n      }\n    }\n  }, {\n    key: "resize",\n    value: function resize(width, height) {\n      if (navigator.userAgent.match(\'Mobile\') && this.$notice) {\n        if (width > height) node_modules_gsap/* default.set */.ZP.set(this.$notice, {\n          display: \'block\'\n        });else node_modules_gsap/* default.set */.ZP.set(this.$notice, {\n          display: \'none\'\n        });\n      }\n    }\n  }]);\n\n  return appUi;\n}();\n\n/* harmony default export */ const app_appUi = (appUi);\n// EXTERNAL MODULE: ./node_modules/@dogstudio/highway/build/highway.module.js\nvar highway_module = __webpack_require__(1219);\n// EXTERNAL MODULE: ./node_modules/preload-it/dist/preload-it.js\nvar preload_it = __webpack_require__(1130);\nvar preload_it_default = /*#__PURE__*/__webpack_require__.n(preload_it);\n// EXTERNAL MODULE: ./node_modules/lazyload/lazyload.js\nvar lazyload = __webpack_require__(261);\nvar lazyload_default = /*#__PURE__*/__webpack_require__.n(lazyload);\n// EXTERNAL MODULE: ./node_modules/virtual-scroll/lib/virtualscroll.js\nvar virtualscroll = __webpack_require__(9389);\nvar virtualscroll_default = /*#__PURE__*/__webpack_require__.n(virtualscroll);\n;// CONCATENATED MODULE: ./app/src/js/classes/superScroller.js\nfunction superScroller_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction superScroller_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction superScroller_createClass(Constructor, protoProps, staticProps) { if (protoProps) superScroller_defineProperties(Constructor.prototype, protoProps); if (staticProps) superScroller_defineProperties(Constructor, staticProps); return Constructor; }\n\n// utilities\n\n\n // empty function\n\nvar noop = function noop() {}; // eslint-disable-line\n\n\nvar _default = /*#__PURE__*/function () {\n  function _default(options) {\n    var _this = this;\n\n    superScroller_classCallCheck(this, _default);\n\n    // store\n    this.appStore = appStore; // hook functions\n\n    this._onRaf = options.onRaf || noop;\n    this._onScroll = options.onScroll || noop;\n    this._currentSection = options.currentSection ? options.currentSection : null;\n    this._global = {\n      percent: {\n        x: 0,\n        y: 0\n      },\n      lerp: 0.15,\n      mode: options.mode || \'vertical\'\n    };\n\n    var lerp = function lerp(value1, value2, amount) {\n      amount = amount < 0 ? 0 : amount;\n      amount = amount > 1 ? 1 : amount;\n      return value1 + (value2 - value1) * amount;\n    }; // scroll properties\n\n\n    if (options.scroll) {\n      // default virtualScroll options\n      this._virtualScroll = null;\n      this._virtualScrollOptions = {\n        el: typeof options.el !== \'undefined\' ? options.el : document.documentElement,\n        mouseMultiplier: typeof options.mouseMultiplier !== \'undefined\' ? options.mouseMultiplier : this.appStore.client.os === \'windows\' ? 1 : 0.4,\n        touchMultiplier: typeof options.touchMultiplier !== \'undefined\' ? options.touchMultiplier : 2,\n        firefoxMultiplier: typeof options.firefoxMultiplier !== \'undefined\' ? options.firefoxMultiplier : 50,\n        limitInertia: typeof options.limitInertia !== \'undefined\' ? options.limitInertia : false,\n        passive: typeof options.passive !== \'undefined\' ? options.pasive : false,\n        useKeyboard: false\n      };\n      this._scroll = {\n        enable: typeof options.enable !== \'undefined\' ? options.enable : true,\n        parent: typeof options.el !== \'undefined\' ? options.el : document.documentElement,\n        target: options.scrollTarget,\n        lockHeader: false,\n        width: 0,\n        height: 0,\n        timeout: false,\n        dragging: false,\n        ratio: {\n          x: 0,\n          y: 0\n        },\n        clickedPoint: {\n          x: 0,\n          y: 0\n        },\n        position: {\n          x: 0,\n          y: options.startAt !== null && typeof options.startAt !== \'undefined\' ? options.startAt : 0\n        },\n        lastPosition: {\n          x: 0,\n          y: options.startAt !== null && typeof options.startAt !== \'undefined\' ? options.startAt : 0\n        },\n        livePosition: {\n          x: 0,\n          y: options.startAt !== null && typeof options.startAt !== \'undefined\' ? options.startAt : 0\n        },\n        maxScroll: {\n          x: 0,\n          y: 0\n        }\n      };\n\n      this._scrollDown = function (e) {\n        // set flag\n        _this._scroll.dragging = true;\n\n        _this._scroll.target.classList.add(\'dragging\'); // get the point the user clicked on the bar\n\n\n        _this._scroll.clickedPoint.x = e.clientX - _this._scroll.livePosition.x;\n        _this._scroll.clickedPoint.y = e.clientY - _this._scroll.livePosition.y; // track the mouse events\n\n        document.addEventListener(\'mousemove\', _this._scrollDrag);\n        document.addEventListener(\'mouseup\', _this._scrollUp);\n      };\n\n      this._scrollDrag = function (e) {\n        if (_this._global.mode === \'horizontal\') {\n          // calculate the amount the user moved from the clicked point on the scrollbar, checking limits\n          _this._scroll.position.x = Math.min(0, Math.max(_this._scroll.maxScroll.x, e.clientX - _this._scroll.clickedPoint.x)); // update global percentage\n\n          _this._global.percent.x = _this._scroll.position.x / _this._scroll.maxScroll.x;\n        } else {\n          // calculate the amount the user moved from the clicked point on the scrollbar, checking limits\n          _this._scroll.position.y = Math.min(0, Math.max(_this._scroll.maxScroll.y, e.clientY - _this._scroll.clickedPoint.y)); // update global percentage\n\n          _this._global.percent.y = _this._scroll.position.y / _this._scroll.maxScroll.y;\n        }\n      };\n\n      this._scrollUp = function () {\n        // stop tracking the two mouse events\n        document.removeEventListener(\'mousemove\', _this._scrollDrag);\n        document.removeEventListener(\'mouseup\', _this._scrollUp); // set flag\n\n        _this._scroll.dragging = false;\n\n        _this._scroll.target.classList.remove(\'dragging\');\n      }; // bind mousedown event\n\n\n      if (this._global.mode === \'horizontal\') this._scroll.target.addEventListener(\'mousedown\', this._scrollDown);\n\n      this._scrollMove = function (e) {\n        _this._onScroll(); // Prevent pointerevents on scroll\n        // this._scroll.target.parentNode.style.pointerEvents = \'none\';\n\n\n        clearTimeout(_this._scroll.timeout); // this._scroll.timeout = setTimeout(() => {\n        //     this._scroll.target.parentNode.style.pointerEvents = \'all\';\n        // }, 200);\n        // check if scroll is allowed\n\n        if (!_this._scroll.enable) return; // update scroll\n\n        if (_this._global.mode === \'horizontal\') {\n          // get scroll values\n          _this._scroll.position.x = Math.min(0, Math.max(_this._scroll.maxScroll.x, _this._scroll.position.x += e.deltaY));\n          _this._scroll.position.x = Math.min(0, Math.max(_this._scroll.maxScroll.x, _this._scroll.position.x += e.deltaX));\n          _this._global.percent.x = _this._scroll.position.x / _this._scroll.maxScroll.x;\n          _this._global.percent.x = Number.isNaN(_this._global.percent.x) ? 0 : _this._global.percent.x;\n          _this._scroll.lastPosition.x = _this._scroll.position.x;\n        } else {\n          // get scroll values\n          _this._scroll.position.y = Math.min(0, Math.max(_this._scroll.maxScroll.y, _this._scroll.position.y += e.deltaY));\n          _this._global.percent.y = _this._scroll.position.y / _this._scroll.maxScroll.y;\n          _this._global.percent.y = Number.isNaN(_this._global.percent.y) ? 0 : _this._global.percent.y;\n          _this._scroll.lastPosition.y = _this._scroll.position.y;\n        }\n\n        e.originalEvent.preventDefault();\n      };\n\n      this._scrollRaf = function () {\n        if (_this._global.mode === \'horizontal\') _this._scroll.livePosition.x = lerp(_this._scroll.livePosition.x, _this._scroll.maxScroll.x * _this._global.percent.x, _this._global.lerp);else _this._scroll.livePosition.y = lerp(_this._scroll.livePosition.y, _this._scroll.maxScroll.y * _this._global.percent.y, _this._global.lerp);\n        _this._scroll.target.style.transform = \'translate3d(\' + _this._scroll.livePosition.x + \'px,\' + _this._scroll.livePosition.y + \'px, 0px)\';\n      };\n    } // bar properties\n\n\n    if (options.bar) {\n      this._bar = {\n        enable: true,\n        target: options.barTarget,\n        parent: options.barTarget.parentNode,\n        width: 0,\n        height: 0,\n        dragging: false,\n        ratio: {\n          x: 0,\n          y: 0\n        },\n        position: {\n          x: 0,\n          y: 0\n        },\n        livePosition: {\n          x: 0,\n          y: 0\n        },\n        maxScroll: {\n          x: 0,\n          y: 0\n        },\n        clickedPoint: {\n          x: 0,\n          y: 0\n        }\n      };\n\n      this._barDown = function (e) {\n        // set flag\n        _this._bar.dragging = true;\n\n        _this._bar.target.classList.add(\'dragging\'); // get the point the user clicked on the bar\n\n\n        _this._bar.clickedPoint.x = e.clientX - _this._bar.livePosition.x;\n        _this._bar.clickedPoint.y = e.clientY - _this._bar.livePosition.y; // track the mouse events\n\n        document.addEventListener(\'mousemove\', _this._barMove);\n        document.addEventListener(\'mouseup\', _this._barUp);\n      };\n\n      this._barMove = function (e) {\n        if (_this._global.mode === \'horizontal\') {\n          // calculate the amount the user moved from the clicked point on the scrollbar, checking limits\n          _this._bar.position.x = Math.min(Math.max(e.clientX - _this._bar.clickedPoint.x, 0), _this._bar.maxScroll.x); // update global percentage\n\n          _this._global.percent.x = _this._bar.position.x / _this._bar.maxScroll.x;\n          _this._scroll.position.x = _this._global.percent.x * _this._scroll.maxScroll.x;\n        } else {\n          // calculate the amount the user moved from the clicked point on the scrollbar, checking limits\n          _this._bar.position.y = Math.min(Math.max(e.clientY - _this._bar.clickedPoint.y, 0), _this._bar.maxScroll.y); // update global percentage\n\n          _this._global.percent.y = _this._bar.position.y / _this._bar.maxScroll.y;\n          _this._scroll.position.y = _this._global.percent.y * _this._scroll.maxScroll.y;\n        }\n      };\n\n      this._barUp = function () {\n        // stop tracking the two mouse events\n        document.removeEventListener(\'mousemove\', _this._barMove);\n        document.removeEventListener(\'mouseup\', _this._barUp); // set flag\n\n        _this._bar.dragging = false;\n\n        _this._bar.target.classList.remove(\'dragging\');\n      };\n\n      this._barRaf = function () {\n        if (_this._global.mode === \'horizontal\') _this._bar.livePosition.x = lerp(_this._bar.livePosition.x, _this._bar.maxScroll.x * _this._global.percent.x, 0.1);else _this._bar.livePosition.y = lerp(_this._bar.livePosition.y, _this._bar.maxScroll.y * _this._global.percent.y, 0.1);\n        _this._bar.target.style.transform = \'translate3d(\' + _this._bar.livePosition.x + \'px,\' + _this._bar.livePosition.y + \'px, 0px)\';\n      }; // bind mousedown event\n\n\n      this._bar.target.addEventListener(\'mousedown\', this._barDown);\n    }\n\n    this._raf = function () {\n      if (!_this._scroll.enable) return;\n      if (_this._scroll) _this._scrollRaf();\n      if (_this._bar) _this._barRaf();\n\n      _this._onRaf(_this._scroll.livePosition, _this._global.percent);\n    }; // bind to gsap ticker\n\n\n    node_modules_gsap/* gsap.ticker.add */.p8.ticker.add(this._raf); // bind\n\n    this.init();\n  }\n\n  superScroller_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      // virtualscroll properties\n      if (this._virtualScroll !== \'undefined\') {\n        this._virtualScroll = new (virtualscroll_default())(this._virtualScrollOptions);\n\n        this._virtualScroll.on(function (e) {\n          _this2._scrollMove(e);\n        });\n      }\n    }\n  }, {\n    key: "scrollAnimate",\n    value: function scrollAnimate(_position) {\n      var _this3 = this;\n\n      var _duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n\n      var _ease = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'power4.inOut\';\n\n      var _force = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      this._scroll.lockHeader = true;\n      _duration = this.appStore.client.browser === \'firefox\' ? _duration / 2 : _duration;\n      if (!_force && !this._scroll.enable) return;\n      this._scroll.position.y = Math.max(-_position, this._scroll.maxScroll.y);\n      node_modules_gsap/* gsap.to */.p8.to(this._global.percent, {\n        y: this._scroll.position.y / this._scroll.maxScroll.y,\n        ease: _ease,\n        duration: _duration\n      });\n      node_modules_gsap/* gsap.delayedCall */.p8.delayedCall(_duration * 5, function () {\n        _this3._scroll.lockHeader = false;\n      });\n    }\n  }, {\n    key: "scrollSet",\n    value: function scrollSet(_position) {\n      var _this4 = this;\n\n      this._scroll.lockHeader = true;\n      this._global.lerp = 1;\n      this._scroll.position.y = Math.max(-_position, this._scroll.maxScroll.y);\n      this._global.percent.y = this._scroll.position.y / this._scroll.maxScroll.y;\n      node_modules_gsap/* gsap.delayedCall */.p8.delayedCall(1, function () {\n        _this4._global.lerp = 0.05;\n      });\n      node_modules_gsap/* gsap.delayedCall */.p8.delayedCall(5, function () {\n        _this4._scroll.lockHeader = false;\n      });\n    }\n  }, {\n    key: "scrollResize",\n    value: function scrollResize() {\n      //\n      this._scroll.width = this._scroll.target.getBoundingClientRect().width;\n      this._scroll.height = this._scroll.target.getBoundingClientRect().height;\n      this._scroll.parentWidth = this._scroll.parent.getBoundingClientRect().height;\n      this._scroll.parentHeight = this._scroll.parent.getBoundingClientRect().height;\n      this._scroll.maxScroll.x = -(this._scroll.width - this._scroll.parentWidth);\n      this._scroll.maxScroll.y = -(this._scroll.height - this._scroll.parentHeight);\n      this._global.percent.x = this._scroll.position.x / this._scroll.maxScroll.x;\n      this._global.percent.x = Number.isNaN(this._global.percent.x) ? 0 : this._global.percent.x;\n      this._global.percent.y = this._scroll.position.y / this._scroll.maxScroll.y;\n      this._global.percent.y = Number.isNaN(this._global.percent.y) ? 0 : this._global.percent.y;\n    }\n  }, {\n    key: "barResize",\n    value: function barResize() {\n      // get container el sizes\n      this._bar.parentWidth = this._bar.parent.getBoundingClientRect().width;\n      this._bar.parentHeight = this._bar.parent.getBoundingClientRect().height; // get bar size\n\n      if (this._global.mode === \'horizontal\') {\n        this._bar.width = this._bar.parentWidth * (this._scroll.parentWidth / this._scroll.width);\n        this._bar.height = this._bar.target.getBoundingClientRect().height;\n        this._bar.target.style.width = this._bar.width + \'px\';\n      } else {\n        this._bar.width = this._bar.target.getBoundingClientRect().width;\n        this._bar.height = this._bar.parentHeight * (this._scroll.parentHeight / this._scroll.height);\n        this._bar.target.style.height = this._bar.height + \'px\';\n      } // calculate maximum scroll\n\n\n      this._bar.maxScroll.x = this._bar.parentWidth - this._bar.width;\n      this._bar.maxScroll.y = this._bar.parentHeight - this._bar.height;\n      this._bar.ratio.x = this._bar.width / this._bar.parentWidth;\n      this._bar.ratio.y = this._bar.height / this._bar.parentHeight;\n    }\n  }, {\n    key: "resize",\n    value: function resize() {\n      if (this._scroll) this.scrollResize();\n      if (this._bar) this.barResize();\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      node_modules_gsap/* gsap.ticker.remove */.p8.ticker.remove(this._raf);\n    }\n  }]);\n\n  return _default;\n}();\n\n\n// EXTERNAL MODULE: ./node_modules/gsap/ScrollTrigger.js\nvar ScrollTrigger = __webpack_require__(7082);\n;// CONCATENATED MODULE: ./app/src/js/renderers/renderer.js\nfunction renderer_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { renderer_typeof = function _typeof(obj) { return typeof obj; }; } else { renderer_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return renderer_typeof(obj); }\n\nfunction renderer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction renderer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction renderer_createClass(Constructor, protoProps, staticProps) { if (protoProps) renderer_defineProperties(Constructor.prototype, protoProps); if (staticProps) renderer_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (renderer_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n// App\n\n\n // Classes\n\n // Highway\n\n // Preload\n\n\n // Utilities\n\n // GSAP Library\n\n\n\n\nnode_modules_gsap/* default.registerPlugin */.ZP.registerPlugin(ScrollTrigger/* default */.Z);\n\nvar Renderer = /*#__PURE__*/function (_Highway$Renderer) {\n  _inherits(Renderer, _Highway$Renderer);\n\n  var _super = _createSuper(Renderer);\n\n  function Renderer(properties) {\n    var _this;\n\n    renderer_classCallCheck(this, Renderer);\n\n    _this = _super.call(this, properties); // Store\n\n    _this.appStore = appStore; // App references\n\n    _this.appCore = new app_appCore();\n    _this.appUi = new app_appUi(); // Events\n\n    _this.domEvents = new domEvents_default();\n    _this.hash = window.location.hash !== \'\' ? window.location.hash : null;\n    _this.params = new URLSearchParams(window.location.search);\n    _this.appStore.firstNavigation = _this.appStore.currentSection === null; // Preloader\n\n    _this.preloadMain = null;\n    _this.preloadSecondary = null;\n    _this.preloadDelay = 1;\n    _this.preloadItems = {\n      // main: [\'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerEscapes.mp4\', \'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\', \'https://images.pexels.com/photos/248797/pexels-photo-248797.jpeg\'], // Test\n      main: [],\n      // Mandatory items\n      secondary: [] // Secondary items\n\n    }; // Scroll\n\n    _this.superScroller = null;\n    _this.superTrigger = null;\n    _this.appStore.currentSection = _assertThisInitialized(_this);\n    _this.appStore.current = _this.properties.slug;\n    _this._scroll = 0;\n    _this._scrollPosition = document.documentElement.scrollTop;\n    _this.form = {\n      isAnimating: false\n    };\n    return _this;\n  }\n\n  renderer_createClass(Renderer, [{\n    key: "onEnter",\n    value: function onEnter() {\n      this.preselectors();\n      this.selectors();\n      this.events();\n      this.preload();\n\n      if (!this.params.has(\'trp-edit-translation\')) {\n        // Set animations\n        this.setForms();\n        this.setLabels();\n        this.setTitles();\n        this.setTitlesLarge();\n        this.setTexts();\n        this.setImages();\n        this.setLines();\n        this.setLinks();\n        this.setWords();\n        this.setDraggables();\n        if (this.appStore.isDesktop) this.setFooter();\n      }\n\n      this.beforeEnter();\n    }\n  }, {\n    key: "preselectors",\n    value: function preselectors() {\n      // Set reference to current section\n      this.$app = document.getElementById(\'app\');\n      this.$el = this.wrap.lastElementChild;\n      this.$inner = this.$el.querySelector(\'[data-scroll-wrapper] .inner\');\n      this.$scrollbar = this.$el.querySelector(\'[data-scroll-wrapper] .scrollbar\'); // Forms\n\n      this.$hubspot = this.$el.querySelector(\'.hubspot\');\n\n      if (this.$hubspot) {\n        this.$hubspotMask = this.$hubspot.querySelector(\'.hubspot__mask\');\n        this.$hubspotContent = this.$hubspot.querySelector(\'.hubspot__content\');\n        this.$hubspotCloser = this.$hubspot.querySelector(\'.hubspot__closer\');\n        this.$hubspotForm = document.getElementById(\'hubspotform\');\n      } // Scroll\n\n\n      this.$scroll = this.$el.querySelector(\'#scroll\');\n    }\n  }, {\n    key: "selectors",\n    value: function selectors() {} // eslint-disable-line\n\n  }, {\n    key: "events",\n    value: function events() {} // eslint-disable-line\n\n  }, {\n    key: "preload",\n    value: function preload() {} // eslint-disable-line\n\n  }, {\n    key: "checkElements",\n    value: function checkElements() {\n      if (this.appStore.isDesktop) {\n        this.$elementsMobile = document.querySelectorAll(\'[data-mobile]\');\n\n        for (var i = 0; i < this.$elementsMobile.length; i++) {\n          this.$elementsMobile[i].remove();\n        }\n      } else {\n        this.$elementsDesktop = document.querySelectorAll(\'[data-desktop]\');\n\n        for (var _i = 0; _i < this.$elementsDesktop.length; _i++) {\n          this.$elementsDesktop[_i].remove();\n        }\n      }\n    }\n  }, {\n    key: "beforeEnter",\n    value: function beforeEnter() {} // eslint-disable-line\n\n  }, {\n    key: "onEnterCompleted",\n    value: function onEnterCompleted() {\n      var _this2 = this;\n\n      // Reset Scroll\n      window.scrollTo(0, 0);\n      document.documentElement.scrollTop = 0; // Lazy load\n\n      this.lazyLoad = new (lazyload_default())(this.lazyLoad, {\n        root: null,\n        rootMargin: window.innerHeight * 0.25 + \'px\',\n        threshold: 0\n      }); // If first navigation and need preload\n\n      if (this.preloadItems.main.length > 0 && this.appStore.firstNavigation) {\n        var _preloadOn = new Date().getTime();\n\n        this.preloadMain = preload_it_default()();\n        this.preloadMain.fetch(this.preloadItems.main);\n\n        this.preloadMain.onprogress = function (event) {\n          /* this.appUi.$loaderProgress.innerHTML = event.progress + \'%\'; */\n        };\n\n        this.preloadMain.oncomplete = function (items) {\n          var _preloadOff = new Date().getTime();\n\n          var _preloadDifference = (_preloadOff - _preloadOn) / 1000;\n\n          var _preloadDelay = Math.max(0, _this2.preloadDelay - _preloadDifference);\n\n          node_modules_gsap/* default.delayedCall */.ZP.delayedCall(_preloadDelay, function () {\n            _this2.start();\n          });\n        };\n      } // If first navigation but dont need preloads\n      else if (this.preloadItems.main.length === 0 && this.appStore.firstNavigation) {\n        node_modules_gsap/* default.delayedCall */.ZP.delayedCall(this.preloadDelay, function () {\n          _this2.start();\n        });\n      } // If not first navigation\n      else {\n        this.start();\n      }\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      // Reset Scroll\n      window.scrollTo(0, 0);\n      document.documentElement.scrollTop = 0;\n      if (this.appStore.firstNavigation) this.appUi.hideLoader(); // Menu\n\n      this.eventsAlternative();\n      this.scroll();\n      if (this.appStore.firstNavigation) this.appCore.navigateStart();\n\n      if (!this.params.has(\'trp-edit-translation\')) {\n        // Init animations\n        this.initLabels();\n        this.initTitles();\n        this.initTitlesLarge();\n        this.initTexts();\n        this.initImages();\n        this.initLines();\n        this.initLinks();\n        this.initWords();\n        this.initAnchors();\n        this.initDraggables();\n        this.initCarousel();\n        if (this.appStore.isDesktop) this.initFooter();\n      }\n\n      this.enter();\n      if (this.appStore.firstNavigation && this.appStore.current !== \'home\') this.appUi.showHeader();\n      this.beforeResize(window.innerWidth, window.innerHeight);\n      if (this.hash) this.scrollTo(this.hash);\n      this.hideLogo();\n\n      if (this.preloadItems.secondary.length > 0) {\n        this.preloadSecondary = preload_it_default()();\n        this.preloadSecondary.fetch(this.preloadItems.secondary);\n      }\n\n      if (this.appStore.isDesktop && this.$scroll) this.scrollRotate();\n    }\n  }, {\n    key: "scroll",\n    value: function scroll() {\n      var _this3 = this,\n          _arguments = arguments;\n\n      if (this.$inner) {\n        if (this.appStore.isDesktop) {\n          // Superscroller\n          this.superScroller = new _default({\n            scroll: true,\n            scrollTarget: this.$inner,\n            bar: true,\n            barTarget: this.$scrollbar.children[0],\n            onRaf: function onRaf(scroll, percent) {\n              _this3.raf();\n\n              if (_this3.superTrigger) _this3.superTrigger.update();\n            }\n          }); // Scroll Trigger\n\n          this.superTrigger = ScrollTrigger/* default */.Z;\n          this.superTrigger.defaults({\n            scroller: this.$inner\n          });\n          this.superTrigger.scrollerProxy(this.$inner, {\n            scrollTop: function scrollTop(value) {\n              if (_arguments.length) _this3.superScroller._scroll.livePosition.y = -value;\n              return -_this3.superScroller._scroll.livePosition.y;\n            },\n            getBoundingClientRect: function getBoundingClientRect() {\n              return {\n                top: 0,\n                left: 0,\n                width: window.innerWidth,\n                height: window.innerHeight\n              };\n            }\n          });\n          this.superTrigger.refresh();\n        } else {\n          this.superTrigger = ScrollTrigger/* default */.Z;\n          this.superTrigger.config({\n            autoRefreshEvents: \'DOMContentLoaded,load\',\n            syncInterval: 999999999\n          });\n          this.superTrigger.refresh();\n          this.superTrigger = node_modules_gsap/* default.timeline */.ZP.timeline({\n            defaults: {\n              ease: \'none\'\n            },\n            scrollTrigger: {\n              trigger: this.$app,\n              scrub: true,\n              start: \'top top\',\n              end: \'bottom bottom\',\n              onUpdate: function onUpdate(self) {\n                _this3.raf();\n              }\n            }\n          });\n        }\n      }\n    }\n  }, {\n    key: "scrollTo",\n    value: function scrollTo(hash) {\n      var $target = this.$el.querySelector(hash);\n\n      if ($target) {\n        if (this.appStore.isDesktop) {\n          var offset = $target.getBoundingClientRect().y + -this.superScroller._scroll.livePosition.y;\n          this.superScroller.scrollAnimate(offset, 2, \'power4.inOut\');\n        } else {\n          var _offset = $target.getBoundingClientRect().y + document.documentElement.scrollTop;\n\n          node_modules_gsap/* default.to */.ZP.to(document.documentElement, {\n            scrollTop: _offset,\n            duration: 2,\n            ease: \'power4.inOut\'\n          });\n        }\n      }\n    }\n  }, {\n    key: "scrollRotate",\n    value: function scrollRotate() {\n      var _this4 = this;\n\n      node_modules_gsap/* default.to */.ZP.to(this.$scroll.querySelector(\'svg\'), {\n        rotation: \'360\',\n        duration: 15,\n        ease: \'none\',\n        repeat: -1\n      });\n      ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$inner,\n        start: window.innerWidth * 0.02 + \' top\',\n        markers: false,\n        onEnter: function onEnter() {\n          node_modules_gsap/* default.to */.ZP.to(_this4.$scroll, {\n            opacity: 0.0001,\n            duration: 0.5,\n            ease: \'power2.out\',\n            onComplete: function onComplete() {\n              node_modules_gsap/* default.set */.ZP.set(_this4.$scroll, {\n                display: \'none\'\n              });\n            }\n          });\n          node_modules_gsap/* default.to */.ZP.to(_this4.$scroll.querySelector(\'svg\'), {\n            rotation: \'+=180\',\n            duration: 0.3,\n            ease: \'power2.inOut\'\n          });\n        }\n      });\n    }\n  }, {\n    key: "eventsAlternative",\n    value: function eventsAlternative() {\n      var _this5 = this;\n\n      // Open menu\n      this.domEvents.add(this.appUi.$trigger, \'click\', function () {\n        if (_this5.appUi.isAnimating) _this5.appUi.closeMenu();else _this5.appUi.openMenu();\n      }); // Close menu\n\n      this.domEvents.add(this.appUi.$menuMask, \'click\', function () {\n        _this5.appUi.closeMenu();\n      }); // Mouse enter/leave on trigger\n\n      if (this.appStore.isDesktop) {\n        this.domEvents.add(this.appUi.$trigger, \'mouseenter\', function () {\n          _this5.appUi.enterTrigger();\n        });\n        this.domEvents.add(this.appUi.$trigger, \'mouseleave\', function () {\n          _this5.appUi.leaveTrigger();\n        });\n      } // Open forms modal\n\n\n      if (this.appUi.$requestButton) this.domEvents.add(this.appUi.$requestButton, \'click\', function () {\n        _this5.openForm();\n      });\n    }\n  }, {\n    key: "hideLogo",\n    value: function hideLogo() {\n      var _this6 = this;\n\n      ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$inner,\n        start: window.innerHeight * 0.1 + \' top\',\n        onEnter: function onEnter() {\n          if (_this6.appUi.$logo) node_modules_gsap/* default.to */.ZP.to(_this6.appUi.$logo, {\n            opacity: 0.0001,\n            duration: 0.3,\n            ease: \'power2.out\'\n          });\n        },\n        onLeaveBack: function onLeaveBack() {\n          if (_this6.appUi.$logo) {\n            // gsap.set(this.appUi.$logo, { display: \'block\' });\n            node_modules_gsap/* default.to */.ZP.to(_this6.appUi.$logo, {\n              opacity: 1,\n              duration: 0.3,\n              ease: \'power2.out\'\n            });\n          }\n        }\n      });\n    }\n  }, {\n    key: "setForms",\n    value: function setForms() {\n      var _this7 = this;\n\n      this.$forms = this.$el.querySelectorAll(\'.hubspotform\');\n\n      if (this.$forms) {\n        for (var i = 0; i < this.$forms.length; i++) {\n          var _target = \'#\' + this.$forms[i].id;\n\n          var _id = this.$forms[i].getAttribute(\'data-id\');\n\n          if (_id) {\n            hbspt.forms.create({\n              region: \'na1\',\n              portalId: \'6580383\',\n              target: _target,\n              formId: _id,\n              onFormReady: function onFormReady() {\n                if (_this7.appStore.isDesktop) {\n                  if (_this7.interval) {\n                    clearInterval(_this7.interval);\n                    _this7.interval = null;\n                  }\n\n                  _this7.interval = setInterval(function () {\n                    if (_this7.superScroller) {\n                      _this7.superScroller.resize();\n\n                      clearInterval(_this7.interval);\n                    }\n                  }, 300);\n                }\n              }\n            });\n          }\n        }\n      }\n    }\n  }, {\n    key: "setLabels",\n    value: function setLabels() {\n      this.$labels = this.$el.querySelectorAll(\'.label--init\');\n\n      if (this.$labels) {\n        for (var i = 0; i < this.$labels.length; i++) {\n          // eslint-disable-next-line no-new\n          new SplitText(this.$labels[i], {\n            type: \'lines, words\',\n            linesClass: \'line line--++\',\n            wordsClass: \'word word--++\'\n          });\n\n          for (var j = 0; j < this.$labels[i].querySelectorAll(\'.word\').length; j++) {\n            node_modules_gsap/* default.set */.ZP.set(this.$labels[i].querySelectorAll(\'.word\')[j], {\n              opacity: 0.0001,\n              y: \'100%\'\n            });\n          }\n        }\n      }\n    }\n  }, {\n    key: "setTitles",\n    value: function setTitles() {\n      this.$titles = this.$el.querySelectorAll(\'.title--init\');\n\n      if (this.$titles) {\n        for (var i = 0; i < this.$titles.length; i++) {\n          // eslint-disable-next-line no-new\n          new SplitText(this.$titles[i], {\n            type: \'lines words\',\n            linesClass: \'line line--++\',\n            wordsClass: \'word word--++\'\n          });\n          var words = this.$titles[i].querySelectorAll(\'.word\');\n\n          for (var j = 0; j < words.length; j++) {\n            node_modules_gsap/* default.set */.ZP.set(words[j], {\n              opacity: 0.0001,\n              y: \'100%\',\n              rotationX: \'3deg\'\n            });\n          }\n        }\n      }\n    }\n  }, {\n    key: "setTitlesLarge",\n    value: function setTitlesLarge() {\n      this.$titlesLarge = this.$el.querySelectorAll(\'.titlelarge--init\');\n\n      if (this.$titlesLarge) {\n        for (var i = 0; i < this.$titlesLarge.length; i++) {\n          // eslint-disable-next-line no-new\n          new SplitText(this.$titlesLarge[i], {\n            type: \'lines words chars\',\n            linesClass: \'line line--++\',\n            wordsClass: \'word word--++\',\n            charsClass: \'char char--++\'\n          });\n          var chars = this.$titlesLarge[i].querySelectorAll(\'.char\');\n\n          for (var j = 0; j < chars.length; j++) {\n            node_modules_gsap/* default.set */.ZP.set(chars[j], {\n              opacity: 0.0001,\n              y: \'100%\',\n              rotationX: \'3deg\'\n            });\n          }\n        }\n      }\n    }\n  }, {\n    key: "setTexts",\n    value: function setTexts() {\n      this.$texts = this.$el.querySelectorAll(\'.text--init\');\n\n      if (this.$texts) {\n        for (var i = 0; i < this.$texts.length; i++) {\n          node_modules_gsap/* default.set */.ZP.set(this.$texts[i], {\n            opacity: 0.0001,\n            y: \'50%\'\n          });\n        }\n      }\n    }\n  }, {\n    key: "setImages",\n    value: function setImages() {\n      this.$opacity = this.$el.querySelectorAll(\'.image--init\');\n\n      if (this.$opacity) {\n        for (var i = 0; i < this.$opacity.length; i++) {\n          node_modules_gsap/* default.set */.ZP.set(this.$opacity[i], {\n            opacity: 0.0001\n          });\n        }\n      }\n    }\n  }, {\n    key: "setLines",\n    value: function setLines() {\n      this.$lines = this.$el.querySelectorAll(\'.hr--init\');\n\n      if (this.$lines) {\n        for (var i = 0; i < this.$lines.length; i++) {\n          node_modules_gsap/* default.set */.ZP.set(this.$lines[i], {\n            scaleX: 0,\n            transformOrigin: \'0 50%\'\n          });\n        }\n      }\n    }\n  }, {\n    key: "setLinks",\n    value: function setLinks() {\n      this.$links = this.$el.querySelectorAll(\'.link--init\');\n\n      if (this.$links && this.appStore.isDesktop) {\n        for (var i = 0; i < this.$links.length; i++) {\n          node_modules_gsap/* default.set */.ZP.set(this.$links[i].querySelector(\'.underline\'), {\n            scaleX: 0,\n            transformOrigin: \'0 50%\'\n          });\n        }\n      }\n    }\n  }, {\n    key: "setWords",\n    value: function setWords() {\n      this.$wordsTitles = this.$el.querySelectorAll(\'.words--init\');\n\n      if (this.$wordsTitles && !this.appStore.isDesktop) {\n        for (var i = 0; i < this.$wordsTitles.length; i++) {\n          // eslint-disable-next-line no-new\n          new SplitText(this.$wordsTitles[i], {\n            type: \'lines words\',\n            linesClass: \'line line--++\',\n            wordsClass: \'word word--++\'\n          });\n          var words = this.$wordsTitles[i].querySelectorAll(\'.word\');\n\n          for (var j = 0; j < words.length; j++) {\n            node_modules_gsap/* default.set */.ZP.set(words[j], {\n              opacity: 0.0001,\n              y: \'100%\',\n              rotation: \'3deg\'\n            });\n          }\n        }\n      }\n    }\n  }, {\n    key: "setDraggables",\n    value: function setDraggables() {\n      this.$draggables = this.$el.querySelectorAll(\'.draggable--init\');\n\n      if (this.$draggables) {\n        for (var i = 0; i < this.$draggables.length; i++) {\n          this.$draggableInner = this.$draggables[i].querySelector(\'.slider__inner\');\n          this.$draggableItems = this.$draggables[i].querySelectorAll(\'.slider__item\'); // this.$draggableProgress = this.$draggables[i].querySelector(\'.slider__progress\');\n\n          for (var j = 0; j < this.$draggableItems.length; j++) {\n            node_modules_gsap/* default.set */.ZP.set(this.$draggableItems[j], {\n              x: 60 * j + \'%\'\n            });\n          }\n\n          node_modules_gsap/* default.set */.ZP.set(this.$draggableInner, {\n            opacity: 0.0001,\n            x: \'100%\'\n          }); // if(this.$draggableProgress && !this.appStore.isDesktop)\n          //     gsap.set(this.$draggableProgress, { opacity: 0.0001 });\n        }\n      }\n    }\n  }, {\n    key: "setFooter",\n    value: function setFooter() {\n      // Selectors\n      this.$footer = this.$el.querySelector(\'[class*="__footer"]\');\n      this.$footerContainer = this.$footer.querySelector(\'.container\');\n      this.$footerTitle = this.$footer.querySelector(\'.supertitle\');\n      this.$footerText = this.$footer.querySelector(\'.wysiwyg\');\n\n      if (this.$footer) {\n        // Set animation\n        node_modules_gsap/* default.set */.ZP.set(this.$footerContainer, {\n          y: \'-100vh\'\n        }); // eslint-disable-next-line no-new\n\n        new SplitText(this.$footerTitle, {\n          type: \'lines words chars\',\n          linesClass: \'line line--++\',\n          wordsClass: \'word word--++\',\n          charsClass: \'char char--++\'\n        });\n        var chars = this.$footerTitle.querySelectorAll(\'.char\');\n\n        for (var i = 0; i < chars.length; i++) {\n          node_modules_gsap/* default.set */.ZP.set(chars[i], {\n            opacity: 0.0001\n          });\n        } // eslint-disable-next-line no-new\n\n\n        new SplitText(this.$footerText, {\n          type: \'lines words\',\n          linesClass: \'line line--++\',\n          wordsClass: \'word word--++\'\n        });\n        var words = this.$footerText.querySelectorAll(\'.word\');\n\n        for (var _i2 = 0; _i2 < words.length; _i2++) {\n          node_modules_gsap/* default.set */.ZP.set(words[_i2], {\n            opacity: 0.0001,\n            y: \'100%\',\n            rotation: \'3deg\'\n          });\n        }\n\n        node_modules_gsap/* default.set */.ZP.set([this.$footer.querySelector(\'.social\'), this.$footer.querySelector(\'.legal\')], {\n          opacity: 0.0001\n        });\n      }\n    }\n  }, {\n    key: "initLabels",\n    value: function initLabels() {\n      var _this8 = this;\n\n      if (this.$labels) {\n        var _loop = function _loop(i) {\n          ScrollTrigger/* default.create */.Z.create({\n            start: \'top 90%\',\n            trigger: _this8.$labels[i],\n            once: true,\n            onEnter: function onEnter() {\n              var $words = _this8.$labels[i].querySelectorAll(\'.word\');\n\n              for (var j = 0; j < $words.length; j++) {\n                node_modules_gsap/* default.to */.ZP.to($words[j], {\n                  opacity: 1,\n                  y: \'0%\',\n                  rotation: \'0deg\',\n                  ease: \'expo.inOut\',\n                  duration: 0.8,\n                  delay: 0.2 + j * 0.01\n                });\n              }\n            }\n          });\n        };\n\n        for (var i = 0; i < this.$labels.length; i++) {\n          _loop(i);\n        }\n      }\n    }\n  }, {\n    key: "initTitles",\n    value: function initTitles() {\n      var _this9 = this;\n\n      if (this.$titles) {\n        var _loop2 = function _loop2(i) {\n          ScrollTrigger/* default.create */.Z.create({\n            start: \'top 90%\',\n            trigger: _this9.$titles[i],\n            once: true,\n            onEnter: function onEnter() {\n              var words = _this9.$titles[i].querySelectorAll(\'.word\');\n\n              for (var j = 0; j < words.length; j++) {\n                node_modules_gsap/* default.to */.ZP.to(words[j], {\n                  opacity: 1,\n                  y: \'0%\',\n                  rotationX: \'0deg\',\n                  ease: \'expo.out\',\n                  duration: 0.8,\n                  delay: 0.2 + j * 0.01\n                });\n              }\n            }\n          });\n        };\n\n        for (var i = 0; i < this.$titles.length; i++) {\n          _loop2(i);\n        }\n      }\n    }\n  }, {\n    key: "initTitlesLarge",\n    value: function initTitlesLarge() {\n      var _this10 = this;\n\n      if (this.$titlesLarge) {\n        var _loop3 = function _loop3(i) {\n          ScrollTrigger/* default.create */.Z.create({\n            trigger: _this10.appStore.isDesktop ? _this10.$titlesLarge[i] : _this10.$titlesLarge[i].parentNode.parentNode,\n            start: _this10.appStore.isDesktop ? \'top 90%\' : \'top 35%\',\n            once: true,\n            onEnter: function onEnter() {\n              var chars = _this10.$titlesLarge[i].querySelectorAll(\'.char\');\n\n              for (var j = 0; j < chars.length; j++) {\n                node_modules_gsap/* default.to */.ZP.to(chars[j], {\n                  opacity: 1,\n                  y: \'0%\',\n                  rotationX: \'0deg\',\n                  ease: \'expo.out\',\n                  duration: 1.4,\n                  delay: 0.7 + j * 0.02\n                });\n              }\n            }\n          });\n        };\n\n        for (var i = 0; i < this.$titlesLarge.length; i++) {\n          _loop3(i);\n        }\n      }\n    }\n  }, {\n    key: "initTexts",\n    value: function initTexts() {\n      var _this11 = this;\n\n      if (this.$texts) {\n        var _loop4 = function _loop4(i) {\n          ScrollTrigger/* default.create */.Z.create({\n            trigger: _this11.appStore.isDesktop ? _this11.$texts[i] : _this11.$texts[i].parentNode,\n            start: \'top 90%\',\n            once: true,\n            onEnter: function onEnter() {\n              node_modules_gsap/* default.to */.ZP.to(_this11.$texts[i], {\n                opacity: 1,\n                y: \'0%\',\n                duration: _this11.appStore.isDesktop ? 1.5 : 2,\n                ease: \'expo.out\'\n              });\n            }\n          });\n        };\n\n        for (var i = 0; i < this.$texts.length; i++) {\n          _loop4(i);\n        }\n      }\n    }\n  }, {\n    key: "initImages",\n    value: function initImages() {\n      var _this12 = this;\n\n      if (this.$images) {\n        var _loop5 = function _loop5(i) {\n          ScrollTrigger/* default.create */.Z.create({\n            trigger: _this12.$images[i],\n            start: _this12.appStore.isDesktop ? \'top 90%\' : \'top 80%\',\n            once: true,\n            onEnter: function onEnter() {\n              node_modules_gsap/* default.to */.ZP.to(_this12.$images[i], {\n                opacity: 1,\n                duration: 5,\n                ease: \'expo.out\'\n              });\n            }\n          });\n        };\n\n        for (var i = 0; i < this.$images.length; i++) {\n          _loop5(i);\n        }\n      }\n    }\n  }, {\n    key: "initLines",\n    value: function initLines() {\n      var _this13 = this;\n\n      if (this.$lines) {\n        var _loop6 = function _loop6(i) {\n          ScrollTrigger/* default.create */.Z.create({\n            trigger: _this13.$lines[i],\n            start: _this13.appStore.isDesktop ? \'top 90%\' : \'top 80%\',\n            once: true,\n            onEnter: function onEnter() {\n              node_modules_gsap/* default.to */.ZP.to(_this13.$lines[i], {\n                scaleX: 1,\n                duration: 1.5,\n                ease: \'expo.inOut\'\n              });\n            }\n          });\n        };\n\n        for (var i = 0; i < this.$lines.length; i++) {\n          _loop6(i);\n        }\n      }\n    }\n  }, {\n    key: "initLinks",\n    value: function initLinks() {\n      var _this14 = this;\n\n      if (this.$links) {\n        var _loop7 = function _loop7(i) {\n          ScrollTrigger/* default.create */.Z.create({\n            trigger: _this14.$links[i],\n            start: _this14.appStore.isDesktop ? \'top 90%\' : \'top 80%\',\n            once: true,\n            onEnter: function onEnter() {\n              node_modules_gsap/* default.to */.ZP.to(_this14.$links[i].querySelector(\'.underline\'), {\n                scaleX: 1,\n                duration: 1,\n                ease: \'expo.inOut\'\n              });\n            }\n          });\n\n          if (_this14.appStore.isDesktop) {\n            _this14.domEvents.add(_this14.$links[i], \'mouseenter\', function (a, e, el) {\n              node_modules_gsap/* default.to */.ZP.to(el.querySelector(\'.underline\'), {\n                scaleX: 0,\n                duration: 0.6,\n                ease: \'expo.inOut\'\n              });\n            });\n\n            _this14.domEvents.add(_this14.$links[i], \'mouseleave\', function (a, e, el) {\n              node_modules_gsap/* default.to */.ZP.to(el.querySelector(\'.underline\'), {\n                scaleX: 1,\n                duration: 0.6,\n                ease: \'expo.inOut\'\n              });\n            });\n          }\n        };\n\n        for (var i = 0; i < this.$links.length; i++) {\n          _loop7(i);\n        }\n      }\n    }\n  }, {\n    key: "initWords",\n    value: function initWords() {\n      var _this15 = this;\n\n      if (this.$wordsTitles && !this.appStore.isDesktop) {\n        var _loop8 = function _loop8(i) {\n          ScrollTrigger/* default.create */.Z.create({\n            trigger: _this15.$wordsTitles[i],\n            start: _this15.appStore.isDesktop ? \'top 90%\' : \'top 80%\',\n            once: true,\n            onEnter: function onEnter() {\n              var words = _this15.$wordsTitles[i].querySelectorAll(\'.word\');\n\n              for (var j = 0; j < words.length; j++) {\n                node_modules_gsap/* default.to */.ZP.to(words[j], {\n                  opacity: 1,\n                  y: \'0%\',\n                  rotation: 0,\n                  ease: \'expo.inOut\',\n                  duration: 0.8,\n                  delay: 0 + j * 0.01\n                });\n              }\n            }\n          });\n        };\n\n        for (var i = 0; i < this.$wordsTitles.length; i++) {\n          _loop8(i);\n        }\n      }\n    }\n  }, {\n    key: "initAnchors",\n    value: function initAnchors() {\n      var _this16 = this;\n\n      this.$anchors = this.$el.querySelectorAll(\'a[href*="#"]\');\n\n      if (this.$anchors) {\n        var _loop9 = function _loop9(i) {\n          _this16.domEvents.add(_this16.$anchors[i], \'click\', function (e) {\n            _this16.scrollTo(\'#\' + _this16.$anchors[i].href.split(\'#\')[1]);\n          });\n        };\n\n        for (var i = 0; i < this.$anchors.length; i++) {\n          _loop9(i);\n        }\n      }\n    }\n  }, {\n    key: "initDraggables",\n    value: function initDraggables() {\n      var _this17 = this;\n\n      if (this.$draggables) {\n        for (var i = 0; i < this.$draggables.length; i++) {\n          ScrollTrigger/* default.create */.Z.create({\n            trigger: this.$draggables[i],\n            start: \'top 90%\',\n            once: true,\n            onEnter: function onEnter() {\n              node_modules_gsap/* default.to */.ZP.to(_this17.$draggableInner, {\n                opacity: 1,\n                x: \'0%\',\n                duration: 2,\n                ease: \'expo.out\'\n              });\n\n              for (var j = 0; j < _this17.$draggableItems.length; j++) {\n                node_modules_gsap/* default.to */.ZP.to(_this17.$draggableItems[j], {\n                  x: \'0%\',\n                  duration: 1.5,\n                  ease: \'expo.out\'\n                });\n              }\n            }\n          });\n        }\n      }\n    }\n  }, {\n    key: "initCarousel",\n    value: function initCarousel() {\n      var _this18 = this;\n\n      this.carousel = [];\n      this.$carousels = this.$el.querySelectorAll(\'.carousel__inner\');\n\n      var _loop10 = function _loop10(i) {\n        // const _direction = this.$carousels[i].dataset.direction;\n        var _carousel = {};\n        _carousel.$carouselItems = _this18.$carousels[i].children;\n\n        var _width = _carousel.$carouselItems[0].offsetWidth + \'px\';\n\n        _this18.$carousels[i].style.width = _width;\n        _carousel.carouselLeft = node_modules_gsap/* default.timeline */.ZP.timeline({\n          paused: false,\n          defaults: {\n            ease: \'none\',\n            duration: _this18.appStore.isDesktop ? _carousel.$carouselItems[0].offsetWidth / 200 : _carousel.$carouselItems[0].offsetWidth / 75,\n            repeat: \'-1\',\n            onReverseComplete: function onReverseComplete() {\n              _carousel.carouselLeft.pause();\n\n              _carousel.carouselRight.play();\n            }\n          }\n        });\n\n        for (var j = 0; j < _carousel.$carouselItems.length; j++) {\n          _carousel.carouselLeft.to(_carousel.$carouselItems[j], {\n            x: -100 + \'%\'\n          }, 0);\n        }\n\n        _carousel.carouselRight = node_modules_gsap/* default.timeline */.ZP.timeline({\n          paused: true,\n          defaults: {\n            ease: \'none\',\n            duration: _this18.appStore.isDesktop ? _carousel.$carouselItems[0].offsetWidth / 200 : _carousel.$carouselItems[0].offsetWidth / 75,\n            repeat: \'-1\',\n            onReverseComplete: function onReverseComplete() {\n              _carousel.carouselRight.pause();\n\n              _carousel.carouselLeft.play();\n            }\n          }\n        });\n\n        for (var _j = 0; _j < _carousel.$carouselItems.length; _j++) {\n          _carousel.carouselRight.to(_carousel.$carouselItems[_j], {\n            x: 100 + \'%\'\n          }, 0);\n        }\n\n        if (_this18.appStore.isDesktop) {\n          _carousel.carouselMove = node_modules_gsap/* default.timeline */.ZP.timeline({\n            defaults: {\n              ease: \'none\'\n            },\n            scrollTrigger: {\n              trigger: _this18.$carousels[i],\n              scrub: true,\n              start: \'top bottom\',\n              end: \'bottom top\',\n              onUpdate: function onUpdate(self) {\n                if (!_carousel.carouselLeft.paused()) _carousel.carouselLeft.reversed(self.direction !== 1);\n                if (!_carousel.carouselRight.paused()) _carousel.carouselRight.reversed(self.direction === 1);\n              }\n            }\n          }); // _carousel.carouselMove.fromTo(this.$carousels[i], { x: window.innerWidth * 0.2 * _direction }, { x: -window.innerWidth * 0.2 * _direction }, 0);\n\n          _carousel.carouselMove.fromTo(_this18.$carousels[i], {\n            x: window.innerWidth * 0.2\n          }, {\n            x: -window.innerWidth * 0.2\n          }, 0);\n        }\n\n        _this18.carousel.push(_carousel);\n      };\n\n      for (var i = 0; i < this.$carousels.length; i++) {\n        _loop10(i);\n      }\n    }\n  }, {\n    key: "initFooter",\n    value: function initFooter() {\n      if (this.$footer) {\n        // Start footer timeline\n        this._footerTimeline = node_modules_gsap/* default.timeline */.ZP.timeline({\n          defaults: {\n            ease: \'none\',\n            duration: 1\n          },\n          scrollTrigger: {\n            trigger: this.$footer,\n            start: \'top bottom\',\n            end: \'bottom 100%\',\n            scrub: true\n          }\n        }); // Animate in/out\n\n        this._footerTimeline.to(this.$footerContainer, {\n          y: \'100vh\',\n          duration: 1\n        }, 0);\n\n        var chars = this.$footerTitle.querySelectorAll(\'.char\');\n\n        this._footerTimeline.to(chars, {\n          opacity: 0.1,\n          duration: 0.1\n        }, 0.3);\n\n        this._footerTimeline.to(chars, {\n          opacity: 1,\n          stagger: 0.5 / chars.length,\n          duration: 0.5 / chars.length\n        }, 0.5);\n\n        var words = this.$footerText.querySelectorAll(\'.word\');\n\n        this._footerTimeline.to(words, {\n          opacity: 1,\n          y: \'0%\',\n          rotation: \'0deg\',\n          duration: 0.1 / words.length,\n          stagger: {\n            each: 0.1 / words.length,\n            from: \'start\'\n          }\n        }, 0.9);\n\n        this._footerTimeline.to(this.$footer.querySelector(\'.social\'), {\n          opacity: 1,\n          duration: 0.1\n        }, 0.9);\n\n        this._footerTimeline.to(this.$footer.querySelector(\'.legal\'), {\n          opacity: 1,\n          duration: 0.1\n        }, 0.9);\n      }\n    }\n  }, {\n    key: "enterCards",\n    value: function enterCards(a, e, el) {\n      if (el.querySelector(\'.link\')) {\n        node_modules_gsap/* default.killTweensOf */.ZP.killTweensOf(el.querySelector(\'.link\'), el.querySelector(\'.background__bg\'));\n        node_modules_gsap/* default.to */.ZP.to(el.querySelector(\'.link\'), {\n          scale: 0.9,\n          duration: 2.5,\n          ease: \'expo.out\'\n        });\n        node_modules_gsap/* default.to */.ZP.to(el.querySelector(\'.background__bg\'), {\n          scale: 1,\n          duration: 2.5,\n          ease: \'expo.out\'\n        });\n      }\n    }\n  }, {\n    key: "leaveCards",\n    value: function leaveCards(a, e, el) {\n      if (el.querySelector(\'.link\')) {\n        node_modules_gsap/* default.killTweensOf */.ZP.killTweensOf(el.querySelector(\'.link\'), el.querySelector(\'.background__bg\'));\n        node_modules_gsap/* default.to */.ZP.to(el.querySelector(\'.link\'), {\n          scale: 1,\n          duration: 2.5,\n          ease: \'expo.out\'\n        });\n        node_modules_gsap/* default.to */.ZP.to(el.querySelector(\'.background__bg\'), {\n          scale: 1.1,\n          duration: 2.5,\n          ease: \'expo.out\'\n        });\n      }\n    }\n  }, {\n    key: "openForm",\n    value: function openForm() {\n      var _this19 = this;\n\n      if (this.form.isAnimating) return;\n      this.form.isAnimating = true;\n      this.appUi.closeMenuOpacity(); // Animate in\n\n      node_modules_gsap/* default.set */.ZP.set(this.appUi.$header, {\n        pointerEvents: \'none\'\n      });\n      if (this.appStore.isDesktop) node_modules_gsap/* default.set */.ZP.set([this.appUi.$trigger, this.appUi.$requestButton], {\n        opacity: 0.0001\n      });else node_modules_gsap/* default.set */.ZP.set(this.appUi.$trigger, {\n        opacity: 0.0001\n      });\n      node_modules_gsap/* default.set */.ZP.set(this.$hubspot, {\n        display: \'block\',\n        zIndex: 999\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$hubspotMask, {\n        opacity: 1,\n        duration: 0.8,\n        ease: \'power2.out\'\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$hubspotContent, {\n        scaleY: 1,\n        duration: 1,\n        ease: \'expo.inOut\'\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$hubspotCloser, {\n        opacity: 1,\n        duration: 0.8,\n        ease: \'power2.out\',\n        delay: 1\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$forms, {\n        opacity: 1,\n        duration: 1,\n        ease: \'power2.out\',\n        delay: 1\n      }); // Block scroll\n\n      if (this.appStore.isDesktop) this.appStore.currentSection.superScroller._scroll.enable = false;else this.appUi.disableScroll();\n      this.domEvents.add(this.$hubspotCloser, \'click\', function () {\n        _this19.closeForm();\n      });\n      if (this.appStore.isDesktop) this.domEvents.add(this.$hubspotMask, \'click\', function () {\n        _this19.closeForm();\n      });\n    }\n  }, {\n    key: "closeForm",\n    value: function closeForm() {\n      var _this20 = this;\n\n      // Animate out\n      node_modules_gsap/* default.to */.ZP.to(this.$hubspotMask, {\n        opacity: 0.0001,\n        duration: 0.4,\n        ease: \'power2.out\'\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$hubspotCloser, {\n        opacity: 0.0001,\n        duration: 0.6,\n        ease: \'power2.out\'\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$forms, {\n        opacity: 0.0001,\n        duration: 0.6,\n        ease: \'power2.out\'\n      });\n      if (this.appStore.isDesktop) node_modules_gsap/* default.set */.ZP.set([this.appUi.$trigger, this.appUi.$requestButton], {\n        opacity: 1,\n        delay: 0.6\n      });else node_modules_gsap/* default.set */.ZP.set(this.appUi.$trigger, {\n        opacity: 1,\n        delay: 0.6\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$hubspotContent, {\n        scaleY: 0,\n        duration: 0.6,\n        ease: \'expo.inOut\',\n        delay: 0.1,\n        onComplete: function onComplete() {\n          if (_this20.appStore.isDesktop) _this20.appStore.currentSection.superScroller._scroll.enable = true;else _this20.appUi.enableScroll();\n          node_modules_gsap/* default.set */.ZP.set(_this20.appUi.$header, {\n            pointerEvents: \'initial\'\n          });\n          node_modules_gsap/* default.set */.ZP.set(_this20.appUi.$menu, {\n            opacity: 1\n          });\n          node_modules_gsap/* default.set */.ZP.set(_this20.$hubspot, {\n            display: \'none\',\n            zIndex: 0\n          });\n          delete _this20.$hubspotForm.dataset.id;\n          _this20.form.isAnimating = false;\n        }\n      });\n    }\n  }, {\n    key: "raf",\n    value: function raf() {} // eslint-disable-line\n\n  }, {\n    key: "beforeResize",\n    value: function beforeResize(width, height) {\n      if (this.superScroller) this.superScroller.resize();\n      this.resize(width, height);\n    }\n  }, {\n    key: "resize",\n    value: function resize(width, height) {} // eslint-disable-line\n\n  }, {\n    key: "enter",\n    value: function enter() {} // eslint-disable-line\n\n  }, {\n    key: "onLeave",\n    value: function onLeave() {\n      this.leave();\n    }\n  }, {\n    key: "leave",\n    value: function leave() {} // eslint-disable-line\n\n  }, {\n    key: "onLeaveCompleted",\n    value: function onLeaveCompleted() {\n      this.afterLeave();\n    }\n  }, {\n    key: "afterLeave",\n    value: function afterLeave() {\n      for (var i = 0; i < this.$forms.length; i++) {\n        this.$forms[i].remove();\n      }\n\n      if (this.domEvents) this.domEvents.destroy();\n      if (this.superScroller) this.superScroller.destroy();\n    }\n  }]);\n\n  return Renderer;\n}(highway_module/* default.Renderer */.Z.Renderer); // Don\'t forget to export your renderer\n\n\n/* harmony default export */ const renderer = (Renderer);\n;// CONCATENATED MODULE: ./app/src/js/renderers/rendererDefault.js\nfunction rendererDefault_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rendererDefault_typeof = function _typeof(obj) { return typeof obj; }; } else { rendererDefault_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rendererDefault_typeof(obj); }\n\nfunction rendererDefault_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rendererDefault_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rendererDefault_createClass(Constructor, protoProps, staticProps) { if (protoProps) rendererDefault_defineProperties(Constructor.prototype, protoProps); if (staticProps) rendererDefault_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rendererDefault_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rendererDefault_setPrototypeOf(subClass, superClass); }\n\nfunction rendererDefault_setPrototypeOf(o, p) { rendererDefault_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rendererDefault_setPrototypeOf(o, p); }\n\nfunction rendererDefault_createSuper(Derived) { var hasNativeReflectConstruct = rendererDefault_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rendererDefault_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rendererDefault_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rendererDefault_possibleConstructorReturn(this, result); }; }\n\nfunction rendererDefault_possibleConstructorReturn(self, call) { if (call && (rendererDefault_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return rendererDefault_assertThisInitialized(self); }\n\nfunction rendererDefault_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rendererDefault_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rendererDefault_getPrototypeOf(o) { rendererDefault_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rendererDefault_getPrototypeOf(o); }\n\n// GSAP Library\n\n\nnode_modules_gsap/* default.registerPlugin */.ZP.registerPlugin(ScrollTrigger/* default */.Z); // Import Renderer\n\n // Utilities\n\n\n\n\nvar RendererDefault = /*#__PURE__*/function (_Renderer) {\n  rendererDefault_inherits(RendererDefault, _Renderer);\n\n  var _super = rendererDefault_createSuper(RendererDefault);\n\n  function RendererDefault() {\n    rendererDefault_classCallCheck(this, RendererDefault);\n\n    return _super.apply(this, arguments);\n  }\n\n  rendererDefault_createClass(RendererDefault, [{\n    key: "selectors",\n    value: function selectors() {} // eslint-disable-line\n\n  }, {\n    key: "events",\n    value: function events() {} // eslint-disable-line\n\n  }, {\n    key: "preload",\n    value: function preload() {\n      // this.preloadDelay = 1;\n      this.preloadItems = {\n        main: [],\n        secondary: []\n      };\n    }\n  }, {\n    key: "beforeEnter",\n    value: function beforeEnter() {} // eslint-disable-line\n\n  }, {\n    key: "enter",\n    value: function enter() {} // eslint-disable-line\n\n  }, {\n    key: "raf",\n    value: function raf() {} // eslint-disable-line\n\n  }, {\n    key: "resize",\n    value: function resize(width, height) {} // eslint-disable-line\n\n  }]);\n\n  return RendererDefault;\n}(renderer); // Don\'t forget to export your renderer\n\n\n/* harmony default export */ const rendererDefault = (RendererDefault);\n// EXTERNAL MODULE: ./app/src/js/classes/DrawSVGPlugin.min.js\nvar DrawSVGPlugin_min = __webpack_require__(4374);\nvar DrawSVGPlugin_min_default = /*#__PURE__*/__webpack_require__.n(DrawSVGPlugin_min);\n// EXTERNAL MODULE: ./node_modules/three/examples/jsm/controls/OrbitControls.js\nvar OrbitControls = __webpack_require__(9365);\n// EXTERNAL MODULE: ./node_modules/dat.gui/build/dat.gui.module.js\nvar dat_gui_module = __webpack_require__(4376);\n// EXTERNAL MODULE: ./node_modules/three/build/three.module.js\nvar three_module = __webpack_require__(9477);\n;// CONCATENATED MODULE: ./app/src/js/webgl/WebGLUtils.js\nfunction WebGLUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction WebGLUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction WebGLUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) WebGLUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) WebGLUtils_defineProperties(Constructor, staticProps); return Constructor; }\n\n//import * as THREE from "three"\n//import gsap from "gsap"\n//import {GLTFLoader, GLTLoader} from "three/examples/jsm/loaders/GLTFLoader"\nvar WebGLUtils = /*#__PURE__*/function () {\n  function WebGLUtils() {\n    WebGLUtils_classCallCheck(this, WebGLUtils);\n  }\n\n  WebGLUtils_createClass(WebGLUtils, null, [{\n    key: "clamp",\n    value: function clamp(num, min, max) {\n      // Given a num y return the num but making sure its between min and max.\n      // If its below min it will equal to min\n      // If its above max it will equal max\n      return Math.min(Math.max(num, min), max);\n    }\n  }, {\n    key: "lerp",\n    value: function lerp(x, y, a) {\n      //A lerp returns the value between two numbers at a specified, decimal midpoint:\n      // Funciona como mix de glsl\n      // lerp(20, 80, 0)   // 20\n      // lerp(20, 80, 1)   // 80\n      // lerp(20, 80, 0.5) // 40\n      return x * (1 - a) + y * a;\n    }\n  }, {\n    key: "invlerp",\n    value: function invlerp(x, y, a) {\n      // Works in the opposite way to the lerp. Instead of passing a decimal midpoint, you pass any value,\n      // and it’ll return that decimal, wherever it falls on that spectrum. Internally it also uses a clamp,\n      // so you never get unwieldy values back.\n      // invlerp(50, 100, 75)  // 0.5\n      // invlerp(50, 100, 25)  // 0\n      // invlerp(50, 100, 125) // 1\n      return this.clamp((a - x) / (y - x));\n    }\n  }, {\n    key: "range",\n    value: function range(x1, y1, x2, y2, a) {\n      // This final method is ace. It’s a one-liner that converts a value from one data range to another.\n      // That might sound a bit arbitrary, but it’s surprisingly useful.\n      // We pass in two data ranges and a value that sits within data range one (it will still be clamped).\n      //    Range 1    Range 2    Value\n      //range(10, 100, 2000, 20000, 50) // 10000\n      return this.lerp(x2, y2, this.invlerp(x1, y1, a));\n    }\n  }]);\n\n  return WebGLUtils;\n}();\n\n/* harmony default export */ const webgl_WebGLUtils = (WebGLUtils);\n// EXTERNAL MODULE: ./node_modules/easing-functions/index.js\nvar easing_functions = __webpack_require__(6908);\nvar easing_functions_default = /*#__PURE__*/__webpack_require__.n(easing_functions);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home1/shaders/home1_dots_vertex.glsl\n/* harmony default export */ const home1_dots_vertex = ("#define GLSLIFY 1\\nattribute vec3 a_randomness;\\nattribute vec3 a_geo1_position;\\nattribute vec3 a_geo1_color;\\nattribute float a_geo1_anguloRad;\\nattribute float a_geo1_orbital;\\nattribute float a_geo1_pos_orbita;\\nattribute float a_geo1_incr_anguloRad;\\nattribute float a_geo1_incr;\\nattribute float a_geo1_dir;\\nattribute float a_geo1_radio;\\n\\nuniform float uCamaraDistance;\\nuniform float uTime;\\nuniform float uOpenProgress;\\nuniform float uResponsiveScale;\\n\\nuniform float uScrollDelta;\\nuniform float uRotation1;\\nuniform float uRotation2;\\nuniform float uRotation3;\\n\\nuniform float uIntroProgress1;\\nuniform float uIntroProgress2;\\nuniform float uIntroProgress3;\\n\\nuniform float uZoomOutProgress1;\\nuniform float uZoomOutProgress2;\\nuniform float uZoomOutProgress3;\\n\\nuniform float uVideoYOffset;\\n\\nuniform float uZoomingProgress;\\n\\nuniform float uHeight;\\n//uniform float uScale;\\n\\nvarying vec3 v_color;\\nvarying float v_pulseStrengthNorm1;\\nvarying float v_pulseStrengthNorm2;\\n\\n//\\tClassic Perlin 3D Noise \\n//\\tby Stefan Gustavson\\n//\\n\\n#define PI 3.1415926538\\n//#define PI 3.1415926535897932384626433832795\\n\\nvec3 get_pos1(float anguloRad){\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(1.*a_geo1_dir*0.2);\\n    float x = cos(anguloRad)*a_geo1_radio;\\n    float y = sin(anguloRad)*a_geo1_radio;\\n    float z = 0.0;\\n    vec3 newPos = vec3(x, y, z);\\n    return newPos;\\n}\\n\\nfloat get_openScale(){\\n    return mix(1., 8., uOpenProgress);\\n}\\n\\nvec3 get_openFx( vec3 pos){\\n    //float openScale = mix(1., 8., uOpenProgress);\\n    vec3 posFx = pos*get_openScale();\\n    return posFx;\\n}\\n\\nfloat get_cosTime(float time, float radius){\\n    //\\n    //float value = sin(uTime)*2.*PI;\\n    float value = sin(time)*radius;\\n    return value;\\n}\\n\\nfloat get_x(float angleRad, float radius){\\n    return cos(angleRad)*a_geo1_radio;\\n}\\n\\nfloat get_pulseStrengthNorm( float direction){\\n    float dotAguleNorm = a_geo1_anguloRad/(2.*PI); // Pasamos el angulo del punto que está en radianes a un valor de 0 a 1.\\n\\n    float modSpeed = mix(1., 2.5, 13./a_geo1_orbital)*direction;\\n    float radialSpeed = uTime*0.02*modSpeed; // Modificamos uTime para determinar la velocidad radial.\\n\\n    float pulseAngleRad = radialSpeed*(4.*PI);\\n\\n    // El valor de pulseAngleRad debe estar entre 0 y 2PI (inicio y fin de una circunferencia).\\n    // Como depende de uTime el valor saldrá de ese rango pronto por lo que tomaremos el resto (modulo),\\n    // de dividir pulseAngleRad por 2PI.\\n    if(pulseAngleRad > 2.*PI){\\n        pulseAngleRad = mod(pulseAngleRad, (2.*PI));\\n    }\\n    if(pulseAngleRad < 0.){\\n        pulseAngleRad = mod(pulseAngleRad, (2.*PI));\\n    }\\n\\n    float pulseAngleNorm = pulseAngleRad/(2.*PI); // Normalizamos el valor (de 0 a 1)\\n\\n    float distAngleNorm = abs(pulseAngleNorm-dotAguleNorm); // Calculamos la distancia radial del pulso al punto\\n\\n    // Apañamos la distancia de tal forma que no le afecte el punto de discontinuidad OPI = 2PI\\n    if(distAngleNorm > 0.5){ \\n        distAngleNorm = 0.5-(distAngleNorm-0.5);\\n    }\\n\\n    // La maxima distancia es de medio circulo y en terminos normalizados es 0.5\\n    // Creamos una variable que normalice ese valor entre 0 y 1.\\n    float pulseStrengthNorm  = distAngleNorm*2.; \\n\\n    float pico = 0.92;\\n    pico = mix(pico*0.99, pico*1.01, a_geo1_orbital/13.);\\n\\n    // Nos interesa solo el pico, la zona que va entre 0.95 y 1.\\n    // Toodo lo que haya por debajo de 0.95 lo pasamos a 0.95\\n    // y le restamos ese mismo 0.95 para quedarnos con el pico de 0.05 eol cual amplificamos x20 para normalizarlo (de 0 a 1).\\n    pulseStrengthNorm = (clamp(pulseStrengthNorm, pico, 1.)-pico)*10.;\\n    //--\\n    return pulseStrengthNorm;\\n}\\n\\nvoid main() {\\n\\n    // SORTING:\\n    float anguloRad_time = a_geo1_anguloRad;\\n    float introProgress;\\n    float zoomOutProgress;\\n\\n    if(abs(a_geo1_orbital-9.) < 0.5){ // Detecta el orbital 9\\n        anguloRad_time = a_geo1_anguloRad+uRotation1;\\n        introProgress = mix(2., 0.3, uIntroProgress1); \\n        zoomOutProgress = uZoomOutProgress1;\\n\\n    }else if(abs(a_geo1_orbital-13.) < 0.5){ // Detecta el orbital 13\\n        anguloRad_time = a_geo1_anguloRad+uRotation2;\\n        introProgress = mix(2., 0.5, uIntroProgress2); \\n        zoomOutProgress = uZoomOutProgress2;\\n\\n    }else if(abs(a_geo1_orbital-17.) < 0.5){ // Detecta el orbital 17\\n        anguloRad_time = a_geo1_anguloRad+uRotation3;\\n        introProgress= mix(2., 0.8, uIntroProgress3); \\n        zoomOutProgress = uZoomOutProgress3;\\n    }\\n\\n    float pulseStrengthNorm1 = get_pulseStrengthNorm(1.5);\\n    float pulseStrengthNorm2 = get_pulseStrengthNorm(-1.);\\n    \\n\\n    // Determinamos el tamaño del punto teniendo un minimo de 5 y amplificando el maximo para que visualmente sea bonito\\n    //float size = 5.+(pulseStrengthNorm*15.*longPeriod);\\n    float size = 3.;\\n    //size *= clamp(introProgress, 5., 1.5);\\n    size += (pulseStrengthNorm1*5.);\\n    size += (pulseStrengthNorm2*5.);\\n    size *= mix(1., 8., uOpenProgress);\\n\\n    //-----------------------------------\\n    // POSITION:\\n    vec3 pos_original = get_pos1(anguloRad_time);\\n    pos_original *= uResponsiveScale;\\n\\n    vec3 pos_final = pos_original;\\n    pos_final *= introProgress;\\n    pos_final = mix(pos_final, pos_original, zoomOutProgress);\\n\\n    pos_final *= mix(1., 8., uOpenProgress);\\n\\n    float videoYOffset = uVideoYOffset;\\n    videoYOffset = clamp (videoYOffset, 0., abs(videoYOffset));\\n    pos_final.y -= videoYOffset;\\n    \\n\\n    vec4 mvPosition = modelViewMatrix * vec4( pos_final, 1.0 ); //<-----------------------------------\\n    gl_Position = projectionMatrix * mvPosition; //<--------------------------------------------------\\n    gl_PointSize = size*(uCamaraDistance/-mvPosition.z); //<------------------------------------------\\n\\n    //--------------------------------------\\n    // VARYINGS:\\n    v_color = a_geo1_color; \\n    v_pulseStrengthNorm1 = pulseStrengthNorm1; \\n    v_pulseStrengthNorm2 = pulseStrengthNorm2; \\n\\n}\\n\\n");\n;// CONCATENATED MODULE: ./app/src/js/webgl/home1/shaders/home1_dots_fragment.glsl\n/* harmony default export */ const home1_dots_fragment = ("#define GLSLIFY 1\\nvarying vec3 v_color;\\nvarying float v_pulseStrengthNorm1;\\nvarying float v_pulseStrengthNorm2;\\n\\nfloat circulizar(float radio){\\n    // radio es un valor entre 0 y 1. 0 es 0 de radio y 1 es el maximo del radio dentro de\\n    radio = 1.0-(0.5*radio);\\n    float result = distance(gl_PointCoord, vec2(0.5, 0.5));\\n    result = 1. -result;\\n    result = pow(result, 1.);\\n    result = step(radio, result);\\n    return result;\\n}\\n\\nvoid main() {\\n    vec3 white = vec3(1., 1., 1.);\\n    float pulse = v_pulseStrengthNorm1+v_pulseStrengthNorm2;\\n    pulse = clamp(pulse, 0., 1.);\\n    vec3 finalColor = v_color;\\n    //finalColor = mix(finalColor, white, pulse*5.);\\n    //finalColor = mix(finalColor, white, 0.);\\n    float alpha = circulizar(1.0);\\n\\n    gl_FragColor = vec4(finalColor, alpha*0.8);\\n}");\n;// CONCATENATED MODULE: ./app/src/js/webgl/EventProgress.js\nfunction EventProgress_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction EventProgress_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction EventProgress_createClass(Constructor, protoProps, staticProps) { if (protoProps) EventProgress_defineProperties(Constructor.prototype, protoProps); if (staticProps) EventProgress_defineProperties(Constructor, staticProps); return Constructor; }\n\n//import * as THREE from "three"\n\n\n\nvar events = __webpack_require__(7187);\n\nvar EventProgress = /*#__PURE__*/function () {\n  function EventProgress(id) {\n    EventProgress_classCallCheck(this, EventProgress);\n\n    //console.log("(EventProgress.CONSTRUCTORA)! ")\n    this.durationSec;\n    this.id = id;\n    this.easingFunc = null;\n    this.processTimeSec = null;\n    this.refTimeSec = null; // Secs de referencia del rejof de gsap cuando empieza el start\n    //--\n\n    this.starting_t = 0; // t de referencia de inicio.\n\n    this.t = 0; // En un valor que progresa linealmente de 0 a 1.\n\n    this.range_t = 0; // Ee el rango sobre el que progresará t quitando su starting point.\n    //--\n    //this.process = 0 // Es un valor que traduce la progresión lineal de t a un progresión easong en función de this.easingFunc \n    //--\n\n    this.initialized = false;\n    this.active = false; //--\n\n    this.emitter = new events.EventEmitter();\n  }\n\n  EventProgress_createClass(EventProgress, [{\n    key: "start",\n    value: function start(durationSec, starting_t, easingFunc, pauseSec) {\n      var _this = this;\n\n      //console.log("(EventProgress.start)("+this.id+") durationSec: "+durationSec+" starting_t: "+starting_t)\n      if (pauseSec == 0) {\n        this.initialized = true;\n        this.active = true;\n        this.durationSec = durationSec;\n        this.easingFunc = easingFunc;\n        this.starting_t = starting_t;\n        this.t = starting_t;\n        this.range_t = 1 - this.starting_t;\n        this.refTimeSec = this._get_tickerTime(); //--\n\n        node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this.onTick);\n        this.onTick = this._update.bind(this);\n        node_modules_gsap/* default.ticker.add */.ZP.ticker.add(this.onTick);\n      } else {\n        node_modules_gsap/* default.delayedCall */.ZP.delayedCall(pauseSec, function () {\n          return _this.start(durationSec, starting_t, easingFunc, 0);\n        });\n      }\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      this.active = false;\n      node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this.onTick);\n    }\n  }, {\n    key: "get_t",\n    value: function get_t() {\n      return this.t;\n    }\n  }, {\n    key: "get_progress",\n    value: function get_progress() {\n      if (this.initialized) {\n        return this.easingFunc(this.t);\n      } else {\n        return 0;\n      }\n    } //-----------------------------------------\n\n  }, {\n    key: "_get_tickerTime",\n    value: function _get_tickerTime() {\n      return node_modules_gsap/* default.ticker.time */.ZP.ticker.time;\n    }\n  }, {\n    key: "_update",\n    value: function _update() {\n      var tickerTime = this._get_tickerTime();\n\n      this.processTimeSec = tickerTime - this.refTimeSec;\n\n      if (this.processTimeSec >= this.durationSec) {\n        this.active = false;\n        this.processTimeSec = this.durationSec;\n        node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this.onTick); //--\n        //console.log("onProgressFinished")\n\n        this.emitter.emit("onProgressFinished");\n      } //console.log("starting_t: "+this.starting_t)\n      // console.log("this.processTimeSec/this.durationSec: "+this.processTimeSec/this.durationSec)\n      //console.log("this.range_t: "+this.range_t)\n\n\n      this.t = this.starting_t + this.processTimeSec / this.durationSec * this.range_t; //console.log("t: "+this.t)\n    }\n  }]);\n\n  return EventProgress;\n}();\n\n/* harmony default export */ const webgl_EventProgress = (EventProgress);\n;// CONCATENATED MODULE: ./app/src/js/webgl/EasedOutValue.js\nfunction EasedOutValue_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction EasedOutValue_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction EasedOutValue_createClass(Constructor, protoProps, staticProps) { if (protoProps) EasedOutValue_defineProperties(Constructor.prototype, protoProps); if (staticProps) EasedOutValue_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar EasedOutValue = /*#__PURE__*/function () {\n  function EasedOutValue(_value, _factor) {\n    EasedOutValue_classCallCheck(this, EasedOutValue);\n\n    //console.log("(EasedOutValue.CONSTRUCTORA): "+_value)\n    this.value = _value;\n    this.factor = _factor;\n  }\n\n  EasedOutValue_createClass(EasedOutValue, [{\n    key: "get",\n    value: function get(newValue) {\n      var filteredValue = this.value + (newValue - this.value) * this.factor;\n      this.value = filteredValue; //console.log(filteredValue)\n\n      return filteredValue;\n    }\n  }]);\n\n  return EasedOutValue;\n}();\n\n/* harmony default export */ const webgl_EasedOutValue = (EasedOutValue);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home1/Home1Geometry.js\nfunction Home1Geometry_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Home1Geometry_typeof = function _typeof(obj) { return typeof obj; }; } else { Home1Geometry_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Home1Geometry_typeof(obj); }\n\nfunction Home1Geometry_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home1Geometry_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home1Geometry_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home1Geometry_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home1Geometry_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Home1Geometry_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Home1Geometry_setPrototypeOf(subClass, superClass); }\n\nfunction Home1Geometry_setPrototypeOf(o, p) { Home1Geometry_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Home1Geometry_setPrototypeOf(o, p); }\n\nfunction Home1Geometry_createSuper(Derived) { var hasNativeReflectConstruct = Home1Geometry_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Home1Geometry_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Home1Geometry_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Home1Geometry_possibleConstructorReturn(this, result); }; }\n\nfunction Home1Geometry_possibleConstructorReturn(self, call) { if (call && (Home1Geometry_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Home1Geometry_assertThisInitialized(self); }\n\nfunction Home1Geometry_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Home1Geometry_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Home1Geometry_getPrototypeOf(o) { Home1Geometry_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Home1Geometry_getPrototypeOf(o); }\n\n//import * as THREE from "three"\n//import gsap from "gsap"\n//import {GLTFLoader, GLTLoader} from "three/examples/jsm/loaders/GLTFLoader"\nvar EventEmitter = __webpack_require__(7187);\n\nvar Home1Geometry = /*#__PURE__*/function (_EventEmitter) {\n  Home1Geometry_inherits(Home1Geometry, _EventEmitter);\n\n  var _super = Home1Geometry_createSuper(Home1Geometry);\n\n  function Home1Geometry(obj) {\n    var _this;\n\n    Home1Geometry_classCallCheck(this, Home1Geometry);\n\n    //console.log("(Home1Geometry.CONSTRUCTORA)!")\n    _this = _super.call(this); //--\n\n    _this.factor = obj.factor; //6\n\n    _this.incr_radio = obj.incr_radio; //25\n\n    _this.numOrbits = obj.numOrbits; //37\n\n    _this.array_triangular = obj.array_triangular;\n    _this.array_dotPos = obj.array_dotPos;\n    _this.numDots = obj.numDots; //--\n\n    _this.arrayColores_RGB = [];\n    _this.arrayColores_RGB_01 = [];\n    _this.colorPos = 0;\n\n    _this._init_colors(); //--\n\n\n    _this.attributes = {\n      a_posiciones: new Float32Array(_this.numDots * 3),\n      a_color: new Float32Array(_this.numDots * 3),\n      a_orbital: new Float32Array(_this.numDots * 1),\n      a_pos_orbita: new Float32Array(_this.numDots * 1),\n      a_incr_anguloRad: new Float32Array(_this.numDots * 1),\n      a_anguloRad: new Float32Array(_this.numDots * 1),\n      a_radio: new Float32Array(_this.numDots * 1),\n      a_dir: new Float32Array(_this.numDots * 1),\n      a_incr: new Float32Array(_this.numDots * 1),\n      a_x: new Float32Array(_this.numDots * 1),\n      a_y: new Float32Array(_this.numDots * 1),\n      a_z: new Float32Array(_this.numDots * 1)\n    }; //--\n\n    for (var i = 0; i < _this.array_dotPos.length; i++) {\n      var dotPos = _this.array_dotPos[i];\n\n      var dot = _this._get_dot(dotPos);\n\n      var i3 = i * 3;\n      _this.attributes.a_posiciones[i3] = dot.x;\n      _this.attributes.a_posiciones[i3 + 1] = dot.y;\n      _this.attributes.a_posiciones[i3 + 2] = dot.z; //--\n\n      _this.attributes.a_color[i3] = dot.color[0];\n      _this.attributes.a_color[i3 + 1] = dot.color[1];\n      _this.attributes.a_color[i3 + 2] = dot.color[2]; //--\n\n      _this.attributes.a_orbital[i] = dot.orbital;\n      _this.attributes.a_pos_orbita[i] = dot.pos_orbita;\n      _this.attributes.a_incr_anguloRad[i] = dot.incr_anguloRad;\n      _this.attributes.a_anguloRad[i] = dot.anguloRad;\n      _this.attributes.a_radio[i] = dot.radio;\n      _this.attributes.a_dir[i] = dot.dir;\n      _this.attributes.a_incr[i] = dot.incr;\n      _this.attributes.a_x[i] = dot.y;\n      _this.attributes.a_y[i] = dot.y;\n      _this.attributes.a_z[i] = dot.z;\n    } //--\n\n\n    _this.loaded = false;\n    return _this;\n  } //------------------------------------------\n  // PRIVADAS\n\n\n  Home1Geometry_createClass(Home1Geometry, [{\n    key: "_get_dot",\n    value: function _get_dot(num) {\n      // Devuelve un objeto con la información de un punto de la geometria "orbital MIOTI"\n      var obj = {\n        num: num,\n        color: this._get_color(),\n        x: 0,\n        y: 0,\n        z: 0,\n        orbital: 0,\n        co_orbitantes: 0,\n        pos_orbita: 0,\n        incr_anguloRad: 0,\n        anguloRad: 0,\n        radio: 0\n      }; //--\n\n      for (var i = 0; i <= this.array_triangular.length; i++) {\n        var limSup = this.array_triangular[i]; //console.log("limSup: "+limSup)\n\n        if (num > limSup) {\n          // console.log("*")\n          obj.orbital = i + 1;\n          obj.co_orbitantes = (i + 1) * this.factor;\n          obj.pos_orbita = num - limSup - 1;\n          obj.incr_anguloRad = 2 * Math.PI / obj.co_orbitantes;\n\n          if (obj.orbital % 2 == 0) {\n            obj.dir = 1;\n            obj.incr = 0;\n            obj.anguloRad = obj.pos_orbita * obj.incr_anguloRad;\n          } else {\n            obj.dir = -1;\n            obj.incr = 1;\n            obj.anguloRad = obj.pos_orbita * obj.incr_anguloRad + obj.incr_anguloRad / 2;\n          }\n\n          obj.radio = obj.orbital * this.incr_radio; //--\n\n          obj.x = Math.cos(obj.anguloRad) * obj.radio;\n          obj.y = Math.sin(obj.anguloRad) * obj.radio;\n          obj.z = 0;\n        } //break\n\n      }\n\n      return obj;\n    }\n  }, {\n    key: "_get_color",\n    value: function _get_color() {\n      var color_RGB_01 = this.arrayColores_RGB_01[this.colorPos];\n      this.colorPos++;\n\n      if (this.colorPos > this.arrayColores_RGB_01.length - 1) {\n        this.colorPos = 0;\n      }\n\n      return color_RGB_01;\n    }\n  }, {\n    key: "_init_colors",\n    value: function _init_colors() {\n      this.arrayColores_RGB = [];\n      this.arrayColores_RGB.push([255, 87, 131]); // Rosa\n\n      this.arrayColores_RGB.push([89, 2, 2]);\n      this.arrayColores_RGB.push([1, 3, 49]);\n      this.arrayColores_RGB.push([0, 16, 116]);\n      this.arrayColores_RGB.push([14, 133, 255]);\n      this.arrayColores_RGB_01 = [];\n\n      for (var i = 0; i < this.arrayColores_RGB.length; i++) {\n        var color_RGB = this.arrayColores_RGB[i];\n        var color_RGB_01 = [color_RGB[0] / 255, color_RGB[1] / 255, color_RGB[2] / 255];\n        this.arrayColores_RGB_01.push(color_RGB_01);\n      }\n    }\n  }]);\n\n  return Home1Geometry;\n}(EventEmitter);\n\n/* harmony default export */ const home1_Home1Geometry = (Home1Geometry);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home1/Home1Dots.js\nfunction Home1Dots_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home1Dots_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home1Dots_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home1Dots_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home1Dots_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n //import vertex_bg from "./shaders/home1_background_vertex.glsl"\n//import fragment_bg from "./shaders/home1_background_fragment.glsl"\n\n\n\n\n\nvar Home1Dots = /*#__PURE__*/function () {\n  function Home1Dots(obj) {\n    Home1Dots_classCallCheck(this, Home1Dots);\n\n    //console.log("(Home1Dots.CONSTRUCTORA)!!")\n    //console.log(obj)\n    this.worldGL = obj.worldGL; //--\n    //--\n\n    this.scene = this.worldGL.scene;\n    this.cameraDistance = this.worldGL.cameraDistance; //console.log("this.worldGL.cameraDistance: "+this.worldGL.cameraDistance)\n    //--\n\n    this.material = null;\n    this.geometry = null;\n    this.mesh = null;\n    this.numParticles = null;\n    this.created = false;\n    this.clock = new three_module/* Clock */.SUY();\n    this.rotation = 0; //--\n    //this.event_intro_c1 = new EventProcess({durationSec: 2})\n\n    this.event_intro_c1 = new webgl_EventProgress();\n    this.event_intro_c2 = new webgl_EventProgress();\n    this.event_intro_c3 = new webgl_EventProgress();\n    this.event_zoomout_c1 = new webgl_EventProgress();\n    this.event_zoomout_c2 = new webgl_EventProgress();\n    this.event_zoomout_c3 = new webgl_EventProgress();\n    this.eased_scrollDelta_fast = new webgl_EasedOutValue(this.worldGL.settings.scroll_normalizedDelta * 0.5, 0.1); //--\n\n    this._setup_settings(); //this._init_scrollListeners()\n    //this._setup_gui()\n    //--\n\n\n    this.orbital_geometry = new home1_Home1Geometry(this.settings); //--\n    //--\n    //this._createcube(this.scene)\n\n    this._create(); //--\n    //--\n    // const animTime_intro = 1.5\n    // const animTime_acelDecel = 2\n    // const animTime_unzoom = 0.9\n    //const easeFunc_intro = Easing.Exponential.Out\n    //const initial_pause = 0.3\n    //this.eventFase = "intro"\n    //this.event_intro_c1.start(0.9, 0, easeFunc_intro, initial_pause+0.0)\n    //this.event_intro_c2.start(1.1, 0, easeFunc_intro, initial_pause+0.1)\n    //this.event_intro_c3.start(1.2, 0, easeFunc_intro, initial_pause+0.2)        //--\n    //\n    //gsap.delayedCall(initial_pause+1.2, ()=>{\n    //    this.worldGL.hw_renderer.initEnterAnimation();\n    //    this.do_zoomOut();\n    //})\n\n  }\n\n  Home1Dots_createClass(Home1Dots, [{\n    key: "do_zoomOut",\n    value: function do_zoomOut() {\n      var _this = this;\n\n      //console.log("((Home1Dots.do_zoomOut)!")\n      var easeFunc_zoomout = (easing_functions_default()).Quartic.InOut; //const easeFunc_zoomout = Easing.Exponential.InOut\n\n      this.eventFase = "unzoom"; //--\n\n      this.event_zoomout_c1.start(1.4, 0, easeFunc_zoomout, 0);\n      this.event_zoomout_c2.start(1.5, 0, easeFunc_zoomout, 0.1);\n      this.event_zoomout_c3.start(1.8, 0, easeFunc_zoomout, 0.2); //--\n\n      this.event_zoomout_c3.emitter.on("onProgressFinished", function () {\n        _this.eventFase = "interactive";\n      });\n    } //------------------------------------\n    // PUBLICAS: \n\n  }, {\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      console.log("(Home1Dots.init)!");\n      var easeFunc_intro = (easing_functions_default()).Exponential.Out;\n      var initial_pause = 0;\n      this.eventFase = "intro";\n      this.event_intro_c1.start(0.9, 0, easeFunc_intro, initial_pause + 0.0);\n      this.event_intro_c2.start(1.1, 0, easeFunc_intro, initial_pause + 0.1);\n      this.event_intro_c3.start(1.2, 0, easeFunc_intro, initial_pause + 0.2); //--\n\n      node_modules_gsap/* default.delayedCall */.ZP.delayedCall(initial_pause + 1.2, function () {\n        _this2.worldGL.hw_renderer.initEnterAnimation();\n\n        _this2.do_zoomOut();\n      });\n    } //------------------------------------\n\n  }, {\n    key: "render",\n    value: function render() {\n      if (this.created) {\n        this.material.uniforms.uTime.value = this.clock.getElapsedTime();\n        this.material.uniforms.uCamaraDistance.value = this.worldGL.cameraDistance;\n        this.material.uniforms.uOpenProgress.value = this.settings.openProgress * 2;\n        this.material.uniforms.uResponsiveScale.value = this.worldGL.responsiveScale;\n        this.material.uniforms.uScrollDelta.value = -this.eased_scrollDelta_fast.get(this.worldGL.settings.scroll_normalizedDelta * 0.5); //--\n\n        var extraSpeed;\n\n        if (this.eventFase == "interactive") {\n          extraSpeed = 1 + Math.abs(this.eased_scrollDelta_fast.get(this.worldGL.settings.scroll_normalizedDelta * 0.5) * 10);\n        } else {\n          extraSpeed = 1;\n        }\n\n        this.settings.rotation1 += this.settings.speedRotation1 * extraSpeed;\n        this.settings.rotation2 += this.settings.speedRotation2 * extraSpeed;\n        this.settings.rotation3 += this.settings.speedRotation3 * extraSpeed;\n        this.material.uniforms.uRotation1.value = this.settings.rotation1;\n        this.material.uniforms.uRotation2.value = -this.settings.rotation2;\n        this.material.uniforms.uRotation3.value = this.settings.rotation3; //console.log(this.material.uniforms.uRotation1.value)\n\n        this.material.uniforms.uIntroProgress1.value = this.event_intro_c1.get_progress();\n        this.material.uniforms.uIntroProgress2.value = this.event_intro_c2.get_progress();\n        this.material.uniforms.uIntroProgress3.value = this.event_intro_c3.get_progress();\n        this.material.uniforms.uZoomOutProgress1.value = this.event_zoomout_c1.get_progress();\n        this.material.uniforms.uZoomOutProgress2.value = this.event_zoomout_c2.get_progress();\n        this.material.uniforms.uZoomOutProgress3.value = this.event_zoomout_c3.get_progress(); //console.log(this.material.uniforms.uZoomOutProgress1.value+" - "+this.material.uniforms.uZoomOutProgress2.value+" - "+this.material.uniforms.uZoomOutProgress3.value)\n        //this.material.uniforms.uFallProcess.value = this.event_fall.get_progress()\n\n        this.material.uniforms.uFallProcess.value = 1;\n        this.material.uniforms.uHeight.value = this.worldGL.height; //console.log("uIntroProgress1: "+this.material.uniforms.uIntroProgress1.value)\n\n        var videoBounds = this.worldGL.$video.getBoundingClientRect();\n        this.material.uniforms.uVideoYOffset.value = videoBounds.y; //console.log(videoBounds.y)\n      }\n    }\n    /*\r\n    onUpdateGeometryPosY(posY){\r\n        // Este script hacia los calculos para sincronizar la posicin de la geometria con las de un div que se movía verticalmente con el scroll.\r\n                // Comentado por si sirve en el futuro.\r\n        console.log("posY: "+posY)\r\n        this.settings.geometryPosY = posY\r\n        this.mesh.position.setY(posY);\r\n    }\r\n    */\n\n  }, {\n    key: "onUpdateOpenProgress",\n    value: function onUpdateOpenProgress(progress) {\n      this.settings.openProgress = progress;\n    } //------------------------------------\n    // PUBLICAS:\n\n  }, {\n    key: "resize",\n    value: function resize(newWidth, newHeight) {//console.log("(GradientBackground.resize)!")\n    } //------------------------------------\n    // PRIVADAS: \n\n  }, {\n    key: "_setup_settings",\n    value: function _setup_settings() {\n      //console.log("(Home1Dots._setup_settings)!!")\n      var speedBase = 0.002;\n      this.settings = {\n        factor: 6,\n        incr_radio: 25,\n        numOrbits: 31,\n        //arrayOrbits: [5, 6, 7, 8, 9, 10, 13, 17, 18, 19, 22, 23, 24, 25, 26, 27]\n        arrayOrbits: [9, 13, 17],\n        //arrayOrbits: [1, 3]\n        // Ortbit rotation\n        speedBase: speedBase,\n        rotation1: 0,\n        speedRotation1: 3 * speedBase,\n        rotation2: 2,\n        speedRotation2: 2 * speedBase,\n        rotation3: 0,\n        speedRotation3: 1 * speedBase\n      };\n      this.settings.array_triangular = this._get_array_triangular(this.settings.factor, this.settings.numOrbits);\n      this.settings.array_triangular_dots_x_orbita = this._get_array_triangular_dots_x_orbita(this.settings.array_triangular, this.settings.arrayOrbits);\n      this.settings.array_dotPos = this._get_array_dotPos(this.settings.arrayOrbits, this.settings.array_triangular, this.settings.array_triangular_dots_x_orbita);\n      this.settings.numDots = this.settings.array_dotPos.length;\n      this.settings.openProgress = 0;\n      this.settings.geometryPosY = 0; //this.settings.numDots = this.settings.array_triangular[this.settings.array_triangular.length-1]\n      //console.log("this.settings.array_triangular: "+this.settings.array_triangular)\n      //console.log("this.settings.array_triangular_dots_x_orbita: "+this.settings.array_triangular_dots_x_orbita)\n      //console.log("this.settings.numDots: "+this.settings.numDots)\n      //console.log("this.settings.arrayOrbits: "+this.settings.arrayOrbits)\n      //console.log("this.settings.array_dotPos: "+this.settings.array_dotPos)\n      //console.log("this.settings.array_dotPos.length: "+this.settings.array_dotPos.length)\n    }\n  }, {\n    key: "_create",\n    value: function _create() {\n      //console.log("(Home1Dots._create)!")\n      //--\n      var videoBounds = this.worldGL.$video.getBoundingClientRect();\n      this.material = new three_module/* ShaderMaterial */.jyz({\n        depthWrite: false,\n        //blending: THREE.AdditiveBlending,\n        vertexColors: true,\n        vertexShader: home1_dots_vertex,\n        fragmentShader: home1_dots_fragment,\n        transparent: true,\n        uniforms: {\n          uCamaraDistance: {\n            value: this.worldGL.cameraDistance\n          },\n          uTime: {\n            value: 0\n          },\n          //uScale:{value: 1},\n          uOpenProgress: {\n            value: 0\n          },\n          uResponsiveScale: {\n            value: 0\n          },\n          uScrollDelta: {\n            value: 0\n          },\n          uRotation1: {\n            value: 0\n          },\n          uRotation2: {\n            value: 0\n          },\n          uRotation3: {\n            value: 0\n          },\n          uIntroProgress1: {\n            value: 0\n          },\n          uIntroProgress2: {\n            value: 0\n          },\n          uIntroProgress3: {\n            value: 0\n          },\n          uZoomOutProgress1: {\n            value: 0\n          },\n          uZoomOutProgress2: {\n            value: 0\n          },\n          uZoomOutProgress3: {\n            value: 0\n          },\n          uFallProcess: {\n            value: 0\n          },\n          uHeight: {\n            value: this.worldGL.height\n          },\n          uVideoYOffset: {\n            value: videoBounds.y\n          },\n          uZoomingProgress: {\n            value: 0\n          } //uVideoHeight:{value: videoBounds.height},\n\n        }\n      }); //--\n      //console.log(this.orbital_geometry.attributes.a_color)\n      //--\n\n      this.geometry = new three_module/* BufferGeometry */.u9r();\n      this.geometry.setAttribute(\'position\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_geo1_position\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_geo1_color\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_color, 3));\n      this.geometry.setAttribute(\'a_geo1_orbital\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_orbital, 1));\n      this.geometry.setAttribute(\'a_geo1_pos_orbita\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_pos_orbita, 1));\n      this.geometry.setAttribute(\'a_geo1_incr_anguloRad\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_incr_anguloRad, 1));\n      this.geometry.setAttribute(\'a_geo1_anguloRad\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_anguloRad, 1));\n      this.geometry.setAttribute(\'a_geo1_radio\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_radio, 1));\n      this.geometry.setAttribute(\'a_geo1_dir\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_dir, 1));\n      this.geometry.setAttribute(\'a_geo1_incr\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_incr, 1));\n      this.geometry.setAttribute(\'a_geo1_x\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_x, 1));\n      this.geometry.setAttribute(\'a_geo1_y\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_y, 1));\n      this.geometry.setAttribute(\'a_geo1_z\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_z, 1));\n      this.mesh = new three_module/* Points */.woe(this.geometry, this.material);\n      this.scene.add(this.mesh); //---------\n      // this.material2 = new THREE.ShaderMaterial({\n      //     depthWrite: false,\n      //     blending: THREE.AdditiveBlending,\n      //     vertexColors: true,\n      //     vertexShader: vertex_bg, \n      //     fragmentShader: fragment_bg,\n      //     transparent: true,\n      //     uniforms: {\n      //         uCamaraDistance: {value: this.worldGL.cameraDistance},\n      //         uTime: {value: 0},\n      //         //uScale:{value: 1.5},\n      //         uOpenProgress:{value: 0}\n      //     }\n      // })\n      // this.mesh2 = new THREE.Points(this.geometry, this.material2)\n      // this.mesh2.position.z =-1\n      // this.scene.add(this.mesh2)\n      //---------\n\n      this.created = true;\n    }\n  }, {\n    key: "_init_scrollListeners",\n    value: function _init_scrollListeners() {\n      /*\r\n      ScrollTrigger.create({\r\n          trigger: document.querySelector(\'.about__hero\'),\r\n          start: \'top top\',\r\n          end: \'bottom top\',\r\n          //once: true,\r\n          // markers: true,\r\n          scrub: true,\r\n          onUpdate: (e) => {\r\n              let incr = e.progress - this.lastScrollValue\r\n              incr = Math.round(incr * 1000)\r\n              this.lastScrollValue = e.progress\r\n              incr = Math.min(Math.max(parseInt(incr), -20), 20);\r\n              this.settings.scrollSpeed = incr/20\r\n              //--console.log(e)\r\n              this.settings.progress5 = e.progress*5 //Rotaciones\r\n              this.settings.progress0 = e.progress*10 //\r\n              this.settings.progress6 = e.progress*10\r\n              this.settings.progress4 = e.progress*50\r\n          }\r\n      })\r\n      // Progreso sección Touch\r\n      ScrollTrigger.create({\r\n          trigger: document.querySelector(\'.about__touch\'),\r\n          start: \'top bottom\',\r\n          end: \'bottom bottom\',\r\n          //once: true,\r\n          // markers: true,\r\n          scrub: true,\r\n          onUpdate: (e) => {\r\n              this.settings.progress1 = e.progress\r\n          }\r\n      })\r\n      */\n    }\n  }, {\n    key: "_get_array_dotPos",\n    value: function _get_array_dotPos(_arrayOrbits, _array_triangular, _array_triangular_dots_x_orbita) {\n      var miArray = [];\n\n      for (var i = 0; i < _arrayOrbits.length; i++) {\n        var orbitNum = _arrayOrbits[i];\n        var dots_x_orbit = _array_triangular_dots_x_orbita[i];\n        var dotNum_base = _array_triangular[_arrayOrbits[i] - 1]; // console.log("orbitNum: "+orbitNum)\n        // console.log("dots_x_orbit: "+dots_x_orbit)\n        // console.log("dotNum_base: "+dotNum_base)\n\n        for (var j = 0; j < dots_x_orbit; j++) {\n          miArray.push(dotNum_base + j + 1);\n        }\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_get_numDots",\n    value: function _get_numDots(_array_triangular_dots_x_orbita) {\n      var numDots = 0;\n\n      for (var i = 0; i <= _array_triangular_dots_x_orbita.length - 1; i++) {\n        numDots += _array_triangular_dots_x_orbita[i];\n      }\n\n      return numDots;\n    }\n  }, {\n    key: "_get_array_triangular_dots_x_orbita",\n    value: function _get_array_triangular_dots_x_orbita(_array_triangular, _arrayOrbits) {\n      // Genera una array basada en la progresión triangular (* factor).\n      // ... donde se indica el numero de dots por orbital\n      // Una progresión triangular es: 1, 3, 6, 10, 15 (https://significativa.org/diccionarios/numeros-figurados/#:~:text=3.1.1.1.-,Definici%C3%B3n,anterior%20no%20obtenemos%20una%20constante.)\n      var miArray = [];\n\n      for (var i = 0; i <= _arrayOrbits.length - 1; i++) {\n        //array_numTriagulares.push(i*(i+1)/2)\n        var numDots_orbita_actual = _array_triangular[_arrayOrbits[i]];\n        var numDots_orbita_anterior = _array_triangular[_arrayOrbits[i] - 1];\n        var numDots_orbita = numDots_orbita_actual - numDots_orbita_anterior;\n        miArray.push(numDots_orbita);\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_get_array_triangular",\n    value: function _get_array_triangular(_factor, _numObits) {\n      // Genera una array de progresión triangular (* factor).\n      // Una progresión triangular es: 1, 3, 6, 10, 15 (https://significativa.org/diccionarios/numeros-figurados/#:~:text=3.1.1.1.-,Definici%C3%B3n,anterior%20no%20obtenemos%20una%20constante.)\n      var miArray = [];\n\n      for (var i = 0; i <= _numObits; i++) {\n        //array_numTriagulares.push(i*(i+1)/2)\n        miArray.push(i * (i + 1) / 2 * _factor);\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_setup_gui",\n    value: function _setup_gui() {//console.log("(Home1Dots._setup_gui)!")\n      // this.gui = new dat.GUI();\n      // this.gui.width = 400\n      // const folder0 = this.gui.addFolder("Orbit spinning")\n      // folder0.add(this.settings, "progress5", 0, 10, 0.01).name("Progress")\n      // folder0.open()\n    }\n  }, {\n    key: "_createcube",\n    value: function _createcube(_scene) {\n      var geometry = new three_module/* BoxGeometry */.DvJ(100, 100, 100);\n      var material = new three_module/* MeshBasicMaterial */.vBJ({\n        color: 0xff0000\n      });\n      var cube = new three_module/* Mesh */.Kj0(geometry, material);\n\n      _scene.add(cube);\n    } //---------------------------------------------------------\n    //---------------------------------------------------------\n\n  }]);\n\n  return Home1Dots;\n}();\n\n/* harmony default export */ const home1_Home1Dots = (Home1Dots);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home1/Home1App.js\nfunction Home1App_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home1App_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home1App_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home1App_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home1App_defineProperties(Constructor, staticProps); return Constructor; }\n\n// FPS-Meter:\n//(function(){var script=document.createElement(\'script\');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src=\'//cdn.jsdelivr.net/gh/Kevnz/stats.js/build/stats.min.js\';document.head.appendChild(script);})()\n\n\n\n\n\n\n\n\nvar Home1App = /*#__PURE__*/function () {\n  function Home1App(obj) {\n    Home1App_classCallCheck(this, Home1App);\n\n    //console.log("(Home1App.CONSTRUCTORA)!!", obj) \n    this.hw_renderer = obj.renderer; // Rederer/pagina de HighWay. No confundir con el render/renderer de Three.js\n\n    this.$container = obj.domElement; //--\n\n    this.$video = this.hw_renderer.$video;\n    this.$inner = document.querySelector(\'.inner\');\n    this.$video = this.hw_renderer.$video; //--\n\n    this.width = this.$container.offsetWidth; //console.log("width: "+this.width)\n\n    this.height = this.$container.offsetHeight; //--\n\n    this.refResolution = 1920;\n    this.responsiveScale = this.width / this.refResolution; //--\n\n    this.cameraDistance = 500; //--\n\n    this.settings = {\n      scroll_lastInnerY: 0,\n      // Ultima posición del elemento de referencia\n      scroll_delta: 0,\n      // Incremento de pixels del scroll\n      scroll_limitedDelta: 0,\n      // Limita los valores a -20 -> +20\n      scroll_normalizedDelta: 0,\n      // Pasa el delta a -1 -> +1\n      scroll_factordDelta: 1,\n      // Valores absolutos de 0 -> 1\n      scroll_direction: 1 // Direccion del delta. 1 si está parado\n\n    }; //--\n    // Scene\n\n    this.scene = new three_module/* Scene */.xsS(); //--\n    // Camera\n    //PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )\n\n    this.camera = new three_module/* PerspectiveCamera */.cPb(30, this.width / this.height, 0.1, 2000);\n    this.camera.position.z = this.cameraDistance;\n    this.camera.fov = 2 * Math.atan(this.height / 2 / this.cameraDistance) * (180 / Math.PI); //--\n    // Renderer\n    //--\n\n    this.ACTIVE_RENDER = false; //--\n\n    this.renderer = new three_module/* WebGL1Renderer */.b5g({\n      antialias: true,\n      alpha: true\n    });\n    this.renderer.autoClear = false; // Vamos a usar 2 scenas (una para el background y otra para los puntos) que implicarán usar 2 acciones de render. Con autoclear false permitimos que la segunda no borre la primera.\n    //console.log("window.devicePixelRatio (original): "+window.devicePixelRatio)\n\n    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1)); //console.log("window.devicePixelRatio (filtrado): "+window.devicePixelRatio)\n    //console.log("WebGL2?: "+this.renderer.capabilities.isWebGL2)\n    //--\n    //this.controls = new OrbitControls( this.camera, this.renderer.domElement );\n    // this.controls.addEventListener(\'change\', (e) =>{\n    //     this.onCameraPositionChange(e)\n    // });\n    //--\n\n    this.$container.appendChild(this.renderer.domElement); //--\n\n    this.dots = new home1_Home1Dots({\n      worldGL: this\n    }); //--\n\n    this._resize(); //this._render();\n    //this._init_scrollListeners()\n\n  } //---------------------------\n  // PUBLICAS:\n\n\n  Home1App_createClass(Home1App, [{\n    key: "init",\n    value: function init() {\n      this.$video = this.hw_renderer.$video;\n      this.$inner = document.querySelector(\'.inner\');\n      this.$video = this.hw_renderer.$video; //--\n\n      this.dots.init(); //--\n\n      this._init_scrollListeners();\n\n      this._render();\n    }\n  }, {\n    key: "kill",\n    value: function kill() {\n      this.trigger.kill();\n      node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this._binded_render);\n      node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this._binded_eval_scroll);\n      this.dots = null;\n    } //---------------------------\n\n  }, {\n    key: "onUpdateOpenProgress",\n    value: function onUpdateOpenProgress(progress) {\n      if (this.dots) {\n        this.dots.onUpdateOpenProgress(progress);\n      }\n    }\n  }, {\n    key: "onResize",\n    value: function onResize() {\n      //console.log("(Home1App.onResize)!")\n      this._resize();\n    } //---------------------------\n    // PRIVADAS:\n\n  }, {\n    key: "_init_scrollListeners",\n    value: function _init_scrollListeners() {\n      var _this = this;\n\n      var binded_render = function binded_render() {\n        _this._render();\n      };\n\n      var binded_eval_scroll = function binded_eval_scroll() {\n        _this._eval_scroll(_this.trigger.progress);\n      };\n\n      this._binded_render = binded_render;\n      this._binded_eval_scroll = binded_eval_scroll;\n      this.trigger = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$video,\n        start: \'top bottom\',\n        end: \'bottom top\',\n        scrub: true,\n        // Scrub: Genera eventos en una franja mas que en un punto.\n        //markers: true,\n        onToggle: function onToggle(self) {\n          if (self.isActive) {\n            // console.log("MAIN_ACTIVE")\n            node_modules_gsap/* default.ticker.add */.ZP.ticker.add(binded_render);\n            node_modules_gsap/* default.ticker.add */.ZP.ticker.add(binded_eval_scroll);\n          } else {\n            // console.log("MAIN_NOT_ACTIVE")\n            node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(binded_render);\n            node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(binded_eval_scroll);\n          }\n        }\n      });\n    }\n  }, {\n    key: "_eval_scroll",\n    value: function _eval_scroll(progress) {\n      var innerData = this.$inner.getBoundingClientRect();\n      var newInnerY = innerData.y;\n      this.settings.scroll_delta = newInnerY - this.settings.scroll_lastInnerY;\n      this.settings.scroll_lastInnerY = newInnerY;\n      this.settings.scroll_limitedDelta = webgl_WebGLUtils.clamp(this.settings.scroll_delta, -20, 20); // Limita los valores a -20 -> +20\n\n      this.settings.scroll_normalizedDelta = (this.settings.scroll_limitedDelta / 20).toFixed(3); // Pasa el delta a -1 -> +1\n\n      this.settings.scroll_factordDelta = Math.abs(this.settings.scroll_normalizedDelta) + 0; // Valores absolutos de 0 -> 1\n\n      this.settings.scroll_direction = 1;\n\n      if (this.settings.scroll_normalizedDelta < 0) {\n        this.settings.scroll_direction = -1;\n      } // console.log("this.settings.scroll_normalizedDelta: "+this.settings.scroll_normalizedDelta)\n      //console.log("this.settings.scroll_factordDelta: "+this.settings.scroll_factordDelta)\n\n    }\n  }, {\n    key: "_resize",\n    value: function _resize() {\n      //console.log("(Home1App._resize)!!")\n      this.width = this.$container.offsetWidth;\n      this.height = this.$container.offsetHeight;\n      this.responsiveScale = this.width / this.refResolution;\n      this.renderer.setSize(this.width, this.height);\n      this.camera.aspect = this.width / this.height;\n      this.cameraDistance = this.camera.position.z;\n      this.camera.fov = 2 * Math.atan(this.height / 2 / this.cameraDistance) * (180 / Math.PI); //--\n\n      this.camera.updateProjectionMatrix(); //--\n\n      if (this.dots) {//this.dots.resize(this.width, this.height);\n      }\n    }\n  }, {\n    key: "_render",\n    value: function _render() {\n      //console.log("(Home1App._render)!")\n      if (this.height != this.$container.offsetHeight || this.width != this.$container.offsetWidth) {\n        this._resize();\n      }\n\n      if (this.dots) {\n        this.dots.render();\n      }\n\n      this.renderer.render(this.scene, this.camera); //requestAnimationFrame(this._render.bind(this)) // El bucle de render lo genera el onUpdate del ScrollTrigger\n    }\n  }]);\n\n  return Home1App;\n}();\n\n/* harmony default export */ const home1_Home1App = (Home1App);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home2/Home2Geometry.js\nfunction Home2Geometry_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Home2Geometry_typeof = function _typeof(obj) { return typeof obj; }; } else { Home2Geometry_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Home2Geometry_typeof(obj); }\n\nfunction Home2Geometry_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home2Geometry_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home2Geometry_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home2Geometry_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home2Geometry_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Home2Geometry_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Home2Geometry_setPrototypeOf(subClass, superClass); }\n\nfunction Home2Geometry_setPrototypeOf(o, p) { Home2Geometry_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Home2Geometry_setPrototypeOf(o, p); }\n\nfunction Home2Geometry_createSuper(Derived) { var hasNativeReflectConstruct = Home2Geometry_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Home2Geometry_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Home2Geometry_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Home2Geometry_possibleConstructorReturn(this, result); }; }\n\nfunction Home2Geometry_possibleConstructorReturn(self, call) { if (call && (Home2Geometry_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Home2Geometry_assertThisInitialized(self); }\n\nfunction Home2Geometry_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Home2Geometry_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Home2Geometry_getPrototypeOf(o) { Home2Geometry_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Home2Geometry_getPrototypeOf(o); }\n\n//import * as THREE from "three"\n//import gsap from "gsap"\n//import {GLTFLoader, GLTLoader} from "three/examples/jsm/loaders/GLTFLoader"\nvar Home2Geometry_EventEmitter = __webpack_require__(7187);\n\nvar Home2Geometry = /*#__PURE__*/function (_EventEmitter) {\n  Home2Geometry_inherits(Home2Geometry, _EventEmitter);\n\n  var _super = Home2Geometry_createSuper(Home2Geometry);\n\n  function Home2Geometry(obj) {\n    var _this;\n\n    Home2Geometry_classCallCheck(this, Home2Geometry);\n\n    //console.log("(Home2Geometry.CONSTRUCTORA)!")\n    _this = _super.call(this); //--\n\n    _this.factor = obj.factor; //6\n\n    _this.incr_radio = obj.incr_radio; //25\n\n    _this.numOrbits = obj.numOrbits; //37\n\n    _this.array_triangular = obj.array_triangular;\n    _this.array_dotPos = obj.array_dotPos;\n    _this.numDots = obj.numDots; //--\n\n    _this.arrayColores_RGB = [];\n    _this.arrayColores_RGB_01 = [];\n    _this.colorPos = 0;\n\n    _this._init_colors(); //--\n\n\n    _this.attributes = {\n      a_posiciones: new Float32Array(_this.numDots * 3),\n      a_color: new Float32Array(_this.numDots * 3),\n      a_orbital: new Float32Array(_this.numDots * 1),\n      a_pos_orbita: new Float32Array(_this.numDots * 1),\n      a_incr_anguloRad: new Float32Array(_this.numDots * 1),\n      a_anguloRad: new Float32Array(_this.numDots * 1),\n      a_radio: new Float32Array(_this.numDots * 1),\n      a_dir: new Float32Array(_this.numDots * 1),\n      a_incr: new Float32Array(_this.numDots * 1),\n      a_x: new Float32Array(_this.numDots * 1),\n      a_y: new Float32Array(_this.numDots * 1),\n      a_z: new Float32Array(_this.numDots * 1)\n    }; //--\n\n    for (var i = 0; i < _this.array_dotPos.length; i++) {\n      var dotPos = _this.array_dotPos[i];\n\n      var dot = _this._get_dot(dotPos);\n\n      var i3 = i * 3;\n      _this.attributes.a_posiciones[i3] = dot.x;\n      _this.attributes.a_posiciones[i3 + 1] = dot.y;\n      _this.attributes.a_posiciones[i3 + 2] = dot.z; //--\n\n      _this.attributes.a_color[i3] = dot.color[0];\n      _this.attributes.a_color[i3 + 1] = dot.color[1];\n      _this.attributes.a_color[i3 + 2] = dot.color[2]; //--\n\n      _this.attributes.a_orbital[i] = dot.orbital;\n      _this.attributes.a_pos_orbita[i] = dot.pos_orbita;\n      _this.attributes.a_incr_anguloRad[i] = dot.incr_anguloRad;\n      _this.attributes.a_anguloRad[i] = dot.anguloRad;\n      _this.attributes.a_radio[i] = dot.radio;\n      _this.attributes.a_dir[i] = dot.dir;\n      _this.attributes.a_incr[i] = dot.incr;\n      _this.attributes.a_x[i] = dot.y;\n      _this.attributes.a_y[i] = dot.y;\n      _this.attributes.a_z[i] = dot.z;\n    } //--\n\n\n    _this.loaded = false;\n    return _this;\n  } //------------------------------------------\n  // PRIVADAS\n\n\n  Home2Geometry_createClass(Home2Geometry, [{\n    key: "_get_dot",\n    value: function _get_dot(num) {\n      // Devuelve un objeto con la información de un punto de la geometria "orbital MIOTI"\n      var obj = {\n        num: num,\n        color: this._get_color(),\n        x: 0,\n        y: 0,\n        z: 0,\n        orbital: 0,\n        co_orbitantes: 0,\n        pos_orbita: 0,\n        incr_anguloRad: 0,\n        anguloRad: 0,\n        radio: 0\n      }; //--\n\n      for (var i = 0; i <= this.array_triangular.length; i++) {\n        var limSup = this.array_triangular[i]; //console.log("limSup: "+limSup)\n\n        if (num > limSup) {\n          // console.log("*")\n          obj.orbital = i + 1;\n          obj.co_orbitantes = (i + 1) * this.factor;\n          obj.pos_orbita = num - limSup - 1;\n          obj.incr_anguloRad = 2 * Math.PI / obj.co_orbitantes;\n\n          if (obj.orbital % 2 == 0) {\n            obj.dir = 1;\n            obj.incr = 0;\n            obj.anguloRad = obj.pos_orbita * obj.incr_anguloRad;\n          } else {\n            obj.dir = -1;\n            obj.incr = 1;\n            obj.anguloRad = obj.pos_orbita * obj.incr_anguloRad + obj.incr_anguloRad / 2;\n          }\n\n          obj.radio = obj.orbital * this.incr_radio; //--\n\n          obj.x = Math.cos(obj.anguloRad) * obj.radio;\n          obj.y = Math.sin(obj.anguloRad) * obj.radio;\n          obj.z = 0;\n        } //break\n\n      }\n\n      return obj;\n    }\n  }, {\n    key: "_get_color",\n    value: function _get_color() {\n      var color_RGB_01 = this.arrayColores_RGB_01[this.colorPos];\n      this.colorPos++;\n\n      if (this.colorPos > this.arrayColores_RGB_01.length - 1) {\n        this.colorPos = 0;\n      }\n\n      return color_RGB_01;\n    }\n  }, {\n    key: "_init_colors",\n    value: function _init_colors() {\n      this.arrayColores_RGB = [];\n      this.arrayColores_RGB.push([232, 67, 131]);\n      this.arrayColores_RGB.push([0, 126, 255]);\n      this.arrayColores_RGB_01 = [];\n\n      for (var i = 0; i < this.arrayColores_RGB.length; i++) {\n        var color_RGB = this.arrayColores_RGB[i];\n        var color_RGB_01 = [color_RGB[0] / 255, color_RGB[1] / 255, color_RGB[2] / 255];\n        this.arrayColores_RGB_01.push(color_RGB_01);\n      }\n    }\n  }]);\n\n  return Home2Geometry;\n}(Home2Geometry_EventEmitter);\n\n/* harmony default export */ const home2_Home2Geometry = (Home2Geometry);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home2/shaders/home2_dots_vertex.glsl\n/* harmony default export */ const home2_dots_vertex = ("#define GLSLIFY 1\\nattribute vec3 a_randomness;\\nattribute vec3 a_geo1_position;\\nattribute vec3 a_geo1_color;\\nattribute float a_geo1_anguloRad;\\nattribute float a_geo1_orbital;\\nattribute float a_geo1_pos_orbita;\\nattribute float a_geo1_incr_anguloRad;\\nattribute float a_geo1_incr;\\nattribute float a_geo1_dir;\\nattribute float a_geo1_radio;\\n\\nuniform float uCamaraDistance;\\nuniform float uTime;\\nuniform float uResponsiveScale;\\nuniform float uScrollDelta;\\nuniform float uRotation1;\\nuniform float uRotation2;\\nuniform float uRotation3;\\n\\nvarying float v_angleRad;\\nvarying vec3 v_color;\\nvarying float v_pulseStrengthNorm1;\\nvarying float v_pulseStrengthNorm2;\\n\\n#define PI 3.1415926538\\n\\nvec3 get_pos1(float anguloRad){\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(1.*a_geo1_dir*0.2);\\n    float x = cos(anguloRad)*a_geo1_radio;\\n    float y = sin(anguloRad)*a_geo1_radio;\\n    float z = 0.0;\\n    vec3 newPos = vec3(x, y, z);\\n    return newPos;\\n}\\n\\nfloat get_cosTime(float time, float radius){\\n    //\\n    //float value = sin(uTime)*2.*PI;\\n    float value = sin(time)*radius;\\n    return value;\\n}\\n\\nfloat get_x(float angleRad, float radius){\\n    return cos(angleRad)*a_geo1_radio;\\n}\\n\\nfloat get_pulseStrengthNorm( float direction){\\n    float dotAguleNorm = a_geo1_anguloRad/(2.*PI); // Pasamos el angulo del punto que está en radianes a un valor de 0 a 1.\\n\\n    float modSpeed = mix(1., 2.5, 13./a_geo1_orbital)*direction;\\n    float radialSpeed = uTime*0.02*modSpeed; // Modificamos uTime para determinar la velocidad radial.\\n\\n    float pulseAngleRad = radialSpeed*(4.*PI);\\n\\n    // El valor de pulseAngleRad debe estar entre 0 y 2PI (inicio y fin de una circunferencia).\\n    // Como depende de uTime el valor saldrá de ese rango pronto por lo que tomaremos el resto (modulo),\\n    // de dividir pulseAngleRad por 2PI.\\n    if(pulseAngleRad > 2.*PI){\\n        pulseAngleRad = mod(pulseAngleRad, (2.*PI));\\n    }\\n    if(pulseAngleRad < 0.){\\n        pulseAngleRad = mod(pulseAngleRad, (2.*PI));\\n    }\\n\\n    float pulseAngleNorm = pulseAngleRad/(2.*PI); // Normalizamos el valor (de 0 a 1)\\n\\n    float distAngleNorm = abs(pulseAngleNorm-dotAguleNorm); // Calculamos la distancia radial del pulso al punto\\n\\n    // Apañamos la distancia de tal forma que no le afecte el punto de discontinuidad OPI = 2PI\\n    if(distAngleNorm > 0.5){ \\n        distAngleNorm = 0.5-(distAngleNorm-0.5);\\n    }\\n\\n    // La maxima distancia es de medio circulo y en terminos normalizados es 0.5\\n    // Creamos una variable que normalice ese valor entre 0 y 1.\\n    float pulseStrengthNorm  = distAngleNorm*2.; \\n\\n    float pico = 0.92;\\n    pico = mix(pico*0.99, pico*1.01, a_geo1_orbital/13.);\\n\\n    // Nos interesa solo el pico, la zona que va entre 0.95 y 1.\\n    // Toodo lo que haya por debajo de 0.95 lo pasamos a 0.95\\n    // y le restamos ese mismo 0.95 para quedarnos con el pico de 0.05 eol cual amplificamos x20 para normalizarlo (de 0 a 1).\\n    pulseStrengthNorm = (clamp(pulseStrengthNorm, pico, 1.)-pico)*10.;\\n    //--\\n    return pulseStrengthNorm;\\n}\\n\\nvoid main() {\\n\\n    float pulseStrengthNorm1 = get_pulseStrengthNorm(1.5);\\n    float pulseStrengthNorm2 = get_pulseStrengthNorm(-1.);\\n\\n    // Determinamos el tamaño del punto teniendo un minimo de 5 y amplificando el maximo para que visualmente sea bonito\\n    //float size = 5.+(pulseStrengthNorm*15.*longPeriod);\\n    float size = 5.;\\n    size += (pulseStrengthNorm1*5.);\\n    size += (pulseStrengthNorm2*5.);\\n    size *= uResponsiveScale;\\n\\n    float anguloRad_time = 0.;\\n\\n    if(abs(a_geo1_orbital-6.) < 0.5){ // Detecta el orbital 6\\n        anguloRad_time = a_geo1_anguloRad+uRotation1;\\n    }else if(abs(a_geo1_orbital-10.) < 0.5){ // Detecta el orbital 11\\n        anguloRad_time = a_geo1_anguloRad+uRotation2;\\n    }else if(abs(a_geo1_orbital-14.) < 0.5){ // Detecta el orbital 13\\n        anguloRad_time = a_geo1_anguloRad+uRotation3;\\n    }\\n    \\n    //float anguloRad_time = a_geo1_anguloRad+(direction*sin(uTime+a_geo1_orbital)*0.2);\\n    vec3 pos1 = get_pos1(anguloRad_time);\\n    pos1 *= 2.;\\n    //pos1 *= 1.+(uScrollDelta*0.2);\\n    pos1 *= uResponsiveScale;\\n    //vec3 pos2 = pos1*1.0;\\n    //pos1= mix(pos1, pos2, pulseStrengthNorm);\\n\\n    //----------------------------------------------------------\\n    // VERTEX\\n    vec4 mvPosition = modelViewMatrix * vec4( pos1, 1.0 );\\n    gl_Position = projectionMatrix * mvPosition;\\n    gl_PointSize = size*(uCamaraDistance/-mvPosition.z);\\n    //----------------------------------------------------------\\n\\n    //--------------------------------------\\n    // VARYINGS:\\n    v_angleRad = anguloRad_time;\\n    v_color = a_geo1_color; \\n    v_pulseStrengthNorm1 = pulseStrengthNorm1; \\n    v_pulseStrengthNorm2 = pulseStrengthNorm2; \\n\\n}\\n\\n");\n;// CONCATENATED MODULE: ./app/src/js/webgl/home2/shaders/home2_dots_fragment.glsl\n/* harmony default export */ const home2_dots_fragment = ("#define GLSLIFY 1\\nuniform vec3 uColor1;\\nuniform vec3 uColor2;\\n\\nvarying float v_angleRad;\\nvarying vec3 v_color;\\nvarying float v_pulseStrengthNorm1;\\nvarying float v_pulseStrengthNorm2;\\n\\n#define PI 3.1415926538\\n\\nfloat circulizar(float radio){\\n    // radio es un valor entre 0 y 1. 0 es 0 de radio y 1 es el maximo del radio dentro de\\n    radio = 1.0-(0.5*radio);\\n    float result = distance(gl_PointCoord, vec2(0.5, 0.5));\\n    result = 1. -result;\\n    result = pow(result, 1.);\\n    result = step(radio, result);\\n    return result;\\n}\\n\\nvoid main() {\\n    vec3 white = vec3(1., 1., 1.);\\n    float pulse = v_pulseStrengthNorm1+v_pulseStrengthNorm2;\\n    pulse = clamp(pulse, 0., 1.);\\n    vec3 finalColor = v_color;\\n    //finalColor = mix(finalColor, white, pulse*5.);\\n    //finalColor = mix(finalColor, white, 0.);\\n    float alpha = circulizar(1.0);\\n\\n    float mod_angleRad = mod(v_angleRad, (2.*PI));\\n    float hemisphere = step(PI, mod_angleRad);\\n\\n    finalColor = mix(uColor1, uColor2, hemisphere);\\n\\n    gl_FragColor = vec4(finalColor, alpha*0.8);\\n}");\n;// CONCATENATED MODULE: ./app/src/js/webgl/home2/Home2Dots.js\nfunction Home2Dots_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home2Dots_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home2Dots_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home2Dots_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home2Dots_defineProperties(Constructor, staticProps); return Constructor; }\n\n //import gsap from "gsap"\n\n\n\n\n\n\nvar Home2Dots = /*#__PURE__*/function () {\n  function Home2Dots(obj) {\n    Home2Dots_classCallCheck(this, Home2Dots);\n\n    //console.log("(Home2Dots.CONSTRUCTORA)!")\n    //console.log(obj)\n    this.worldGL = obj.worldGL; //--\n\n    this.scene = this.worldGL.scene;\n    this.cameraDistance = this.worldGL.cameraDistance; //--\n\n    this.material = null;\n    this.geometry = null;\n    this.mesh = null;\n    this.numParticles = null;\n    this.created = false;\n    this.clock = new three_module/* Clock */.SUY(); //--\n\n    this.eased_scrollDelta = new webgl_EasedOutValue(this.worldGL.settings.scroll_normalizedDelta * 0.5, 0.01);\n    this.eeased_scrollDelta_fast = new webgl_EasedOutValue(this.worldGL.settings.scroll_normalizedDelta * 0.5, 0.1); //--\n\n    this._setup_settings(); //--\n\n\n    this.orbital_geometry = new home2_Home2Geometry(this.settings); //--\n    //--\n    //this._createcube(this.scene)\n\n    this._create();\n\n    this.resize();\n  } //------------------------------------\n  // PUBLICAS: \n\n\n  Home2Dots_createClass(Home2Dots, [{\n    key: "render",\n    value: function render() {\n      if (this.created) {\n        this.material.uniforms.uTime.value = this.clock.getElapsedTime();\n        this.material.uniforms.uCamaraDistance.value = this.worldGL.cameraDistance;\n        this.material.uniforms.uResponsiveScale.value = this.worldGL.responsiveScale;\n        this.material.uniforms.uScrollDelta.value = -this.eeased_scrollDelta_fast.get(this.worldGL.settings.scroll_normalizedDelta * 0.5); //--\n\n        var extraSpeed = 1 + Math.abs(this.eeased_scrollDelta_fast.get(this.worldGL.settings.scroll_normalizedDelta * 0.5) * 10);\n        this.settings.rotation1 += this.settings.speedRotation1 * extraSpeed;\n        this.settings.rotation2 += this.settings.speedRotation2 * extraSpeed;\n        this.settings.rotation3 += this.settings.speedRotation3 * extraSpeed;\n        this.material.uniforms.uRotation1.value = this.settings.rotation1;\n        this.material.uniforms.uRotation2.value = -this.settings.rotation2;\n        this.material.uniforms.uRotation3.value = this.settings.rotation3;\n      }\n    }\n  }, {\n    key: "resize",\n    value: function resize(newWidth, newHeight) {\n      //console.log("(Home2Dots.resize)!")\n      if (this.mesh) {\n        this.mesh.position.setX(this.worldGL.width / 2);\n      }\n    } //------------------------------------\n    // PRIVADAS: \n\n  }, {\n    key: "_setup_settings",\n    value: function _setup_settings() {\n      //console.log("(Home2Dots._setup_settings)!")\n      var speedBase = 0.002;\n      this.settings = {\n        factor: 6,\n        incr_radio: 25,\n        numOrbits: 26,\n        //arrayOrbits: [12, 19, 26]\n        arrayOrbits: [6, 10, 14],\n        // Ortbit rotation\n        rotation1: 0,\n        speedRotation1: 3 * speedBase,\n        rotation2: 2,\n        speedRotation2: 2 * speedBase,\n        rotation3: 0,\n        speedRotation3: 1 * speedBase\n      };\n      this.settings.array_triangular = this._get_array_triangular(this.settings.factor, this.settings.numOrbits);\n      this.settings.array_triangular_dots_x_orbita = this._get_array_triangular_dots_x_orbita(this.settings.array_triangular, this.settings.arrayOrbits);\n      this.settings.array_dotPos = this._get_array_dotPos(this.settings.arrayOrbits, this.settings.array_triangular, this.settings.array_triangular_dots_x_orbita);\n      this.settings.numDots = this.settings.array_dotPos.length; //this.settings.numDots = this.settings.array_triangular[this.settings.array_triangular.length-1]\n      //console.log("this.settings.array_triangular: "+this.settings.array_triangular)\n      //console.log("this.settings.array_triangular_dots_x_orbita: "+this.settings.array_triangular_dots_x_orbita)\n      //console.log("this.settings.numDots: "+this.settings.numDots)\n      //console.log("this.settings.arrayOrbits: "+this.settings.arrayOrbits)\n      //console.log("this.settings.array_dotPos: "+this.settings.array_dotPos)\n      //console.log("this.settings.array_dotPos.length: "+this.settings.array_dotPos.length)\n    }\n  }, {\n    key: "_create",\n    value: function _create() {\n      //console.log("(Home2Dots._create)!")\n      //--\n      this.material = new three_module/* ShaderMaterial */.jyz({\n        depthWrite: false,\n        //blending: THREE.AdditiveBlending,\n        vertexColors: true,\n        vertexShader: home2_dots_vertex,\n        fragmentShader: home2_dots_fragment,\n        transparent: true,\n        uniforms: {\n          uColor1: {\n            value: new three_module/* Color */.Ilk(0xe84371)\n          },\n          uColor2: {\n            value: new three_module/* Color */.Ilk(0x007eff)\n          },\n          uCamaraDistance: {\n            value: this.worldGL.cameraDistance\n          },\n          uTime: {\n            value: 0\n          },\n          uScrollDelta: {\n            value: 0\n          },\n          uResponsiveScale: {\n            value: 1\n          },\n          uRotation1: {\n            value: 0\n          },\n          uRotation2: {\n            value: 0\n          },\n          uRotation3: {\n            value: 0\n          }\n        }\n      }); //--\n      //console.log(this.orbital_geometry.attributes.a_color)\n      //--\n\n      this.geometry = new three_module/* BufferGeometry */.u9r();\n      this.geometry.setAttribute(\'position\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_geo1_position\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_geo1_color\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_color, 3));\n      this.geometry.setAttribute(\'a_geo1_orbital\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_orbital, 1));\n      this.geometry.setAttribute(\'a_geo1_pos_orbita\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_pos_orbita, 1));\n      this.geometry.setAttribute(\'a_geo1_incr_anguloRad\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_incr_anguloRad, 1));\n      this.geometry.setAttribute(\'a_geo1_anguloRad\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_anguloRad, 1));\n      this.geometry.setAttribute(\'a_geo1_radio\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_radio, 1));\n      this.geometry.setAttribute(\'a_geo1_dir\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_dir, 1));\n      this.geometry.setAttribute(\'a_geo1_incr\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_incr, 1));\n      this.geometry.setAttribute(\'a_geo1_x\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_x, 1));\n      this.geometry.setAttribute(\'a_geo1_y\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_y, 1));\n      this.geometry.setAttribute(\'a_geo1_z\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_z, 1));\n      this.mesh = new three_module/* Points */.woe(this.geometry, this.material);\n      this.scene.add(this.mesh); //---------\n\n      /*\n      this.material2 = new THREE.ShaderMaterial({\n          depthWrite: false,\n          blending: THREE.AdditiveBlending,\n          vertexColors: true,\n          vertexShader: vertex_bg, \n          fragmentShader: fragment_bg,\n          transparent: true,\n          uniforms: {\n              uCamaraDistance: {value: this.worldGL.cameraDistance},\n              uTime: {value: 0},\n              uScale:{value: 1.5}\n          }\n      })\n      this.mesh2 = new THREE.Points(this.geometry, this.material2)\n      this.mesh2.position.z =-1\n      this.scene.add(this.mesh2)\n      */\n      //---------\n\n      this.created = true;\n    }\n  }, {\n    key: "_get_array_dotPos",\n    value: function _get_array_dotPos(_arrayOrbits, _array_triangular, _array_triangular_dots_x_orbita) {\n      var miArray = [];\n\n      for (var i = 0; i < _arrayOrbits.length; i++) {\n        var orbitNum = _arrayOrbits[i];\n        var dots_x_orbit = _array_triangular_dots_x_orbita[i];\n        var dotNum_base = _array_triangular[_arrayOrbits[i] - 1]; // console.log("orbitNum: "+orbitNum)\n        // console.log("dots_x_orbit: "+dots_x_orbit)\n        // console.log("dotNum_base: "+dotNum_base)\n\n        for (var j = 0; j < dots_x_orbit; j++) {\n          miArray.push(dotNum_base + j + 1);\n        }\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_get_numDots",\n    value: function _get_numDots(_array_triangular_dots_x_orbita) {\n      var numDots = 0;\n\n      for (var i = 0; i <= _array_triangular_dots_x_orbita.length - 1; i++) {\n        numDots += _array_triangular_dots_x_orbita[i];\n      }\n\n      return numDots;\n    }\n  }, {\n    key: "_get_array_triangular_dots_x_orbita",\n    value: function _get_array_triangular_dots_x_orbita(_array_triangular, _arrayOrbits) {\n      // Genera una array basada en la progresión triangular (* factor).\n      // ... donde se indica el numero de dots por orbital\n      // Una progresión triangular es: 1, 3, 6, 10, 15 (https://significativa.org/diccionarios/numeros-figurados/#:~:text=3.1.1.1.-,Definici%C3%B3n,anterior%20no%20obtenemos%20una%20constante.)\n      var miArray = [];\n\n      for (var i = 0; i <= _arrayOrbits.length - 1; i++) {\n        //array_numTriagulares.push(i*(i+1)/2)\n        var numDots_orbita_actual = _array_triangular[_arrayOrbits[i]];\n        var numDots_orbita_anterior = _array_triangular[_arrayOrbits[i] - 1];\n        var numDots_orbita = numDots_orbita_actual - numDots_orbita_anterior;\n        miArray.push(numDots_orbita);\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_get_array_triangular",\n    value: function _get_array_triangular(_factor, _numObits) {\n      // Genera una array de progresión triangular (* factor).\n      // Una progresión triangular es: 1, 3, 6, 10, 15 (https://significativa.org/diccionarios/numeros-figurados/#:~:text=3.1.1.1.-,Definici%C3%B3n,anterior%20no%20obtenemos%20una%20constante.)\n      var miArray = [];\n\n      for (var i = 0; i <= _numObits; i++) {\n        //array_numTriagulares.push(i*(i+1)/2)\n        miArray.push(i * (i + 1) / 2 * _factor);\n      }\n\n      return miArray;\n    }\n    /* \n    _createcube(_scene){\n        const geometry = new THREE.BoxGeometry(100,100,100);\n        const material = new THREE.MeshBasicMaterial({color: 0xff0000});\n        const cube = new THREE.Mesh(geometry,material);\n        _scene.add(cube);\n    }\n    */\n    //---------------------------------------------------------\n    //---------------------------------------------------------\n\n  }]);\n\n  return Home2Dots;\n}();\n\n/* harmony default export */ const home2_Home2Dots = (Home2Dots);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home2/Home2App.js\nfunction Home2App_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home2App_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home2App_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home2App_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home2App_defineProperties(Constructor, staticProps); return Constructor; }\n\n//(function(){var script=document.createElement(\'script\');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src=\'//cdn.jsdelivr.net/gh/Kevnz/stats.js/build/stats.min.js\';document.head.appendChild(script);})()\n\n\n\n\n\n\n\n\nvar Home2App = /*#__PURE__*/function () {\n  function Home2App(obj) {\n    Home2App_classCallCheck(this, Home2App);\n\n    //console.log("(Home2App.CONSTRUCTORA)!!", obj) \n    this.hw_renderer = obj.renderer; // Rederer/pagina de HighWay. No confundir con el render/renderer de Three.js\n\n    this.$container = obj.domElement; //--\n\n    this.$services = this.hw_renderer.$services;\n    this.$inner = document.querySelector(\'.inner\'); //--\n\n    this.width = this.$container.offsetWidth;\n    this.height = this.$container.offsetHeight; //--\n\n    this.refResolution = 1920;\n    this.responsiveScale = this.width / this.refResolution; //--\n\n    this.cameraDistance = 500; //--\n\n    this.settings = {\n      scroll_lastInnerY: 0,\n      // Ultima posición del elemento de referencia\n      scroll_delta: 0,\n      // Incremento de pixels del scroll\n      scroll_limitedDelta: 0,\n      // Limita los valores a -20 -> +20\n      scroll_normalizedDelta: 0,\n      // Pasa el delta a -1 -> +1\n      scroll_factordDelta: 1,\n      // Valores absolutos de 0 -> 1\n      scroll_direction: 1 // Direccion del delta. 1 si está parado\n\n    }; //--\n    // Scene\n\n    this.scene = new three_module/* Scene */.xsS(); //--\n    // Camera\n    //PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )\n\n    this.camera = new three_module/* PerspectiveCamera */.cPb(30, this.width / this.height, 0.1, 2000);\n    this.camera.position.z = this.cameraDistance;\n    this.camera.fov = 2 * Math.atan(this.height / 2 / this.cameraDistance) * (180 / Math.PI); //--\n    // Renderer\n\n    this.renderer = new three_module/* WebGL1Renderer */.b5g({\n      antialias: true,\n      alpha: true,\n      transparent: true\n    });\n    this.renderer.autoClear = false; // Vamos a usar 2 scenas (una para el background y otra para los puntos) que implicarán usar 2 acciones de render. Con autoclear false permitimos que la segunda no borre la primera.\n    //console.log("window.devicePixelRatio (original): "+window.devicePixelRatio)\n\n    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1)); //console.log("window.devicePixelRatio (filtrado): "+window.devicePixelRatio)\n    //console.log("WebGL2?: "+this.renderer.capabilities.isWebGL2)\n    //--\n    //this.controls = new OrbitControls( this.camera, this.renderer.domElement );\n    // this.controls.addEventListener(\'change\', (e) =>{\n    //     this.onCameraPositionChange(e)\n    // });\n    //--\n\n    this.$container.appendChild(this.renderer.domElement); //--\n    // this.background = new Home2App_background({\n    //     worldGL:this,\n    // })\n    //--\n\n    this.dots = new home2_Home2Dots({\n      worldGL: this\n    }); //--\n\n    this._resize(); //this._render();\n    //this._init_scrollListeners()\n\n  } //---------------------------\n  // PUBLICAS:\n\n\n  Home2App_createClass(Home2App, [{\n    key: "init",\n    value: function init() {\n      this._init_scrollListeners();\n\n      this._render();\n    }\n  }, {\n    key: "kill",\n    value: function kill() {\n      //console.log("(Solutions1App.kill)!") \n      this.trigger.kill();\n      node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this._binded_render);\n      node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this._binded_eval_scroll);\n      this.dots = null;\n    } //---------------------------\n\n  }, {\n    key: "onResize",\n    value: function onResize() {\n      //console.log("(Home1App.onResize)!")\n      this._resize();\n    } //---------------------------\n    // PRIVADAS:\n\n  }, {\n    key: "_init_scrollListeners",\n    value: function _init_scrollListeners() {\n      var _this = this;\n\n      var binded_render = function binded_render() {\n        _this._render();\n      };\n\n      var binded_eval_scroll = function binded_eval_scroll() {\n        _this._eval_scroll(_this.trigger.progress);\n      };\n\n      this._binded_render = binded_render;\n      this._binded_eval_scroll = binded_eval_scroll;\n      this.trigger = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$services,\n        start: \'top bottom\',\n        end: \'bottom top\',\n        scrub: true,\n        // Scrub: Genera eventos en una franja mas que en un punto.\n        // markers: true,\n        onToggle: function onToggle(self) {\n          if (self.isActive) {\n            node_modules_gsap/* default.ticker.add */.ZP.ticker.add(binded_render);\n            node_modules_gsap/* default.ticker.add */.ZP.ticker.add(binded_eval_scroll);\n          } else {\n            node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(binded_render);\n            node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(binded_eval_scroll);\n          }\n        }\n      });\n    }\n  }, {\n    key: "_eval_scroll",\n    value: function _eval_scroll(progress) {\n      var innerData = this.$inner.getBoundingClientRect();\n      var newInnerY = innerData.y;\n      this.settings.scroll_delta = newInnerY - this.settings.scroll_lastInnerY;\n      this.settings.scroll_lastInnerY = newInnerY;\n      this.settings.scroll_limitedDelta = webgl_WebGLUtils.clamp(this.settings.scroll_delta, -20, 20); // Limita los valores a -20 -> +20\n\n      this.settings.scroll_normalizedDelta = (this.settings.scroll_limitedDelta / 20).toFixed(3); // Pasa el delta a -1 -> +1\n\n      this.settings.scroll_factordDelta = Math.abs(this.settings.scroll_normalizedDelta) + 0; // Valores absolutos de 0 -> 1\n\n      this.settings.scroll_direction = 1;\n\n      if (this.settings.scroll_normalizedDelta < 0) {\n        this.settings.scroll_direction = -1;\n      } // console.log("this.settings.scroll_normalizedDelta: "+this.settings.scroll_normalizedDelta)\n      //console.log("this.settings.scroll_factordDelta: "+this.settings.scroll_factordDelta)\n\n    }\n  }, {\n    key: "_resize",\n    value: function _resize() {\n      //console.log("(Home2App.resize)!")\n      this.width = this.$container.offsetWidth;\n      this.height = this.$container.offsetHeight;\n      this.responsiveScale = this.width / this.refResolution;\n      this.renderer.setSize(this.width, this.height);\n      this.camera.aspect = this.width / this.height;\n      this.cameraDistance = this.camera.position.z;\n      this.camera.fov = 2 * Math.atan(this.height / 2 / this.cameraDistance) * (180 / Math.PI); //--\n\n      this.camera.updateProjectionMatrix(); //--\n\n      if (this.dots) {\n        this.dots.resize(this.width, this.height);\n      }\n    }\n  }, {\n    key: "_render",\n    value: function _render() {\n      //console.log("(Home2App._render)!")\n      if (this.height != this.$container.offsetHeight) {\n        this._resize();\n      }\n\n      if (this.dots) {\n        this.dots.render();\n      }\n\n      this.renderer.render(this.scene, this.camera); //requestAnimationFrame(this._render.bind(this))\n    }\n  }]);\n\n  return Home2App;\n}();\n\n/* harmony default export */ const home2_Home2App = (Home2App);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home3/Home3Geometry.js\nfunction Home3Geometry_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Home3Geometry_typeof = function _typeof(obj) { return typeof obj; }; } else { Home3Geometry_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Home3Geometry_typeof(obj); }\n\nfunction Home3Geometry_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home3Geometry_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home3Geometry_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home3Geometry_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home3Geometry_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Home3Geometry_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Home3Geometry_setPrototypeOf(subClass, superClass); }\n\nfunction Home3Geometry_setPrototypeOf(o, p) { Home3Geometry_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Home3Geometry_setPrototypeOf(o, p); }\n\nfunction Home3Geometry_createSuper(Derived) { var hasNativeReflectConstruct = Home3Geometry_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Home3Geometry_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Home3Geometry_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Home3Geometry_possibleConstructorReturn(this, result); }; }\n\nfunction Home3Geometry_possibleConstructorReturn(self, call) { if (call && (Home3Geometry_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Home3Geometry_assertThisInitialized(self); }\n\nfunction Home3Geometry_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Home3Geometry_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Home3Geometry_getPrototypeOf(o) { Home3Geometry_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Home3Geometry_getPrototypeOf(o); }\n\n//import * as THREE from "three"\n//import gsap from "gsap"\n//import {GLTFLoader, GLTLoader} from "three/examples/jsm/loaders/GLTFLoader"\nvar Home3Geometry_EventEmitter = __webpack_require__(7187);\n\nvar Home3Geometry = /*#__PURE__*/function (_EventEmitter) {\n  Home3Geometry_inherits(Home3Geometry, _EventEmitter);\n\n  var _super = Home3Geometry_createSuper(Home3Geometry);\n\n  function Home3Geometry(obj) {\n    var _this;\n\n    Home3Geometry_classCallCheck(this, Home3Geometry);\n\n    //console.log("(Home3Geometry.CONSTRUCTORA)!")\n    _this = _super.call(this); //--\n\n    _this.factor = obj.factor; //6\n\n    _this.incr_radio = obj.incr_radio; //25\n\n    _this.numOrbits = obj.numOrbits; //37\n\n    _this.array_triangular = obj.array_triangular;\n    _this.array_dotPos = obj.array_dotPos;\n    _this.numDots = obj.numDots; //--\n\n    _this.arrayColores_RGB = [];\n    _this.arrayColores_RGB_01 = [];\n    _this.colorPos = 0;\n\n    _this._init_colors(); //--\n\n\n    _this.attributes = {\n      a_posiciones: new Float32Array(_this.numDots * 3),\n      a_color: new Float32Array(_this.numDots * 3),\n      a_orbital: new Float32Array(_this.numDots * 1),\n      a_pos_orbita: new Float32Array(_this.numDots * 1),\n      a_incr_anguloRad: new Float32Array(_this.numDots * 1),\n      a_anguloRad: new Float32Array(_this.numDots * 1),\n      a_radio: new Float32Array(_this.numDots * 1),\n      a_dir: new Float32Array(_this.numDots * 1),\n      a_incr: new Float32Array(_this.numDots * 1),\n      a_x: new Float32Array(_this.numDots * 1),\n      a_y: new Float32Array(_this.numDots * 1),\n      a_z: new Float32Array(_this.numDots * 1)\n    }; //--\n\n    for (var i = 0; i < _this.array_dotPos.length; i++) {\n      var dotPos = _this.array_dotPos[i];\n\n      var dot = _this._get_dot(dotPos);\n\n      var i3 = i * 3;\n      _this.attributes.a_posiciones[i3] = dot.x;\n      _this.attributes.a_posiciones[i3 + 1] = dot.y;\n      _this.attributes.a_posiciones[i3 + 2] = dot.z; //--\n\n      _this.attributes.a_color[i3] = dot.color[0];\n      _this.attributes.a_color[i3 + 1] = dot.color[1];\n      _this.attributes.a_color[i3 + 2] = dot.color[2]; //--\n\n      _this.attributes.a_orbital[i] = dot.orbital;\n      _this.attributes.a_pos_orbita[i] = dot.pos_orbita;\n      _this.attributes.a_incr_anguloRad[i] = dot.incr_anguloRad;\n      _this.attributes.a_anguloRad[i] = dot.anguloRad;\n      _this.attributes.a_radio[i] = dot.radio;\n      _this.attributes.a_dir[i] = dot.dir;\n      _this.attributes.a_incr[i] = dot.incr;\n      _this.attributes.a_x[i] = dot.y;\n      _this.attributes.a_y[i] = dot.y;\n      _this.attributes.a_z[i] = dot.z;\n    } //--\n\n\n    _this.loaded = false;\n    return _this;\n  } //------------------------------------------\n  // PRIVADAS\n\n\n  Home3Geometry_createClass(Home3Geometry, [{\n    key: "_get_dot",\n    value: function _get_dot(num) {\n      // Devuelve un objeto con la información de un punto de la geometria "orbital MIOTI"\n      var obj = {\n        num: num,\n        color: this._get_color(),\n        x: 0,\n        y: 0,\n        z: 0,\n        orbital: 0,\n        co_orbitantes: 0,\n        pos_orbita: 0,\n        incr_anguloRad: 0,\n        anguloRad: 0,\n        radio: 0\n      }; //--\n\n      for (var i = 0; i <= this.array_triangular.length; i++) {\n        var limSup = this.array_triangular[i]; //console.log("limSup: "+limSup)\n\n        if (num > limSup) {\n          // console.log("*")\n          obj.orbital = i + 1;\n          obj.co_orbitantes = (i + 1) * this.factor;\n          obj.pos_orbita = num - limSup - 1;\n          obj.incr_anguloRad = 2 * Math.PI / obj.co_orbitantes;\n\n          if (obj.orbital % 2 == 0) {\n            obj.dir = 1;\n            obj.incr = 0;\n            obj.anguloRad = obj.pos_orbita * obj.incr_anguloRad;\n          } else {\n            obj.dir = -1;\n            obj.incr = 1;\n            obj.anguloRad = obj.pos_orbita * obj.incr_anguloRad + obj.incr_anguloRad / 2;\n          }\n\n          obj.radio = obj.orbital * this.incr_radio; //--\n\n          obj.x = Math.cos(obj.anguloRad) * obj.radio;\n          obj.y = Math.sin(obj.anguloRad) * obj.radio;\n          obj.z = 0;\n        } //break\n\n      }\n\n      return obj;\n    }\n  }, {\n    key: "_get_color",\n    value: function _get_color() {\n      var color_RGB_01 = this.arrayColores_RGB_01[this.colorPos];\n      this.colorPos++;\n\n      if (this.colorPos > this.arrayColores_RGB_01.length - 1) {\n        this.colorPos = 0;\n      }\n\n      return color_RGB_01;\n    }\n  }, {\n    key: "_init_colors",\n    value: function _init_colors() {\n      this.arrayColores_RGB = [];\n      this.arrayColores_RGB.push([232, 67, 131]);\n      this.arrayColores_RGB.push([0, 126, 255]);\n      this.arrayColores_RGB_01 = [];\n\n      for (var i = 0; i < this.arrayColores_RGB.length; i++) {\n        var color_RGB = this.arrayColores_RGB[i];\n        var color_RGB_01 = [color_RGB[0] / 255, color_RGB[1] / 255, color_RGB[2] / 255];\n        this.arrayColores_RGB_01.push(color_RGB_01);\n      }\n    }\n  }]);\n\n  return Home3Geometry;\n}(Home3Geometry_EventEmitter);\n\n/* harmony default export */ const home3_Home3Geometry = (Home3Geometry);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home3/shaders/home3_dots_vertex.glsl\n/* harmony default export */ const home3_dots_vertex = ("#define GLSLIFY 1\\nattribute vec3 a_randomness;\\nattribute vec3 a_geo1_position;\\nattribute vec3 a_geo1_color;\\nattribute float a_geo1_anguloRad;\\nattribute float a_geo1_orbital;\\nattribute float a_geo1_pos_orbita;\\nattribute float a_geo1_incr_anguloRad;\\nattribute float a_geo1_incr;\\nattribute float a_geo1_dir;\\nattribute float a_geo1_radio;\\n\\nuniform float uCamaraDistance;\\nuniform float uTime;\\nuniform float uResponsiveScale;\\nuniform float uScrollDelta;\\nuniform float uRotation1;\\nuniform float uRotation2;\\nuniform float uRotation3;\\n\\nuniform float uChangeAnim;\\nuniform float uChangeProgress;\\n\\nuniform vec3 uPrevColor;\\nuniform vec3 uNextColor;\\n\\nvarying float v_angleRad;\\nvarying float v_colorPosition;\\nvarying float v_pulseStrengthNorm1;\\nvarying float v_pulseStrengthNorm2;\\n\\nvarying vec3 v_prevColor;\\nvarying vec3 v_nextColor;\\n\\n#define PI 3.1415926538\\n\\nvec3 get_pos1(float anguloRad){\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(1.*a_geo1_dir*0.2);\\n    float x = cos(anguloRad)*a_geo1_radio;\\n    float y = sin(anguloRad)*a_geo1_radio;\\n    float z = 0.0;\\n    vec3 newPos = vec3(x, y, z);\\n    return newPos;\\n}\\n\\nfloat get_cosTime(float time, float radius){\\n    //\\n    //float value = sin(uTime)*2.*PI;\\n    float value = sin(time)*radius;\\n    return value;\\n}\\n\\nfloat get_x(float angleRad, float radius){\\n    return cos(angleRad)*a_geo1_radio;\\n}\\n\\nfloat get_pulseStrengthNorm( float direction){\\n    float dotAguleNorm = a_geo1_anguloRad/(2.*PI); // Pasamos el angulo del punto que está en radianes a un valor de 0 a 1.\\n\\n    float modSpeed = mix(1., 2.5, 13./a_geo1_orbital)*direction;\\n    float radialSpeed = uTime*0.02*modSpeed; // Modificamos uTime para determinar la velocidad radial.\\n\\n    float pulseAngleRad = radialSpeed*(4.*PI);\\n\\n    // El valor de pulseAngleRad debe estar entre 0 y 2PI (inicio y fin de una circunferencia).\\n    // Como depende de uTime el valor saldrá de ese rango pronto por lo que tomaremos el resto (modulo),\\n    // de dividir pulseAngleRad por 2PI.\\n    if(pulseAngleRad > 2.*PI){\\n        pulseAngleRad = mod(pulseAngleRad, (2.*PI));\\n    }\\n    if(pulseAngleRad < 0.){\\n        pulseAngleRad = mod(pulseAngleRad, (2.*PI));\\n    }\\n\\n    float pulseAngleNorm = pulseAngleRad/(2.*PI); // Normalizamos el valor (de 0 a 1)\\n\\n    float distAngleNorm = abs(pulseAngleNorm-dotAguleNorm); // Calculamos la distancia radial del pulso al punto\\n\\n    // Apañamos la distancia de tal forma que no le afecte el punto de discontinuidad OPI = 2PI\\n    if(distAngleNorm > 0.5){ \\n        distAngleNorm = 0.5-(distAngleNorm-0.5);\\n    }\\n\\n    // La maxima distancia es de medio circulo y en terminos normalizados es 0.5\\n    // Creamos una variable que normalice ese valor entre 0 y 1.\\n    float pulseStrengthNorm  = distAngleNorm*2.; \\n\\n    float pico = 0.92;\\n    pico = mix(pico*0.99, pico*1.01, a_geo1_orbital/13.);\\n\\n    // Nos interesa solo el pico, la zona que va entre 0.95 y 1.\\n    // Toodo lo que haya por debajo de 0.95 lo pasamos a 0.95\\n    // y le restamos ese mismo 0.95 para quedarnos con el pico de 0.05 eol cual amplificamos x20 para normalizarlo (de 0 a 1).\\n    pulseStrengthNorm = (clamp(pulseStrengthNorm, pico, 1.)-pico)*10.;\\n    //--\\n    return pulseStrengthNorm;\\n}\\n\\nvoid main() {\\n\\n    float pulseStrengthNorm1 = get_pulseStrengthNorm(1.5);\\n    float pulseStrengthNorm2 = get_pulseStrengthNorm(-1.);\\n\\n    \\n\\n    float anguloRad_time = 0.;\\n    float changeScale = 0.5;\\n\\n    if(abs(a_geo1_orbital-12.) < 0.5){ // Detecta el orbital 14\\n        anguloRad_time = a_geo1_anguloRad+uRotation1;\\n        v_colorPosition = 1.;\\n        changeScale = 0.3;\\n    }else if(abs(a_geo1_orbital-15.) < 0.5){ // Detecta el orbital 14\\n        anguloRad_time = a_geo1_anguloRad+uRotation2;\\n        v_colorPosition = 0.;\\n        changeScale = 0.5;\\n    }else if(abs(a_geo1_orbital-18.) < 0.5){ // Detecta el orbital 17\\n        anguloRad_time = a_geo1_anguloRad+uRotation3;\\n        v_colorPosition = 1.;\\n        changeScale = 0.8;\\n    }\\n    \\n    //float anguloRad_time = a_geo1_anguloRad+(direction*sin(uTime+a_geo1_orbital)*0.2);\\n    vec3 pos1 = get_pos1(anguloRad_time);\\n    //pos1 *= 2.;\\n    //pos1 *= 1.+(uScrollDelta*0.2);\\n    pos1 *= mix(1., changeScale, uChangeAnim);\\n    pos1 *= uResponsiveScale;\\n    //vec3 pos2 = pos1*1.0;\\n    //pos1= mix(pos1, pos2, pulseStrengthNorm);\\n\\n    float obitalFactor = a_geo1_orbital/18.;\\n    if(uChangeProgress >= obitalFactor){\\n        v_nextColor = uNextColor;\\n    }else{\\n        v_nextColor = uPrevColor;\\n    }\\n\\n    // Determinamos el tamaño del punto teniendo un minimo de 5 y amplificando el maximo para que visualmente sea bonito\\n    //float size = 5.+(pulseStrengthNorm*15.*longPeriod);\\n    float size = 3.;\\n    size += (pulseStrengthNorm1*1.);\\n    size += (pulseStrengthNorm2*1.);\\n    size *= uResponsiveScale;\\n\\n    //----------------------------------------------------------\\n    // VERTEX\\n    vec4 mvPosition = modelViewMatrix * vec4( pos1, 1.0 );\\n    gl_Position = projectionMatrix * mvPosition;\\n    gl_PointSize = size*(uCamaraDistance/-mvPosition.z);\\n    //----------------------------------------------------------\\n\\n    //--------------------------------------\\n    // VARYINGS:\\n    v_angleRad = anguloRad_time;\\n    v_pulseStrengthNorm1 = pulseStrengthNorm1; \\n    v_pulseStrengthNorm2 = pulseStrengthNorm2; \\n\\n    //v_prevColor = uPrevColor;\\n    //v_nextColor = uNextColor;\\n\\n}\\n\\n");\n;// CONCATENATED MODULE: ./app/src/js/webgl/home3/shaders/home3_dots_fragment.glsl\n/* harmony default export */ const home3_dots_fragment = ("#define GLSLIFY 1\\nuniform vec3 uColor1;\\nuniform vec3 uColor2;\\n\\nvarying float v_angleRad;\\nvarying float v_colorPosition;\\nvarying float v_pulseStrengthNorm1;\\nvarying float v_pulseStrengthNorm2;\\n\\nvarying vec3 v_prevColor;\\nvarying vec3 v_nextColor;\\n\\n#define PI 3.1415926538\\n\\nfloat circulizar(float radio){\\n    // radio es un valor entre 0 y 1. 0 es 0 de radio y 1 es el maximo del radio dentro de\\n    radio = 1.0-(0.5*radio);\\n    float result = distance(gl_PointCoord, vec2(0.5, 0.5));\\n    result = 1. -result;\\n    result = pow(result, 1.);\\n    result = step(radio, result);\\n    return result;\\n}\\n\\nvoid main() {\\n    float alpha = circulizar(1.0);\\n    //vec3 finalColor = mix(uColor1, uColor2, v_colorPosition);\\n    vec3 finalColor = v_nextColor;\\n\\n    gl_FragColor = vec4(finalColor, alpha*0.8);\\n}");\n;// CONCATENATED MODULE: ./app/src/js/webgl/home3/Home3Dots.js\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Home3Dots_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home3Dots_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home3Dots_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home3Dots_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home3Dots_defineProperties(Constructor, staticProps); return Constructor; }\n\n //import gsap from "gsap"\n\n\n\n\n\n\n\n\nvar Home3Dots = /*#__PURE__*/function () {\n  function Home3Dots(obj) {\n    var _this = this;\n\n    Home3Dots_classCallCheck(this, Home3Dots);\n\n    //console.log("(Home3Dots.CONSTRUCTORA)!")\n    //console.log(obj)\n    this.worldGL = obj.worldGL; //--\n\n    this.scene = this.worldGL.scene;\n    this.cameraDistance = this.worldGL.cameraDistance; //--\n\n    this.material = null;\n    this.geometry = null;\n    this.mesh = null;\n    this.numParticles = null;\n    this.created = false;\n    this.clock = new three_module/* Clock */.SUY(); //--\n\n    this.changeAnim_fase = 0; // 0: idle 1,Out, 2:In\n\n    this.changeAnim_duration = null;\n    this.eventProgress_changeAnim_OUT = new webgl_EventProgress("OUT");\n    this.eventProgress_changeAnim_OUT.emitter.on("onProgressFinished", function () {\n      _this._faseOutEnded();\n    });\n    this.eventProgress_changeAnim_IN = new webgl_EventProgress("IN");\n    this.eventProgress_changeAnim_IN.emitter.on("onProgressFinished", function () {\n      _this._faseInEnded();\n    }); //--\n\n    this.eased_scrollDelta = new webgl_EasedOutValue(this.worldGL.settings.scroll_normalizedDelta * 0.5, 0.01);\n    this.eeased_scrollDelta_fast = new webgl_EasedOutValue(this.worldGL.settings.scroll_normalizedDelta * 0.5, 0.1); //--\n\n    this._setup_settings(); //--\n\n\n    this.orbital_geometry = new home3_Home3Geometry(this.settings); //--\n    //--\n    //this._createcube(this.scene)\n\n    this._create();\n\n    this.resize();\n  } //------------------------------------\n  // PUBLICAS: \n\n\n  Home3Dots_createClass(Home3Dots, [{\n    key: "doChangeAnim",\n    value: function doChangeAnim(obj) {\n      // console.log("(Home3Dots.doChangeAnim): ", obj)\n      this.changeAnim_duration = obj.duration * 0.9;\n      var t;\n\n      if (this.changeAnim_fase == 0) {\n        // Pilla en estado idel.\n        t = 0;\n      } else if (this.changeAnim_fase == 1) {\n        // Corta la animación de out\n        t = this.eventProgress_changeAnim_OUT.get_t();\n      } else if (this.changeAnim_fase == 2) {\n        // Corta la animación de in\n        //t = this.eventProgress_changeAnim_IN.get_t()\n        t = 1 - this.eventProgress_changeAnim_IN.get_progress();\n      } //console.log("t: "+t)\n\n\n      this.settings.prevColor = _toConsumableArray(this.settings.nextColor);\n      this.settings.nextColor = obj.color.split(",");\n      this.settings.nextColor[0] = this.settings.nextColor[0] / 255;\n      this.settings.nextColor[1] = this.settings.nextColor[1] / 255;\n      this.settings.nextColor[2] = this.settings.nextColor[2] / 255; //console.log("color: "+this.settings.nextColor)\n\n      this._startChangeAnim(t);\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      if (this.created) {\n        this.material.uniforms.uTime.value = this.clock.getElapsedTime();\n        this.material.uniforms.uCamaraDistance.value = this.worldGL.cameraDistance;\n        this.material.uniforms.uResponsiveScale.value = this.worldGL.responsiveScale;\n        this.material.uniforms.uScrollDelta.value = -this.eeased_scrollDelta_fast.get(this.worldGL.settings.scroll_normalizedDelta * 0.5); //--\n\n        var extraSpeed = 1 + Math.abs(this.eeased_scrollDelta_fast.get(this.worldGL.settings.scroll_normalizedDelta * 0.5) * 10);\n        this.settings.rotation1 += this.settings.speedRotation1 * extraSpeed;\n        this.settings.rotation2 += this.settings.speedRotation2 * extraSpeed;\n        this.settings.rotation3 += this.settings.speedRotation3 * extraSpeed;\n        this.material.uniforms.uRotation1.value = this.settings.rotation1;\n        this.material.uniforms.uRotation2.value = -this.settings.rotation2;\n        this.material.uniforms.uRotation3.value = this.settings.rotation3; //--\n\n        this.material.uniforms.uPrevColor.value = new three_module/* Color */.Ilk(this.settings.prevColor[0], this.settings.prevColor[1], this.settings.prevColor[2]);\n        this.material.uniforms.uNextColor.value = new three_module/* Color */.Ilk(this.settings.nextColor[0], this.settings.nextColor[1], this.settings.nextColor[2]); //--\n\n        if (this.eventProgress_changeAnim_IN != null) {\n          var changeAnim;\n          var changeProgress;\n\n          if (this.changeAnim_fase == 0) {\n            changeAnim = 0;\n            changeProgress = 1; //console.log("0: "+changeAnim)\n          } else if (this.changeAnim_fase == 1) {\n            changeAnim = this.eventProgress_changeAnim_OUT.get_progress();\n            changeProgress = changeAnim * 0.5; //const t = this.eventProgress_changeAnim_OUT.get_t()\n            //console.log("changeAnim: "+changeAnim)\n            //console.log("changeProgress: "+changeProgress)\n          } else if (this.changeAnim_fase == 2) {\n            changeAnim = 1 - this.eventProgress_changeAnim_IN.get_progress();\n            changeProgress = 0.5 + this.eventProgress_changeAnim_IN.get_progress() * 0.5; //const t = this.eventProgress_changeAnim_IN.get_t()\n            // console.log("2: "+changeAnim+" t:"+t)\n            // console.log("changeProgress: "+changeProgress)\n          } //console.log("changeProgress: "+changeProgress)\n\n\n          this.material.uniforms.uChangeAnim.value = changeAnim;\n          this.material.uniforms.uChangeProgress.value = changeProgress;\n        }\n      }\n    }\n  }, {\n    key: "resize",\n    value: function resize(newWidth, newHeight) {\n      //console.log("(Home3Dots.resize)!")\n      if (this.mesh) {//this.mesh.position.setX(this.worldGL.width/2)\n      }\n    } //------------------------------------\n    // PRIVADAS: \n\n  }, {\n    key: "_startChangeAnim",\n    value: function _startChangeAnim(starting_t) {\n      //console.log("(Home3Dots._startChangeAnim): "+starting_t+"----------------------------------------------")\n      this.changeAnim_fase = 1;\n      this.eventProgress_changeAnim_OUT.stop();\n      this.eventProgress_changeAnim_IN.stop(); //--\n\n      var easeFunc;\n\n      if (starting_t == 0) {\n        easeFunc = (easing_functions_default()).Exponential.InOut;\n      } else {\n        easeFunc = (easing_functions_default()).Exponential.InOut; //easeFunc = Easing.Linear.None\n      }\n\n      this.eventProgress_changeAnim_OUT.start(this.changeAnim_duration, starting_t, easeFunc, 0);\n    }\n  }, {\n    key: "_faseOutEnded",\n    value: function _faseOutEnded() {\n      //console.log("(Home3Dots._faseOutEnded)!----------------------------------------------")\n      this.changeAnim_fase = 2;\n      this.eventProgress_changeAnim_IN.start(this.changeAnim_duration, 0, (easing_functions_default()).Quadratic.InOut, 0);\n    }\n  }, {\n    key: "_faseInEnded",\n    value: function _faseInEnded() {\n      //console.log("(Home3Dots._faseInEnded)!----------------------------------------------")\n      this.changeAnim_fase = 0;\n    }\n  }, {\n    key: "_setup_settings",\n    value: function _setup_settings() {\n      //console.log("(Home3Dots._setup_settings)!")\n      var speedBase = 0.002;\n      this.settings = {\n        factor: 6,\n        incr_radio: 25,\n        numOrbits: 26,\n        arrayOrbits: [12, 15, 18],\n        rotation1: 0,\n        speedRotation1: 3 * speedBase,\n        rotation2: 2,\n        speedRotation2: 2 * speedBase,\n        rotation3: 0,\n        speedRotation3: 1 * speedBase,\n        prevColor: [0.909, 0.262, 0.443],\n        nextColor: [0.909, 0.262, 0.443]\n      };\n      this.settings.array_triangular = this._get_array_triangular(this.settings.factor, this.settings.numOrbits);\n      this.settings.array_triangular_dots_x_orbita = this._get_array_triangular_dots_x_orbita(this.settings.array_triangular, this.settings.arrayOrbits);\n      this.settings.array_dotPos = this._get_array_dotPos(this.settings.arrayOrbits, this.settings.array_triangular, this.settings.array_triangular_dots_x_orbita);\n      this.settings.numDots = this.settings.array_dotPos.length; //this.settings.numDots = this.settings.array_triangular[this.settings.array_triangular.length-1]\n      //console.log("this.settings.array_triangular: "+this.settings.array_triangular)\n      //console.log("this.settings.array_triangular_dots_x_orbita: "+this.settings.array_triangular_dots_x_orbita)\n      //console.log("this.settings.numDots: "+this.settings.numDots)\n      //console.log("this.settings.arrayOrbits: "+this.settings.arrayOrbits)\n      //console.log("this.settings.array_dotPos: "+this.settings.array_dotPos)\n      //console.log("this.settings.array_dotPos.length: "+this.settings.array_dotPos.length)\n    }\n  }, {\n    key: "_create",\n    value: function _create() {\n      //console.log("(Home3Dots._create)!")\n      //--\n      this.material = new three_module/* ShaderMaterial */.jyz({\n        depthWrite: false,\n        //blending: THREE.AdditiveBlending,\n        vertexColors: true,\n        vertexShader: home3_dots_vertex,\n        fragmentShader: home3_dots_fragment,\n        transparent: true,\n        uniforms: {\n          uColor1: {\n            value: new three_module/* Color */.Ilk(0x333333)\n          },\n          uColor2: {\n            value: new three_module/* Color */.Ilk(0x999999)\n          },\n          uCamaraDistance: {\n            value: this.worldGL.cameraDistance\n          },\n          uTime: {\n            value: 0\n          },\n          uScrollDelta: {\n            value: 0\n          },\n          uResponsiveScale: {\n            value: 1\n          },\n          uRotation1: {\n            value: 0\n          },\n          uRotation2: {\n            value: 0\n          },\n          uRotation3: {\n            value: 0\n          },\n          uChangeAnim: {\n            value: 0\n          },\n          uChangeProgress: {\n            value: 0\n          },\n          uPrevColor: {\n            value: new three_module/* Color */.Ilk(0x333333)\n          },\n          uNextColor: {\n            value: new three_module/* Color */.Ilk(0x333333)\n          }\n        }\n      }); //--\n      //console.log(this.orbital_geometry.attributes.a_color)\n      //--\n\n      this.geometry = new three_module/* BufferGeometry */.u9r();\n      this.geometry.setAttribute(\'position\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_geo1_position\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_geo1_color\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_color, 3));\n      this.geometry.setAttribute(\'a_geo1_orbital\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_orbital, 1));\n      this.geometry.setAttribute(\'a_geo1_pos_orbita\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_pos_orbita, 1));\n      this.geometry.setAttribute(\'a_geo1_incr_anguloRad\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_incr_anguloRad, 1));\n      this.geometry.setAttribute(\'a_geo1_anguloRad\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_anguloRad, 1));\n      this.geometry.setAttribute(\'a_geo1_radio\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_radio, 1));\n      this.geometry.setAttribute(\'a_geo1_dir\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_dir, 1));\n      this.geometry.setAttribute(\'a_geo1_incr\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_incr, 1));\n      this.geometry.setAttribute(\'a_geo1_x\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_x, 1));\n      this.geometry.setAttribute(\'a_geo1_y\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_y, 1));\n      this.geometry.setAttribute(\'a_geo1_z\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_z, 1));\n      this.mesh = new three_module/* Points */.woe(this.geometry, this.material);\n      this.scene.add(this.mesh); //---------\n\n      /*\n      this.material2 = new THREE.ShaderMaterial({\n          depthWrite: false,\n          blending: THREE.AdditiveBlending,\n          vertexColors: true,\n          vertexShader: vertex_bg, \n          fragmentShader: fragment_bg,\n          transparent: true,\n          uniforms: {\n              uCamaraDistance: {value: this.worldGL.cameraDistance},\n              uTime: {value: 0},\n              uScale:{value: 1.5}\n          }\n      })\n      this.mesh2 = new THREE.Points(this.geometry, this.material2)\n      this.mesh2.position.z =-1\n      this.scene.add(this.mesh2)\n      */\n      //---------\n\n      this.created = true;\n    }\n  }, {\n    key: "_get_array_dotPos",\n    value: function _get_array_dotPos(_arrayOrbits, _array_triangular, _array_triangular_dots_x_orbita) {\n      var miArray = [];\n\n      for (var i = 0; i < _arrayOrbits.length; i++) {\n        var orbitNum = _arrayOrbits[i];\n        var dots_x_orbit = _array_triangular_dots_x_orbita[i];\n        var dotNum_base = _array_triangular[_arrayOrbits[i] - 1]; // console.log("orbitNum: "+orbitNum)\n        // console.log("dots_x_orbit: "+dots_x_orbit)\n        // console.log("dotNum_base: "+dotNum_base)\n\n        for (var j = 0; j < dots_x_orbit; j++) {\n          miArray.push(dotNum_base + j + 1);\n        }\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_get_numDots",\n    value: function _get_numDots(_array_triangular_dots_x_orbita) {\n      var numDots = 0;\n\n      for (var i = 0; i <= _array_triangular_dots_x_orbita.length - 1; i++) {\n        numDots += _array_triangular_dots_x_orbita[i];\n      }\n\n      return numDots;\n    }\n  }, {\n    key: "_get_array_triangular_dots_x_orbita",\n    value: function _get_array_triangular_dots_x_orbita(_array_triangular, _arrayOrbits) {\n      // Genera una array basada en la progresión triangular (* factor).\n      // ... donde se indica el numero de dots por orbital\n      // Una progresión triangular es: 1, 3, 6, 10, 15 (https://significativa.org/diccionarios/numeros-figurados/#:~:text=3.1.1.1.-,Definici%C3%B3n,anterior%20no%20obtenemos%20una%20constante.)\n      var miArray = [];\n\n      for (var i = 0; i <= _arrayOrbits.length - 1; i++) {\n        //array_numTriagulares.push(i*(i+1)/2)\n        var numDots_orbita_actual = _array_triangular[_arrayOrbits[i]];\n        var numDots_orbita_anterior = _array_triangular[_arrayOrbits[i] - 1];\n        var numDots_orbita = numDots_orbita_actual - numDots_orbita_anterior;\n        miArray.push(numDots_orbita);\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_get_array_triangular",\n    value: function _get_array_triangular(_factor, _numObits) {\n      // Genera una array de progresión triangular (* factor).\n      // Una progresión triangular es: 1, 3, 6, 10, 15 (https://significativa.org/diccionarios/numeros-figurados/#:~:text=3.1.1.1.-,Definici%C3%B3n,anterior%20no%20obtenemos%20una%20constante.)\n      var miArray = [];\n\n      for (var i = 0; i <= _numObits; i++) {\n        //array_numTriagulares.push(i*(i+1)/2)\n        miArray.push(i * (i + 1) / 2 * _factor);\n      }\n\n      return miArray;\n    }\n    /* \n    _createcube(_scene){\n        const geometry = new THREE.BoxGeometry(100,100,100);\n        const material = new THREE.MeshBasicMaterial({color: 0xff0000});\n        const cube = new THREE.Mesh(geometry,material);\n        _scene.add(cube);\n    }\n    */\n    //---------------------------------------------------------\n    //---------------------------------------------------------\n\n  }]);\n\n  return Home3Dots;\n}();\n\n/* harmony default export */ const home3_Home3Dots = (Home3Dots);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home3/Home3App.js\nfunction Home3App_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home3App_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home3App_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home3App_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home3App_defineProperties(Constructor, staticProps); return Constructor; }\n\n// FPS-Meter:\n//(function(){var script=document.createElement(\'script\');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src=\'//cdn.jsdelivr.net/gh/Kevnz/stats.js/build/stats.min.js\';document.head.appendChild(script);})()\n\n\n\n\n\n\n\n\nvar Home3App = /*#__PURE__*/function () {\n  function Home3App(obj) {\n    Home3App_classCallCheck(this, Home3App);\n\n    //console.log("(Home3App.CONSTRUCTORA)!", obj) \n    this.hw_renderer = obj.renderer; // Rederer/pagina de HighWay. No confundir con el render/renderer de Three.js\n\n    this.$container = obj.domElement;\n    this.dotColor = obj.dotColor; //this.sliderRef = obj.sliderRef\n    //--\n    //this.sliderRef.emitter.on("onSliderChange", (obj)=>{\n    //    this.onSliderChange(obj)\n    //})\n    //--\n\n    this.REF_RESOLUTION = {\n      width: 1920,\n      height: 947\n    };\n    this.REF_CAMERA_DISTANCE = 500; //--\n\n    this.width = this.$container.offsetWidth;\n    this.height = this.$container.offsetHeight;\n    this.responsiveScale = this.width / this.REF_RESOLUTION.width;\n    this.cameraDistance = this.REF_CAMERA_DISTANCE * (this.height / this.REF_RESOLUTION.height); //--\n\n    this.$main = document.querySelector(\'.inner\');\n    this.$hero = document.querySelector(\'.hero\');\n    this.$footer = document.querySelector(\'.footer\');\n    this.$image = document.querySelector(\'.ai__hero .image\'); //--\n    //this.MAIN_ACTIVE = false\n    //--\n\n    this.mouseNorm = {\n      x: 0,\n      y: 0\n    }; //--\n\n    this.settings = {\n      scroll_lastInnerY: 0,\n      // Ultima posición del elemento de referencia\n      scroll_delta: 0,\n      // Incremento de pixels del scroll\n      scroll_limitedDelta: 0,\n      // Limita los valores a -20 -> +20\n      scroll_normalizedDelta: 0,\n      // Pasa el delta a -1 -> +1\n      scroll_factordDelta: 1,\n      // Valores absolutos de 0 -> 1\n      scroll_direction: 1,\n      // Direccion del delta. 1 si está parado\n      scroll_hero_progress: 0,\n      scroll_footer_progress: 0,\n      morphingProgress: 0\n    }; //--\n    // Scene\n\n    this.scene = new three_module/* Scene */.xsS(); //this.scene.background = new THREE.Color(0x333333)\n    //--\n    // Camera\n    //PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )\n\n    this.camera = new three_module/* PerspectiveCamera */.cPb(30, this.width / this.height, 0.1, 2000);\n    this.camera.position.z = this.cameraDistance; //console.log("this.camera.fov: "+this.camera.fov)\n\n    this.camera.fov = 2 * Math.atan(this.height / 2 / this.cameraDistance) * (180 / Math.PI); //console.log("this.camera.fov: "+this.camera.fov)\n    //--\n    // Renderer\n\n    this.renderer = new three_module/* WebGL1Renderer */.b5g({\n      antialias: true,\n      alpha: true\n    });\n    this.renderer.autoClear = false; // Vamos a usar 2 scenas (una para el background y otra para los puntos) que implicarán usar 2 acciones de render. Con autoclear false permitimos que la segunda no borre la primera.\n\n    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1)); //--\n\n    this.$container.appendChild(this.renderer.domElement); //--\n    //--\n\n    this.dots = new home3_Home3Dots({\n      worldGL: this\n    }); //--\n\n    this._resize(); //this._render();\n    //this._init_scrollListeners()\n\n  } //---------------------------\n  // PUBLICAS:\n\n\n  Home3App_createClass(Home3App, [{\n    key: "init",\n    value: function init(obj) {\n      var _this = this;\n\n      this.sliderRef = obj.sliderRef; //--\n\n      this.sliderRef.emitter.on("onSliderChange", function (obj) {\n        _this.onSliderChange(obj);\n      }); //--\n\n      this._init_scrollListeners();\n\n      this._render();\n    }\n  }, {\n    key: "kill",\n    value: function kill() {\n      this.$container_scrollTrigger.kill();\n      node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this._binded_render);\n      node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this._binded_eval_scroll);\n      this.dots = null;\n    } //---------------------------\n\n  }, {\n    key: "onSliderChange",\n    value: function onSliderChange(obj) {\n      if (this.dots) {\n        this.dots.doChangeAnim(obj);\n      }\n    }\n  }, {\n    key: "onResize",\n    value: function onResize() {\n      //console.log("(Home3App.onResize)!")\n      this._resize();\n    } //---------------------------\n    // PRIVADAS:\n\n  }, {\n    key: "_init_scrollListeners",\n    value: function _init_scrollListeners() {\n      var _this2 = this;\n\n      var binded_render = function binded_render() {\n        _this2._render();\n      };\n\n      var binded_eval_scroll = function binded_eval_scroll() {\n        _this2._eval_inertia_scroll(_this2.$container_scrollTrigger.progress);\n      };\n\n      this._binded_render = binded_render;\n      this._binded_eval_scroll = binded_eval_scroll;\n      this.$container_scrollTrigger = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$container,\n        start: \'top bottom\',\n        end: \'bottom top\',\n        scrub: true,\n        // Scrub: Genera eventos en una franja mas que en un punto.\n        //markers: true,\n        onToggle: function onToggle(self) {\n          if (self.isActive) {\n            node_modules_gsap/* default.ticker.add */.ZP.ticker.add(binded_render);\n            node_modules_gsap/* default.ticker.add */.ZP.ticker.add(binded_eval_scroll);\n          } else {\n            node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(binded_render);\n            node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(binded_eval_scroll);\n          }\n        }\n      });\n    }\n  }, {\n    key: "_eval_inertia_scroll",\n    value: function _eval_inertia_scroll(progress) {\n      var innerData = this.$main.getBoundingClientRect();\n      var newInnerY = innerData.y;\n      this.settings.scroll_progress = progress;\n      this.settings.scroll_delta = newInnerY - this.settings.scroll_lastInnerY;\n      this.settings.scroll_lastInnerY = newInnerY;\n      this.settings.scroll_limitedDelta = webgl_WebGLUtils.clamp(this.settings.scroll_delta, -20, 20); // Limita los valores a -20 -> +20\n\n      this.settings.scroll_normalizedDelta = (this.settings.scroll_limitedDelta / 20).toFixed(3); // Pasa el delta a -1 -> +1\n\n      this.settings.scroll_factordDelta = Math.abs(this.settings.scroll_normalizedDelta) + 0; // Valores absolutos de 0 -> 1\n\n      this.settings.scroll_direction = 1;\n\n      if (this.settings.scroll_normalizedDelta < 0) {\n        this.settings.scroll_direction = -1;\n      }\n    }\n  }, {\n    key: "_eval_footer_scroll",\n    value: function _eval_footer_scroll(progress) {\n      //console.log("(Home3App._eval_footer_scroll): "+progress)\n      this.settings.scroll_footer_progress = progress;\n      this.settings.morphingProgress = progress;\n    }\n  }, {\n    key: "_eval_hero_scroll",\n    value: function _eval_hero_scroll(progress) {\n      //console.log("(Home3App._eval_hero_scroll): "+progress)\n      this.settings.scroll_hero_progress = progress;\n    }\n  }, {\n    key: "_resize",\n    value: function _resize() {\n      //console.log("(Home3App._resize)!")\n      this.width = this.$container.offsetWidth;\n      this.height = this.$container.offsetHeight;\n      this.responsiveScale = this.width / this.REF_RESOLUTION.width;\n      this.cameraDistance = this.REF_CAMERA_DISTANCE * (this.height / this.REF_RESOLUTION.height);\n      this.renderer.setSize(this.width, this.height);\n      this.camera.aspect = this.width / this.height;\n      this.camera.position.z = this.cameraDistance;\n      this.camera.fov = 2 * Math.atan(this.height / 2 / this.cameraDistance) * (180 / Math.PI); // console.log("this.width: "+this.width)\n      // console.log("this.height: "+this.height)\n      // console.log("this.responsiveScale: "+this.responsiveScale)\n      // console.log("this.camera.aspect: "+this.camera.aspect)\n      // console.log("this.camera.position.z: "+this.camera.position.z)\n      // console.log("this.camera.fov: "+this.camera.fov)\n      //--\n\n      this.camera.updateProjectionMatrix(); //--\n\n      if (this.background) {\n        this.background.resize(this.width, this.height);\n      }\n\n      if (this.dots) {\n        this.dots.resize(this.width, this.height);\n      }\n    }\n  }, {\n    key: "_render",\n    value: function _render() {\n      //console.log("(Home3App._render)!")\n      if (this.height != this.$container.offsetHeight) {\n        this._resize();\n      }\n\n      if (this.background) {\n        this.background.render();\n      }\n\n      if (this.dots) {\n        this.dots.render();\n      }\n\n      this.renderer.render(this.scene, this.camera); //requestAnimationFrame(this.render.bind(this))\n    }\n  }]);\n\n  return Home3App;\n}();\n\n/* harmony default export */ const home3_Home3App = (Home3App);\n// EXTERNAL MODULE: ./node_modules/three/examples/jsm/math/MeshSurfaceSampler.js\nvar MeshSurfaceSampler = __webpack_require__(441);\n// EXTERNAL MODULE: ./node_modules/three/examples/jsm/loaders/GLTFLoader.js\nvar GLTFLoader = __webpack_require__(1217);\n// EXTERNAL MODULE: ./node_modules/three/examples/jsm/loaders/DRACOLoader.js\nvar DRACOLoader = __webpack_require__(2854);\n;// CONCATENATED MODULE: ./js/LoadedGeometry.js\nfunction LoadedGeometry_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { LoadedGeometry_typeof = function _typeof(obj) { return typeof obj; }; } else { LoadedGeometry_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return LoadedGeometry_typeof(obj); }\n\nfunction LoadedGeometry_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction LoadedGeometry_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction LoadedGeometry_createClass(Constructor, protoProps, staticProps) { if (protoProps) LoadedGeometry_defineProperties(Constructor.prototype, protoProps); if (staticProps) LoadedGeometry_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction LoadedGeometry_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) LoadedGeometry_setPrototypeOf(subClass, superClass); }\n\nfunction LoadedGeometry_setPrototypeOf(o, p) { LoadedGeometry_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return LoadedGeometry_setPrototypeOf(o, p); }\n\nfunction LoadedGeometry_createSuper(Derived) { var hasNativeReflectConstruct = LoadedGeometry_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = LoadedGeometry_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = LoadedGeometry_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return LoadedGeometry_possibleConstructorReturn(this, result); }; }\n\nfunction LoadedGeometry_possibleConstructorReturn(self, call) { if (call && (LoadedGeometry_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return LoadedGeometry_assertThisInitialized(self); }\n\nfunction LoadedGeometry_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction LoadedGeometry_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction LoadedGeometry_getPrototypeOf(o) { LoadedGeometry_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return LoadedGeometry_getPrototypeOf(o); }\n\n\n\n\n\n\nvar LoadedGeometry_EventEmitter = __webpack_require__(7187);\n\nvar LoadedGeometry = /*#__PURE__*/function (_EventEmitter) {\n  LoadedGeometry_inherits(LoadedGeometry, _EventEmitter);\n\n  var _super = LoadedGeometry_createSuper(LoadedGeometry);\n\n  function LoadedGeometry(obj, settings) {\n    var _this;\n\n    LoadedGeometry_classCallCheck(this, LoadedGeometry);\n\n    //console.log("(LoadedGeometry.CONSTRUCTORA)!")\n    _this = _super.call(this); //--\n\n    _this.file = obj.file;\n    _this.id = obj.id;\n    _this.isDraco = obj.isDraco || false;\n    _this.scale = obj.scale;\n    _this.rotationY = obj.rotationY || 0; //--\n\n    _this.numDots = settings.numDots; //--\n\n    _this.mesh = null;\n    _this.sampler = null;\n    _this.attributes = {\n      a_posiciones: new Float32Array(_this.numDots * 3),\n      a_randomness: new Float32Array(_this.numDots * 3)\n    };\n    _this.loader = new GLTFLoader/* GLTFLoader */.E();\n\n    if (_this.isDraco) {\n      _this.dracoLoader = new DRACOLoader/* DRACOLoader */._();\n\n      _this.dracoLoader.setDecoderPath("./draco/");\n\n      _this.loader.setDRACOLoader(_this.dracoLoader);\n    }\n\n    _this.loaded = false; //--\n    //this.init()\n\n    return _this;\n  }\n\n  LoadedGeometry_createClass(LoadedGeometry, [{\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      //console.log("(LoadedGeometry.init)!")\n      this.loader.load(this.file, function (response) {\n        //console.log("   mesh "+this.id+" loaded!")\n        //console.log("response: ", response)\n        _this2.mesh = response.scene.children[0];\n\n        _this2.mesh.geometry.rotateY(_this2.rotationY);\n\n        _this2.sampler = new MeshSurfaceSampler/* MeshSurfaceSampler */.a(_this2.mesh).build(); //--\n\n        for (var i = 0; i < _this2.numDots; i++) {\n          var newPostion = new three_module/* Vector3 */.Pa4();\n\n          _this2.sampler.sample(newPostion);\n\n          _this2.attributes.a_posiciones.set([newPostion.x * _this2.scale, newPostion.y * _this2.scale, newPostion.z * _this2.scale], i * 3);\n\n          _this2.attributes.a_randomness.set([Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1], i * 3);\n        } //--\n\n\n        _this2.loaded = true;\n\n        _this2.emit("onMeshLoaded", {\n          ref: _this2\n        });\n      });\n    }\n  }]);\n\n  return LoadedGeometry;\n}(LoadedGeometry_EventEmitter);\n\n/* harmony default export */ const webgl_LoadedGeometry = (LoadedGeometry);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home4/Home4Geometry.js\nfunction Home4Geometry_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Home4Geometry_typeof = function _typeof(obj) { return typeof obj; }; } else { Home4Geometry_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Home4Geometry_typeof(obj); }\n\nfunction Home4Geometry_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home4Geometry_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home4Geometry_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home4Geometry_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home4Geometry_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Home4Geometry_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Home4Geometry_setPrototypeOf(subClass, superClass); }\n\nfunction Home4Geometry_setPrototypeOf(o, p) { Home4Geometry_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Home4Geometry_setPrototypeOf(o, p); }\n\nfunction Home4Geometry_createSuper(Derived) { var hasNativeReflectConstruct = Home4Geometry_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Home4Geometry_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Home4Geometry_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Home4Geometry_possibleConstructorReturn(this, result); }; }\n\nfunction Home4Geometry_possibleConstructorReturn(self, call) { if (call && (Home4Geometry_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Home4Geometry_assertThisInitialized(self); }\n\nfunction Home4Geometry_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Home4Geometry_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Home4Geometry_getPrototypeOf(o) { Home4Geometry_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Home4Geometry_getPrototypeOf(o); }\n\n//import * as THREE from "three"\n//import gsap from "gsap"\n//import {GLTFLoader, GLTLoader} from "three/examples/jsm/loaders/GLTFLoader"\nvar Home4Geometry_EventEmitter = __webpack_require__(7187);\n\nvar About1Geometry = /*#__PURE__*/function (_EventEmitter) {\n  Home4Geometry_inherits(About1Geometry, _EventEmitter);\n\n  var _super = Home4Geometry_createSuper(About1Geometry);\n\n  function About1Geometry(obj) {\n    var _this;\n\n    Home4Geometry_classCallCheck(this, About1Geometry);\n\n    //console.log("(About1Geometry.CONSTRUCTORA): ", obj)\n    _this = _super.call(this); //--\n\n    _this.factor = obj.factor; //6\n\n    _this.incr_radio = obj.incr_radio; //25\n\n    _this.numOrbits = obj.numOrbits; //37\n\n    _this.array_triangular = obj.array_triangular;\n    _this.numDots = obj.numDots; //--\n\n    _this.attributes = {\n      a_posiciones: new Float32Array(_this.numDots * 3),\n      a_dot_num: new Float32Array(_this.numDots * 1),\n      a_orbital: new Float32Array(_this.numDots * 1),\n      a_pos_orbita: new Float32Array(_this.numDots * 1),\n      a_incr_anguloRad: new Float32Array(_this.numDots * 1),\n      a_anguloRad: new Float32Array(_this.numDots * 1),\n      a_radio: new Float32Array(_this.numDots * 1),\n      a_dir: new Float32Array(_this.numDots * 1),\n      a_incr: new Float32Array(_this.numDots * 1),\n      a_x: new Float32Array(_this.numDots * 1),\n      a_y: new Float32Array(_this.numDots * 1),\n      a_z: new Float32Array(_this.numDots * 1)\n    }; //--\n\n    for (var i = 0; i < _this.numDots; i++) {\n      var dot = _this._get_dot(i);\n\n      var i3 = i * 3;\n      _this.attributes.a_posiciones[i3] = dot.x;\n      _this.attributes.a_posiciones[i3 + 1] = dot.y;\n      _this.attributes.a_posiciones[i3 + 2] = dot.z; //--\n\n      _this.attributes.a_dot_num[i] = i;\n      _this.attributes.a_orbital[i] = dot.orbital;\n      _this.attributes.a_pos_orbita[i] = dot.pos_orbita;\n      _this.attributes.a_incr_anguloRad[i] = dot.incr_anguloRad;\n      _this.attributes.a_anguloRad[i] = dot.anguloRad;\n      _this.attributes.a_radio[i] = dot.radio;\n      _this.attributes.a_dir[i] = dot.dir;\n      _this.attributes.a_incr[i] = dot.incr;\n      _this.attributes.a_x[i] = dot.y;\n      _this.attributes.a_y[i] = dot.y;\n      _this.attributes.a_z[i] = dot.z;\n    } //--\n\n\n    _this.loaded = false; //console.log(this.attributes.a_dot_num)\n\n    return _this;\n  }\n\n  Home4Geometry_createClass(About1Geometry, [{\n    key: "init",\n    value: function init() {\n      //console.log("(About1Geometry.init)!")\n      //--\n      //--\n      this.emit("onMeshLoaded", {\n        ref: this\n      });\n    } //------------------------------------------\n    // PRIVADAS\n\n  }, {\n    key: "_get_dot",\n    value: function _get_dot(num) {\n      // Devuelve un objeto con la informaciín de un punto de la geometria "orbital MIOTI"\n      var obj = {\n        num: num,\n        x: 0,\n        y: 0,\n        z: 0,\n        orbital: 0,\n        co_orbitantes: 0,\n        pos_orbita: 0,\n        incr_anguloRad: 0,\n        anguloRad: 0,\n        radio: 0\n      }; //--\n\n      for (var i = 0; i <= this.array_triangular.length; i++) {\n        var limSup = this.array_triangular[i]; //console.log("limSup: "+limSup)\n\n        if (num > limSup) {\n          // console.log("*")\n          obj.orbital = i + 1;\n          obj.co_orbitantes = (i + 1) * this.factor;\n          obj.pos_orbita = num - limSup - 1;\n          obj.incr_anguloRad = 2 * Math.PI / obj.co_orbitantes;\n\n          if (obj.orbital % 2 == 0) {\n            obj.dir = 1;\n            obj.incr = 0;\n            obj.anguloRad = obj.pos_orbita * obj.incr_anguloRad;\n          } else {\n            obj.dir = -1;\n            obj.incr = 1;\n            obj.anguloRad = obj.pos_orbita * obj.incr_anguloRad + obj.incr_anguloRad / 2;\n          }\n\n          obj.radio = obj.orbital * this.incr_radio; //--\n\n          obj.x = Math.cos(obj.anguloRad) * obj.radio;\n          obj.y = Math.sin(obj.anguloRad) * obj.radio;\n          obj.z = 0;\n        } //break\n\n      }\n\n      return obj;\n    }\n  }]);\n\n  return About1Geometry;\n}(Home4Geometry_EventEmitter);\n\n/* harmony default export */ const Home4Geometry = (About1Geometry);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home4/shaders/home4_dots_vertex.glsl\n/* harmony default export */ const home4_dots_vertex = ("#define GLSLIFY 1\\nattribute vec3 a_randomness;\\nattribute vec3 a_geo1_position;\\nattribute float a_geo1_dot_num;\\nattribute float a_geo1_orbital;\\nattribute float a_geo1_pos_orbita;\\nattribute float a_geo1_incr_anguloRad;\\nattribute float a_geo1_anguloRad;\\nattribute float a_geo1_incr;\\nattribute float a_geo1_dir;\\nattribute float a_geo1_radio;\\n\\nattribute vec3 a_geo2_position;\\nattribute vec3 a_geo3_position;\\n\\nuniform float uTime;\\nuniform float uCamaraDistance;\\nuniform float uScrollSpeed;\\nuniform float uScale;\\nuniform float uResponsiveScale;\\nuniform float uScrollDelta;\\nuniform float uScrollProgress;\\nuniform float uMorphingProgress;\\nuniform float uIntroProgress;\\n\\nuniform float uRotationInner;\\nuniform float uRotationOutter;\\n\\nuniform float uProgress0;\\nuniform float uProgress0b;\\n\\nuniform float uProgress1;\\nuniform float uProgress2;\\nuniform float uProgress3;\\nuniform float uProgress4;\\nuniform float uProgress4b;\\nuniform float uProgress5;\\nuniform float uProgress6;\\nuniform float uProgress6b;\\n\\n// varying vec3 vPosition;\\n//varying vec2 vUv;\\nvarying vec3 v_randomness;\\nvarying float v_colorStrength;\\n\\nvarying float v_activePulse;\\nvarying float v_activePulseProgress;\\nvarying float v_test;\\n\\n//\\tClassic Perlin 3D Noise \\n//\\tby Stefan Gustavson\\n//\\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\\n\\nfloat cnoise(vec3 P){\\n  vec3 Pi0 = floor(P); // Integer part for indexing\\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\\n  Pi0 = mod(Pi0, 289.0);\\n  Pi1 = mod(Pi1, 289.0);\\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n  vec4 iz0 = Pi0.zzzz;\\n  vec4 iz1 = Pi1.zzzz;\\n\\n  vec4 ixy = permute(permute(ix) + iy);\\n  vec4 ixy0 = permute(ixy + iz0);\\n  vec4 ixy1 = permute(ixy + iz1);\\n\\n  vec4 gx0 = ixy0 / 7.0;\\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\\n  gx0 = fract(gx0);\\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n  vec4 sz0 = step(gz0, vec4(0.0));\\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n\\n  vec4 gx1 = ixy1 / 7.0;\\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\\n  gx1 = fract(gx1);\\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n  vec4 sz1 = step(gz1, vec4(0.0));\\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n\\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\n\\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n  g000 *= norm0.x;\\n  g010 *= norm0.y;\\n  g100 *= norm0.z;\\n  g110 *= norm0.w;\\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n  g001 *= norm1.x;\\n  g011 *= norm1.y;\\n  g101 *= norm1.z;\\n  g111 *= norm1.w;\\n\\n  float n000 = dot(g000, Pf0);\\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n  float n111 = dot(g111, Pf1);\\n\\n  vec3 fade_xyz = fade(Pf0);\\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \\n  return 2.2 * n_xyz;\\n}\\n\\nvec3 get_pos1(float anguloRad){\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(1.*a_geo1_dir*0.2);\\n    float x = cos(anguloRad)*a_geo1_radio;\\n    float y = sin(anguloRad)*a_geo1_radio;\\n    float z = 0.0;\\n    vec3 newPos = vec3(x, y, z);\\n    return newPos;\\n}\\n\\nvec3 get_posScrollSpeed(vec3 pos){\\n    float factor = mix(1.0, 2.0, uScrollSpeed);\\n    pos = pos*factor;\\n    return pos;\\n}\\n\\nfloat get_escalaNoise(float x, float y, float amplitudMapa, float progress){\\n    float valor = cnoise(vec3(x/amplitudMapa, y/amplitudMapa, progress));\\n    valor = 0.5+(valor/2.);\\n    valor *=2.;\\n    return valor;\\n}\\n\\nfloat get_escalaOndaRadial(float orbital, float progress){\\n    float frecuencia = 0.5; // Valores bajos ondas mas largas, valores altos ondas mas cortas\\n    float seno = (sin((progress+orbital)*frecuencia)+1.)/2.;\\n\\n    float valor = 0.5+(seno*0.5);\\n\\n    return valor;\\n}\\n\\nfloat get_escalaEdge(float orbital){\\n    float value = 1.;\\n    float orbitalMax = 37.;\\n    float fadeLimit = 22.;\\n    float fadeScale = 1.;\\n    float rango = orbitalMax -fadeLimit;\\n    if(orbital >= fadeLimit){\\n        float orbitalRel = orbital -fadeLimit;\\n        float ratio = orbitalRel/rango;\\n        fadeScale = fadeScale-ratio;\\n    }\\n    return fadeScale;\\n}\\n\\nvec3 randomizePosition(vec3 oldPos, vec3 randomness, float time, float amplitude, float amount, float speed){\\n    time = time*speed;\\n    vec3 newPos = oldPos;\\n    newPos.x += sin(time * randomness.x) * (amplitude*amount);\\n    newPos.y += cos(time * randomness.y) * (amplitude*amount);\\n    newPos.z += cos(time * randomness.z) * (amplitude*amount);\\n    return newPos;\\n}\\n\\nfloat quinticOut(float t) {\\n  return (pow(t - 1.0, 5.0));\\n}\\n\\nfloat quadraticOut(float t) {\\n  return -t * (t - 2.0);\\n}\\n\\nfloat quarticOut(float t) {\\n  return pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\\n}\\n\\nvoid main() {\\n\\n    // float time = uTime * 4.;    \\n\\n    //vec3 pos = mix(position, a_geo1_position, uProgress);\\n    // vec3 pos = a_geo2_position;\\n    //vec3 pos = position;\\n    //vec3 pos1 = get_pos1();\\n    //pos1 = pos1*(sin((-uTime+a_geo1_orbital)*0.5)+2.)*0.1;\\n\\n    //float senoFx = sin((-uTime+a_geo1_orbital))*0.5*0.5;\\n    //float escalaFx = mix(0.98, 1.02, senoFx);\\n    //pos1 = pos1*escalaFx;\\n    //pos1 = get_posScrollSpeed(pos1);\\n\\n    //vec3 endPos = mix(a_geo2_position, a_geo3_position, 0.);\\n    //vec3 endPos = a_geo2_position;\\n    //vec3 pos = mix(pos1, a_geo2_position, uProgress1);\\n    //pos = randomizePosition(pos, a_randomness, uTime, 5.0, uProgress1, 5.);\\n    // pos.x += sin(time * a_randomness.x) *0.02;\\n    // pos.y += cos(time * a_randomness.y) *0.02;\\n    // pos.z += cos(time * a_randomness.z) *0.02;\\n    \\n    // pos *= uScale;\\n    // vPosition = pos;\\n\\n    //----------------------------------------------------------\\n    // POSITION:\\n    float rotation = mix(uRotationInner, uRotationOutter, ((a_geo1_orbital)*1.)/37.);\\n    float anguloRad_time = (a_geo1_anguloRad+rotation);\\n    // Geometries present:\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(uScrollProgress*a_geo1_dir*2.2);\\n    vec3 POSITION_1 = get_pos1(anguloRad_time);\\n    //vec3 POSITION_1 = position;\\n    vec3 POSITION_2 = a_geo2_position;\\n    POSITION_2 = randomizePosition(POSITION_2, a_randomness, uTime, 5.0, uMorphingProgress, 5.);\\n    // Z modifications:\\n    \\n    // Ondas de seno:\\n    float senoFx = sin((-uTime+a_geo1_orbital))*0.5*0.5;\\n    float escalaFx = mix(0.98, 1.02, senoFx);\\n    //POSITION_1 *= escalaFx;\\n    // Morphing:\\n    float clamped_morpingProgress = clamp(0., 0.95, uMorphingProgress);\\n    POSITION_1 = mix(POSITION_1, POSITION_2, clamped_morpingProgress);\\n    // Randomized position while in POSITION_2\\n    POSITION_1 = randomizePosition(POSITION_1, a_randomness*2., uTime, 5.0, uMorphingProgress, 2.5);\\n    // Escala por scroll delta:\\n    //POSITION_1 *= 1.+(uScrollDelta);\\n    // Escalado incial:\\n    //POSITION_1 *= mix(5., 1., quinticOut(uIntroProgress));\\n    //POSITION_1 *= mix(5., 1., quadraticOut(uIntroProgress));\\n    //POSITION_1 *= mix(10., 1., quarticOut(uIntroProgress));\\n    POSITION_1 *= mix(10., 1., uIntroProgress);\\n    // Responsive Scale:\\n    POSITION_1 *= uResponsiveScale;\\n    //\\n    POSITION_1 = mix(POSITION_1, POSITION_2, uMorphingProgress);\\n    //----------------------------------------------------------\\n\\n    //----------------------------------------------------------\\n    // SIZE:\\n    float SIZE_1 = 8.;\\n    // Los puntos son mas pequeños en los orbitales de la periferia\\n    float esclaEdege = get_escalaEdge(a_geo1_orbital); \\n    float rango = 1.-esclaEdege;\\n    SIZE_1 *= (esclaEdege + (rango*uProgress1));\\n    // Los puntos se escalan en base a un mapa de ruido\\n    SIZE_1 *= mix(1., get_escalaNoise(POSITION_1.x, POSITION_1.y, 500., uProgress0), uProgress0b);\\n    // Los puntos se escalan en base a ondas concentricas de seno:\\n    SIZE_1 *= mix(1., get_escalaOndaRadial(a_geo1_orbital, -uTime*10.), uProgress4b);\\n    // Los puntos se escalan por pulson random:\\n    SIZE_1 *= mix(1., 1.5, v_activePulseProgress);\\n    // Los puntos se escalan junto con la geometria con el scrolldelta\\n    SIZE_1 *= 1.+(uScrollDelta);\\n\\n    float SIZE_2 = 5.; \\n    // \\n    float zDepthNorm = (POSITION_2.z+600.)/(600.*2.); // de -600 a 600 de un valor normalizado (sin clamp, es decir que puede ser <0 y >1) de la posicion z\\n    float zDepthAlpha = mix(0.2, 0.9, zDepthNorm);\\n    float zDepthScale = mix(0.8, 2.5, zDepthNorm);\\n    float randomSize = SIZE_2 *0.5+(a_randomness.x*0.9);\\n    randomSize *= zDepthScale;\\n    SIZE_2 = mix(SIZE_2, randomSize, uMorphingProgress);\\n    \\n    \\n    float SIZE = mix(SIZE_1, SIZE_2, uMorphingProgress);\\n    // Los puntos se escalan si se redimensona el lienzo\\n    SIZE *= uResponsiveScale;\\n    \\n    \\n    //----------------------------------------------------------\\n\\n    //----------------------------------------------------------\\n    // VERTEX\\n    vec4 mvPosition = modelViewMatrix * vec4( POSITION_1, 1.0 );\\n    gl_Position = projectionMatrix * mvPosition;\\n    gl_PointSize = SIZE*(uCamaraDistance/-mvPosition.z);\\n    //----------------------------------------------------------\\n\\n    \\n\\n    //----------------------------------------------------------\\n    // VARYINGS:\\n    v_randomness = a_randomness;\\n    v_colorStrength = get_escalaNoise(POSITION_1.x, POSITION_1.y, 200., sin(uTime));\\n    v_colorStrength = mix(1., v_colorStrength, uMorphingProgress);\\n\\n}");\n;// CONCATENATED MODULE: ./app/src/js/webgl/home4/shaders/home4_dots_fragment.glsl\n/* harmony default export */ const home4_dots_fragment = ("#define GLSLIFY 1\\n// varying vec3 vPosition;\\n// varying vec2 vUv;\\n\\nvarying vec3 v_randomness;\\nvarying float v_colorStrength;\\n\\nuniform vec3 uColor1;\\nuniform vec3 uColor2;\\nuniform vec3 uColor3;\\n\\nuniform float uProgress1;\\nuniform float uProgress2;\\nuniform float uProgress3;\\nuniform float uIntroProgress;\\n\\nvarying float v_activePulse;\\nvarying float v_activePulseProgress; \\nvarying float v_test;\\n\\nfloat quarticOut(float t) {\\n  return pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\\n}\\n\\nfloat circulizar(float radio){\\n    // radio es un valor entre 0 y 1. 0 es 0 de radio y 1 es el maximo del radio dentro de\\n    radio = 1.0-(0.5*radio);\\n    float result = distance(gl_PointCoord, vec2(0.5, 0.5));\\n    result = 1. -result;\\n    result = pow(result, 1.);\\n    result = step(radio, result);\\n    return result;\\n}\\n\\nvoid main() {\\n\\n    float randomnessCir = v_randomness.x*uProgress1;\\n    randomnessCir = mix(1., randomnessCir, uProgress1);\\n    //float alpha = circulizar(1.0*randomnessCir);\\n    float alpha = circulizar(1.0);\\n\\n    //alpha *= mix(-2., 1., quarticOut(uIntroProgress));\\n    alpha *= mix(0.8, 1., uIntroProgress);\\n\\n    vec3 finalColor = mix(uColor2, uColor1, v_colorStrength);\\n\\n    vec3 colorWhite = vec3(1.0, 1.0, 1.0);\\n    vec3 mixActiveColor = mix(finalColor, uColor3, v_activePulse);\\n\\n    vec3 white = vec3(1., 1., 1.);\\n\\n    finalColor =  mix(finalColor, white, v_activePulseProgress*0.15);\\n\\n    gl_FragColor = vec4(finalColor, alpha);\\n\\n}");\n;// CONCATENATED MODULE: ./app/src/js/webgl/home4/Home4Dots.js\nfunction Home4Dots_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home4Dots_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home4Dots_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home4Dots_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home4Dots_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\n\n\n\n\nvar Home4Dots = /*#__PURE__*/function () {\n  function Home4Dots(obj) {\n    var _this = this;\n\n    Home4Dots_classCallCheck(this, Home4Dots);\n\n    //console.log("(Home4Dots.CONSTRUCTORA)!")\n    //console.log(obj)\n    this.worldGL = obj.worldGL; //--\n\n    this.scene = this.worldGL.scene;\n    this.cameraDistance = this.worldGL.cameraDistance; //--\n\n    this.material = null;\n    this.geometry = null;\n    this.mesh = null;\n    this.numParticles = null;\n    this.allLoaded = false;\n    this.created = false;\n    this.clock = new three_module/* Clock */.SUY();\n    this.startTime = null;\n    this.introTime = 1.2;\n    this.rotationX = 0;\n    this.rotationY = 0;\n    this.rotationWantedX = 0;\n    this.rotationWantedY = 0;\n    this.morphingProgress = 0; //--\n\n    this.eased_rotation = new webgl_EasedOutValue(0, 0.05);\n    this.eased_scrollDelta = new webgl_EasedOutValue(this.worldGL.settings.scroll_normalizedDelta * 0.3, 0.05);\n    this.eased_scrollDelta_fast = new webgl_EasedOutValue(this.worldGL.settings.scroll_normalizedDelta * 0.5, 0.1);\n    this.eased_scrollProgress = new webgl_EasedOutValue(this.worldGL.settings.scroll_progress, 0.05); //--\n\n    this._setup_settings(); //--\n\n\n    this.orbital_geometry = new Home4Geometry(this.settings); //--\n\n    this.M_geometry = new webgl_LoadedGeometry({\n      id: "M_geometry",\n      file: "",\n      isDraco: false,\n      scale: 600 //rotationY : -Math.PI*0.25\n\n    }, this.settings);\n    this.M_geometry.on("onMeshLoaded", function (data) {\n      //console.log("(Home4Dots) onMeshLoaded!")\n      _this._eval_allLoaded();\n    }); //--\n\n    this.resize(); //--\n\n    this.M_geometry.init();\n  } //------------------------------------\n  // PUBLICAS:\n\n\n  Home4Dots_createClass(Home4Dots, [{\n    key: "create",\n    value: function create() {\n      //console.log("(Home4Dots._create)!")\n      //--\n      this.material = new three_module/* ShaderMaterial */.jyz({\n        depthWrite: false,\n        blending: three_module/* AdditiveBlending */.WMw,\n        //blending: THREE.NormalBlending,\n        //blending: THREE.MultiplyBlending,\n        vertexColors: true,\n        vertexShader: home4_dots_vertex,\n        fragmentShader: home4_dots_fragment,\n        transparent: true,\n        uniforms: {\n          uColor1: {\n            value: new three_module/* Color */.Ilk("#170e41")\n          },\n          //801c65\n          uColor2: {\n            value: new three_module/* Color */.Ilk("#801c65")\n          },\n          uColor3: {\n            value: new three_module/* Color */.Ilk("#880364")\n          },\n          uTime: {\n            value: 0\n          },\n          uCamaraDistance: {\n            value: this.cameraDistance\n          },\n          uScrollDelta: {\n            value: 0\n          },\n          uScrollProgress: {\n            value: 1\n          },\n          uResponsiveScale: {\n            value: 1\n          },\n          uRotation1: {\n            value: 0\n          },\n          uRotation2: {\n            value: 0\n          },\n          uRotation3: {\n            value: 0\n          },\n          uRotationInner: {\n            value: 0\n          },\n          uRotationOutter: {\n            value: 0\n          },\n          uMorphingProgress: {\n            value: 0\n          },\n          uIntroProgress: {\n            value: 0\n          },\n          uScrollSpeed: {\n            value: 0\n          },\n          uProgress0: {\n            value: 0\n          },\n          uProgress0b: {\n            value: 1\n          },\n          uProgress1: {\n            value: 0\n          },\n          uProgress2: {\n            value: 0\n          },\n          uProgress3: {\n            value: 0\n          },\n          uProgress4: {\n            value: 0\n          },\n          uProgress4b: {\n            value: 0\n          },\n          uProgress5: {\n            value: 0\n          },\n          uProgress6: {\n            value: 0\n          },\n          uProgress6b: {\n            value: 0\n          } //uScale: {value: 1},\n          //uSize: {value: 30 * this.renderer.getPixelRatio()}\n\n        }\n      }); //--\n      //console.log(this.orbital_geometry.attributes.a_posiciones)\n      //--\n\n      this.geometry = new three_module/* BufferGeometry */.u9r();\n      this.geometry.setAttribute(\'position\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_geo1_position\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_geo1_dot_num\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_dot_num, 1));\n      this.geometry.setAttribute(\'a_geo1_orbital\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_orbital, 1));\n      this.geometry.setAttribute(\'a_geo1_pos_orbita\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_pos_orbita, 1));\n      this.geometry.setAttribute(\'a_geo1_incr_anguloRad\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_incr_anguloRad, 1));\n      this.geometry.setAttribute(\'a_geo1_anguloRad\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_anguloRad, 1));\n      this.geometry.setAttribute(\'a_geo1_radio\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_radio, 1));\n      this.geometry.setAttribute(\'a_geo1_dir\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_dir, 1));\n      this.geometry.setAttribute(\'a_geo1_incr\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_incr, 1));\n      this.geometry.setAttribute(\'a_geo1_x\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_x, 1));\n      this.geometry.setAttribute(\'a_geo1_y\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_y, 1));\n      this.geometry.setAttribute(\'a_geo1_z\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_z, 1));\n      this.geometry.setAttribute(\'a_geo2_position\', new three_module/* BufferAttribute */.TlE(this.M_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_randomness\', new three_module/* BufferAttribute */.TlE(this.M_geometry.attributes.a_randomness, 3));\n      this.mesh = new three_module/* Points */.woe(this.geometry, this.material);\n      this.scene.add(this.mesh);\n    }\n  }, {\n    key: "onMouseUpdate",\n    value: function onMouseUpdate(mouseNormX, mouseNormY) {\n      //console.log("(Home4Dots.onMouseUpdate): "+mouseNormX)\n      if (this.morphingProgress > 0) {\n        //console.log("*")\n        this._mouseUpdateX(mouseNormX);\n\n        this._mouseUpdateY(mouseNormY);\n      }\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      if (this.allLoaded) {\n        //console.log("(Home4Dots.render)!")\n        //--\n        if (this.startTime == null) {\n          this.startTime = this.clock.getElapsedTime();\n        }\n\n        var introProgress = webgl_WebGLUtils.clamp((this.clock.getElapsedTime() - this.startTime) / this.introTime, 0, 1);\n        introProgress = easing_functions_default().Quartic.Out(introProgress);\n        this.material.uniforms.uIntroProgress.value = introProgress; //--\n\n        var rotationEasedY = this.rotationY + (this.rotationWantedY - this.rotationY) * 0.05;\n        this.rotationY = rotationEasedY;\n        this.mesh.rotation.y = rotationEasedY; //--\n\n        var rotationEasedX = this.rotationX + (this.rotationWantedX - this.rotationX) * 0.05;\n        this.rotationX = rotationEasedX;\n        this.mesh.rotation.x = rotationEasedX; //--\n\n        this.material.uniforms.uTime.value = this.clock.getElapsedTime();\n        this.material.uniforms.uCamaraDistance.value = this.worldGL.cameraDistance;\n        this.material.uniforms.uResponsiveScale.value = this.worldGL.responsiveScale;\n        this.material.uniforms.uScrollDelta.value = -this.eased_scrollDelta.get(this.worldGL.settings.scroll_normalizedDelta * 0.5);\n        this.material.uniforms.uScrollProgress.value = this.worldGL.settings.scroll_progress;\n\n        if (this.worldGL.settings.morphingProgress <= 0.5) {\n          this.morphingProgress = 0;\n\n          this._mouseUpdateX(0);\n\n          this._mouseUpdateY(0);\n        } else {\n          this.morphingProgress = (this.worldGL.settings.morphingProgress - 0.5) * 2;\n        } //console.log("this.morphingProgress: "+this.morphingProgress)\n        //--\n\n\n        this.material.uniforms.uMorphingProgress.value = this.morphingProgress;\n        var extraSpeed = 1 + Math.abs(this.eased_scrollDelta_fast.get(this.worldGL.settings.scroll_normalizedDelta * 0.5) * 10);\n        this.settings.rotation1 += this.settings.speedRotation1 * extraSpeed;\n        this.settings.rotation2 += this.settings.speedRotation2 * extraSpeed;\n        this.settings.rotation3 += this.settings.speedRotation3 * extraSpeed;\n        this.material.uniforms.uRotation1.value = this.settings.rotation1;\n        this.material.uniforms.uRotation2.value = -this.settings.rotation2;\n        this.material.uniforms.uRotation3.value = this.settings.rotation3;\n        this.settings.rotationInner += this.settings.speedRotationInner * extraSpeed;\n        this.settings.rotationOutter += this.settings.speedRotationOutter * extraSpeed;\n        this.material.uniforms.uRotationInner.value = this.settings.rotationInner;\n        this.material.uniforms.uRotationOutter.value = this.settings.rotationOutter;\n        this.material.uniforms.uProgress0.value = this.settings.progress0;\n        this.material.uniforms.uProgress0b.value = this.settings.progress0b;\n        this.material.uniforms.uProgress1.value = this.settings.progress1;\n        this.material.uniforms.uProgress2.value = this.settings.progress2;\n        this.material.uniforms.uProgress3.value = this.settings.progress3;\n        this.material.uniforms.uProgress4.value = this.settings.progress4;\n        this.material.uniforms.uProgress4b.value = this.settings.progress4b;\n        this.material.uniforms.uProgress5.value = this.settings.progress5;\n        this.material.uniforms.uProgress6.value = this.settings.progress6;\n        this.material.uniforms.uProgress6b.value = this.settings.progress6b;\n        this.material.uniforms.uScrollSpeed.value = this.settings.scrollSpeedFiltered; //--\n\n        this.settings.rotationInner += this.settings.speedRotationInner * extraSpeed;\n        this.settings.rotationOutter += this.settings.speedRotationOutter * extraSpeed;\n      }\n    }\n  }, {\n    key: "resize",\n    value: function resize() {//NADA\n    } //------------------------------------\n    // PRIVADAS: \n\n  }, {\n    key: "_mouseUpdateX",\n    value: function _mouseUpdateX(mouseNormX) {\n      var maxAngleRad = Math.PI * 0.25;\n      this.rotationWantedY = maxAngleRad * mouseNormX * this.morphingProgress;\n    }\n  }, {\n    key: "_mouseUpdateY",\n    value: function _mouseUpdateY(mouseNormY) {\n      var maxAngleRad = Math.PI * 0.1;\n      this.rotationWantedX = maxAngleRad * mouseNormY * this.morphingProgress;\n    }\n  }, {\n    key: "_eval_allLoaded",\n    value: function _eval_allLoaded() {\n      if (this.M_geometry.loaded) {\n        this.allLoaded = true;\n        this.worldGL.eval_start();\n      }\n    }\n  }, {\n    key: "_setup_settings3",\n    value: function _setup_settings3() {\n      //console.log("(Home4Dots._setup_settings)!")\n      this.settings = {\n        factor: 6,\n        incr_radio: 25,\n        numOrbits: 26,\n        //arrayOrbits: [12, 19, 26]\n        arrayOrbits: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26] //arrayOrbits: [1, 3]\n\n      };\n      this.settings.array_triangular = this._get_array_triangular(this.settings.factor, this.settings.numOrbits);\n      this.settings.array_triangular_dots_x_orbita = this._get_array_triangular_dots_x_orbita(this.settings.array_triangular, this.settings.arrayOrbits);\n      this.settings.array_dotPos = this._get_array_dotPos(this.settings.arrayOrbits, this.settings.array_triangular, this.settings.array_triangular_dots_x_orbita);\n      this.settings.numDots = this.settings.array_dotPos.length;\n    }\n  }, {\n    key: "_setup_settings",\n    value: function _setup_settings() {\n      //console.log("(Home4Dots._setup_settings)!")\n      var speedBase = 0.00005; //--\n\n      this.settings = {\n        //--\n        rotationInner: 0,\n        speedRotationInner: 37 * speedBase,\n        rotationOutter: 0,\n        speedRotationOutter: 1 * speedBase,\n        //--\n        factor: 6,\n        incr_radio: 25,\n        numOrbits: 37,\n        pulseArray: [],\n        pulseMax: 1,\n        pulseNum_0: 0,\n        pulseInitTime_0: 0,\n        pulseProgress_0: 0,\n        progress0: 0,\n        progress0b: 1,\n        progress1: 0,\n        progress2: 0,\n        progress3: 0,\n        progress4: 0,\n        progress4b: 1,\n        progress5: 0,\n        progress6: 0,\n        progress6b: 1,\n        scrollSpeed: 0,\n        scrollSpeedFiltered: 0\n      };\n      this.settings.array_triangular = this._get_array_triangular(this.settings.factor, this.settings.numOrbits);\n      this.settings.numDots = this.settings.array_triangular[this.settings.array_triangular.length - 1];\n    }\n  }, {\n    key: "_get_array_triangular",\n    value: function _get_array_triangular(_factor, _numObits) {\n      // Genera una array de progresión triangular (* factor).\n      // Una progresión triangular es: 1, 3, 6, 10, 15 (https://significativa.org/diccionarios/numeros-figurados/#:~:text=3.1.1.1.-,Definici%C3%B3n,anterior%20no%20obtenemos%20una%20constante.)\n      var miArray = [];\n\n      for (var i = 0; i <= _numObits; i++) {\n        //array_numTriagulares.push(i*(i+1)/2)\n        miArray.push(i * (i + 1) / 2 * _factor);\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_get_array_dotPos",\n    value: function _get_array_dotPos(_arrayOrbits, _array_triangular, _array_triangular_dots_x_orbita) {\n      var miArray = [];\n\n      for (var i = 0; i < _arrayOrbits.length; i++) {\n        var orbitNum = _arrayOrbits[i];\n        var dots_x_orbit = _array_triangular_dots_x_orbita[i];\n        var dotNum_base = _array_triangular[_arrayOrbits[i] - 1]; // console.log("orbitNum: "+orbitNum)\n        // console.log("dots_x_orbit: "+dots_x_orbit)\n        // console.log("dotNum_base: "+dotNum_base)\n\n        for (var j = 0; j < dots_x_orbit; j++) {\n          miArray.push(dotNum_base + j + 1);\n        }\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_get_numDots",\n    value: function _get_numDots(_array_triangular_dots_x_orbita) {\n      var numDots = 0;\n\n      for (var i = 0; i <= _array_triangular_dots_x_orbita.length - 1; i++) {\n        numDots += _array_triangular_dots_x_orbita[i];\n      }\n\n      return numDots;\n    }\n  }, {\n    key: "_get_array_triangular_dots_x_orbita",\n    value: function _get_array_triangular_dots_x_orbita(_array_triangular, _arrayOrbits) {\n      // Genera una array basada en la progresión triangular (* factor).\n      // ... donde se indica el numero de dots por orbital\n      // Una progresión triangular es: 1, 3, 6, 10, 15 (https://significativa.org/diccionarios/numeros-figurados/#:~:text=3.1.1.1.-,Definici%C3%B3n,anterior%20no%20obtenemos%20una%20constante.)\n      var miArray = [];\n\n      for (var i = 0; i <= _arrayOrbits.length - 1; i++) {\n        //array_numTriagulares.push(i*(i+1)/2)\n        var numDots_orbita_actual = _array_triangular[_arrayOrbits[i]];\n        var numDots_orbita_anterior = _array_triangular[_arrayOrbits[i] - 1];\n        var numDots_orbita = numDots_orbita_actual - numDots_orbita_anterior;\n        miArray.push(numDots_orbita);\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_createcube",\n    value: function _createcube(_scene) {\n      var geometry = new three_module/* BoxGeometry */.DvJ(100, 100, 100);\n      var material = new three_module/* MeshBasicMaterial */.vBJ({\n        color: 0x00ff00\n      });\n      var cube = new three_module/* Mesh */.Kj0(geometry, material);\n\n      _scene.add(cube);\n    }\n  }]);\n\n  return Home4Dots;\n}();\n\n/* harmony default export */ const home4_Home4Dots = (Home4Dots);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home4/Home4App.js\nfunction Home4App_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home4App_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home4App_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home4App_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home4App_defineProperties(Constructor, staticProps); return Constructor; }\n\n// FPS-Meter:\n//(function(){var script=document.createElement(\'script\');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src=\'//cdn.jsdelivr.net/gh/Kevnz/stats.js/build/stats.min.js\';document.head.appendChild(script);})()\n\n\n\n\n\n\nvar Home4App = /*#__PURE__*/function () {\n  function Home4App(obj) {\n    var _this = this;\n\n    Home4App_classCallCheck(this, Home4App);\n\n    //console.log("(Home4App.CONSTRUCTORA)!", obj) \n    this.hw_renderer = obj.renderer; // Rederer/pagina de HighWay. No confundir con el render/renderer de Three.js\n\n    this.$container = obj.domElement; //-- \n    //this.$inner = document.querySelector(\'.inner\')\n    //this.$footer = document.querySelector(\'.footer\')\n    //--\n\n    this.REF_RESOLUTION = {\n      width: 1920,\n      height: 947\n    };\n    this.REF_CAMERA_DISTANCE = 500; //--\n\n    this.initialized = false; //--\n\n    this.width;\n    this.height;\n    this.responsiveScale;\n    this.cameraDistance; //--\n\n    document.addEventListener(\'mousemove\', function (self) {\n      _this.onMouseUpdate(self);\n    }, false);\n    document.addEventListener(\'wheel\', function (self) {\n      _this.onMouseUpdate(self);\n    }, false); //--\n\n    this.MAIN_ACTIVE = false;\n    this.FOOTER_ACTIVE = false; //--\n\n    this.mouseNorm = {\n      x: 0,\n      y: 0\n    }; //--\n    //this.refResolution = 1920;\n    //this.refResolution = 450;\n    //this.responsiveScale = this.width/this.refResolution;\n    //--\n    //this.cameraDistance = 500\n    //--\n\n    this.settings = {\n      scroll_lastInnerY: 0,\n      // Ultima posición del elemento de referencia\n      scroll_delta: 0,\n      // Incremento de pixels del scroll\n      scroll_limitedDelta: 0,\n      // Limita los valores a -20 -> +20\n      scroll_normalizedDelta: 0,\n      // Pasa el delta a -1 -> +1\n      scroll_factordDelta: 1,\n      // Valores absolutos de 0 -> 1\n      scroll_direction: 1,\n      // Direccion del delta. 1 si está parado\n      scroll_footer_progress: 0,\n      morphingProgress: 0\n    }; //--\n\n    this._update_dimensions(); //--\n    // Scene\n\n\n    this.scene = new three_module/* Scene */.xsS();\n    this.scene.background = new three_module/* Color */.Ilk(0x000a33); //--\n    // Camera\n    //PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )\n\n    this.camera = new three_module/* PerspectiveCamera */.cPb(30, this.width / this.height, 0.1, 2000);\n    this.camera.position.z = this.cameraDistance; //console.log("this.camera.fov: "+this.camera.fov)\n\n    this.camera.fov = 2 * Math.atan(this.height / 2 / this.cameraDistance) * (180 / Math.PI); //console.log("this.camera.fov: "+this.camera.fov)\n    //--\n    // Renderer\n\n    this.renderer = new three_module/* WebGL1Renderer */.b5g({\n      antialias: true,\n      alpha: true\n    });\n    this.renderer.autoClear = false; // Vamos a usar 2 scenas (una para el background y otra para los puntos) que implicarán usar 2 acciones de render. Con autoclear false permitimos que la segunda no borre la primera.\n\n    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1)); //--\n\n    this.$container.appendChild(this.renderer.domElement); //--\n\n    this.dots = new home4_Home4Dots({\n      worldGL: this\n    }); //--\n\n    this._resize(); //this._render();\n    //this._init_scrollListeners()\n\n  } //---------------------------\n  // PUBLICAS:\n\n\n  Home4App_createClass(Home4App, [{\n    key: "init",\n    value: function init() {\n      //console.log("(Home4App.init)!") \n      this.initialized = true;\n      this.eval_start();\n    }\n  }, {\n    key: "eval_start",\n    value: function eval_start() {\n      //console.log("(Home4App.eval_start): "+this.initialized+":"+this.dots.allLoaded) \n      if (this.initialized && this.dots.allLoaded) {\n        //console.log("(Home4App.eval_start) -- START") \n        //console.log("START!")\n        //--\n        this.$inner = document.querySelector(\'.inner\');\n        this.$footer = document.querySelector(\'.footer\'); //--\n\n        this.dots.create();\n\n        this._render();\n\n        this._init_scrollListeners();\n      }\n    }\n  }, {\n    key: "kill",\n    value: function kill() {\n      //console.log("(Home4App.kill)!") \n      this.$inner_trigger.kill();\n      this.$footer_trigger.kill();\n      node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this._binded_render);\n      node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this._binded_eval_scroll);\n      this.dots = null;\n    } //---------------------------\n\n  }, {\n    key: "onResize",\n    value: function onResize() {\n      //console.log("(Home1App.onResize)!")\n      this._resize();\n    }\n  }, {\n    key: "onMouseUpdate",\n    value: function onMouseUpdate(e) {\n      if (this.FOOTER_ACTIVE) {\n        this.mouseNorm.x = e.pageX / this.width * 2 - 1;\n        this.mouseNorm.y = e.pageY / this.height * 2 - 1;\n\n        if (this.dots) {\n          this.dots.onMouseUpdate(this.mouseNorm.x, this.mouseNorm.y);\n        }\n      }\n    } //---------------------------\n    // PRIVADAS:\n\n  }, {\n    key: "_update_dimensions",\n    value: function _update_dimensions() {\n      // console.log("(Home2App_m._update_dimensions)!", this.renderer)\n      this.width = this.$container.offsetWidth;\n      this.height = this.$container.offsetHeight;\n      this.responsiveScale = this.width / this.REF_RESOLUTION.width;\n      this.cameraDistance = this.REF_CAMERA_DISTANCE * this.responsiveScale; //--\n\n      if (this.renderer) {\n        this.renderer.setSize(this.width, this.height); //--\n\n        this.camera.aspect = this.width / this.height;\n        this.cameraDistance = this.camera.position.z;\n        this.camera.fov = 2 * Math.atan(this.height / 2 / this.cameraDistance) * (180 / Math.PI);\n        this.camera.updateProjectionMatrix();\n      } //--\n\n    }\n  }, {\n    key: "_init_scrollListeners",\n    value: function _init_scrollListeners() {\n      var _this2 = this;\n\n      var binded_render = function binded_render() {\n        _this2._render();\n      };\n\n      var binded_eval_scroll = function binded_eval_scroll() {\n        _this2._eval_inertia_scroll(_this2.$inner_trigger.progress);\n\n        _this2._eval_footer_scroll(_this2.$footer_trigger.progress);\n      };\n\n      this._binded_render = binded_render;\n      this._binded_eval_scroll = binded_eval_scroll;\n      var that = this;\n      this.$inner_trigger = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$inner,\n        start: \'top-=10 top\',\n        end: \'bottom bottom\',\n        scrub: true,\n        // Scrub: Genera eventos en una franja mas que en un punto.\n        // markers: true,\n        onToggle: function onToggle(self) {\n          if (self.isActive) {\n            //console.log("MAIN ACTIVE")\n            that.MAIN_ACTIVE = true;\n            node_modules_gsap/* default.ticker.add */.ZP.ticker.add(binded_render);\n            node_modules_gsap/* default.ticker.add */.ZP.ticker.add(binded_eval_scroll);\n          } else {\n            that.MAIN_ACTIVE = false; //console.log("MAIN NOT ACTIVE")\n            //gsap.ticker.remove(binded_render) // El fondo webgl persiste siempre. No lo desactivamos nunca.\n\n            node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(binded_eval_scroll); // El fondo webgl persiste siempre. No lo desactivamos nunca.\n          }\n        }\n      });\n      this.$footer_trigger = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$footer,\n        start: \'top bottom\',\n        end: \'bottom+=10 bottom\',\n        scrub: true,\n        // Scrub: Genera eventos en una franja mas que en un punto.\n        // markers: true,\n        onToggle: function onToggle(self) {\n          if (self.isActive) {\n            //console.log("FOOTER ACTIVE")\n            that.FOOTER_ACTIVE = true;\n          } else {\n            //console.log("FOOTER NOT ACTIVE")\n            that.FOOTER_ACTIVE = false;\n          }\n        }\n      });\n    }\n  }, {\n    key: "_eval_inertia_scroll",\n    value: function _eval_inertia_scroll(progress) {\n      var innerData = this.$inner.getBoundingClientRect();\n      var newInnerY = innerData.y;\n      this.settings.scroll_progress = progress;\n      this.settings.scroll_delta = newInnerY - this.settings.scroll_lastInnerY;\n      this.settings.scroll_lastInnerY = newInnerY;\n      this.settings.scroll_limitedDelta = webgl_WebGLUtils.clamp(this.settings.scroll_delta, -20, 20); // Limita los valores a -20 -> +20\n\n      this.settings.scroll_normalizedDelta = (this.settings.scroll_limitedDelta / 20).toFixed(3); // Pasa el delta a -1 -> +1\n\n      this.settings.scroll_factordDelta = Math.abs(this.settings.scroll_normalizedDelta) + 0; // Valores absolutos de 0 -> 1\n\n      this.settings.scroll_direction = 1;\n\n      if (this.settings.scroll_normalizedDelta < 0) {\n        this.settings.scroll_direction = -1;\n      }\n    }\n  }, {\n    key: "_eval_footer_scroll",\n    value: function _eval_footer_scroll(progress) {\n      //console.log("(Home4App._eval_footer_scroll): "+progress)\n      this.settings.scroll_footer_progress = progress;\n      this.settings.morphingProgress = progress;\n    }\n  }, {\n    key: "_resize",\n    value: function _resize() {\n      //console.log("(Home4Dots.resize)!")\n      //this.width = this.$container.offsetWidth;\n      //this.height = this.$container.offsetHeight;\n      //this.responsiveScale = this.width/this.refResolution;\n      //this.renderer.setSize( this.width, this.height );\n      //this.camera.aspect = this.width/this.height\n      //this.cameraDistance = this.camera.position.z\n      //this.camera.fov = 2*Math.atan((this.height/2)/(this.cameraDistance)) * (180/Math.PI) \n      ////--\n      //this.camera.updateProjectionMatrix();\n      //--\n      this._update_dimensions(); //--\n\n\n      if (this.dots) {\n        this.dots.resize(this.width, this.height);\n      }\n    }\n  }, {\n    key: "_render",\n    value: function _render() {\n      //console.log("(Home4App._render): "+this.settings.scroll_progress+":"+this.settings.scroll_footer_progress)\n      if (this.height != this.$container.offsetHeight || this.width != this.$container.offsetWidth) {\n        this._resize();\n      }\n\n      if (this.dots) {\n        this.dots.render();\n      }\n\n      this.renderer.render(this.scene, this.camera); //requestAnimationFrame(this.render.bind(this))\n    }\n  }]);\n\n  return Home4App;\n}();\n\n/* harmony default export */ const home4_Home4App = (Home4App);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home1_m/Home1Scroll_m.js\nfunction Home1Scroll_m_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home1Scroll_m_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home1Scroll_m_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home1Scroll_m_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home1Scroll_m_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar Home1Scroll_m = /*#__PURE__*/function () {\n  function Home1Scroll_m(obj) {\n    Home1Scroll_m_classCallCheck(this, Home1Scroll_m);\n\n    // console.log("(Home1Scroll_m.CONSTRUCTORA): ", obj)\n    this.app = obj.app;\n    this.$inner = obj.$inner; //--\n\n    this.lastInnerY = 0; // Ultima posición del elemento de referencia\n\n    this.delta = 0; // Incremento de pixels del scroll\n\n    this.limitedDelta = 0; // Limita los valores a -20 -> +20\n\n    this.normalizedDelta = 0; // Pasa el delta a -1 -> +1\n\n    this.factordDelta = 1; // Valores absolutos de 0 -> 1\n\n    this.direction = 1; // Direccion del delta. 1 si está parado\n    //--\n\n    this.triggers = {}; //--\n\n    this.progress = {};\n    this.progress.$inner = 0; //--\n\n    this._init_$inner();\n  } //------------\n  // PUBLICAS:\n\n\n  Home1Scroll_m_createClass(Home1Scroll_m, [{\n    key: "kill",\n    value: function kill() {\n      this.triggers.$inner.kill();\n      node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this._binded_render);\n      node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this._binded_eval_scroll);\n    } //------------\n    // PRIVADAS\n\n  }, {\n    key: "_init_$inner",\n    value: function _init_$inner() {\n      var _this = this;\n\n      var binded_render = function binded_render() {\n        _this.app.render();\n      };\n\n      var binded_eval_scroll = function binded_eval_scroll() {\n        _this._update_$inner(_this.triggers.$inner.progress);\n      };\n\n      this._binded_render = binded_render;\n      this._binded_eval_scroll = binded_eval_scroll; //--\n\n      this.triggers.$inner = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$inner,\n        start: \'top bottom\',\n        end: \'bottom bottom\',\n        scrub: true,\n        // Scrub: Genera eventos en una franja mas que en un punto.\n        // markers: true,\n        onToggle: function onToggle(self) {\n          if (self.isActive) {\n            node_modules_gsap/* default.ticker.add */.ZP.ticker.add(binded_render);\n            node_modules_gsap/* default.ticker.add */.ZP.ticker.add(binded_eval_scroll);\n          } else {\n            node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(binded_render);\n            node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(binded_eval_scroll);\n          }\n        }\n      });\n    }\n  }, {\n    key: "_update_$inner",\n    value: function _update_$inner(progress) {\n      this.progress.$inner = progress; //--\n\n      var innerData = this.$inner.getBoundingClientRect();\n      var newInnerY = innerData.y;\n      this.delta = newInnerY - this.lastInnerY;\n      this.lastInnerY = newInnerY;\n      this.limitedDelta = webgl_WebGLUtils.clamp(this.delta, -20, 20); // Limita los valores a -20 -> +20\n\n      this.normalizedDelta = (this.limitedDelta / 20).toFixed(3); // Pasa el delta a -1 -> +1\n\n      this.factordDelta = Math.abs(this.normalizedDelta) + 0; // Valores absolutos de 0 -> 1\n\n      this.direction = 1;\n\n      if (this.normalizedDelta < 0) {\n        this.scroll_direction = -1;\n      }\n    }\n  }]);\n\n  return Home1Scroll_m;\n}();\n\n/* harmony default export */ const home1_m_Home1Scroll_m = (Home1Scroll_m);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home1_m/shaders/home1_dots_vertex_m.glsl\n/* harmony default export */ const home1_dots_vertex_m = ("#define GLSLIFY 1\\nattribute vec3 a_randomness;\\nattribute vec3 a_geo1_position;\\nattribute vec3 a_geo1_color;\\nattribute float a_geo1_anguloRad;\\nattribute float a_geo1_orbital;\\nattribute float a_geo1_pos_orbita;\\nattribute float a_geo1_incr_anguloRad;\\nattribute float a_geo1_incr;\\nattribute float a_geo1_dir;\\nattribute float a_geo1_radio;\\n\\nuniform float uCamaraDistance;\\nuniform float uTime;\\nuniform float uOpenProgress;\\nuniform float uResponsiveScale;\\n\\nuniform float uScrollDelta;\\nuniform float uRotation1;\\nuniform float uRotation2;\\nuniform float uRotation3;\\n//uniform float uScale;\\n\\nvarying vec3 v_color;\\nvarying float v_pulseStrengthNorm1;\\nvarying float v_pulseStrengthNorm2;\\n\\n//\\tClassic Perlin 3D Noise \\n//\\tby Stefan Gustavson\\n//\\n\\n#define PI 3.1415926538\\n//#define PI 3.1415926535897932384626433832795\\n\\nvec3 get_pos1(float anguloRad){\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(1.*a_geo1_dir*0.2);\\n    float x = cos(anguloRad)*a_geo1_radio;\\n    float y = sin(anguloRad)*a_geo1_radio;\\n    float z = 0.0;\\n    vec3 newPos = vec3(x, y, z);\\n    return newPos;\\n}\\n\\nfloat get_openScale(){\\n    return mix(1., 8., uOpenProgress);\\n}\\n\\nvec3 get_openFx( vec3 pos){\\n    //float openScale = mix(1., 8., uOpenProgress);\\n    vec3 posFx = pos*get_openScale();\\n    return posFx;\\n}\\n\\nfloat get_cosTime(float time, float radius){\\n    //\\n    //float value = sin(uTime)*2.*PI;\\n    float value = sin(time)*radius;\\n    return value;\\n}\\n\\nfloat get_x(float angleRad, float radius){\\n    return cos(angleRad)*a_geo1_radio;\\n}\\n\\nfloat get_pulseStrengthNorm( float direction){\\n    float dotAguleNorm = a_geo1_anguloRad/(2.*PI); // Pasamos el angulo del punto que está en radianes a un valor de 0 a 1.\\n\\n    float modSpeed = mix(1., 2.5, 13./a_geo1_orbital)*direction;\\n    float radialSpeed = uTime*0.02*modSpeed; // Modificamos uTime para determinar la velocidad radial.\\n\\n    float pulseAngleRad = radialSpeed*(4.*PI);\\n\\n    // El valor de pulseAngleRad debe estar entre 0 y 2PI (inicio y fin de una circunferencia).\\n    // Como depende de uTime el valor saldrá de ese rango pronto por lo que tomaremos el resto (modulo),\\n    // de dividir pulseAngleRad por 2PI.\\n    if(pulseAngleRad > 2.*PI){\\n        pulseAngleRad = mod(pulseAngleRad, (2.*PI));\\n    }\\n    if(pulseAngleRad < 0.){\\n        pulseAngleRad = mod(pulseAngleRad, (2.*PI));\\n    }\\n\\n    float pulseAngleNorm = pulseAngleRad/(2.*PI); // Normalizamos el valor (de 0 a 1)\\n\\n    float distAngleNorm = abs(pulseAngleNorm-dotAguleNorm); // Calculamos la distancia radial del pulso al punto\\n\\n    // Apañamos la distancia de tal forma que no le afecte el punto de discontinuidad OPI = 2PI\\n    if(distAngleNorm > 0.5){ \\n        distAngleNorm = 0.5-(distAngleNorm-0.5);\\n    }\\n\\n    // La maxima distancia es de medio circulo y en terminos normalizados es 0.5\\n    // Creamos una variable que normalice ese valor entre 0 y 1.\\n    float pulseStrengthNorm  = distAngleNorm*2.; \\n\\n    float pico = 0.92;\\n    pico = mix(pico*0.99, pico*1.01, a_geo1_orbital/13.);\\n\\n    // Nos interesa solo el pico, la zona que va entre 0.95 y 1.\\n    // Toodo lo que haya por debajo de 0.95 lo pasamos a 0.95\\n    // y le restamos ese mismo 0.95 para quedarnos con el pico de 0.05 eol cual amplificamos x20 para normalizarlo (de 0 a 1).\\n    pulseStrengthNorm = (clamp(pulseStrengthNorm, pico, 1.)-pico)*10.;\\n    //--\\n    return pulseStrengthNorm;\\n}\\n\\nvoid main() {\\n\\n    //float direction = 1.;\\n    //if(abs(a_geo1_orbital - 13.) < 0.5){ // 13 es el orbital del medio\\n    //    direction = -1.;\\n    //}\\n\\n    //float longPeriod = sin(uTime);\\n    // longPeriod = clamp(longPeriod, 0., 1.);\\n    // longPeriod = 1.;\\n\\n    float pulseStrengthNorm1 = get_pulseStrengthNorm(1.5);\\n    float pulseStrengthNorm2 = get_pulseStrengthNorm(-1.);\\n\\n    \\n\\n    // Determinamos el tamaño del punto teniendo un minimo de 5 y amplificando el maximo para que visualmente sea bonito\\n    //float size = 5.+(pulseStrengthNorm*15.*longPeriod);\\n    float size = 3.;\\n    size += (pulseStrengthNorm1*5.);\\n    size += (pulseStrengthNorm2*5.);\\n    size *= uResponsiveScale;\\n    size *= get_openScale();\\n\\n    float anguloRad_time = 0.;\\n    if(abs(a_geo1_orbital-10.) < 0.5){ // Detecta el orbital 6\\n        anguloRad_time = a_geo1_anguloRad+uRotation1;\\n    }else if(abs(a_geo1_orbital-14.) < 0.5){ // Detecta el orbital 11\\n        anguloRad_time = a_geo1_anguloRad+uRotation2;\\n    }else if(abs(a_geo1_orbital-18.) < 0.5){ // Detecta el orbital 13\\n        anguloRad_time = a_geo1_anguloRad+uRotation3;\\n    }\\n    \\n\\n    //float rotationSpeed = (a_geo1_orbital/13.);\\n    //float rotationSpeed = (13./a_geo1_orbital);\\n    //rotationSpeed *= -u_scroll_factordDelta;\\n    //float anguloRad_time = a_geo1_anguloRad+(rotationSpeed*0.5)+(direction*uTime*0.2);\\n    vec3 pos1 = get_pos1(anguloRad_time);\\n    pos1 = get_openFx(pos1);\\n    pos1 = pos1 *uResponsiveScale;\\n    //pos1 = pos1 * (1.+(u_scroll_factordDelta*0.2));\\n    //vec3 pos2 = pos1*1.0;\\n    //pos1= mix(pos1, pos2, pulseStrengthNorm);\\n    vec4 mvPosition = modelViewMatrix * vec4( pos1, 1.0 ); \\n\\n    gl_Position = projectionMatrix * mvPosition; //<--------------------------------------------------\\n    gl_PointSize = size*(uCamaraDistance/-mvPosition.z); //<------------------------------------------\\n\\n    //--------------------------------------\\n    // VARYINGS:\\n    v_color = a_geo1_color; \\n    v_pulseStrengthNorm1 = pulseStrengthNorm1; \\n    v_pulseStrengthNorm2 = pulseStrengthNorm2; \\n\\n}\\n\\n/*\\nvec3 get_pos1(){\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(1.*a_geo1_dir*0.2);\\n    float x = cos(a_geo1_anguloRad)*a_geo1_radio;\\n    float y = sin(a_geo1_anguloRad)*a_geo1_radio;\\n    float z = 0.0;\\n    vec3 newPos = vec3(x, y, z);\\n    return newPos;\\n}\\n\\nfloat get_cosTime(float time, float radius){\\n    //\\n    //float value = sin(uTime)*2.*PI;\\n    float value = sin(time)*radius;\\n    return value;\\n}\\n\\nfloat get_x(float angleRad, float radius){\\n    return cos(angleRad)*a_geo1_radio;\\n}\\n\\n\\n\\nvoid main() {\\n\\n    vec3 pos1 = get_pos1();\\n    vec4 mvPosition = modelViewMatrix * vec4( pos1, 1.0 ); \\n\\n    float dist = distance(get_x(a_geo1_anguloRad, a_geo1_radio), get_cosTime(uTime*0.005*a_geo1_radio, a_geo1_radio));\\n    float size = 2.+abs(((0.001*a_geo1_radio)-dist)*0.02);\\n\\n    gl_Position = projectionMatrix * mvPosition; //<------------------------------------------\\n    gl_PointSize = size*(uCamaraDistance/-mvPosition.z); //<------------------------------------------\\n\\n    v_color = a_geo1_color; \\n\\n}\\n\\n*//*\\nvec3 get_pos1(){\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(1.*a_geo1_dir*0.2);\\n    float x = cos(a_geo1_anguloRad)*a_geo1_radio;\\n    float y = sin(a_geo1_anguloRad)*a_geo1_radio;\\n    float z = 0.0;\\n    vec3 newPos = vec3(x, y, z);\\n    return newPos;\\n}\\n\\nfloat get_cosTime(float time, float radius){\\n    //\\n    //float value = sin(uTime)*2.*PI;\\n    float value = sin(time)*radius;\\n    return value;\\n}\\n\\nfloat get_x(float angleRad, float radius){\\n    return cos(angleRad)*a_geo1_radio;\\n}\\n\\n\\n\\nvoid main() {\\n\\n    vec3 pos1 = get_pos1();\\n    vec4 mvPosition = modelViewMatrix * vec4( pos1, 1.0 ); \\n\\n    float dist = distance(get_x(a_geo1_anguloRad, a_geo1_radio), get_cosTime(uTime*0.005*a_geo1_radio, a_geo1_radio));\\n    float size = 2.+abs(((0.001*a_geo1_radio)-dist)*0.02);\\n\\n    gl_Position = projectionMatrix * mvPosition; //<------------------------------------------\\n    gl_PointSize = size*(uCamaraDistance/-mvPosition.z); //<------------------------------------------\\n\\n    v_color = a_geo1_color; \\n\\n}\\n\\n*//*\\nvec3 get_pos1(){\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(1.*a_geo1_dir*0.2);\\n    float x = cos(a_geo1_anguloRad)*a_geo1_radio;\\n    float y = sin(a_geo1_anguloRad)*a_geo1_radio;\\n    float z = 0.0;\\n    vec3 newPos = vec3(x, y, z);\\n    return newPos;\\n}\\n\\nfloat get_cosTime(float time, float radius){\\n    //\\n    //float value = sin(uTime)*2.*PI;\\n    float value = sin(time)*radius;\\n    return value;\\n}\\n\\nfloat get_x(float angleRad, float radius){\\n    return cos(angleRad)*a_geo1_radio;\\n}\\n\\n\\n\\nvoid main() {\\n\\n    vec3 pos1 = get_pos1();\\n    vec4 mvPosition = modelViewMatrix * vec4( pos1, 1.0 ); \\n\\n    float dist = distance(get_x(a_geo1_anguloRad, a_geo1_radio), get_cosTime(uTime*0.005*a_geo1_radio, a_geo1_radio));\\n    float size = 2.+abs(((0.001*a_geo1_radio)-dist)*0.02);\\n\\n    gl_Position = projectionMatrix * mvPosition; //<------------------------------------------\\n    gl_PointSize = size*(uCamaraDistance/-mvPosition.z); //<------------------------------------------\\n\\n    v_color = a_geo1_color; \\n\\n}\\n\\n*//*\\nvec3 get_pos1(){\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(1.*a_geo1_dir*0.2);\\n    float x = cos(a_geo1_anguloRad)*a_geo1_radio;\\n    float y = sin(a_geo1_anguloRad)*a_geo1_radio;\\n    float z = 0.0;\\n    vec3 newPos = vec3(x, y, z);\\n    return newPos;\\n}\\n\\nfloat get_cosTime(float time, float radius){\\n    //\\n    //float value = sin(uTime)*2.*PI;\\n    float value = sin(time)*radius;\\n    return value;\\n}\\n\\nfloat get_x(float angleRad, float radius){\\n    return cos(angleRad)*a_geo1_radio;\\n}\\n\\n\\n\\nvoid main() {\\n\\n    vec3 pos1 = get_pos1();\\n    vec4 mvPosition = modelViewMatrix * vec4( pos1, 1.0 ); \\n\\n    float dist = distance(get_x(a_geo1_anguloRad, a_geo1_radio), get_cosTime(uTime*0.005*a_geo1_radio, a_geo1_radio));\\n    float size = 2.+abs(((0.001*a_geo1_radio)-dist)*0.02);\\n\\n    gl_Position = projectionMatrix * mvPosition; //<------------------------------------------\\n    gl_PointSize = size*(uCamaraDistance/-mvPosition.z); //<------------------------------------------\\n\\n    v_color = a_geo1_color; \\n\\n}\\n\\n*/");\n;// CONCATENATED MODULE: ./app/src/js/webgl/home1_m/shaders/home1_dots_fragment_m.glsl\n/* harmony default export */ const home1_dots_fragment_m = ("#define GLSLIFY 1\\nvarying vec3 v_color;\\nvarying float v_pulseStrengthNorm1;\\nvarying float v_pulseStrengthNorm2;\\n\\nfloat circulizar(float radio){\\n    // radio es un valor entre 0 y 1. 0 es 0 de radio y 1 es el maximo del radio dentro de\\n    radio = 1.0-(0.5*radio);\\n    float result = distance(gl_PointCoord, vec2(0.5, 0.5));\\n    result = 1. -result;\\n    result = pow(result, 1.);\\n    result = step(radio, result);\\n    return result;\\n}\\n\\nvoid main() {\\n    vec3 white = vec3(1., 1., 1.);\\n    float pulse = v_pulseStrengthNorm1+v_pulseStrengthNorm2;\\n    pulse = clamp(pulse, 0., 1.);\\n    vec3 finalColor = v_color;\\n    //finalColor = mix(finalColor, white, pulse*5.);\\n    //finalColor = mix(finalColor, white, 0.);\\n    float alpha = circulizar(1.0);\\n\\n    gl_FragColor = vec4(finalColor, alpha*0.8);\\n}");\n;// CONCATENATED MODULE: ./app/src/js/webgl/home1_m/Home1Geometry_m.js\nfunction Home1Geometry_m_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Home1Geometry_m_typeof = function _typeof(obj) { return typeof obj; }; } else { Home1Geometry_m_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Home1Geometry_m_typeof(obj); }\n\nfunction Home1Geometry_m_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home1Geometry_m_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home1Geometry_m_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home1Geometry_m_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home1Geometry_m_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Home1Geometry_m_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Home1Geometry_m_setPrototypeOf(subClass, superClass); }\n\nfunction Home1Geometry_m_setPrototypeOf(o, p) { Home1Geometry_m_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Home1Geometry_m_setPrototypeOf(o, p); }\n\nfunction Home1Geometry_m_createSuper(Derived) { var hasNativeReflectConstruct = Home1Geometry_m_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Home1Geometry_m_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Home1Geometry_m_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Home1Geometry_m_possibleConstructorReturn(this, result); }; }\n\nfunction Home1Geometry_m_possibleConstructorReturn(self, call) { if (call && (Home1Geometry_m_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Home1Geometry_m_assertThisInitialized(self); }\n\nfunction Home1Geometry_m_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Home1Geometry_m_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Home1Geometry_m_getPrototypeOf(o) { Home1Geometry_m_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Home1Geometry_m_getPrototypeOf(o); }\n\n//import * as THREE from "three"\n//import gsap from "gsap"\n//import {GLTFLoader, GLTLoader} from "three/examples/jsm/loaders/GLTFLoader"\nvar Home1Geometry_m_EventEmitter = __webpack_require__(7187);\n\nvar Home1Geometry_m_Home1Geometry = /*#__PURE__*/function (_EventEmitter) {\n  Home1Geometry_m_inherits(Home1Geometry, _EventEmitter);\n\n  var _super = Home1Geometry_m_createSuper(Home1Geometry);\n\n  function Home1Geometry(obj) {\n    var _this;\n\n    Home1Geometry_m_classCallCheck(this, Home1Geometry);\n\n    //console.log("(Home1Geometry.CONSTRUCTORA)!")\n    _this = _super.call(this); //--\n\n    _this.factor = obj.factor; //6\n\n    _this.incr_radio = obj.incr_radio; //25\n\n    _this.numOrbits = obj.numOrbits; //37\n\n    _this.array_triangular = obj.array_triangular;\n    _this.array_dotPos = obj.array_dotPos;\n    _this.numDots = obj.numDots; //--\n\n    _this.arrayColores_RGB = [];\n    _this.arrayColores_RGB_01 = [];\n    _this.colorPos = 0;\n\n    _this._init_colors(); //--\n\n\n    _this.attributes = {\n      a_posiciones: new Float32Array(_this.numDots * 3),\n      a_color: new Float32Array(_this.numDots * 3),\n      a_orbital: new Float32Array(_this.numDots * 1),\n      a_pos_orbita: new Float32Array(_this.numDots * 1),\n      a_incr_anguloRad: new Float32Array(_this.numDots * 1),\n      a_anguloRad: new Float32Array(_this.numDots * 1),\n      a_radio: new Float32Array(_this.numDots * 1),\n      a_dir: new Float32Array(_this.numDots * 1),\n      a_incr: new Float32Array(_this.numDots * 1),\n      a_x: new Float32Array(_this.numDots * 1),\n      a_y: new Float32Array(_this.numDots * 1),\n      a_z: new Float32Array(_this.numDots * 1)\n    }; //--\n\n    for (var i = 0; i < _this.array_dotPos.length; i++) {\n      var dotPos = _this.array_dotPos[i];\n\n      var dot = _this._get_dot(dotPos);\n\n      var i3 = i * 3;\n      _this.attributes.a_posiciones[i3] = dot.x;\n      _this.attributes.a_posiciones[i3 + 1] = dot.y;\n      _this.attributes.a_posiciones[i3 + 2] = dot.z; //--\n\n      _this.attributes.a_color[i3] = dot.color[0];\n      _this.attributes.a_color[i3 + 1] = dot.color[1];\n      _this.attributes.a_color[i3 + 2] = dot.color[2]; //--\n\n      _this.attributes.a_orbital[i] = dot.orbital;\n      _this.attributes.a_pos_orbita[i] = dot.pos_orbita;\n      _this.attributes.a_incr_anguloRad[i] = dot.incr_anguloRad;\n      _this.attributes.a_anguloRad[i] = dot.anguloRad;\n      _this.attributes.a_radio[i] = dot.radio;\n      _this.attributes.a_dir[i] = dot.dir;\n      _this.attributes.a_incr[i] = dot.incr;\n      _this.attributes.a_x[i] = dot.y;\n      _this.attributes.a_y[i] = dot.y;\n      _this.attributes.a_z[i] = dot.z;\n    } //--\n\n\n    _this.loaded = false;\n    return _this;\n  } //------------------------------------------\n  // PRIVADAS\n\n\n  Home1Geometry_m_createClass(Home1Geometry, [{\n    key: "_get_dot",\n    value: function _get_dot(num) {\n      // Devuelve un objeto con la información de un punto de la geometria "orbital MIOTI"\n      var obj = {\n        num: num,\n        color: this._get_color(),\n        x: 0,\n        y: 0,\n        z: 0,\n        orbital: 0,\n        co_orbitantes: 0,\n        pos_orbita: 0,\n        incr_anguloRad: 0,\n        anguloRad: 0,\n        radio: 0\n      }; //--\n\n      for (var i = 0; i <= this.array_triangular.length; i++) {\n        var limSup = this.array_triangular[i]; //console.log("limSup: "+limSup)\n\n        if (num > limSup) {\n          // console.log("*")\n          obj.orbital = i + 1;\n          obj.co_orbitantes = (i + 1) * this.factor;\n          obj.pos_orbita = num - limSup - 1;\n          obj.incr_anguloRad = 2 * Math.PI / obj.co_orbitantes;\n\n          if (obj.orbital % 2 == 0) {\n            obj.dir = 1;\n            obj.incr = 0;\n            obj.anguloRad = obj.pos_orbita * obj.incr_anguloRad;\n          } else {\n            obj.dir = -1;\n            obj.incr = 1;\n            obj.anguloRad = obj.pos_orbita * obj.incr_anguloRad + obj.incr_anguloRad / 2;\n          }\n\n          obj.radio = obj.orbital * this.incr_radio; //--\n\n          obj.x = Math.cos(obj.anguloRad) * obj.radio;\n          obj.y = Math.sin(obj.anguloRad) * obj.radio;\n          obj.z = 0;\n        } //break\n\n      }\n\n      return obj;\n    }\n  }, {\n    key: "_get_color",\n    value: function _get_color() {\n      var color_RGB_01 = this.arrayColores_RGB_01[this.colorPos];\n      this.colorPos++;\n\n      if (this.colorPos > this.arrayColores_RGB_01.length - 1) {\n        this.colorPos = 0;\n      }\n\n      return color_RGB_01;\n    }\n  }, {\n    key: "_init_colors",\n    value: function _init_colors() {\n      this.arrayColores_RGB = [];\n      this.arrayColores_RGB.push([255, 87, 131]); // Rosa\n\n      this.arrayColores_RGB.push([89, 2, 2]);\n      this.arrayColores_RGB.push([1, 3, 49]);\n      this.arrayColores_RGB.push([0, 16, 116]);\n      this.arrayColores_RGB.push([14, 133, 255]);\n      this.arrayColores_RGB_01 = [];\n\n      for (var i = 0; i < this.arrayColores_RGB.length; i++) {\n        var color_RGB = this.arrayColores_RGB[i];\n        var color_RGB_01 = [color_RGB[0] / 255, color_RGB[1] / 255, color_RGB[2] / 255];\n        this.arrayColores_RGB_01.push(color_RGB_01);\n      }\n    }\n  }]);\n\n  return Home1Geometry;\n}(Home1Geometry_m_EventEmitter);\n\n/* harmony default export */ const Home1Geometry_m = (Home1Geometry_m_Home1Geometry);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home1_m/Home1Dots_m.js\nfunction Home1Dots_m_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home1Dots_m_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home1Dots_m_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home1Dots_m_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home1Dots_m_defineProperties(Constructor, staticProps); return Constructor; }\n\n //import gsap from "gsap"\n\n\n //import vertex_bg from "./shaders/home1_background_vertex.glsl"\n//import fragment_bg from "./shaders/home1_background_fragment.glsl"\n\n\n\n\nvar Home1Dots_m_Home1Dots = /*#__PURE__*/function () {\n  function Home1Dots(obj) {\n    Home1Dots_m_classCallCheck(this, Home1Dots);\n\n    //console.log("(Home1Dots.CONSTRUCTORA)!")\n    //console.log(obj)\n    this.app = obj.app; //--\n\n    this.scene = this.app.scene;\n    this.cameraDistance = this.app.cameraDistance; //--\n\n    this.material = null;\n    this.geometry = null;\n    this.mesh = null;\n    this.created = false;\n    this.clock = new three_module/* Clock */.SUY(); //--\n    //this.eased_scrollDelta_fast = new EasedOutValue(this.app.scrollData.normalizedDelta*0.5, 0.1)\n    //--\n\n    this._setup_settings(); //--\n\n\n    this.orbital_geometry = new Home1Geometry_m(this.settings); //--\n    //this._create()\n  } //------------------------------------\n  // PUBLICAS: \n\n\n  Home1Dots_m_createClass(Home1Dots, [{\n    key: "init",\n    value: function init() {\n      this.eased_scrollDelta_fast = new webgl_EasedOutValue(this.app.scrollData.normalizedDelta * 0.5, 0.1);\n\n      this._create();\n    } //------------------------------------\n\n  }, {\n    key: "render",\n    value: function render() {\n      if (this.created) {\n        this.material.uniforms.uTime.value = this.clock.getElapsedTime();\n        this.material.uniforms.uCamaraDistance.value = this.app.cameraDistance;\n        this.material.uniforms.uOpenProgress.value = this.settings.openProgress;\n        this.material.uniforms.uResponsiveScale.value = this.app.responsiveScale; //this.material.uniforms.u_scroll_factordDelta.value = this.app.scrollData.factordDelta\n        //this.material.uniforms.u_scroll_direction.value = this.app.scrollData.direction\n\n        this.material.uniforms.uScrollDelta.value = -this.eased_scrollDelta_fast.get(this.app.scrollData.normalizedDelta * 0.5); //--\n\n        var extraSpeed = 1 + Math.abs(this.eased_scrollDelta_fast.get(this.app.scrollData.normalizedDelta * 0.5) * 10);\n        this.settings.rotation1 += this.settings.speedRotation1 * extraSpeed;\n        this.settings.rotation2 += this.settings.speedRotation2 * extraSpeed;\n        this.settings.rotation3 += this.settings.speedRotation3 * extraSpeed;\n        this.material.uniforms.uRotation1.value = this.settings.rotation1;\n        this.material.uniforms.uRotation2.value = -this.settings.rotation2;\n        this.material.uniforms.uRotation3.value = this.settings.rotation3; //console.log(this.material.uniforms.uRotation1.value)\n      }\n    } //------------------------------------\n    // PUBLICAS:\n\n  }, {\n    key: "resize",\n    value: function resize(newWidth, newHeight) {//console.log("(GradientBackground.resize)!")\n    } //------------------------------------\n    // PRIVADAS: \n\n  }, {\n    key: "_setup_settings",\n    value: function _setup_settings() {\n      //console.log("(Home1Dots._setup_settings)!!")\n      var speedBase = 0.002;\n      this.settings = {\n        factor: 6,\n        //incr_radio: 25,\n        incr_radio: 13.2,\n        numOrbits: 19,\n        //arrayOrbits: [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,  17, 18, 19],\n        arrayOrbits: [10, 14, 18],\n        //arrayOrbits: [1, 3, 4, 5],\n        // Ortbit rotation\n        rotation1: 0,\n        speedRotation1: 3 * speedBase,\n        rotation2: 2,\n        speedRotation2: 2 * speedBase,\n        rotation3: 0,\n        speedRotation3: 1 * speedBase\n      };\n      this.settings.array_triangular = this._get_array_triangular(this.settings.factor, this.settings.numOrbits);\n      this.settings.array_triangular_dots_x_orbita = this._get_array_triangular_dots_x_orbita(this.settings.array_triangular, this.settings.arrayOrbits);\n      this.settings.array_dotPos = this._get_array_dotPos(this.settings.arrayOrbits, this.settings.array_triangular, this.settings.array_triangular_dots_x_orbita);\n      this.settings.numDots = this.settings.array_dotPos.length;\n      this.settings.openProgress = 0;\n    }\n  }, {\n    key: "_create",\n    value: function _create() {\n      //console.log("(Home1Dots._create)!")\n      //--\n      this.material = new three_module/* ShaderMaterial */.jyz({\n        depthWrite: false,\n        //blending: THREE.AdditiveBlending,\n        vertexColors: true,\n        vertexShader: home1_dots_vertex_m,\n        fragmentShader: home1_dots_fragment_m,\n        transparent: true,\n        uniforms: {\n          uCamaraDistance: {\n            value: this.app.cameraDistance\n          },\n          uTime: {\n            value: 0\n          },\n          //uScale:{value: 1},\n          uOpenProgress: {\n            value: 0\n          },\n          uResponsiveScale: {\n            value: 0\n          },\n          //u_scroll_factordDelta: {value: 1},\n          //u_scroll_direction: {value: 1},\n          uScrollDelta: {\n            value: 0\n          },\n          uRotation1: {\n            value: 0\n          },\n          uRotation2: {\n            value: 0\n          },\n          uRotation3: {\n            value: 0\n          }\n        }\n      }); //--\n      //console.log(this.orbital_geometry.attributes.a_color)\n      //--\n\n      this.geometry = new three_module/* BufferGeometry */.u9r();\n      this.geometry.setAttribute(\'position\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_geo1_position\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_geo1_color\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_color, 3));\n      this.geometry.setAttribute(\'a_geo1_orbital\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_orbital, 1));\n      this.geometry.setAttribute(\'a_geo1_pos_orbita\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_pos_orbita, 1));\n      this.geometry.setAttribute(\'a_geo1_incr_anguloRad\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_incr_anguloRad, 1));\n      this.geometry.setAttribute(\'a_geo1_anguloRad\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_anguloRad, 1));\n      this.geometry.setAttribute(\'a_geo1_radio\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_radio, 1));\n      this.geometry.setAttribute(\'a_geo1_dir\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_dir, 1));\n      this.geometry.setAttribute(\'a_geo1_incr\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_incr, 1));\n      this.geometry.setAttribute(\'a_geo1_x\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_x, 1));\n      this.geometry.setAttribute(\'a_geo1_y\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_y, 1));\n      this.geometry.setAttribute(\'a_geo1_z\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_z, 1));\n      this.mesh = new three_module/* Points */.woe(this.geometry, this.material);\n      this.scene.add(this.mesh);\n      this.created = true;\n    }\n  }, {\n    key: "_get_array_dotPos",\n    value: function _get_array_dotPos(_arrayOrbits, _array_triangular, _array_triangular_dots_x_orbita) {\n      var miArray = [];\n\n      for (var i = 0; i < _arrayOrbits.length; i++) {\n        var orbitNum = _arrayOrbits[i];\n        var dots_x_orbit = _array_triangular_dots_x_orbita[i];\n        var dotNum_base = _array_triangular[_arrayOrbits[i] - 1]; // console.log("orbitNum: "+orbitNum)\n        // console.log("dots_x_orbit: "+dots_x_orbit)\n        // console.log("dotNum_base: "+dotNum_base)\n\n        for (var j = 0; j < dots_x_orbit; j++) {\n          miArray.push(dotNum_base + j + 1);\n        }\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_get_numDots",\n    value: function _get_numDots(_array_triangular_dots_x_orbita) {\n      var numDots = 0;\n\n      for (var i = 0; i <= _array_triangular_dots_x_orbita.length - 1; i++) {\n        numDots += _array_triangular_dots_x_orbita[i];\n      }\n\n      return numDots;\n    }\n  }, {\n    key: "_get_array_triangular_dots_x_orbita",\n    value: function _get_array_triangular_dots_x_orbita(_array_triangular, _arrayOrbits) {\n      // Genera una array basada en la progresión triangular (* factor).\n      // ... donde se indica el numero de dots por orbital\n      // Una progresión triangular es: 1, 3, 6, 10, 15 (https://significativa.org/diccionarios/numeros-figurados/#:~:text=3.1.1.1.-,Definici%C3%B3n,anterior%20no%20obtenemos%20una%20constante.)\n      var miArray = [];\n\n      for (var i = 0; i <= _arrayOrbits.length - 1; i++) {\n        //array_numTriagulares.push(i*(i+1)/2)\n        var numDots_orbita_actual = _array_triangular[_arrayOrbits[i]];\n        var numDots_orbita_anterior = _array_triangular[_arrayOrbits[i] - 1];\n        var numDots_orbita = numDots_orbita_actual - numDots_orbita_anterior;\n        miArray.push(numDots_orbita);\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_get_array_triangular",\n    value: function _get_array_triangular(_factor, _numObits) {\n      // Genera una array de progresión triangular (* factor).\n      // Una progresión triangular es: 1, 3, 6, 10, 15 (https://significativa.org/diccionarios/numeros-figurados/#:~:text=3.1.1.1.-,Definici%C3%B3n,anterior%20no%20obtenemos%20una%20constante.)\n      var miArray = [];\n\n      for (var i = 0; i <= _numObits; i++) {\n        //array_numTriagulares.push(i*(i+1)/2)\n        miArray.push(i * (i + 1) / 2 * _factor);\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_setup_gui",\n    value: function _setup_gui() {//console.log("(Home1Dots._setup_gui)!")\n      // this.gui = new dat.GUI();\n      // this.gui.width = 400\n      // const folder0 = this.gui.addFolder("Orbit spinning")\n      // folder0.add(this.settings, "progress5", 0, 10, 0.01).name("Progress")\n      // folder0.open()\n    } //---------------------------------------------------------\n    //---------------------------------------------------------\n\n  }]);\n\n  return Home1Dots;\n}();\n\n/* harmony default export */ const Home1Dots_m = (Home1Dots_m_Home1Dots);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home1_m/Home1App_m.js\nfunction Home1App_m_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home1App_m_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home1App_m_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home1App_m_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home1App_m_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n //--\n\n\n\nvar Home1App_m = /*#__PURE__*/function () {\n  function Home1App_m(obj) {\n    Home1App_m_classCallCheck(this, Home1App_m);\n\n    // console.log("(Home1App_m.CONSTRUCTORA)!!", obj) \n    this.hw_renderer = obj.renderer; // Rederer/pagina de HighWay. No confundir con el render/renderer de Three.js\n\n    this.$container = obj.domElement; //--\n\n    this.$inner = document.querySelector(\'.inner\'); //--\n\n    this.REF_RESOLUTION = {\n      width: 480,\n      height: 480\n    };\n    this.REF_CAMERA_DISTANCE = 500; //--\n\n    this.width;\n    this.height;\n    this.responsiveScale;\n    this.cameraDistance; //--\n    //--\n    //this.scrollData = new Home1Scroll_m({\n    //    app:this,\n    //    $inner: this.$inner\n    //})\n    //--\n\n    this._update_dimensions(); //--\n    // Scene\n\n\n    this.scene = new three_module/* Scene */.xsS(); //this.scene.background = new THREE.Color( 0x00ff00 );\n    //--\n    // console.log("this.width: "+this.width)\n    // console.log("this.height: "+this.height)\n    // console.log("this.cameraDistance: "+this.cameraDistance)\n    //--\n    // Camera\n    //PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )\n\n    this.camera = new three_module/* PerspectiveCamera */.cPb(30, this.width / this.height, 0.1, 2000);\n    this.camera.position.z = this.cameraDistance;\n    this.camera.fov = 2 * Math.atan(this.height / 2 / this.cameraDistance) * (180 / Math.PI); //--\n    // Renderer\n    //--\n\n    this.renderer = new three_module/* WebGL1Renderer */.b5g({\n      antialias: true,\n      alpha: true\n    }); //this.renderer.autoClear = false // Vamos a usar 2 scenas (una para el background y otra para los puntos) que implicarán usar 2 acciones de render. Con autoclear false permitimos que la segunda no borre la primera.\n\n    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1)); //this.renderer.setClearColorHex( 0xff0000, 1 );\n    //--\n\n    this.$container.appendChild(this.renderer.domElement); //--\n\n    this.dots = new Home1Dots_m({\n      app: this\n    }); //--\n    //this._createcube(this.scene)\n\n    this._resize(); //this._render();\n\n  } //---------------------------\n  // PUBLICAS:\n\n\n  Home1App_m_createClass(Home1App_m, [{\n    key: "init",\n    value: function init() {\n      this.$inner = document.querySelector(\'.inner\');\n      this.scrollData = new home1_m_Home1Scroll_m({\n        app: this,\n        $inner: this.$inner\n      }); //--\n\n      this.dots.init(); //--\n\n      this._render();\n    }\n  }, {\n    key: "kill",\n    value: function kill() {\n      this.scrollData.kill();\n      this.scrollData = null;\n      this.dots = null;\n    } //---------------------------\n\n  }, {\n    key: "render",\n    value: function render() {\n      //console.log("(Home1App_m.render)!")\n      this._render(); // Lo llama scrollData\n\n    }\n  }, {\n    key: "resize",\n    value: function resize() {\n      //console.log("(Home1App_m.resize)!")\n      this._resize();\n    } //---------------------------\n    // PRIVADAS:\n\n  }, {\n    key: "_update_dimensions",\n    value: function _update_dimensions() {\n      // console.log("(Home1App_m._update_dimensions)!", this.renderer)\n      this.width = this.$container.offsetWidth;\n      this.height = this.$container.offsetHeight;\n      this.responsiveScale = this.width / this.REF_RESOLUTION.width;\n      this.cameraDistance = this.REF_CAMERA_DISTANCE * this.responsiveScale; //--\n\n      if (this.renderer) {\n        this.renderer.setSize(this.width, this.height); //--\n\n        this.camera.aspect = this.width / this.height;\n        this.cameraDistance = this.camera.position.z;\n        this.camera.fov = 2 * Math.atan(this.height / 2 / this.cameraDistance) * (180 / Math.PI);\n        this.camera.updateProjectionMatrix();\n      } //--\n\n    }\n  }, {\n    key: "_resize",\n    value: function _resize() {\n      //console.log("(Home1App_m._resize)!!")\n      this._update_dimensions(); //--\n\n\n      if (this.dots) {//this.dots.resize(this.width, this.height);\n      }\n    }\n  }, {\n    key: "_render",\n    value: function _render() {\n      //console.log("(Home1App_m._render)!")\n      if (this.height != this.$container.offsetHeight || this.width != this.$container.offsetWidth) {\n        this._resize();\n      }\n\n      if (this.dots) {\n        this.dots.render();\n      }\n\n      this.renderer.render(this.scene, this.camera);\n    }\n  }, {\n    key: "_createcube",\n    value: function _createcube(_scene) {\n      var geometry = new three_module/* BoxGeometry */.DvJ(100, 100, 100);\n      var material = new three_module/* MeshBasicMaterial */.vBJ({\n        color: 0xff0000\n      });\n      var cube = new three_module/* Mesh */.Kj0(geometry, material); //cube.position.set(100, 100, 100)\n\n      _scene.add(cube);\n    }\n  }]);\n\n  return Home1App_m;\n}();\n\n/* harmony default export */ const home1_m_Home1App_m = (Home1App_m);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home2_m/Home2Scroll_m.js\nfunction Home2Scroll_m_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home2Scroll_m_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home2Scroll_m_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home2Scroll_m_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home2Scroll_m_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar Home2Scroll_m = /*#__PURE__*/function () {\n  function Home2Scroll_m(obj) {\n    Home2Scroll_m_classCallCheck(this, Home2Scroll_m);\n\n    // console.log("(Home2Scroll_m.CONSTRUCTORA): ", obj)\n    this.app = obj.app;\n    this.$inner = obj.$inner; //--\n\n    this.lastInnerY = 0; // Ultima posición del elemento de referencia\n\n    this.delta = 0; // Incremento de pixels del scroll\n\n    this.limitedDelta = 0; // Limita los valores a -20 -> +20\n\n    this.normalizedDelta = 0; // Pasa el delta a -1 -> +1\n\n    this.factordDelta = 1; // Valores absolutos de 0 -> 1\n\n    this.direction = 1; // Direccion del delta. 1 si está parado\n    //--\n\n    this.triggers = {}; //--\n\n    this.progress = {};\n    this.progress.$inner = 0; //--\n\n    this._init_$inner();\n  } //------------\n  // PUBLICAS:\n\n\n  Home2Scroll_m_createClass(Home2Scroll_m, [{\n    key: "kill",\n    value: function kill() {\n      this.triggers.$inner.kill();\n      node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this._binded_render);\n      node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this._binded_eval_scroll);\n    } //------------\n    // PRIVADAS\n\n  }, {\n    key: "_init_$inner",\n    value: function _init_$inner() {\n      var _this = this;\n\n      var binded_render = function binded_render() {\n        _this.app.render();\n      };\n\n      var binded_eval_scroll = function binded_eval_scroll() {\n        _this._update_$inner(_this.triggers.$inner.progress);\n      };\n\n      this._binded_render = binded_render;\n      this._binded_eval_scroll = binded_eval_scroll; //--\n\n      this.triggers.$inner = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$inner,\n        start: \'top bottom\',\n        end: \'bottom bottom\',\n        scrub: true,\n        // Scrub: Genera eventos en una franja mas que en un punto.\n        // markers: true,\n        onToggle: function onToggle(self) {\n          if (self.isActive) {\n            node_modules_gsap/* default.ticker.add */.ZP.ticker.add(binded_render);\n            node_modules_gsap/* default.ticker.add */.ZP.ticker.add(binded_eval_scroll);\n          } else {\n            node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(binded_render);\n            node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(binded_eval_scroll);\n          }\n        }\n      });\n    }\n  }, {\n    key: "_update_$inner",\n    value: function _update_$inner(progress) {\n      this.progress.$inner = progress; //--\n\n      var innerData = this.$inner.getBoundingClientRect();\n      var newInnerY = innerData.y;\n      this.delta = newInnerY - this.lastInnerY;\n      this.lastInnerY = newInnerY;\n      this.limitedDelta = webgl_WebGLUtils.clamp(this.delta, -20, 20); // Limita los valores a -20 -> +20\n\n      this.normalizedDelta = (this.limitedDelta / 20).toFixed(3); // Pasa el delta a -1 -> +1\n\n      this.factordDelta = Math.abs(this.normalizedDelta) + 0; // Valores absolutos de 0 -> 1\n\n      this.direction = 1;\n\n      if (this.normalizedDelta < 0) {\n        this.scroll_direction = -1;\n      }\n    }\n  }]);\n\n  return Home2Scroll_m;\n}();\n\n/* harmony default export */ const home2_m_Home2Scroll_m = (Home2Scroll_m);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home2_m/shaders/home2_dots_vertex_m.glsl\n/* harmony default export */ const home2_dots_vertex_m = ("#define GLSLIFY 1\\nattribute vec3 a_randomness;\\nattribute vec3 a_geo1_position;\\nattribute vec3 a_geo1_color;\\nattribute float a_geo1_anguloRad;\\nattribute float a_geo1_orbital;\\nattribute float a_geo1_pos_orbita;\\nattribute float a_geo1_incr_anguloRad;\\nattribute float a_geo1_incr;\\nattribute float a_geo1_dir;\\nattribute float a_geo1_radio;\\n\\nuniform float uCamaraDistance;\\nuniform float uTime;\\nuniform float uOpenProgress;\\nuniform float uResponsiveScale;\\n\\nuniform float uScrollDelta;\\nuniform float uRotation1;\\nuniform float uRotation2;\\nuniform float uRotation3;\\nuniform vec3 uDotColor;\\n//uniform float uScale;\\n\\nvarying vec3 v_color;\\nvarying float v_pulseStrengthNorm1;\\nvarying float v_pulseStrengthNorm2;\\n\\n//\\tClassic Perlin 3D Noise \\n//\\tby Stefan Gustavson\\n//\\n\\n#define PI 3.1415926538\\n//#define PI 3.1415926535897932384626433832795\\n\\nvec3 get_pos1(float anguloRad){\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(1.*a_geo1_dir*0.2);\\n    float x = cos(anguloRad)*a_geo1_radio;\\n    float y = sin(anguloRad)*a_geo1_radio;\\n    float z = 0.0;\\n    vec3 newPos = vec3(x, y, z);\\n    return newPos;\\n}\\n\\nfloat get_openScale(){\\n    return mix(1., 8., uOpenProgress);\\n}\\n\\nvec3 get_openFx( vec3 pos){\\n    //float openScale = mix(1., 8., uOpenProgress);\\n    vec3 posFx = pos*get_openScale();\\n    return posFx;\\n}\\n\\nfloat get_cosTime(float time, float radius){\\n    //\\n    //float value = sin(uTime)*2.*PI;\\n    float value = sin(time)*radius;\\n    return value;\\n}\\n\\nfloat get_x(float angleRad, float radius){\\n    return cos(angleRad)*a_geo1_radio;\\n}\\n\\nfloat get_pulseStrengthNorm( float direction){\\n    float dotAguleNorm = a_geo1_anguloRad/(2.*PI); // Pasamos el angulo del punto que está en radianes a un valor de 0 a 1.\\n\\n    float modSpeed = mix(1., 2.5, 13./a_geo1_orbital)*direction;\\n    float radialSpeed = uTime*0.02*modSpeed; // Modificamos uTime para determinar la velocidad radial.\\n\\n    float pulseAngleRad = radialSpeed*(4.*PI);\\n\\n    // El valor de pulseAngleRad debe estar entre 0 y 2PI (inicio y fin de una circunferencia).\\n    // Como depende de uTime el valor saldrá de ese rango pronto por lo que tomaremos el resto (modulo),\\n    // de dividir pulseAngleRad por 2PI.\\n    if(pulseAngleRad > 2.*PI){\\n        pulseAngleRad = mod(pulseAngleRad, (2.*PI));\\n    }\\n    if(pulseAngleRad < 0.){\\n        pulseAngleRad = mod(pulseAngleRad, (2.*PI));\\n    }\\n\\n    float pulseAngleNorm = pulseAngleRad/(2.*PI); // Normalizamos el valor (de 0 a 1)\\n\\n    float distAngleNorm = abs(pulseAngleNorm-dotAguleNorm); // Calculamos la distancia radial del pulso al punto\\n\\n    // Apañamos la distancia de tal forma que no le afecte el punto de discontinuidad OPI = 2PI\\n    if(distAngleNorm > 0.5){ \\n        distAngleNorm = 0.5-(distAngleNorm-0.5);\\n    }\\n\\n    // La maxima distancia es de medio circulo y en terminos normalizados es 0.5\\n    // Creamos una variable que normalice ese valor entre 0 y 1.\\n    float pulseStrengthNorm  = distAngleNorm*2.; \\n\\n    float pico = 0.92;\\n    pico = mix(pico*0.99, pico*1.01, a_geo1_orbital/13.);\\n\\n    // Nos interesa solo el pico, la zona que va entre 0.95 y 1.\\n    // Toodo lo que haya por debajo de 0.95 lo pasamos a 0.95\\n    // y le restamos ese mismo 0.95 para quedarnos con el pico de 0.05 eol cual amplificamos x20 para normalizarlo (de 0 a 1).\\n    pulseStrengthNorm = (clamp(pulseStrengthNorm, pico, 1.)-pico)*10.;\\n    //--\\n    return pulseStrengthNorm;\\n}\\n\\nvoid main() {\\n\\n    //float direction = 1.;\\n    //if(abs(a_geo1_orbital - 13.) < 0.5){ // 13 es el orbital del medio\\n    //    direction = -1.;\\n    //}\\n\\n    //float longPeriod = sin(uTime);\\n    // longPeriod = clamp(longPeriod, 0., 1.);\\n    // longPeriod = 1.;\\n\\n    float pulseStrengthNorm1 = get_pulseStrengthNorm(1.5);\\n    float pulseStrengthNorm2 = get_pulseStrengthNorm(-1.);\\n\\n    \\n\\n    // Determinamos el tamaño del punto teniendo un minimo de 5 y amplificando el maximo para que visualmente sea bonito\\n    //float size = 5.+(pulseStrengthNorm*15.*longPeriod);\\n    float size = 3.;\\n    //size += (pulseStrengthNorm1*5.);\\n    //size += (pulseStrengthNorm2*5.);\\n    size *= uResponsiveScale;\\n    size *= get_openScale();\\n\\n    float anguloRad_time = 0.;\\n    if(abs(a_geo1_orbital-8.) < 0.5){ // Detecta el orbital 6\\n        anguloRad_time = a_geo1_anguloRad+uRotation1;\\n    }else if(abs(a_geo1_orbital-13.) < 0.5){ // Detecta el orbital 11\\n        anguloRad_time = a_geo1_anguloRad+uRotation2;\\n    }else if(abs(a_geo1_orbital-18.) < 0.5){ // Detecta el orbital 13\\n        anguloRad_time = a_geo1_anguloRad+uRotation3;\\n    }\\n    \\n\\n    //float rotationSpeed = (a_geo1_orbital/13.);\\n    //float rotationSpeed = (13./a_geo1_orbital);\\n    //rotationSpeed *= -u_scroll_factordDelta;\\n    //float anguloRad_time = a_geo1_anguloRad+(rotationSpeed*0.5)+(direction*uTime*0.2);\\n    vec3 pos1 = get_pos1(anguloRad_time);\\n    pos1 = get_openFx(pos1);\\n    pos1 = pos1 *uResponsiveScale;\\n    //pos1 = pos1 * (1.+(u_scroll_factordDelta*0.2));\\n    //vec3 pos2 = pos1*1.0;\\n    //pos1= mix(pos1, pos2, pulseStrengthNorm);\\n    vec4 mvPosition = modelViewMatrix * vec4( pos1, 1.0 ); \\n\\n    gl_Position = projectionMatrix * mvPosition; //<--------------------------------------------------\\n    gl_PointSize = size*(uCamaraDistance/-mvPosition.z); //<------------------------------------------\\n\\n    //--------------------------------------\\n    // VARYINGS:\\n    v_color = a_geo1_color; \\n   //v_pulseStrengthNorm1 = pulseStrengthNorm1; \\n    //v_pulseStrengthNorm2 = pulseStrengthNorm2; \\n\\n}\\n\\n/*\\nvec3 get_pos1(){\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(1.*a_geo1_dir*0.2);\\n    float x = cos(a_geo1_anguloRad)*a_geo1_radio;\\n    float y = sin(a_geo1_anguloRad)*a_geo1_radio;\\n    float z = 0.0;\\n    vec3 newPos = vec3(x, y, z);\\n    return newPos;\\n}\\n\\nfloat get_cosTime(float time, float radius){\\n    //\\n    //float value = sin(uTime)*2.*PI;\\n    float value = sin(time)*radius;\\n    return value;\\n}\\n\\nfloat get_x(float angleRad, float radius){\\n    return cos(angleRad)*a_geo1_radio;\\n}\\n\\n\\n\\nvoid main() {\\n\\n    vec3 pos1 = get_pos1();\\n    vec4 mvPosition = modelViewMatrix * vec4( pos1, 1.0 ); \\n\\n    float dist = distance(get_x(a_geo1_anguloRad, a_geo1_radio), get_cosTime(uTime*0.005*a_geo1_radio, a_geo1_radio));\\n    float size = 2.+abs(((0.001*a_geo1_radio)-dist)*0.02);\\n\\n    gl_Position = projectionMatrix * mvPosition; //<------------------------------------------\\n    gl_PointSize = size*(uCamaraDistance/-mvPosition.z); //<------------------------------------------\\n\\n    v_color = a_geo1_color; \\n\\n}\\n\\n*//*\\nvec3 get_pos1(){\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(1.*a_geo1_dir*0.2);\\n    float x = cos(a_geo1_anguloRad)*a_geo1_radio;\\n    float y = sin(a_geo1_anguloRad)*a_geo1_radio;\\n    float z = 0.0;\\n    vec3 newPos = vec3(x, y, z);\\n    return newPos;\\n}\\n\\nfloat get_cosTime(float time, float radius){\\n    //\\n    //float value = sin(uTime)*2.*PI;\\n    float value = sin(time)*radius;\\n    return value;\\n}\\n\\nfloat get_x(float angleRad, float radius){\\n    return cos(angleRad)*a_geo1_radio;\\n}\\n\\n\\n\\nvoid main() {\\n\\n    vec3 pos1 = get_pos1();\\n    vec4 mvPosition = modelViewMatrix * vec4( pos1, 1.0 ); \\n\\n    float dist = distance(get_x(a_geo1_anguloRad, a_geo1_radio), get_cosTime(uTime*0.005*a_geo1_radio, a_geo1_radio));\\n    float size = 2.+abs(((0.001*a_geo1_radio)-dist)*0.02);\\n\\n    gl_Position = projectionMatrix * mvPosition; //<------------------------------------------\\n    gl_PointSize = size*(uCamaraDistance/-mvPosition.z); //<------------------------------------------\\n\\n    v_color = a_geo1_color; \\n\\n}\\n\\n*//*\\nvec3 get_pos1(){\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(1.*a_geo1_dir*0.2);\\n    float x = cos(a_geo1_anguloRad)*a_geo1_radio;\\n    float y = sin(a_geo1_anguloRad)*a_geo1_radio;\\n    float z = 0.0;\\n    vec3 newPos = vec3(x, y, z);\\n    return newPos;\\n}\\n\\nfloat get_cosTime(float time, float radius){\\n    //\\n    //float value = sin(uTime)*2.*PI;\\n    float value = sin(time)*radius;\\n    return value;\\n}\\n\\nfloat get_x(float angleRad, float radius){\\n    return cos(angleRad)*a_geo1_radio;\\n}\\n\\n\\n\\nvoid main() {\\n\\n    vec3 pos1 = get_pos1();\\n    vec4 mvPosition = modelViewMatrix * vec4( pos1, 1.0 ); \\n\\n    float dist = distance(get_x(a_geo1_anguloRad, a_geo1_radio), get_cosTime(uTime*0.005*a_geo1_radio, a_geo1_radio));\\n    float size = 2.+abs(((0.001*a_geo1_radio)-dist)*0.02);\\n\\n    gl_Position = projectionMatrix * mvPosition; //<------------------------------------------\\n    gl_PointSize = size*(uCamaraDistance/-mvPosition.z); //<------------------------------------------\\n\\n    v_color = a_geo1_color; \\n\\n}\\n\\n*//*\\nvec3 get_pos1(){\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(1.*a_geo1_dir*0.2);\\n    float x = cos(a_geo1_anguloRad)*a_geo1_radio;\\n    float y = sin(a_geo1_anguloRad)*a_geo1_radio;\\n    float z = 0.0;\\n    vec3 newPos = vec3(x, y, z);\\n    return newPos;\\n}\\n\\nfloat get_cosTime(float time, float radius){\\n    //\\n    //float value = sin(uTime)*2.*PI;\\n    float value = sin(time)*radius;\\n    return value;\\n}\\n\\nfloat get_x(float angleRad, float radius){\\n    return cos(angleRad)*a_geo1_radio;\\n}\\n\\n\\n\\nvoid main() {\\n\\n    vec3 pos1 = get_pos1();\\n    vec4 mvPosition = modelViewMatrix * vec4( pos1, 1.0 ); \\n\\n    float dist = distance(get_x(a_geo1_anguloRad, a_geo1_radio), get_cosTime(uTime*0.005*a_geo1_radio, a_geo1_radio));\\n    float size = 2.+abs(((0.001*a_geo1_radio)-dist)*0.02);\\n\\n    gl_Position = projectionMatrix * mvPosition; //<------------------------------------------\\n    gl_PointSize = size*(uCamaraDistance/-mvPosition.z); //<------------------------------------------\\n\\n    v_color = a_geo1_color; \\n\\n}\\n\\n*/");\n;// CONCATENATED MODULE: ./app/src/js/webgl/home2_m/shaders/home2_dots_fragment_m.glsl\n/* harmony default export */ const home2_dots_fragment_m = ("#define GLSLIFY 1\\nuniform vec3 uDotColor;\\n\\nvarying vec3 v_color;\\nvarying float v_pulseStrengthNorm1;\\nvarying float v_pulseStrengthNorm2;\\n\\nfloat circulizar(float radio){\\n    // radio es un valor entre 0 y 1. 0 es 0 de radio y 1 es el maximo del radio dentro de\\n    radio = 1.0-(0.5*radio);\\n    float result = distance(gl_PointCoord, vec2(0.5, 0.5));\\n    result = 1. -result;\\n    result = pow(result, 1.);\\n    result = step(radio, result);\\n    return result;\\n}\\n\\nvoid main() {\\n    float alpha = circulizar(1.0);\\n    gl_FragColor = vec4(uDotColor, alpha);\\n}");\n;// CONCATENATED MODULE: ./app/src/js/webgl/home2_m/Home2Geometry_m.js\nfunction Home2Geometry_m_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Home2Geometry_m_typeof = function _typeof(obj) { return typeof obj; }; } else { Home2Geometry_m_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Home2Geometry_m_typeof(obj); }\n\nfunction Home2Geometry_m_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home2Geometry_m_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home2Geometry_m_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home2Geometry_m_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home2Geometry_m_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Home2Geometry_m_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Home2Geometry_m_setPrototypeOf(subClass, superClass); }\n\nfunction Home2Geometry_m_setPrototypeOf(o, p) { Home2Geometry_m_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Home2Geometry_m_setPrototypeOf(o, p); }\n\nfunction Home2Geometry_m_createSuper(Derived) { var hasNativeReflectConstruct = Home2Geometry_m_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Home2Geometry_m_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Home2Geometry_m_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Home2Geometry_m_possibleConstructorReturn(this, result); }; }\n\nfunction Home2Geometry_m_possibleConstructorReturn(self, call) { if (call && (Home2Geometry_m_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Home2Geometry_m_assertThisInitialized(self); }\n\nfunction Home2Geometry_m_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Home2Geometry_m_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Home2Geometry_m_getPrototypeOf(o) { Home2Geometry_m_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Home2Geometry_m_getPrototypeOf(o); }\n\n//import * as THREE from "three"\n//import gsap from "gsap"\n//import {GLTFLoader, GLTLoader} from "three/examples/jsm/loaders/GLTFLoader"\nvar Home2Geometry_m_EventEmitter = __webpack_require__(7187);\n\nvar Home2Geometry_m = /*#__PURE__*/function (_EventEmitter) {\n  Home2Geometry_m_inherits(Home2Geometry_m, _EventEmitter);\n\n  var _super = Home2Geometry_m_createSuper(Home2Geometry_m);\n\n  function Home2Geometry_m(obj) {\n    var _this;\n\n    Home2Geometry_m_classCallCheck(this, Home2Geometry_m);\n\n    //console.log("(Home2Geometry_m.CONSTRUCTORA)!")\n    _this = _super.call(this); //--\n\n    _this.factor = obj.factor; //6\n\n    _this.incr_radio = obj.incr_radio; //25\n\n    _this.numOrbits = obj.numOrbits; //37\n\n    _this.array_triangular = obj.array_triangular;\n    _this.array_dotPos = obj.array_dotPos;\n    _this.numDots = obj.numDots; //--\n\n    _this.arrayColores_RGB = [];\n    _this.arrayColores_RGB_01 = [];\n    _this.colorPos = 0;\n\n    _this._init_colors(); //--\n\n\n    _this.attributes = {\n      a_posiciones: new Float32Array(_this.numDots * 3),\n      a_color: new Float32Array(_this.numDots * 3),\n      a_orbital: new Float32Array(_this.numDots * 1),\n      a_pos_orbita: new Float32Array(_this.numDots * 1),\n      a_incr_anguloRad: new Float32Array(_this.numDots * 1),\n      a_anguloRad: new Float32Array(_this.numDots * 1),\n      a_radio: new Float32Array(_this.numDots * 1),\n      a_dir: new Float32Array(_this.numDots * 1),\n      a_incr: new Float32Array(_this.numDots * 1),\n      a_x: new Float32Array(_this.numDots * 1),\n      a_y: new Float32Array(_this.numDots * 1),\n      a_z: new Float32Array(_this.numDots * 1)\n    }; //--\n\n    for (var i = 0; i < _this.array_dotPos.length; i++) {\n      var dotPos = _this.array_dotPos[i];\n\n      var dot = _this._get_dot(dotPos);\n\n      var i3 = i * 3;\n      _this.attributes.a_posiciones[i3] = dot.x;\n      _this.attributes.a_posiciones[i3 + 1] = dot.y;\n      _this.attributes.a_posiciones[i3 + 2] = dot.z; //--\n\n      _this.attributes.a_color[i3] = dot.color[0];\n      _this.attributes.a_color[i3 + 1] = dot.color[1];\n      _this.attributes.a_color[i3 + 2] = dot.color[2]; //--\n\n      _this.attributes.a_orbital[i] = dot.orbital;\n      _this.attributes.a_pos_orbita[i] = dot.pos_orbita;\n      _this.attributes.a_incr_anguloRad[i] = dot.incr_anguloRad;\n      _this.attributes.a_anguloRad[i] = dot.anguloRad;\n      _this.attributes.a_radio[i] = dot.radio;\n      _this.attributes.a_dir[i] = dot.dir;\n      _this.attributes.a_incr[i] = dot.incr;\n      _this.attributes.a_x[i] = dot.y;\n      _this.attributes.a_y[i] = dot.y;\n      _this.attributes.a_z[i] = dot.z;\n    } //--\n\n\n    _this.loaded = false;\n    return _this;\n  } //------------------------------------------\n  // PRIVADAS\n\n\n  Home2Geometry_m_createClass(Home2Geometry_m, [{\n    key: "_get_dot",\n    value: function _get_dot(num) {\n      // Devuelve un objeto con la información de un punto de la geometria "orbital MIOTI"\n      var obj = {\n        num: num,\n        color: this._get_color(),\n        x: 0,\n        y: 0,\n        z: 0,\n        orbital: 0,\n        co_orbitantes: 0,\n        pos_orbita: 0,\n        incr_anguloRad: 0,\n        anguloRad: 0,\n        radio: 0\n      }; //--\n\n      for (var i = 0; i <= this.array_triangular.length; i++) {\n        var limSup = this.array_triangular[i]; //console.log("limSup: "+limSup)\n\n        if (num > limSup) {\n          // console.log("*")\n          obj.orbital = i + 1;\n          obj.co_orbitantes = (i + 1) * this.factor;\n          obj.pos_orbita = num - limSup - 1;\n          obj.incr_anguloRad = 2 * Math.PI / obj.co_orbitantes;\n\n          if (obj.orbital % 2 == 0) {\n            obj.dir = 1;\n            obj.incr = 0;\n            obj.anguloRad = obj.pos_orbita * obj.incr_anguloRad;\n          } else {\n            obj.dir = -1;\n            obj.incr = 1;\n            obj.anguloRad = obj.pos_orbita * obj.incr_anguloRad + obj.incr_anguloRad / 2;\n          }\n\n          obj.radio = obj.orbital * this.incr_radio; //--\n\n          obj.x = Math.cos(obj.anguloRad) * obj.radio;\n          obj.y = Math.sin(obj.anguloRad) * obj.radio;\n          obj.z = 0;\n        } //break\n\n      }\n\n      return obj;\n    }\n  }, {\n    key: "_get_color",\n    value: function _get_color() {\n      var color_RGB_01 = this.arrayColores_RGB_01[this.colorPos];\n      this.colorPos++;\n\n      if (this.colorPos > this.arrayColores_RGB_01.length - 1) {\n        this.colorPos = 0;\n      }\n\n      return color_RGB_01;\n    }\n  }, {\n    key: "_init_colors",\n    value: function _init_colors() {\n      this.arrayColores_RGB = [];\n      this.arrayColores_RGB.push([255, 87, 131]); // Rosa\n\n      this.arrayColores_RGB.push([89, 2, 2]);\n      this.arrayColores_RGB.push([1, 3, 49]);\n      this.arrayColores_RGB.push([0, 16, 116]);\n      this.arrayColores_RGB.push([14, 133, 255]);\n      this.arrayColores_RGB_01 = [];\n\n      for (var i = 0; i < this.arrayColores_RGB.length; i++) {\n        var color_RGB = this.arrayColores_RGB[i];\n        var color_RGB_01 = [color_RGB[0] / 255, color_RGB[1] / 255, color_RGB[2] / 255];\n        this.arrayColores_RGB_01.push(color_RGB_01);\n      }\n    }\n  }]);\n\n  return Home2Geometry_m;\n}(Home2Geometry_m_EventEmitter);\n\n/* harmony default export */ const home2_m_Home2Geometry_m = (Home2Geometry_m);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home2_m/Home2Dots_m.js\nfunction Home2Dots_m_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home2Dots_m_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home2Dots_m_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home2Dots_m_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home2Dots_m_defineProperties(Constructor, staticProps); return Constructor; }\n\n //import gsap from "gsap"\n\n\n\n\n\n\nvar Home2Dots_m_Home1Dots = /*#__PURE__*/function () {\n  function Home1Dots(obj) {\n    Home2Dots_m_classCallCheck(this, Home1Dots);\n\n    //console.log("(Home1Dots.CONSTRUCTORA)!")\n    //console.log(obj)\n    this.app = obj.app; //--\n\n    this.scene = this.app.scene;\n    this.cameraDistance = this.app.cameraDistance; //--\n\n    this.material = null;\n    this.geometry = null;\n    this.mesh = null;\n    this.created = false;\n    this.clock = new three_module/* Clock */.SUY(); //--\n    //this.eased_scrollDelta_fast = new EasedOutValue(this.app.scrollData.normalizedDelta*0.5, 0.1)\n    //--\n\n    this._setup_settings(); //--\n\n\n    this.orbital_geometry = new home2_m_Home2Geometry_m(this.settings); //--\n    //this._create()\n  } //------------------------------------\n  // PUBLICAS: \n\n\n  Home2Dots_m_createClass(Home1Dots, [{\n    key: "init",\n    value: function init() {\n      this.eased_scrollDelta_fast = new webgl_EasedOutValue(this.app.scrollData.normalizedDelta * 0.5, 0.1);\n\n      this._create();\n    } //------------------------------------\n\n  }, {\n    key: "render",\n    value: function render() {\n      if (this.created) {\n        this.material.uniforms.uTime.value = this.clock.getElapsedTime();\n        this.material.uniforms.uCamaraDistance.value = this.app.cameraDistance;\n        this.material.uniforms.uOpenProgress.value = this.settings.openProgress;\n        this.material.uniforms.uResponsiveScale.value = this.app.responsiveScale; //this.material.uniforms.u_scroll_factordDelta.value = this.app.scrollData.factordDelta\n        //this.material.uniforms.u_scroll_direction.value = this.app.scrollData.direction\n\n        this.material.uniforms.uScrollDelta.value = -this.eased_scrollDelta_fast.get(this.app.scrollData.normalizedDelta * 0.5); //--\n\n        var extraSpeed = 1 + Math.abs(this.eased_scrollDelta_fast.get(this.app.scrollData.normalizedDelta * 0.5) * 10);\n        this.settings.rotation1 += this.settings.speedRotation1 * extraSpeed;\n        this.settings.rotation2 += this.settings.speedRotation2 * extraSpeed;\n        this.settings.rotation3 += this.settings.speedRotation3 * extraSpeed;\n        this.material.uniforms.uRotation1.value = this.settings.rotation1;\n        this.material.uniforms.uRotation2.value = -this.settings.rotation2;\n        this.material.uniforms.uRotation3.value = this.settings.rotation3; //console.log(this.material.uniforms.uRotation1.value)\n      }\n    } //------------------------------------\n    // PUBLICAS:\n\n  }, {\n    key: "resize",\n    value: function resize(newWidth, newHeight) {//console.log("(GradientBackground.resize)!")\n    } //------------------------------------\n    // PRIVADAS: \n\n  }, {\n    key: "_setup_settings",\n    value: function _setup_settings() {\n      //console.log("(Home1Dots._setup_settings)!!")\n      var speedBase = 0.002;\n      this.settings = {\n        factor: 6,\n        //incr_radio: 25,\n        //incr_radio: 13.2,\n        incr_radio: this.app.incr_radio,\n        numOrbits: 19,\n        //arrayOrbits: [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,  17, 18, 19],\n        arrayOrbits: [8, 13, 18],\n        //arrayOrbits: [1, 3, 4, 5],\n        // Ortbit rotation\n        rotation1: 0,\n        speedRotation1: 3 * speedBase,\n        rotation2: 2,\n        speedRotation2: 2 * speedBase,\n        rotation3: 0,\n        speedRotation3: 1 * speedBase\n      };\n      this.settings.array_triangular = this._get_array_triangular(this.settings.factor, this.settings.numOrbits);\n      this.settings.array_triangular_dots_x_orbita = this._get_array_triangular_dots_x_orbita(this.settings.array_triangular, this.settings.arrayOrbits);\n      this.settings.array_dotPos = this._get_array_dotPos(this.settings.arrayOrbits, this.settings.array_triangular, this.settings.array_triangular_dots_x_orbita);\n      this.settings.numDots = this.settings.array_dotPos.length;\n      this.settings.openProgress = 0;\n    }\n  }, {\n    key: "_create",\n    value: function _create() {\n      //console.log("(Home1Dots._create)!")\n      //--\n      this.material = new three_module/* ShaderMaterial */.jyz({\n        depthWrite: false,\n        //blending: THREE.AdditiveBlending,\n        vertexColors: true,\n        vertexShader: home2_dots_vertex_m,\n        fragmentShader: home2_dots_fragment_m,\n        transparent: true,\n        uniforms: {\n          uCamaraDistance: {\n            value: this.app.cameraDistance\n          },\n          uDotColor: {\n            value: this.app.dotColor\n          },\n          uTime: {\n            value: 0\n          },\n          //uScale:{value: 1},\n          uOpenProgress: {\n            value: 0\n          },\n          uResponsiveScale: {\n            value: 0\n          },\n          //u_scroll_factordDelta: {value: 1},\n          //u_scroll_direction: {value: 1},\n          uScrollDelta: {\n            value: 0\n          },\n          uRotation1: {\n            value: 0\n          },\n          uRotation2: {\n            value: 0\n          },\n          uRotation3: {\n            value: 0\n          }\n        }\n      }); //--\n      //console.log(this.orbital_geometry.attributes.a_color)\n      //--\n\n      this.geometry = new three_module/* BufferGeometry */.u9r();\n      this.geometry.setAttribute(\'position\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_geo1_position\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_geo1_color\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_color, 3));\n      this.geometry.setAttribute(\'a_geo1_orbital\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_orbital, 1));\n      this.geometry.setAttribute(\'a_geo1_pos_orbita\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_pos_orbita, 1));\n      this.geometry.setAttribute(\'a_geo1_incr_anguloRad\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_incr_anguloRad, 1));\n      this.geometry.setAttribute(\'a_geo1_anguloRad\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_anguloRad, 1));\n      this.geometry.setAttribute(\'a_geo1_radio\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_radio, 1));\n      this.geometry.setAttribute(\'a_geo1_dir\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_dir, 1));\n      this.geometry.setAttribute(\'a_geo1_incr\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_incr, 1));\n      this.geometry.setAttribute(\'a_geo1_x\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_x, 1));\n      this.geometry.setAttribute(\'a_geo1_y\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_y, 1));\n      this.geometry.setAttribute(\'a_geo1_z\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_z, 1));\n      this.mesh = new three_module/* Points */.woe(this.geometry, this.material);\n      this.scene.add(this.mesh);\n      this.created = true;\n    }\n  }, {\n    key: "_get_array_dotPos",\n    value: function _get_array_dotPos(_arrayOrbits, _array_triangular, _array_triangular_dots_x_orbita) {\n      var miArray = [];\n\n      for (var i = 0; i < _arrayOrbits.length; i++) {\n        var orbitNum = _arrayOrbits[i];\n        var dots_x_orbit = _array_triangular_dots_x_orbita[i];\n        var dotNum_base = _array_triangular[_arrayOrbits[i] - 1]; // console.log("orbitNum: "+orbitNum)\n        // console.log("dots_x_orbit: "+dots_x_orbit)\n        // console.log("dotNum_base: "+dotNum_base)\n\n        for (var j = 0; j < dots_x_orbit; j++) {\n          miArray.push(dotNum_base + j + 1);\n        }\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_get_numDots",\n    value: function _get_numDots(_array_triangular_dots_x_orbita) {\n      var numDots = 0;\n\n      for (var i = 0; i <= _array_triangular_dots_x_orbita.length - 1; i++) {\n        numDots += _array_triangular_dots_x_orbita[i];\n      }\n\n      return numDots;\n    }\n  }, {\n    key: "_get_array_triangular_dots_x_orbita",\n    value: function _get_array_triangular_dots_x_orbita(_array_triangular, _arrayOrbits) {\n      // Genera una array basada en la progresión triangular (* factor).\n      // ... donde se indica el numero de dots por orbital\n      // Una progresión triangular es: 1, 3, 6, 10, 15 (https://significativa.org/diccionarios/numeros-figurados/#:~:text=3.1.1.1.-,Definici%C3%B3n,anterior%20no%20obtenemos%20una%20constante.)\n      var miArray = [];\n\n      for (var i = 0; i <= _arrayOrbits.length - 1; i++) {\n        //array_numTriagulares.push(i*(i+1)/2)\n        var numDots_orbita_actual = _array_triangular[_arrayOrbits[i]];\n        var numDots_orbita_anterior = _array_triangular[_arrayOrbits[i] - 1];\n        var numDots_orbita = numDots_orbita_actual - numDots_orbita_anterior;\n        miArray.push(numDots_orbita);\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_get_array_triangular",\n    value: function _get_array_triangular(_factor, _numObits) {\n      // Genera una array de progresión triangular (* factor).\n      // Una progresión triangular es: 1, 3, 6, 10, 15 (https://significativa.org/diccionarios/numeros-figurados/#:~:text=3.1.1.1.-,Definici%C3%B3n,anterior%20no%20obtenemos%20una%20constante.)\n      var miArray = [];\n\n      for (var i = 0; i <= _numObits; i++) {\n        //array_numTriagulares.push(i*(i+1)/2)\n        miArray.push(i * (i + 1) / 2 * _factor);\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_setup_gui",\n    value: function _setup_gui() {//console.log("(Home1Dots._setup_gui)!")\n      // this.gui = new dat.GUI();\n      // this.gui.width = 400\n      // const folder0 = this.gui.addFolder("Orbit spinning")\n      // folder0.add(this.settings, "progress5", 0, 10, 0.01).name("Progress")\n      // folder0.open()\n    } //---------------------------------------------------------\n    //---------------------------------------------------------\n\n  }]);\n\n  return Home1Dots;\n}();\n\n/* harmony default export */ const Home2Dots_m = (Home2Dots_m_Home1Dots);\n;// CONCATENATED MODULE: ./app/src/js/webgl/home2_m/Home2App_m.js\nfunction Home2App_m_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Home2App_m_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Home2App_m_createClass(Constructor, protoProps, staticProps) { if (protoProps) Home2App_m_defineProperties(Constructor.prototype, protoProps); if (staticProps) Home2App_m_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n //--\n\n\n\nvar Home2App_m = /*#__PURE__*/function () {\n  function Home2App_m(obj) {\n    Home2App_m_classCallCheck(this, Home2App_m);\n\n    //console.log("(Home2App_m.CONSTRUCTORA)!!", obj) \n    this.hw_renderer = obj.renderer; // Rederer/pagina de HighWay. No confundir con el render/renderer de Three.js\n\n    this.$container = obj.domElement;\n    this.dotColor = new three_module/* Color */.Ilk(obj.dotColor);\n    this.incr_radio = obj.incr_radio; //--\n\n    this.$inner = document.querySelector(\'.inner\'); //--\n\n    this.REF_RESOLUTION = {\n      width: 480,\n      height: 480\n    };\n    this.REF_CAMERA_DISTANCE = 500; //--\n\n    this.width;\n    this.height;\n    this.responsiveScale;\n    this.cameraDistance; //--\n    //--\n    //this.scrollData = new Home2Scroll_m({\n    //    app:this,\n    //    $inner: this.$inner\n    //})\n    //--\n\n    this._update_dimensions(); //--\n    // Scene\n\n\n    this.scene = new three_module/* Scene */.xsS(); //this.scene.background = new THREE.Color( 0x00ff00 );\n    //--\n    // console.log("this.width: "+this.width)\n    // console.log("this.height: "+this.height)\n    // console.log("this.cameraDistance: "+this.cameraDistance)\n    //--\n    // Camera\n    //PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )\n\n    this.camera = new three_module/* PerspectiveCamera */.cPb(30, this.width / this.height, 0.1, 2000);\n    this.camera.position.z = this.cameraDistance;\n    this.camera.fov = 2 * Math.atan(this.height / 2 / this.cameraDistance) * (180 / Math.PI); //--\n    // Renderer\n    //--\n\n    this.renderer = new three_module/* WebGL1Renderer */.b5g({\n      antialias: true,\n      alpha: true\n    }); //this.renderer.autoClear = false // Vamos a usar 2 scenas (una para el background y otra para los puntos) que implicarán usar 2 acciones de render. Con autoclear false permitimos que la segunda no borre la primera.\n\n    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1)); //this.renderer.setClearColorHex( 0xff0000, 1 );\n    //--\n\n    this.$container.appendChild(this.renderer.domElement); //--\n\n    this.dots = new Home2Dots_m({\n      app: this\n    }); //--\n    //this._createcube(this.scene)\n\n    this._resize(); //this._render();\n\n  } //---------------------------\n  // PUBLICAS:\n\n\n  Home2App_m_createClass(Home2App_m, [{\n    key: "init",\n    value: function init() {\n      this.$inner = document.querySelector(\'.inner\');\n      this.scrollData = new home2_m_Home2Scroll_m({\n        app: this,\n        $inner: this.$inner\n      }); //--\n\n      this.dots.init(); //--\n\n      this._render();\n    }\n  }, {\n    key: "kill",\n    value: function kill() {\n      this.scrollData.kill();\n      this.scrollData = null;\n      this.dots = null;\n    } //---------------------------\n\n  }, {\n    key: "render",\n    value: function render() {\n      //console.log("(Home2App_m.render)!")\n      this._render(); // Lo llama scrollData\n\n    }\n  }, {\n    key: "resize",\n    value: function resize() {\n      //console.log("(Home2App_m.resize)!")\n      this._resize();\n    } //---------------------------\n    // PRIVADAS:\n\n  }, {\n    key: "_update_dimensions",\n    value: function _update_dimensions() {\n      // console.log("(Home2App_m._update_dimensions)!", this.renderer)\n      this.width = this.$container.offsetWidth;\n      this.height = this.$container.offsetHeight;\n      this.responsiveScale = this.width / this.REF_RESOLUTION.width;\n      this.cameraDistance = this.REF_CAMERA_DISTANCE * this.responsiveScale; //--\n\n      if (this.renderer) {\n        this.renderer.setSize(this.width, this.height); //--\n\n        this.camera.aspect = this.width / this.height;\n        this.cameraDistance = this.camera.position.z;\n        this.camera.fov = 2 * Math.atan(this.height / 2 / this.cameraDistance) * (180 / Math.PI);\n        this.camera.updateProjectionMatrix();\n      } //--\n\n    }\n  }, {\n    key: "_resize",\n    value: function _resize() {\n      //console.log("(Home2App_m._resize)!!")\n      this._update_dimensions(); //--\n\n\n      if (this.dots) {//this.dots.resize(this.width, this.height);\n      }\n    }\n  }, {\n    key: "_render",\n    value: function _render() {\n      //console.log("(Home2App_m._render)!")\n      if (this.height != this.$container.offsetHeight || this.width != this.$container.offsetWidth) {\n        this._resize();\n      }\n\n      if (this.dots) {\n        this.dots.render();\n      }\n\n      this.renderer.render(this.scene, this.camera);\n    }\n  }, {\n    key: "_createcube",\n    value: function _createcube(_scene) {\n      var geometry = new three_module/* BoxGeometry */.DvJ(100, 100, 100);\n      var material = new three_module/* MeshBasicMaterial */.vBJ({\n        color: 0xff0000\n      });\n      var cube = new three_module/* Mesh */.Kj0(geometry, material); //cube.position.set(100, 100, 100)\n\n      _scene.add(cube);\n    }\n  }]);\n\n  return Home2App_m;\n}();\n\n/* harmony default export */ const home2_m_Home2App_m = (Home2App_m);\n// EXTERNAL MODULE: ./node_modules/gsap/Draggable.js + 1 modules\nvar Draggable = __webpack_require__(2354);\n;// CONCATENATED MODULE: ./app/src/js/utils/VelocityTracker.js\nfunction VelocityTracker_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction VelocityTracker_createClass(Constructor, protoProps, staticProps) { if (protoProps) VelocityTracker_defineProperties(Constructor.prototype, protoProps); if (staticProps) VelocityTracker_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction VelocityTracker_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/*!\n * VelocityTracker: 3.6.1\n * https://greensock.com\n *\n * Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar VelocityTracker_gsap,\n    VelocityTracker_coreInitted,\n    VelocityTracker_toArray,\n    _getUnit,\n    _first,\n    _ticker,\n    _time1,\n    _time2,\n    _getCache,\n    _getGSAP = function _getGSAP() {\n  return VelocityTracker_gsap || typeof window !== "undefined" && (VelocityTracker_gsap = window.gsap);\n},\n    _lookup = {},\n    _round = function _round(value) {\n  return Math.round(value * 10000) / 10000;\n},\n    _getID = function _getID(target) {\n  return _getCache(target).id;\n},\n    _getByTarget = function _getByTarget(target) {\n  return _lookup[_getID(typeof target === "string" ? VelocityTracker_toArray(target)[0] : target)];\n},\n    _onTick = function _onTick(time) {\n  var pt = _first,\n      val; //if the frame rate is too high, we won\'t be able to track the velocity as well, so only update the values about 20 times per second\n\n  if (time - _time1 >= 0.05) {\n    _time2 = _time1;\n    _time1 = time;\n\n    while (pt) {\n      val = pt.g(pt.t, pt.p);\n\n      if (val !== pt.v1 || time - pt.t1 > 0.2) {\n        //use a threshold of 0.2 seconds for zeroing-out velocity. If we only use 0.05 and things update slightly slower, like some Android devices dispatch "touchmove" events sluggishly so 2 or 3 ticks of the gsap.ticker may elapse inbetween, thus it may appear like the object is not moving but it actually is but it\'s not updating as frequently. A threshold of 0.2 seconds seems to be a good balance. We want to update things frequently (0.05 seconds) when they\'re moving so that we can respond to fast motions accurately, but we want to be more resistant to go back to a zero velocity.\n        pt.v2 = pt.v1;\n        pt.v1 = val;\n        pt.t2 = pt.t1;\n        pt.t1 = time;\n      }\n\n      pt = pt._next;\n    }\n  }\n},\n    _types = {\n  deg: 360,\n  rad: Math.PI * 2\n},\n    VelocityTracker_initCore = function _initCore() {\n  VelocityTracker_gsap = _getGSAP();\n\n  if (VelocityTracker_gsap) {\n    VelocityTracker_toArray = VelocityTracker_gsap.utils.toArray;\n    _getUnit = VelocityTracker_gsap.utils.getUnit;\n    _getCache = VelocityTracker_gsap.core.getCache;\n    _ticker = VelocityTracker_gsap.ticker;\n    VelocityTracker_coreInitted = 1;\n  }\n};\n\nvar PropTracker = function PropTracker(target, property, type, next) {\n  VelocityTracker_classCallCheck(this, PropTracker);\n\n  this.t = target;\n  this.p = property;\n  this.g = target._gsap.get;\n  this.rCap = _types[type || _getUnit(this.g(target, property))]; //rotational cap (for degrees, "deg", it\'s 360 and for radians, "rad", it\'s Math.PI * 2)\n\n  this.v1 = this.v2 = 0;\n  this.t1 = this.t2 = _ticker.time;\n\n  if (next) {\n    this._next = next;\n    next._prev = this;\n  }\n};\n\nvar VelocityTracker = /*#__PURE__*/function () {\n  function VelocityTracker(target, property) {\n    VelocityTracker_classCallCheck(this, VelocityTracker);\n\n    if (!VelocityTracker_coreInitted) {\n      VelocityTracker_initCore();\n    }\n\n    this.target = VelocityTracker_toArray(target)[0];\n    _lookup[_getID(this.target)] = this;\n    this._props = {};\n    property && this.add(property);\n  }\n\n  VelocityTracker_createClass(VelocityTracker, [{\n    key: "get",\n    value: function get(property, skipRecentTick) {\n      var pt = this._props[property] || console.warn("Not tracking " + property + " velocity."),\n          val,\n          dif,\n          rotationCap;\n      val = parseFloat(skipRecentTick ? pt.v1 : pt.g(pt.t, pt.p));\n      dif = val - parseFloat(pt.v2);\n      rotationCap = pt.rCap;\n\n      if (rotationCap) {\n        //rotational values need special interpretation so that if, for example, they go from 179 to -178 degrees it is interpreted as a change of 3 instead of -357.\n        dif = dif % rotationCap;\n\n        if (dif !== dif % (rotationCap / 2)) {\n          dif = dif < 0 ? dif + rotationCap : dif - rotationCap;\n        }\n      }\n\n      return _round(dif / ((skipRecentTick ? pt.t1 : _ticker.time) - pt.t2));\n    }\n  }, {\n    key: "getAll",\n    value: function getAll() {\n      var result = {},\n          props = this._props,\n          p;\n\n      for (p in props) {\n        result[p] = this.get(p);\n      }\n\n      return result;\n    }\n  }, {\n    key: "isTracking",\n    value: function isTracking(property) {\n      return property in this._props;\n    }\n  }, {\n    key: "add",\n    value: function add(property, type) {\n      if (!(property in this._props)) {\n        if (!_first) {\n          _ticker.add(_onTick);\n\n          _time1 = _time2 = _ticker.time;\n        }\n\n        _first = this._props[property] = new PropTracker(this.target, property, type, _first);\n      }\n    }\n  }, {\n    key: "remove",\n    value: function remove(property) {\n      var pt = this._props[property],\n          prev,\n          next;\n\n      if (pt) {\n        prev = pt._prev;\n        next = pt._next;\n\n        if (prev) {\n          prev._next = next;\n        }\n\n        if (next) {\n          next._prev = prev;\n        } else if (_first === pt) {\n          _ticker.remove(_onTick);\n\n          _first = 0;\n        }\n\n        delete this._props[property];\n      }\n    }\n  }, {\n    key: "kill",\n    value: function kill(shallow) {\n      for (var p in this._props) {\n        this.remove(p);\n      }\n\n      if (!shallow) {\n        delete _lookup[_getID(this.target)];\n      }\n    }\n  }], [{\n    key: "register",\n    value: function register(core) {\n      VelocityTracker_gsap = core;\n\n      VelocityTracker_initCore();\n    }\n  }, {\n    key: "track",\n    value: function track(targets, properties, types) {\n      if (!VelocityTracker_coreInitted) {\n        VelocityTracker_initCore();\n      }\n\n      var result = [],\n          targs = VelocityTracker_toArray(targets),\n          a = properties.split(","),\n          t = (types || "").split(","),\n          i = targs.length,\n          tracker,\n          j;\n\n      while (i--) {\n        tracker = _getByTarget(targs[i]) || new VelocityTracker(targs[i]);\n        j = a.length;\n\n        while (j--) {\n          tracker.add(a[j], t[j] || t[0]);\n        }\n\n        result.push(tracker);\n      }\n\n      return result;\n    }\n  }, {\n    key: "untrack",\n    value: function untrack(targets, properties) {\n      var props = (properties || "").split(",");\n\n      VelocityTracker_toArray(targets).forEach(function (target) {\n        var tracker = _getByTarget(target);\n\n        if (tracker) {\n          if (!props.length) {\n            tracker.kill(1);\n          } else {\n            props.forEach(function (p) {\n              return tracker.remove(p);\n            });\n          }\n        }\n      });\n    }\n  }, {\n    key: "isTracking",\n    value: function isTracking(target, property) {\n      var tracker = _getByTarget(target);\n\n      return tracker && tracker.isTracking(property);\n    }\n  }, {\n    key: "getVelocity",\n    value: function getVelocity(target, property) {\n      var tracker = _getByTarget(target);\n\n      return !tracker || !tracker.isTracking(property) ? console.warn("Not tracking velocity of " + property) : tracker.get(property);\n    }\n  }]);\n\n  return VelocityTracker;\n}();\nVelocityTracker.getByTarget = _getByTarget;\n_getGSAP() && VelocityTracker_gsap.registerPlugin(VelocityTracker);\n\n;// CONCATENATED MODULE: ./app/src/js/classes/InertiaPlugin.js\nfunction InertiaPlugin_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { InertiaPlugin_typeof = function _typeof(obj) { return typeof obj; }; } else { InertiaPlugin_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return InertiaPlugin_typeof(obj); }\n\n/*!\n * InertiaPlugin 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\n\n\nvar InertiaPlugin_gsap,\n    InertiaPlugin_coreInitted,\n    _parseEase,\n    InertiaPlugin_toArray,\n    _power3,\n    _config,\n    InertiaPlugin_getUnit,\n    PropTween,\n    InertiaPlugin_getCache,\n    _checkPointRatio,\n    _clamp,\n    _processingVars,\n    _getTracker = VelocityTracker.getByTarget,\n    InertiaPlugin_getGSAP = function _getGSAP() {\n  return InertiaPlugin_gsap || typeof window !== "undefined" && (InertiaPlugin_gsap = window.gsap) && InertiaPlugin_gsap.registerPlugin && InertiaPlugin_gsap;\n},\n    _isString = function _isString(value) {\n  return typeof value === "string";\n},\n    _isNumber = function _isNumber(value) {\n  return typeof value === "number";\n},\n    _isObject = function _isObject(value) {\n  return InertiaPlugin_typeof(value) === "object";\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === "function";\n},\n    InertiaPlugin_bonusValidated = 1,\n    //<name>InertiaPlugin</name>\nInertiaPlugin_isArray = Array.isArray,\n    _emptyFunc = function _emptyFunc(p) {\n  return p;\n},\n    _bigNum = 1e10,\n    _tinyNum = 1 / _bigNum,\n    _checkPoint = 0.05,\n    InertiaPlugin_round = function _round(value) {\n  return Math.round(value * 10000) / 10000;\n},\n    _extend = function _extend(obj, defaults, exclude) {\n  for (var p in defaults) {\n    if (!(p in obj) && p !== exclude) {\n      obj[p] = defaults[p];\n    }\n  }\n\n  return obj;\n},\n    _deepClone = function _deepClone(obj) {\n  var copy = {},\n      p,\n      v;\n\n  for (p in obj) {\n    copy[p] = _isObject(v = obj[p]) ? _deepClone(v) : v;\n  }\n\n  return copy;\n},\n    _getClosest = function _getClosest(n, values, max, min, radius) {\n  var i = values.length,\n      closest = 0,\n      absDif = _bigNum,\n      val,\n      dif,\n      p,\n      dist;\n\n  if (_isObject(n)) {\n    while (i--) {\n      val = values[i];\n      dif = 0;\n\n      for (p in n) {\n        dist = val[p] - n[p];\n        dif += dist * dist;\n      }\n\n      if (dif < absDif) {\n        closest = i;\n        absDif = dif;\n      }\n    }\n\n    if ((radius || _bigNum) < _bigNum && radius < Math.sqrt(absDif)) {\n      return n;\n    }\n  } else {\n    while (i--) {\n      val = values[i];\n      dif = val - n;\n\n      if (dif < 0) {\n        dif = -dif;\n      }\n\n      if (dif < absDif && val >= min && val <= max) {\n        closest = i;\n        absDif = dif;\n      }\n    }\n  }\n\n  return values[closest];\n},\n    _parseEnd = function _parseEnd(curProp, end, max, min, name, radius) {\n  if (curProp.end === "auto") {\n    return curProp;\n  }\n\n  var endVar = curProp.end,\n      adjustedEnd,\n      p;\n  max = isNaN(max) ? _bigNum : max;\n  min = isNaN(min) ? -_bigNum : min;\n\n  if (_isObject(end)) {\n    //for objects, like {x, y} where they\'re linked and we must pass an object to the function or find the closest value in an array.\n    adjustedEnd = end.calculated ? end : (_isFunction(endVar) ? endVar(end) : _getClosest(end, endVar, max, min, radius)) || end;\n\n    if (!end.calculated) {\n      for (p in adjustedEnd) {\n        end[p] = adjustedEnd[p];\n      }\n\n      end.calculated = true;\n    }\n\n    adjustedEnd = adjustedEnd[name];\n  } else {\n    adjustedEnd = _isFunction(endVar) ? endVar(end) : InertiaPlugin_isArray(endVar) ? _getClosest(end, endVar, max, min, radius) : parseFloat(endVar);\n  }\n\n  if (adjustedEnd > max) {\n    adjustedEnd = max;\n  } else if (adjustedEnd < min) {\n    adjustedEnd = min;\n  }\n\n  return {\n    max: adjustedEnd,\n    min: adjustedEnd,\n    unitFactor: curProp.unitFactor\n  };\n},\n    _getNumOrDefault = function _getNumOrDefault(vars, property, defaultValue) {\n  return isNaN(vars[property]) ? defaultValue : +vars[property];\n},\n    _calculateChange = function _calculateChange(velocity, duration) {\n  return duration * _checkPoint * velocity / _checkPointRatio;\n},\n    _calculateDuration = function _calculateDuration(start, end, velocity) {\n  return Math.abs((end - start) * _checkPointRatio / velocity / _checkPoint);\n},\n    _reservedProps = {\n  resistance: 1,\n  checkpoint: 1,\n  preventOvershoot: 1,\n  linkedProps: 1,\n  radius: 1,\n  duration: 1\n},\n    _processLinkedProps = function _processLinkedProps(target, vars, getVal, resistance) {\n  if (vars.linkedProps) {\n    //when there are linkedProps (typically "x,y" where snapping has to factor in multiple properties, we must first populate an object with all of those end values, then feed it to the function that make any necessary alterations. So the point of this first loop is to simply build an object (like {x:100, y:204.5}) for feeding into that function which we\'ll do later in the "real" loop.\n    var linkedPropNames = vars.linkedProps.split(","),\n        linkedProps = {},\n        i,\n        p,\n        curProp,\n        curVelocity,\n        tracker,\n        curDuration;\n\n    for (i = 0; i < linkedPropNames.length; i++) {\n      p = linkedPropNames[i];\n      curProp = vars[p];\n\n      if (curProp) {\n        if (_isNumber(curProp.velocity)) {\n          curVelocity = curProp.velocity;\n        } else {\n          tracker = tracker || _getTracker(target);\n          curVelocity = tracker && tracker.isTracking(p) ? tracker.get(p) : 0;\n        }\n\n        curDuration = Math.abs(curVelocity / _getNumOrDefault(curProp, "resistance", resistance));\n        linkedProps[p] = parseFloat(getVal(target, p)) + _calculateChange(curVelocity, curDuration);\n      }\n    }\n\n    return linkedProps;\n  }\n},\n    _calculateTweenDuration = function _calculateTweenDuration(target, vars) {\n  var maxDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n  var minDuration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.2;\n  var overshootTolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  var recordEnd = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  _isString(target) && (target = InertiaPlugin_toArray(target)[0]);\n\n  if (!target) {\n    return 0;\n  }\n\n  var duration = 0,\n      clippedDuration = _bigNum,\n      inertiaVars = vars.inertia || vars,\n      getVal = InertiaPlugin_getCache(target).get,\n      resistance = _getNumOrDefault(inertiaVars, "resistance", _config.resistance),\n      p,\n      curProp,\n      curDuration,\n      curVelocity,\n      curVal,\n      end,\n      curClippedDuration,\n      tracker,\n      unitFactor,\n      linkedProps; //when there are linkedProps (typically "x,y" where snapping has to factor in multiple properties, we must first populate an object with all of those end values, then feed it to the function that make any necessary alterations. So the point of this first loop is to simply build an object (like {x:100, y:204.5}) for feeding into that function which we\'ll do later in the "real" loop.\n\n\n  linkedProps = _processLinkedProps(target, inertiaVars, getVal, resistance);\n\n  for (p in inertiaVars) {\n    if (!_reservedProps[p]) {\n      curProp = inertiaVars[p];\n\n      if (!_isObject(curProp)) {\n        tracker = tracker || _getTracker(target);\n\n        if (tracker && tracker.isTracking(p)) {\n          curProp = _isNumber(curProp) ? {\n            velocity: curProp\n          } : {\n            velocity: tracker.get(p)\n          }; //if we\'re tracking this property, we should use the tracking velocity and then use the numeric value that was passed in as the min and max so that it tweens exactly there.\n        } else {\n          curVelocity = +curProp || 0;\n          curDuration = Math.abs(curVelocity / resistance);\n        }\n      }\n\n      if (_isObject(curProp)) {\n        if (_isNumber(curProp.velocity)) {\n          curVelocity = curProp.velocity;\n        } else {\n          tracker = tracker || _getTracker(target);\n          curVelocity = tracker && tracker.isTracking(p) ? tracker.get(p) : 0;\n        }\n\n        curDuration = _clamp(minDuration, maxDuration, Math.abs(curVelocity / _getNumOrDefault(curProp, "resistance", resistance)));\n        curVal = parseFloat(getVal(target, p)) || 0;\n        end = curVal + _calculateChange(curVelocity, curDuration);\n\n        if ("end" in curProp) {\n          curProp = _parseEnd(curProp, linkedProps && p in linkedProps ? linkedProps : end, curProp.max, curProp.min, p, inertiaVars.radius);\n\n          if (recordEnd) {\n            _processingVars === vars && (_processingVars = inertiaVars = _deepClone(vars));\n            inertiaVars[p] = _extend(curProp, inertiaVars[p], "end");\n          }\n        }\n\n        if ("max" in curProp && end > +curProp.max + _tinyNum) {\n          unitFactor = curProp.unitFactor || _config.unitFactors[p] || 1; //some values are measured in special units like radians in which case our thresholds need to be adjusted accordingly.\n          //if the value is already exceeding the max or the velocity is too low, the duration can end up being uncomfortably long but in most situations, users want the snapping to occur relatively quickly (0.75 seconds), so we implement a cap here to make things more intuitive. If the max and min match, it means we\'re animating to a particular value and we don\'t want to shorten the time unless the velocity is really slow. Example: a rotation where the start and natural end value are less than the snapping spot, but the natural end is pretty close to the snap.\n\n          curClippedDuration = curVal > curProp.max && curProp.min !== curProp.max || curVelocity * unitFactor > -15 && curVelocity * unitFactor < 45 ? minDuration + (maxDuration - minDuration) * 0.1 : _calculateDuration(curVal, curProp.max, curVelocity);\n\n          if (curClippedDuration + overshootTolerance < clippedDuration) {\n            clippedDuration = curClippedDuration + overshootTolerance;\n          }\n        } else if ("min" in curProp && end < +curProp.min - _tinyNum) {\n          unitFactor = curProp.unitFactor || _config.unitFactors[p] || 1; //some values are measured in special units like radians in which case our thresholds need to be adjusted accordingly.\n          //if the value is already exceeding the min or if the velocity is too low, the duration can end up being uncomfortably long but in most situations, users want the snapping to occur relatively quickly (0.75 seconds), so we implement a cap here to make things more intuitive.\n\n          curClippedDuration = curVal < curProp.min && curProp.min !== curProp.max || curVelocity * unitFactor > -45 && curVelocity * unitFactor < 15 ? minDuration + (maxDuration - minDuration) * 0.1 : _calculateDuration(curVal, curProp.min, curVelocity);\n\n          if (curClippedDuration + overshootTolerance < clippedDuration) {\n            clippedDuration = curClippedDuration + overshootTolerance;\n          }\n        }\n\n        curClippedDuration > duration && (duration = curClippedDuration);\n      }\n\n      curDuration > duration && (duration = curDuration);\n    }\n  }\n\n  duration > clippedDuration && (duration = clippedDuration);\n  return duration > maxDuration ? maxDuration : duration < minDuration ? minDuration : duration;\n},\n    InertiaPlugin_initCore = function _initCore() {\n  InertiaPlugin_gsap = InertiaPlugin_getGSAP();\n\n  if (InertiaPlugin_gsap) {\n    _parseEase = InertiaPlugin_gsap.parseEase;\n    InertiaPlugin_toArray = InertiaPlugin_gsap.utils.toArray;\n    InertiaPlugin_getUnit = InertiaPlugin_gsap.utils.getUnit;\n    InertiaPlugin_getCache = InertiaPlugin_gsap.core.getCache;\n    _clamp = InertiaPlugin_gsap.utils.clamp;\n    _power3 = _parseEase("power3");\n    _checkPointRatio = _power3(0.05);\n    PropTween = InertiaPlugin_gsap.core.PropTween;\n    InertiaPlugin_gsap.config({\n      resistance: 100,\n      unitFactors: {\n        time: 1000,\n        totalTime: 1000,\n        progress: 1000,\n        totalProgress: 1000\n      }\n    });\n    _config = InertiaPlugin_gsap.config();\n    InertiaPlugin_gsap.registerPlugin(VelocityTracker);\n    InertiaPlugin_coreInitted = 1;\n  }\n};\n\nvar InertiaPlugin = {\n  version: "3.6.1",\n  name: "inertia",\n  register: function register(core) {\n    InertiaPlugin_gsap = core;\n\n    InertiaPlugin_initCore();\n  },\n  init: function init(target, vars, tween, index, targets) {\n    InertiaPlugin_coreInitted || InertiaPlugin_initCore();\n\n    var tracker = _getTracker(target);\n\n    if (vars === "auto") {\n      if (!tracker) {\n        console.warn("No inertia tracking on " + target + ". InertiaPlugin.track(target) first.");\n        return;\n      }\n\n      vars = tracker.getAll();\n    }\n\n    this.target = target;\n    this.tween = tween;\n    _processingVars = vars; // gets swapped inside _calculateTweenDuration() if there\'s a function-based value encountered (to avoid double-calling it)\n\n    var cache = target._gsap,\n        getVal = cache.get,\n        dur = vars.duration,\n        durIsObj = _isObject(dur),\n        preventOvershoot = vars.preventOvershoot || durIsObj && dur.overshoot === 0,\n        resistance = _getNumOrDefault(vars, "resistance", _config.resistance),\n        duration = _isNumber(dur) ? dur : _calculateTweenDuration(target, vars, durIsObj && dur.max || 10, durIsObj && dur.min || 0.2, durIsObj && "overshoot" in dur ? +dur.overshoot : preventOvershoot ? 0 : 1, true),\n        p,\n        curProp,\n        curVal,\n        unit,\n        velocity,\n        change1,\n        end,\n        change2,\n        linkedProps;\n\n    vars = _processingVars;\n    _processingVars = 0; //when there are linkedProps (typically "x,y" where snapping has to factor in multiple properties, we must first populate an object with all of those end values, then feed it to the function that make any necessary alterations. So the point of this first loop is to simply build an object (like {x:100, y:204.5}) for feeding into that function which we\'ll do later in the "real" loop.\n\n    linkedProps = _processLinkedProps(target, vars, getVal, resistance);\n\n    for (p in vars) {\n      if (!_reservedProps[p]) {\n        curProp = vars[p];\n        _isFunction(curProp) && (curProp = curProp(index, target, targets));\n\n        if (_isNumber(curProp)) {\n          velocity = curProp;\n        } else if (_isObject(curProp) && !isNaN(curProp.velocity)) {\n          velocity = +curProp.velocity;\n        } else {\n          if (tracker && tracker.isTracking(p)) {\n            velocity = tracker.get(p);\n          } else {\n            console.warn("ERROR: No velocity was defined for " + target + " property: " + p);\n          }\n        }\n\n        change1 = _calculateChange(velocity, duration);\n        change2 = 0;\n        curVal = getVal(target, p);\n        unit = InertiaPlugin_getUnit(curVal);\n        curVal = parseFloat(curVal);\n\n        if (_isObject(curProp)) {\n          end = curVal + change1;\n\n          if ("end" in curProp) {\n            curProp = _parseEnd(curProp, linkedProps && p in linkedProps ? linkedProps : end, curProp.max, curProp.min, p, vars.radius);\n          }\n\n          if ("max" in curProp && +curProp.max < end) {\n            if (preventOvershoot || curProp.preventOvershoot) {\n              change1 = curProp.max - curVal;\n            } else {\n              change2 = curProp.max - curVal - change1;\n            }\n          } else if ("min" in curProp && +curProp.min > end) {\n            if (preventOvershoot || curProp.preventOvershoot) {\n              change1 = curProp.min - curVal;\n            } else {\n              change2 = curProp.min - curVal - change1;\n            }\n          }\n        }\n\n        this._props.push(p);\n\n        this._pt = new PropTween(this._pt, target, p, curVal, 0, _emptyFunc, 0, cache.set(target, p, this));\n        this._pt.u = unit || 0;\n        this._pt.c1 = change1;\n        this._pt.c2 = change2;\n      }\n    }\n\n    tween.duration(duration);\n    return InertiaPlugin_bonusValidated;\n  },\n  render: function render(ratio, data) {\n    var pt = data._pt;\n    ratio = _power3(data.tween._time / data.tween._dur);\n\n    while (pt) {\n      pt.set(pt.t, pt.p, InertiaPlugin_round(pt.s + pt.c1 * ratio + pt.c2 * ratio * ratio) + pt.u, pt.d, ratio);\n      pt = pt._next;\n    }\n  }\n};\n"track,untrack,isTracking,getVelocity,getByTarget".split(",").forEach(function (name) {\n  return InertiaPlugin[name] = VelocityTracker[name];\n});\nInertiaPlugin_getGSAP() && InertiaPlugin_gsap.registerPlugin(InertiaPlugin);\n\n;// CONCATENATED MODULE: ./app/src/js/classes/superDraggable.js\nfunction superDraggable_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction superDraggable_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction superDraggable_createClass(Constructor, protoProps, staticProps) { if (protoProps) superDraggable_defineProperties(Constructor.prototype, protoProps); if (staticProps) superDraggable_defineProperties(Constructor, staticProps); return Constructor; }\n\n// GSAP Library\n\n\n\nnode_modules_gsap/* gsap.registerPlugin */.p8.registerPlugin(Draggable/* Draggable */._, InertiaPlugin); // App\n\n\n\n // Utilities\n\n\n\nvar superDraggable_noop = function noop() {}; //eslint-disable-line\n\n\nvar superDraggable_default = /*#__PURE__*/function () {\n  function _default(options) {\n    superDraggable_classCallCheck(this, _default);\n\n    // Store\n    this.appStore = appStore; // App references\n    // this.appCore = new appCore();\n    // this.appUi = new appUi();\n    // Hook functions\n\n    this._onStart = options.onStart || superDraggable_noop;\n    this._onRaf = options.onRaf || superDraggable_noop;\n    this._onClick = options.onClick || superDraggable_noop;\n    this._onPress = options.onPress || superDraggable_noop;\n    this._onRelease = options.onRelease || superDraggable_noop;\n    this._onReleaseComplete = options.onReleaseComplete || superDraggable_noop;\n    this._onItemEnter = options.onItemEnter || superDraggable_noop;\n    this._onItemLeave = options.onItemLeave || superDraggable_noop;\n    this._onItemClick = options.onItemClick || superDraggable_noop;\n    this.domEvents = new domEvents_default();\n    this.$el = options.el;\n    this.$slider = this.$el.querySelector(\'.slider\');\n    this.$sliderInner = this.$slider.querySelector(\'.slider__inner\');\n    this.$sliderItems = this.$slider.querySelectorAll(\'.slider__item\');\n    this.$proxy = document.createElement(\'div\');\n    this.options = {\n      init: false,\n      bounds: null,\n      innerBounds: null,\n      snap: typeof options.snap !== \'undefined\' ? options.snap : false,\n      snapTo: typeof options.snapTo !== \'undefined\' ? options.snapTo : \'center\',\n      snapPoints: [],\n      snapping: false,\n      livePosition: {\n        x: 0,\n        y: 0\n      },\n      position: {\n        x: 0,\n        y: 0\n      },\n      dots: options.dots,\n      percent: 0,\n      progress: 0,\n      progressOrigin: 0\n    };\n    this.isDesktop = window.innerWidth >= 1024;\n    this.init();\n  }\n\n  superDraggable_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      var _this = this;\n\n      var isTouchDevice = function isTouchDevice() {\n        return \'ontouchstart\' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;\n      };\n\n      var _isTouchDevice = isTouchDevice();\n\n      var lerp = function lerp(value1, value2, amount) {\n        amount = amount < 0 ? 0 : amount;\n        amount = amount > 1 ? 1 : amount;\n        return value1 + (value2 - value1) * amount;\n      };\n\n      var rAF = function rAF() {\n        _this.options.percent = _this.draggable[0].x / _this.draggable[0].minX;\n        _this.options.progress = _this.draggable[0].x / (_this.draggable[0].minX - _this.$slider.offsetWidth || 1);\n\n        if (!_isTouchDevice) {\n          _this.options.livePosition.x = lerp(_this.options.livePosition.x, _this.options.position.x, 0.1);\n          node_modules_gsap/* gsap.set */.p8.set(_this.$sliderInner, {\n            x: _this.options.livePosition.x\n          });\n        }\n\n        _this._onRaf(_this.options.percent, _this.options.progress, _this.options.progressOrigin);\n      };\n\n      var rAFTouched = function rAFTouched() {\n        _this.options.percent = _this.draggable[0].x / _this.draggable[0].minX;\n        _this.options.progress = _this.draggable[0].x / (_this.draggable[0].minX - _this.$slider.offsetWidth || 1);\n\n        _this._onRaf(_this.options.percent, _this.options.progress, _this.options.progressOrigin);\n      };\n\n      this.options.bounds = this.$slider.getBoundingClientRect();\n      this.options.innerBounds = this.$sliderInner.getBoundingClientRect();\n      if (Math.round(this.options.innerBounds.width) <= Math.round(this.options.bounds.width)) this.$slider.classList.remove(\'slider--initialized\');else this.$slider.classList.add(\'slider--initialized\');\n\n      if (!_isTouchDevice) {\n        this.draggable = Draggable/* Draggable.create */._.create(this.$proxy, {\n          type: \'x\',\n          trigger: this.$sliderInner,\n          bounds: {\n            maxX: 0,\n            minX: -(this.options.innerBounds.width - this.options.bounds.width)\n          },\n          throwProps: true,\n          edgeResistance: 0.95,\n          dragResistance: 0,\n          snap: this.options.snap ? {\n            x: this.options.snapPoints\n          } : false,\n          onClick: function onClick() {\n            _this._onClick();\n          },\n          onPress: function onPress() {\n            _this._onPress();\n          },\n          onRelease: function onRelease() {\n            _this._onRelease();\n          },\n          onDragStart: function onDragStart() {\n            clearTimeout(_this.killRaf);\n            node_modules_gsap/* gsap.ticker.add */.p8.ticker.add(rAF);\n          },\n          onDrag: function onDrag() {\n            _this.options.position.x = _this.draggable[0].x;\n          },\n          onThrowUpdate: function onThrowUpdate() {\n            _this.options.position.x = _this.draggable[0].x;\n\n            _this.updateDots();\n          },\n          onThrowComplete: function onThrowComplete() {\n            _this._onReleaseComplete();\n\n            _this.killRaf = setTimeout(function () {\n              node_modules_gsap/* gsap.ticker.remove */.p8.ticker.remove(rAF);\n            }, 1000);\n          }\n        });\n      } else {\n        this.draggable = Draggable/* Draggable.create */._.create(this.$sliderInner, {\n          type: \'x\',\n          bounds: {\n            maxX: 0,\n            minX: -(this.options.innerBounds.width - this.options.bounds.width)\n          },\n          throwProps: true,\n          edgeResistance: 0.8,\n          dragResistance: 0,\n          snap: this.options.snap ? {\n            x: this.options.snapPoints\n          } : false,\n          onClick: function onClick() {\n            _this._onClick();\n          },\n          onPress: function onPress() {\n            _this._onPress();\n          },\n          onRelease: function onRelease() {\n            _this._onRelease();\n          },\n          onDrag: function onDrag() {\n            rAFTouched();\n          },\n          onThrowUpdate: function onThrowUpdate() {\n            rAFTouched(); // this.updateDots();\n          },\n          onThrowComplete: function onThrowComplete() {\n            _this._onReleaseComplete();\n          }\n        });\n      }\n\n      this.options.percent = this.draggable[0].x / this.draggable[0].minX;\n      this.options.progressOrigin = -(this.options.bounds.width / (this.draggable[0].minX - this.options.bounds.width));\n\n      for (var i = 0; i < this.$sliderItems.length; i++) {\n        this.domEvents.add(this.$sliderItems[i], \'mouseenter\', function (e, a, el) {\n          _this._onItemEnter(e, a, el);\n        });\n        this.domEvents.add(this.$sliderItems[i], \'mouseleave\', function (e, a, el) {\n          _this._onItemLeave(e, a, el);\n        });\n        this.domEvents.add(this.$sliderItems[i], \'click\', function (e, a, el) {\n          _this._onItemClick(e, a, el);\n        });\n      }\n\n      if (!_isTouchDevice) rAF();else rAFTouched();\n      if (this.options.dots) this.createDots();\n    }\n  }, {\n    key: "createDots",\n    value: function createDots() {\n      this.$sliderDots = this.$el.querySelector(\'.slider__dots\');\n\n      if (this.$sliderDots) {\n        for (var i = 0; i < this.$sliderItems.length; i++) {\n          this.$dot = document.createElement(\'div\');\n          this.$dot.className = \'dots__item\';\n          this.$sliderDots.appendChild(this.$dot);\n        }\n\n        this.$dots = this.$el.querySelectorAll(\'.dots__item\');\n        this.$dots[0].classList.add(\'active\');\n      }\n    }\n  }, {\n    key: "updateDots",\n    value: function updateDots() {\n      if (this.options.snap && this.options.dots && !this.isDesktop) {\n        this.$sliderDots.childNodes.forEach(function (e) {\n          return e.classList.remove(\'active\');\n        });\n        var goal = this.draggable[0].x;\n        var closest = this.options.snapPoints.reduce(function (prev, curr) {\n          return Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev;\n        });\n        var index = this.options.snapPoints.indexOf(closest);\n        this.$dots[index].classList.add(\'active\');\n      }\n    }\n  }, {\n    key: "setBounds",\n    value: function setBounds() {\n      this.options.bounds = this.$slider.getBoundingClientRect();\n      this.options.innerBounds = this.$sliderInner.getBoundingClientRect();\n      this.options.percent = this.draggable[0].x / this.draggable[0].minX;\n      this.options.progressOrigin = -(this.options.bounds.width / (this.draggable[0].minX - this.options.bounds.width));\n      var minX = -(this.options.innerBounds.width - this.options.bounds.width);\n      this.options.position.x = minX * this.options.percent;\n      this.options.livePosition.x = minX * this.options.percent;\n      node_modules_gsap/* gsap.set */.p8.set(this.$proxy, {\n        x: minX * this.options.percent\n      });\n      node_modules_gsap/* gsap.set */.p8.set(this.$sliderInner, {\n        x: minX * this.options.percent\n      });\n    }\n  }, {\n    key: "refresh",\n    value: function refresh() {\n      this.draggable[0].applyBounds({\n        x: 0,\n        minX: -(this.options.innerBounds.width - this.options.bounds.width),\n        maxX: 0\n      });\n      this.draggable[0].update();\n    }\n  }, {\n    key: "setSnapPoints",\n    value: function setSnapPoints() {\n      if (Math.round(this.options.innerBounds.width) <= Math.round(this.options.bounds.width)) this.$slider.classList.remove(\'slider--initialized\');else this.$slider.classList.add(\'slider--initialized\');\n\n      if (this.options.snap) {\n        this.options.snapPoints = [];\n        this.options.snapPoints.push(this.draggable[0].maxX);\n\n        for (var i = 1; i < this.$sliderItems.length - 1; i++) {\n          if (this.options.snapTo === \'center\') this.options.snapPoints.push(-this.$sliderItems[i].offsetLeft + this.options.bounds.width / 2 - this.$sliderItems[i].offsetWidth / 2);else if (this.options.snapTo === \'left\') this.options.snapPoints.push(-this.$sliderItems[i].offsetLeft);else if (this.options.snapTo === \'right\') this.options.snapPoints.push(-this.$sliderItems[i].offsetLeft + this.options.bounds.width - this.$sliderItems[i].offsetWidth);\n        }\n\n        this.options.snapPoints.push(this.draggable[0].minX);\n        this.draggable[0].vars.snap.x = this.options.snapPoints;\n        this.draggable[0].update(true);\n      }\n    }\n  }, {\n    key: "checkStatus",\n    value: function checkStatus() {\n      if (Math.round(this.options.innerBounds.width) <= Math.round(this.options.bounds.width)) {\n        this.draggable[0].disable();\n        node_modules_gsap/* gsap.set */.p8.set(this.$sliderInner, {\n          x: 0\n        });\n      } else {\n        this.draggable[0].enable();\n      }\n    }\n  }, {\n    key: "updateDirections",\n    value: function updateDirections() {// if (this.getDirection(\'velocity\') === \'left\')\n      // {\n      // }\n      // else {\n      // }\n    }\n  }, {\n    key: "resize",\n    value: function resize() {\n      this.setBounds();\n      this.setSnapPoints();\n      this.updateDots();\n      this.checkStatus();\n      this.refresh();\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      this.draggable[0].kill();\n    }\n  }]);\n\n  return _default;\n}();\n\n\n;// CONCATENATED MODULE: ./app/src/js/components/sliderSolutions.js\nfunction sliderSolutions_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction sliderSolutions_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction sliderSolutions_createClass(Constructor, protoProps, staticProps) { if (protoProps) sliderSolutions_defineProperties(Constructor.prototype, protoProps); if (staticProps) sliderSolutions_defineProperties(Constructor, staticProps); return Constructor; }\n\n// GSAP Library\n\n // App\n\n\n\n // Utilities\n\n\n\n\nvar sliderSolutions_EventEmitter = __webpack_require__(7187);\n\nvar sliderSolutions_default = /*#__PURE__*/function () {\n  function _default(options) {\n    sliderSolutions_classCallCheck(this, _default);\n\n    // Store\n    this.appStore = appStore; // App references\n\n    this.appUi = new app_appUi();\n    this.appCore = new app_appCore();\n    this.domEvents = new domEvents_default();\n    this.emitter = new sliderSolutions_EventEmitter();\n    this._slider = {\n      target: options.target,\n      current: 0,\n      total: 0,\n      direction: \'next\',\n      progress: 0,\n      prev: 0,\n      next: 0,\n      dir: 1,\n      navigationProgress1: 0,\n      navigationProgress2: 0,\n      duration: 1.2,\n      delay: typeof options.delay !== \'undefined\' ? options.delay : 4,\n      ease: \'expo.inOut\',\n      animating: true,\n      tlAnimation: null,\n      autoplay: typeof options.autoplay !== \'undefined\' ? options.autoplay : true,\n      autoplaySpeed: typeof options.autoplaySpeed !== \'undefined\' ? options.autoplaySpeed : 4,\n      autoplayProgress: 0,\n      autoplayController: null\n    };\n    this.selectors();\n    this.init();\n    this.events();\n  }\n\n  sliderSolutions_createClass(_default, [{\n    key: "selectors",\n    value: function selectors() {\n      // Selectors\n      this.$slider = this._slider.target;\n      this.$sliderInner = this.$slider.querySelector(\'.slider__inner\');\n      this.$sliderItems = this.$sliderInner.querySelectorAll(\'.slider__item\');\n      this.$sliderNavigation = this.$slider.querySelectorAll(\'.slider__navigation\');\n      this.$sliderNavigationPrev = this.$slider.querySelector(\'.slider__navigation--prev\');\n      this.$sliderNavigationNext = this.$slider.querySelector(\'.slider__navigation--next\');\n    }\n  }, {\n    key: "events",\n    value: function events() {\n      var _this = this;\n\n      this.domEvents.add(this.$sliderNavigationPrev, \'click\', function () {\n        if (_this.appStore.isDesktop) {\n          node_modules_gsap/* gsap.to */.p8.to(_this.$sliderNavigationPrev.children[0], {\n            clipPath: \'circle(10% at 50% 50%)\',\n            webkitClipPath: \'circle(10% at 50% 50%)\',\n            duration: 2,\n            ease: \'expo.out\'\n          });\n        } else {\n          node_modules_gsap/* gsap.set */.p8.set(_this.$sliderNavigationPrev, {\n            pointerEvents: \'none\',\n            onComplete: function onComplete() {\n              node_modules_gsap/* gsap.delayedCall */.p8.delayedCall(1, function () {\n                node_modules_gsap/* gsap.set */.p8.set(_this.$sliderNavigationPrev, {\n                  pointerEvents: \'initial\'\n                });\n              });\n            }\n          });\n        }\n\n        _this.updateNavigation(\'prev\');\n\n        _this.controllAutoplay();\n      });\n      this.domEvents.add(this.$sliderNavigationNext, \'click\', function () {\n        if (_this.appStore.isDesktop) {\n          node_modules_gsap/* gsap.to */.p8.to(_this.$sliderNavigationNext.children[0], {\n            clipPath: \'circle(10% at 50% 50%)\',\n            webkitClipPath: \'circle(10% at 50% 50%)\',\n            duration: 2,\n            ease: \'expo.out\'\n          });\n        } else {\n          node_modules_gsap/* gsap.set */.p8.set(_this.$sliderNavigationNext, {\n            pointerEvents: \'none\',\n            onComplete: function onComplete() {\n              node_modules_gsap/* gsap.delayedCall */.p8.delayedCall(1, function () {\n                node_modules_gsap/* gsap.set */.p8.set(_this.$sliderNavigationNext, {\n                  pointerEvents: \'initial\'\n                });\n              });\n            }\n          });\n        }\n\n        _this.updateNavigation(\'next\');\n\n        _this.controllAutoplay();\n      });\n\n      if (this.appStore.isDesktop) {\n        for (var i = 0; i < this.$sliderNavigation.length; i++) {\n          this.domEvents.add(this.$sliderNavigation[i], \'mouseenter\', function (a, e, el) {\n            _this.enterNavigation(a, e, el);\n          });\n          this.domEvents.add(this.$sliderNavigation[i], \'mouseleave\', function (a, e, el) {\n            _this.leaveNavigation(a, e, el);\n          });\n        }\n\n        this.$sliderLinks = this.$slider.querySelectorAll(\'.link\');\n\n        for (var _i = 0; _i < this.$sliderLinks.length; _i++) {\n          this.domEvents.add(this.$sliderLinks[_i], \'mouseenter\', function (a, e, el) {\n            node_modules_gsap/* gsap.to */.p8.to(el.querySelector(\'.underline\'), {\n              scaleX: 0,\n              duration: 0.6,\n              ease: \'expo.inOut\'\n            });\n          });\n          this.domEvents.add(this.$sliderLinks[_i], \'mouseleave\', function (a, e, el) {\n            node_modules_gsap/* gsap.to */.p8.to(el.querySelector(\'.underline\'), {\n              scaleX: 1,\n              duration: 0.6,\n              ease: \'expo.inOut\'\n            });\n          });\n        }\n      }\n    }\n  }, {\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      // Set total count\n      this._slider.total = this.$sliderItems.length; // Set all slides\n\n      for (var i = 0; i < this.$sliderItems.length; i++) {\n        /* Items */\n        if (this.appStore.isDesktop) node_modules_gsap/* gsap.set */.p8.set(this.$sliderItems[i], {\n          display: \'none\',\n          opacity: 1\n        });\n        /* Texts */\n        // eslint-disable-next-line no-new\n\n        new SplitText(this.$sliderItems[i].querySelector(\'.title\'), {\n          type: \'lines words\',\n          linesClass: \'line line--++\',\n          wordsClass: \'word word--++\'\n        });\n\n        for (var j = 0; j < this.$sliderItems[i].querySelectorAll(\'.title .word\').length; j++) {\n          node_modules_gsap/* gsap.set */.p8.set(this.$sliderItems[i].querySelectorAll(\'.title .word\')[j], {\n            opacity: 0.0001,\n            y: \'100%\',\n            rotation: \'3deg\'\n          });\n        }\n\n        node_modules_gsap/* gsap.set */.p8.set(this.$sliderItems[i].querySelector(\'.link\'), {\n          opacity: 0.0001\n        });\n        /* Backgrounds */\n\n        if (!this.appStore.isDesktop) node_modules_gsap/* gsap.set */.p8.set(this.$sliderItems[i].querySelector(\'.background\'), {\n          display: \'none\'\n        });\n      } // Set current slide\n\n      /* Items */\n\n\n      if (this.appStore.isDesktop) node_modules_gsap/* gsap.set */.p8.set(this.$sliderItems[0], {\n        display: \'block\'\n      });\n      /* Texts */\n\n      for (var _i2 = 0; _i2 < this.$sliderItems[0].querySelectorAll(\'.title .word\').length; _i2++) {\n        node_modules_gsap/* gsap.to */.p8.to(this.$sliderItems[0].querySelectorAll(\'.title .word\')[_i2], {\n          opacity: 1,\n          y: \'0%\',\n          rotation: \'0deg\',\n          ease: this._slider.ease,\n          duration: this._slider.duration,\n          delay: 0.3 + _i2 * 0.01\n        });\n      }\n\n      node_modules_gsap/* gsap.set */.p8.set(this.$sliderItems[0].querySelector(\'.link\'), {\n        opacity: 1\n      });\n      /* Backgrounds */\n\n      if (!this.appStore.isDesktop) node_modules_gsap/* gsap.set */.p8.set(this.$sliderItems[0].querySelector(\'.background\'), {\n        display: \'block\'\n      });\n\n      if (this.appStore.isDesktop) {\n        // Get backgrounds url\n        var prevUrl = this.$sliderItems[this.$sliderItems.length - 1].querySelector(\'.background\').children[0].style.backgroundImage.substring(5, this.$sliderItems[this.$sliderItems.length - 1].querySelector(\'.background\').children[0].style.backgroundImage.length - 2);\n        var nextUrl = this.$sliderItems[1].querySelector(\'.background\').children[0].style.backgroundImage.substring(5, this.$sliderItems[1].querySelector(\'.background\').children[0].style.backgroundImage.length - 2); // Set navigation backgrounds url\n\n        node_modules_gsap/* gsap.set */.p8.set(this.$sliderNavigationPrev.querySelector(\'.background\').children[0], {\n          backgroundImage: \'url(\' + prevUrl + \')\'\n        });\n        node_modules_gsap/* gsap.set */.p8.set(this.$sliderNavigationNext.querySelector(\'.background\').children[0], {\n          backgroundImage: \'url(\' + nextUrl + \')\'\n        });\n      }\n\n      node_modules_gsap/* gsap.delayedCall */.p8.delayedCall(this._slider.autoplaySpeed, function () {\n        _this2.autoplay();\n\n        _this2._slider.animating = false;\n      });\n    }\n  }, {\n    key: "controllAutoplay",\n    value: function controllAutoplay() {\n      if (this._slider.autoplay) return;\n      this._slider.autoplay = true;\n      this.autoplay();\n    }\n  }, {\n    key: "autoplay",\n    value: function autoplay() {\n      var _this3 = this;\n\n      // Timeline Slider scroll\n      if (this._slider.autoplay) {\n        this._slider.autoplayController = node_modules_gsap/* gsap.timeline */.p8.timeline({\n          paused: false,\n          defaults: {\n            duration: this._slider.autoplaySpeed,\n            ease: \'none\'\n          },\n          onComplete: function onComplete() {\n            _this3.change(\'next\');\n          }\n        });\n\n        this._slider.autoplayController.fromTo(this._slider, {\n          autoplayProgress: 0\n        }, {\n          autoplayProgress: 1\n        });\n      }\n    }\n  }, {\n    key: "autoplayPause",\n    value: function autoplayPause() {\n      if (this._slider.autoplayController) this._slider.autoplayController.pause();\n    }\n  }, {\n    key: "autoplayPlay",\n    value: function autoplayPlay() {\n      if (this._slider.autoplayController) this._slider.autoplayController.play();\n    }\n  }, {\n    key: "updateNavigation",\n    value: function updateNavigation(direction) {\n      var _this4 = this;\n\n      this._slider.animating = false;\n      if (this._slider.animating) return;\n      this.navigation(direction);\n\n      if (this._slider.autoplay) {\n        this._slider.autoplayController.pause();\n\n        node_modules_gsap/* gsap.fromTo */.p8.fromTo(this._slider, {\n          navigationProgress1: this._slider.navigationProgress1,\n          navigationProgress2: 0\n        }, {\n          navigationProgress1: 1,\n          navigationProgress2: 1,\n          duration: 1,\n          ease: this._slider.ease,\n          delay: 0,\n          onComplete: function onComplete() {\n            _this4._slider.autoplayController.restart();\n          }\n        });\n      }\n    }\n  }, {\n    key: "enterNavigation",\n    value: function enterNavigation(a, e, el) {\n      node_modules_gsap/* gsap.to */.p8.to(el.children[0], {\n        clipPath: \'circle(45% at 50% 50%)\',\n        webkitClipPath: \'circle(45% at 50% 50%)\',\n        duration: 2,\n        ease: \'expo.out\'\n      });\n      node_modules_gsap/* gsap.to */.p8.to(el.children[1], {\n        scale: 0.9,\n        duration: 2,\n        ease: \'expo.out\'\n      });\n    }\n  }, {\n    key: "leaveNavigation",\n    value: function leaveNavigation(a, e, el) {\n      node_modules_gsap/* gsap.to */.p8.to(el.children[0], {\n        clipPath: \'circle(10% at 50% 50%)\',\n        webkitClipPath: \'circle(10% at 50% 50%)\',\n        duration: 2,\n        ease: \'expo.out\'\n      });\n      node_modules_gsap/* gsap.to */.p8.to(el.children[1], {\n        scale: 1,\n        duration: 2,\n        ease: \'expo.out\'\n      });\n    }\n  }, {\n    key: "change",\n    value: function change(direction) {\n      var _this5 = this;\n\n      this._slider.direction = direction;\n      this._slider.next = (this._slider.current + 1) % this._slider.total;\n      this._slider.prev = this._slider.current === -1 ? this._slider.total - 1 : this._slider.current;\n      this._slider.current = this._slider.next;\n\n      if (this._slider.autoplay) {\n        this._slider.autoplayController.pause();\n\n        node_modules_gsap/* gsap.delayedCall */.p8.delayedCall(this._slider.autoplaySpeed, function () {\n          _this5._slider.autoplayController.restart();\n        });\n      } // Slider animation\n\n\n      if (this.appStore.isDesktop) this.animation(this._slider.direction);else this.animationMobile(this._slider.direction); // WebGL\n\n      this.emitter.emit(\'onSliderChange\', {\n        direction: this._slider.direction,\n        duration: this._slider.duration,\n        action: \'change\',\n        color: this.$sliderItems[this._slider.next].dataset.color\n      }); // Reset animation vars\n\n      node_modules_gsap/* gsap.delayedCall */.p8.delayedCall(this._slider.autoplaySpeed, function () {\n        _this5._slider.current = _this5._slider.next;\n        _this5._slider.animating = false;\n      });\n    }\n  }, {\n    key: "navigation",\n    value: function navigation(direction) {\n      var _this6 = this;\n\n      this._slider.direction = direction;\n\n      if (this._slider.direction === \'next\') {\n        this._slider.next = (this._slider.current + 1) % this._slider.total;\n        this._slider.prev = this._slider.current === -1 ? this._slider.total - 1 : this._slider.current;\n        this._slider.dir = 1;\n      } else {\n        this._slider.next = this._slider.current === 0 ? this._slider.total - 1 : this._slider.current - 1;\n        this._slider.prev = this._slider.current === -1 ? this._slider.total - 1 : this._slider.current;\n        this._slider.dir = -1;\n      }\n\n      this._slider.current = this._slider.next;\n\n      if (this._slider.autoplay) {\n        this._slider.autoplayController.pause();\n\n        node_modules_gsap/* gsap.delayedCall */.p8.delayedCall(this._slider.duration, function () {\n          _this6._slider.autoplayController.restart();\n        });\n      } // Slider animation\n\n\n      if (this.appStore.isDesktop) this.animation(this._slider.direction);else this.animationMobile(this._slider.direction); // WebGL\n\n      this.emitter.emit(\'onSliderChange\', {\n        direction: this._slider.direction,\n        duration: this._slider.duration,\n        action: \'navigation\',\n        color: this.$sliderItems[this._slider.next].dataset.color\n      }); // Reset animation vars\n\n      node_modules_gsap/* gsap.delayedCall */.p8.delayedCall(this._slider.duration, function () {\n        _this6._slider.current = _this6._slider.next;\n        _this6._slider.animating = false;\n      });\n    }\n  }, {\n    key: "animation",\n    value: function animation(direction) {\n      var _this7 = this;\n\n      // Set next slide\n\n      /* Items */\n      node_modules_gsap/* gsap.set */.p8.set(this.$sliderItems[this._slider.next], {\n        display: \'block\',\n        clipPath: \'circle(50% at 50% 50%)\',\n        webkitClipPath: \'circle(50% at 50% 50%)\',\n        opacity: 0.0001\n      });\n      /* Texts */\n\n      for (var i = 0; i < this.$sliderItems[this._slider.next].querySelectorAll(\'.title .word\').length; i++) {\n        node_modules_gsap/* gsap.set */.p8.set(this.$sliderItems[this._slider.next].querySelectorAll(\'.title .word\')[i], {\n          opacity: 0.0001,\n          y: \'100%\',\n          rotation: \'3deg\'\n        });\n      }\n      /* Backgrounds */\n\n\n      node_modules_gsap/* gsap.set */.p8.set(this.$sliderItems[this._slider.next].querySelector(\'.background\').children[0], {\n        scale: 1.2\n      }); // Get backgrounds url\n\n      this.prevUrl = this.$sliderItems[this._slider.prev].querySelector(\'.background\').children[0].style.backgroundImage.substring(5, this.$sliderItems[this._slider.prev].querySelector(\'.background\').children[0].style.backgroundImage.length - 2);\n      this.nextUrl = this.$sliderItems[this._slider.next === this._slider.total - 1 ? 0 : this._slider.next + 1].querySelector(\'.background\').children[0].style.backgroundImage.substring(5, this.$sliderItems[this._slider.next === this._slider.total - 1 ? 0 : this._slider.next + 1].querySelector(\'.background\').children[0].style.backgroundImage.length - 2); // console.log(direction === \'prev\' && this._slider.prev !== 0, this._slider.prev === 0);\n      // console.log(\'Prev: \' + this._slider.prev, \'Next: \' + this._slider.next);\n      // Animate out current slide\n\n      /* Items */\n\n      node_modules_gsap/* gsap.to */.p8.to(this.$sliderItems[this._slider.prev], {\n        clipPath: \'circle(10% at 50% 50%)\',\n        opacity: 0.0001,\n        webkitClipPath: \'circle(10% at 50% 50%)\',\n        duration: this._slider.duration,\n        ease: this._slider.ease\n      });\n      node_modules_gsap/* gsap.to */.p8.to(this.$sliderItems[this._slider.next], {\n        clipPath: \'circle(10% at 50% 50%)\',\n        opacity: 1,\n        webkitClipPath: \'circle(10% at 50% 50%)\',\n        duration: this._slider.duration,\n        ease: this._slider.ease\n      });\n      /* Texts */\n\n      for (var _i3 = 0; _i3 < this.$sliderItems[this._slider.prev].querySelectorAll(\'.title .word\').length; _i3++) {\n        node_modules_gsap/* gsap.to */.p8.to(this.$sliderItems[this._slider.prev].querySelectorAll(\'.title .word\')[_i3], {\n          opacity: 0.0001,\n          y: \'-100%\',\n          rotation: \'-3deg\',\n          duration: this._slider.duration,\n          ease: this._slider.ease,\n          delay: _i3 * 0.01,\n          onComplete: function onComplete() {\n            node_modules_gsap/* gsap.set */.p8.set(_this7.$sliderItems[_this7._slider.prev], {\n              display: \'none\'\n            });\n          }\n        });\n      }\n\n      node_modules_gsap/* gsap.to */.p8.to(this.$sliderItems[this._slider.prev].querySelector(\'.link\'), {\n        opacity: 0.0001,\n        duration: this._slider.duration,\n        ease: this._slider.ease\n      });\n      /* Arrows */\n\n      node_modules_gsap/* gsap.set */.p8.set(this.$sliderNavigationPrev.querySelector(\'.background\').children[0], {\n        backgroundImage: \'url(\' + this.prevUrl + \')\'\n      });\n      node_modules_gsap/* gsap.set */.p8.set(this.$sliderNavigationNext.querySelector(\'.background\').children[0], {\n        backgroundImage: \'url(\' + this.nextUrl + \')\'\n      }); // Animate in next slide\n\n      /* Items */\n\n      node_modules_gsap/* gsap.to */.p8.to(this.$sliderItems[this._slider.next], {\n        clipPath: \'circle(50% at 50% 50%)\',\n        webkitClipPath: \'circle(50% at 50% 50%)\',\n        duration: this._slider.duration,\n        ease: this._slider.ease,\n        delay: this._slider.duration\n      });\n      /* Texts */\n\n      for (var _i4 = 0; _i4 < this.$sliderItems[this._slider.next].querySelectorAll(\'.title .word\').length; _i4++) {\n        node_modules_gsap/* gsap.to */.p8.to(this.$sliderItems[this._slider.next].querySelectorAll(\'.title .word\')[_i4], {\n          opacity: 1,\n          y: \'0%\',\n          rotation: \'0deg\',\n          duration: this._slider.duration,\n          ease: this._slider.ease,\n          delay: this._slider.duration + _i4 * 0.01\n        });\n      }\n\n      node_modules_gsap/* gsap.to */.p8.to(this.$sliderItems[this._slider.next].querySelector(\'.link\'), {\n        opacity: 1,\n        duration: this._slider.duration,\n        ease: this._slider.ease,\n        delay: this._slider.duration\n      });\n      /* Backgrounds */\n\n      node_modules_gsap/* gsap.to */.p8.to(this.$sliderItems[this._slider.next].querySelector(\'.background\').children[0], {\n        scale: 1,\n        duration: this._slider.duration * 6,\n        ease: \'expo.out\',\n        delay: this._slider.duration\n      });\n    }\n  }, {\n    key: "animationMobile",\n    value: function animationMobile(direction) {\n      // Set next slide\n\n      /* Texts */\n      for (var i = 0; i < this.$sliderItems[this._slider.next].querySelectorAll(\'.title .word\').length; i++) {\n        node_modules_gsap/* gsap.set */.p8.set(this.$sliderItems[this._slider.next].querySelectorAll(\'.title .word\')[i], {\n          opacity: 0.0001,\n          y: \'100%\',\n          rotation: \'3deg\'\n        });\n      }\n      /* Backgrounds */\n\n\n      node_modules_gsap/* gsap.set */.p8.set(this.$sliderItems[this._slider.next].querySelector(\'.background\'), {\n        display: \'block\',\n        x: \'100%\'\n      });\n      node_modules_gsap/* gsap.set */.p8.set(this.$sliderItems[this._slider.next].querySelector(\'.background\').children[0], {\n        x: \'0%\'\n      }); // Animate out current slide\n\n      /* Texts */\n\n      for (var _i5 = 0; _i5 < this.$sliderItems[this._slider.prev].querySelectorAll(\'.title .word\').length; _i5++) {\n        node_modules_gsap/* gsap.to */.p8.to(this.$sliderItems[this._slider.prev].querySelectorAll(\'.title .word\')[_i5], {\n          opacity: 0.0001,\n          y: \'-100%\',\n          rotation: \'-3deg\',\n          duration: this._slider.duration,\n          ease: this._slider.ease,\n          delay: _i5 * 0.01\n        });\n      }\n\n      node_modules_gsap/* gsap.to */.p8.to(this.$sliderItems[this._slider.prev].querySelector(\'.link\'), {\n        opacity: 0.0001,\n        duration: this._slider.duration,\n        ease: this._slider.ease\n      });\n      /* Backgrounds */\n\n      node_modules_gsap/* gsap.fromTo */.p8.fromTo(this.$sliderItems[this._slider.prev].querySelector(\'.background\'), {\n        x: \'0%\'\n      }, {\n        x: \'-100%\',\n        ease: this._slider.ease,\n        duration: this._slider.duration,\n        delay: this._slider.duration\n      });\n      node_modules_gsap/* gsap.fromTo */.p8.fromTo(this.$sliderItems[this._slider.prev].querySelector(\'.background\').children[0], {\n        x: \'0%\'\n      }, {\n        x: \'100%\',\n        ease: this._slider.ease,\n        duration: this._slider.duration,\n        delay: this._slider.duration\n      }); // Animate in next slide\n\n      /* Texts */\n\n      for (var _i6 = 0; _i6 < this.$sliderItems[this._slider.next].querySelectorAll(\'.title .word\').length; _i6++) {\n        node_modules_gsap/* gsap.to */.p8.to(this.$sliderItems[this._slider.next].querySelectorAll(\'.title .word\')[_i6], {\n          opacity: 1,\n          y: \'0%\',\n          rotation: \'0deg\',\n          duration: this._slider.duration,\n          ease: this._slider.ease,\n          delay: this._slider.duration + _i6 * 0.01\n        });\n      }\n\n      node_modules_gsap/* gsap.to */.p8.to(this.$sliderItems[this._slider.next].querySelector(\'.link\'), {\n        opacity: 1,\n        duration: this._slider.duration,\n        ease: this._slider.ease,\n        delay: this._slider.duration\n      });\n      /* Backgrounds */\n\n      node_modules_gsap/* gsap.fromTo */.p8.fromTo(this.$sliderItems[this._slider.next].querySelector(\'.background\'), {\n        x: \'100%\'\n      }, {\n        x: \'0%\',\n        ease: this._slider.ease,\n        duration: this._slider.duration,\n        delay: this._slider.duration / 2\n      });\n      node_modules_gsap/* gsap.fromTo */.p8.fromTo(this.$sliderItems[this._slider.next].querySelector(\'.background\').children[0], {\n        x: \'-100%\'\n      }, {\n        x: \'0%\',\n        ease: this._slider.ease,\n        duration: this._slider.duration,\n        delay: this._slider.duration / 2\n      });\n      node_modules_gsap/* gsap.fromTo */.p8.fromTo(this.$sliderItems[this._slider.next].querySelector(\'.background\').children[0], {\n        scale: 1.1\n      }, {\n        scale: 1,\n        duration: 4,\n        ease: \'expo.out\',\n        delay: this._slider.duration / 2\n      });\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      if (this._slider.autoplayController) this._slider.autoplayController.pause();\n      if (this.domEvents) this.domEvents.destroy();\n    }\n  }]);\n\n  return _default;\n}();\n\n\n;// CONCATENATED MODULE: ./app/src/js/renderers/rendererHome.js\nfunction rendererHome_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rendererHome_typeof = function _typeof(obj) { return typeof obj; }; } else { rendererHome_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rendererHome_typeof(obj); }\n\nfunction rendererHome_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rendererHome_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rendererHome_createClass(Constructor, protoProps, staticProps) { if (protoProps) rendererHome_defineProperties(Constructor.prototype, protoProps); if (staticProps) rendererHome_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rendererHome_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rendererHome_setPrototypeOf(subClass, superClass); }\n\nfunction rendererHome_setPrototypeOf(o, p) { rendererHome_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rendererHome_setPrototypeOf(o, p); }\n\nfunction rendererHome_createSuper(Derived) { var hasNativeReflectConstruct = rendererHome_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rendererHome_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rendererHome_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rendererHome_possibleConstructorReturn(this, result); }; }\n\nfunction rendererHome_possibleConstructorReturn(self, call) { if (call && (rendererHome_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return rendererHome_assertThisInitialized(self); }\n\nfunction rendererHome_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rendererHome_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rendererHome_getPrototypeOf(o) { rendererHome_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rendererHome_getPrototypeOf(o); }\n\n// GSAP Library\n\n\n\nnode_modules_gsap/* default.registerPlugin */.ZP.registerPlugin(ScrollTrigger/* default */.Z);\n\nnode_modules_gsap/* default.registerPlugin */.ZP.registerPlugin((DrawSVGPlugin_min_default())); // Import Renderer\n\n // Webgl\n\n\n\n\n\n\n // Utilities\n\n\n\n\n\n\nvar RendererHome = /*#__PURE__*/function (_Renderer) {\n  rendererHome_inherits(RendererHome, _Renderer);\n\n  var _super = rendererHome_createSuper(RendererHome);\n\n  function RendererHome() {\n    rendererHome_classCallCheck(this, RendererHome);\n\n    return _super.apply(this, arguments);\n  }\n\n  rendererHome_createClass(RendererHome, [{\n    key: "selectors",\n    value: function selectors() {\n      // Sections\n      this.$hero = this.$el.querySelector(\'.home__hero\');\n      this.$data = this.$el.querySelector(\'.home__data\');\n      this.$services = this.$el.querySelector(\'.home__services\');\n      this.$solutions = this.$el.querySelector(\'.home__solutions\');\n      this.$technology = this.$el.querySelector(\'.home__technology\');\n      this.$platforms = this.$el.querySelector(\'.home__platforms\');\n      this.$clients = this.$el.querySelector(\'.home__clients\'); // Video\n\n      this.$video = this.$hero.querySelector(\'.hero__video\');\n      if (this.$video) this.$videoEl = this.$video.querySelector(\'.video\'); // Canvas\n\n      this.$canvasHome1 = this.$el.querySelector(\'#webgl_home1\');\n      this.$canvasHome2 = this.$el.querySelector(\'#webgl_home2\');\n      this.$canvasHome3 = this.$el.querySelector(\'#webgl_home3\');\n      this.$canvasHome4 = this.$el.querySelector(\'#webgl_home4\');\n      this.$canvasHome1_m = this.$el.querySelector(\'#webgl_home1_m\');\n      this.$canvasHome2a_m = this.$el.querySelector(\'#webgl_home2a_m\');\n      this.$canvasHome2b_m = this.$el.querySelector(\'#webgl_home2b_m\');\n    }\n  }, {\n    key: "events",\n    value: function events() {\n      var _this = this;\n\n      if (!this.appStore.isDesktop) {\n        if (this.$services) {\n          this.$servicesButtons = this.$services.querySelectorAll(\'.icon--plus\');\n\n          var _loop = function _loop(i) {\n            _this.domEvents.add(_this.$servicesButtons[i], \'click\', function (a, e, el) {\n              if (_this.appUi.isAnimating) _this.closeServicesMobile(a, e, el, i);else _this.openServicesMobile(a, e, el, i);\n            });\n          };\n\n          for (var i = 0; i < this.$servicesButtons.length; i++) {\n            _loop(i);\n          }\n        }\n\n        if (this.$hero) {\n          this.$heroCircle = this.$hero.querySelector(\'.circle\');\n          this.domEvents.add(this.$heroCircle, \'click\', function (a, e, el) {\n            _this.openForm();\n          });\n        }\n      }\n    }\n  }, {\n    key: "preload",\n    value: function preload() {\n      var _main = [];\n      var _secondary = []; // if(this.appStore.isDesktop && this.$videoEl)\n      // {\n      //     const videoUrl = this.$videoEl.querySelector(\'video source\').getAttribute(\'src\');\n      //     _main.push(videoUrl);\n      // }\n\n      this.preloadItems = {\n        main: _main,\n        secondary: _secondary\n      };\n    }\n  }, {\n    key: "beforeEnter",\n    value: function beforeEnter() {\n      this.setEnterAnimation();\n\n      if (this.$platforms) {\n        this.$platformsTitle = this.$platforms.querySelector(\'.title--small\');\n\n        if (this.$platformsTitle) {\n          // eslint-disable-next-line no-new\n          new SplitText(this.$platformsTitle, {\n            type: \'lines words\',\n            linesClass: \'line line--++\',\n            wordsClass: \'word word--++\'\n          });\n          var words = this.$platformsTitle.querySelectorAll(\'.word\');\n\n          for (var i = 0; i < words.length; i++) {\n            node_modules_gsap/* default.set */.ZP.set(words[i], {\n              opacity: 0.0001,\n              y: \'100%\',\n              rotationX: \'3deg\'\n            });\n          }\n\n          if (this.appStore.isDesktop) this.$platformsTitle.querySelector(\'strong\').insertAdjacentHTML(\'beforeend\', \'<span class="stroke"></span>\');\n        }\n      }\n\n      if (this.$services && !this.appStore.isDesktop) {\n        this.$servicesItem = this.$services.querySelectorAll(\'.services__item--mobile\');\n\n        for (var _i = 0; _i < this.$servicesItem.length; _i++) {\n          this.$servicesInfo = this.$servicesItem[_i].querySelector(\'.info\');\n          var _height = this.$servicesInfo.querySelector(\'.columns\').getBoundingClientRect().height;\n\n          var _movement = _height - window.innerWidth * 0.1;\n\n          node_modules_gsap/* default.set */.ZP.set(this.$servicesInfo, {\n            y: _movement + \'px\'\n          });\n        }\n      } // WebGL\n\n\n      if (this.appStore.isDesktop) {\n        this.home1 = new home1_Home1App({\n          renderer: this,\n          domElement: this.$canvasHome1\n        });\n        this.home2 = new home2_Home2App({\n          renderer: this,\n          domElement: this.$canvasHome2\n        });\n        this.home3 = new home3_Home3App({\n          renderer: this,\n          domElement: this.$canvasHome3 // sliderRef: this._solutionsSlider\n\n        });\n        this.home4 = new home4_Home4App({\n          renderer: this,\n          domElement: this.$canvasHome4\n        });\n      } else {\n        this.home1_m = new home1_m_Home1App_m({\n          renderer: this,\n          domElement: this.$canvasHome1_m\n        });\n        this.home2a_m = new home2_m_Home2App_m({\n          renderer: this,\n          domElement: this.$canvasHome2a_m,\n          dotColor: \'#e84371\',\n          incr_radio: 13.2\n        });\n        this.home2b_m = new home2_m_Home2App_m({\n          renderer: this,\n          domElement: this.$canvasHome2b_m,\n          dotColor: \'#007EFF\',\n          incr_radio: 13.2\n        });\n      }\n    }\n  }, {\n    key: "setEnterAnimation",\n    value: function setEnterAnimation() {\n      // Set Enter Animation\n      if (this.$hero) {\n        if (this.appStore.isDesktop) {\n          // Selectors\n          this.$titleHero = this.$hero.querySelector(\'h1\');\n          this.$subTitleHero = this.$hero.querySelector(\'h2\'); // eslint-disable-next-line no-new\n\n          new SplitText(this.$titleHero, {\n            type: \'lines words\',\n            linesClass: \'line line--++\',\n            wordsClass: \'word word--++\'\n          });\n          var titleWords = this.$titleHero.querySelectorAll(\'.word\');\n\n          for (var j = 0; j < titleWords.length; j++) {\n            node_modules_gsap/* default.set */.ZP.set(titleWords[j], {\n              opacity: 0.0001,\n              y: \'100%\',\n              rotationX: \'3deg\'\n            });\n          } // eslint-disable-next-line no-new\n\n\n          new SplitText(this.$subTitleHero, {\n            type: \'lines words\',\n            linesClass: \'line line--++\',\n            wordsClass: \'word word--++\'\n          });\n          var subtitleWords = this.$subTitleHero.querySelectorAll(\'.word\');\n\n          for (var _j = 0; _j < subtitleWords.length; _j++) {\n            node_modules_gsap/* default.set */.ZP.set(subtitleWords[_j], {\n              opacity: 0.0001,\n              y: \'100%\',\n              rotationX: \'3deg\'\n            });\n          }\n\n          node_modules_gsap/* default.set */.ZP.set(this.$video, {\n            y: \'-50vh\'\n          });\n          node_modules_gsap/* default.set */.ZP.set(this.$videoEl, {\n            clipPath: \'circle(0% at 50% 50%)\',\n            webkitClipPath: \'circle(0% at 50% 50%)\'\n          }); // eslint-disable-next-line no-new\n\n          new SplitText(this.$videoEl.querySelector(\'.megatitle\'), {\n            type: \'lines words chars\',\n            linesClass: \'line line--++\',\n            wordsClass: \'word word--++\',\n            charsClass: \'char char--++\'\n          });\n          var chars = this.$videoEl.querySelector(\'.megatitle\').querySelectorAll(\'.char\');\n\n          for (var i = 0; i < chars.length; i++) {\n            node_modules_gsap/* default.set */.ZP.set(chars[i], {\n              opacity: 0.0001\n            });\n          }\n        }\n      }\n    }\n  }, {\n    key: "enter",\n    value: function enter() {\n      // Show header\n      if (!this.appStore.isDesktop) this.appUi.showHeader(); // Start functions\n\n      this.init(); // Disable scroll\n\n      if (this.appStore.isDesktop) this.appStore.currentSection.superScroller._scroll.enable = false;\n    }\n  }, {\n    key: "init",\n    value: function init() {\n      this.initHomeTitles();\n      this.initSolutionsSlider();\n      this.initTechnologyCards();\n      this.initPlatformsDraggable();\n\n      if (this.appStore.isDesktop) {\n        this.initData();\n        this.initSolutionsFeautures();\n        this.initParallaxCards(); // WebGL\n\n        this.home1.init();\n        this.home2.init();\n        this.home3.init({\n          sliderRef: this._solutionsSlider\n        });\n        this.home4.init();\n      } else {\n        this.initDataDraggableMobile();\n        this.initSolutionsDraggableMobile(); // WebGL\n\n        this.home1_m.init();\n        this.home2a_m.init();\n        this.home2b_m.init();\n      }\n    }\n  }, {\n    key: "initEnterAnimation",\n    value: function initEnterAnimation() {\n      var _this2 = this;\n\n      // Fall\n      node_modules_gsap/* default.to */.ZP.to(this.$video, {\n        y: \'0vh\',\n        duration: 1.6,\n        ease: \'expo.inOut\',\n        onComplete: function onComplete() {\n          _this2.initVideoPin();\n\n          _this2.initTechnologyPin();\n\n          _this2.appUi.showHeader();\n\n          _this2.appStore.currentSection.superScroller._scroll.enable = true; // Show cookies\n\n          if (_this2.appUi.$cookies && _this2.appStore.isDesktop) node_modules_gsap/* default.to */.ZP.to(_this2.appUi.$cookies, {\n            opacity: 1,\n            duration: 1,\n            ease: \'power2.out\'\n          });\n        }\n      }); // Circle\n\n      node_modules_gsap/* default.to */.ZP.to(this.$videoEl, {\n        clipPath: \'circle(10% at 50% 50%)\',\n        webkitClipPath: \'circle(10% at 50% 50%)\',\n        duration: 1.6,\n        ease: \'expo.inOut\'\n      }); // Text\n\n      var titleWords = this.$titleHero.querySelectorAll(\'.word\');\n\n      for (var j = 0; j < titleWords.length; j++) {\n        node_modules_gsap/* default.to */.ZP.to(titleWords[j], {\n          opacity: 1,\n          y: \'0%\',\n          rotationX: \'0deg\',\n          ease: \'expo.out\',\n          duration: 1.4,\n          delay: 0.9 + j * 0.02\n        });\n      }\n\n      var subtitleWords = this.$subTitleHero.querySelectorAll(\'.word\');\n\n      for (var _j2 = 0; _j2 < subtitleWords.length; _j2++) {\n        node_modules_gsap/* default.to */.ZP.to(subtitleWords[_j2], {\n          opacity: 1,\n          y: \'0%\',\n          rotationX: \'0deg\',\n          ease: \'expo.out\',\n          duration: 1.4,\n          delay: 0.9 + _j2 * 0.02\n        });\n      }\n    }\n  }, {\n    key: "initVideoPin",\n    value: function initVideoPin() {\n      var _this3 = this;\n\n      if (this.$videoEl) {\n        // Set animation\n        node_modules_gsap/* default.set */.ZP.set(this.$videoEl, {\n          y: \'0vh\'\n        });\n        if (this.appStore.client.browser === \'chrome\') node_modules_gsap/* default.set */.ZP.set(this.$videoEl.querySelector(\'video\'), {\n          width: \'120%\'\n        });else node_modules_gsap/* default.set */.ZP.set(this.$videoEl.querySelector(\'video\'), {\n          scale: 1.1\n        });\n        node_modules_gsap/* default.set */.ZP.set(this.$videoEl.querySelector(\'.video__overlay\'), {\n          opacity: 0.8\n        }); // eslint-disable-next-line no-new\n\n        new SplitText(this.$videoEl.querySelector(\'.title\'), {\n          type: \'lines words\',\n          linesClass: \'line line--++\',\n          wordsClass: \'word word--++\'\n        });\n        var words = this.$videoEl.querySelector(\'.title\').querySelectorAll(\'.word\');\n\n        for (var i = 0; i < words.length; i++) {\n          node_modules_gsap/* default.set */.ZP.set(words[i], {\n            opacity: 0.0001,\n            y: \'100%\',\n            rotation: \'3deg\'\n          });\n        } // Start video timeline\n\n\n        this._videoTimeline = node_modules_gsap/* default.timeline */.ZP.timeline({\n          defaults: {\n            ease: \'none\',\n            duration: 1\n          },\n          scrollTrigger: {\n            trigger: this.$video,\n            start: \'top top\',\n            end: \'bottom bottom\',\n            scrub: true,\n            onUpdate: function onUpdate(self) {\n              if (_this3.home1) _this3.home1.onUpdateOpenProgress(self.progress);\n            }\n          }\n        }); // Animate in/out\n\n        this._videoTimeline.to(this.$videoEl, {\n          y: \'200vh\',\n          duration: 1\n        }, 0);\n\n        this._videoTimeline.to(this.$videoEl, {\n          clipPath: \'circle(75% at 50% 50%)\',\n          webkitClipPath: \'circle(75% at 50% 50%)\',\n          duration: 0.5\n        }, 0); // Scale video\n\n\n        if (this.appStore.client.browser === \'chrome\') this._videoTimeline.to(this.$videoEl.querySelector(\'video\'), {\n          width: \'100%\',\n          duration: 0.35\n        }, 0.15);else this._videoTimeline.to(this.$videoEl.querySelector(\'video\'), {\n          scale: 1,\n          duration: 0.35\n        }, 0.15);\n        if (this.appStore.client.browser === \'safari\') this._videoTimeline.to(this.$videoEl.querySelector(\'.video__overlay\'), {\n          opacity: 0.2,\n          duration: 0.35\n        }, 0.15);else this._videoTimeline.to(this.$videoEl.querySelector(\'.video__overlay\'), {\n          opacity: 0.4,\n          duration: 0.35\n        }, 0.15);\n        var chars = this.$videoEl.querySelector(\'.megatitle\').querySelectorAll(\'.char\');\n\n        this._videoTimeline.to(chars, {\n          opacity: 0.1,\n          stagger: 0.35 / chars.length,\n          duration: 0.35 / chars.length\n        }, 0.15);\n\n        this._videoTimeline.to(chars, {\n          opacity: 1,\n          stagger: 0.65 / chars.length,\n          duration: 0.65 / chars.length\n        }, 0.35);\n\n        var titleWords = this.$videoEl.querySelector(\'.title\').querySelectorAll(\'.word\');\n\n        for (var j = 0; j < titleWords.length; j++) {\n          this._videoTimeline.to(titleWords[j], {\n            opacity: 1,\n            y: \'0%\',\n            rotation: \'0deg\',\n            duration: 0.75 / titleWords.length\n          }, 0.75 + j * 0.01);\n        } // WebGL\n\n\n        this._canvasPin = ScrollTrigger/* default.create */.Z.create({\n          trigger: this.$hero,\n          start: \'top top\',\n          end: \'bottom bottom\',\n          scrub: true,\n          onUpdate: function onUpdate(self) {\n            // Metemos el calculo dentro de onUpdate porque sino falla al hacer resize\n            var _offset2 = _this3.$hero.offsetHeight - _this3.$canvasHome1.offsetHeight;\n\n            node_modules_gsap/* default.set */.ZP.set(_this3.$canvasHome1, {\n              y: _offset2 * self.progress + \'px\'\n            });\n          }\n        });\n        this._footerCanvasPin = ScrollTrigger/* default.create */.Z.create({\n          trigger: this.$footer,\n          start: \'top bottom\',\n          end: \'bottom bottom\',\n          scrub: true,\n          onUpdate: function onUpdate(self) {\n            var posY = -_this3.$canvasHome4.offsetHeight + _this3.$canvasHome4.offsetHeight * 2 * self.progress;\n            node_modules_gsap/* default.set */.ZP.set(_this3.$canvasHome4, {\n              y: posY + \'px\'\n            });\n          }\n        });\n      }\n    }\n  }, {\n    key: "initHomeTitles",\n    value: function initHomeTitles() {\n      var _this4 = this;\n\n      if (this.$platformsTitle) {\n        ScrollTrigger/* default.create */.Z.create({\n          start: \'top bottom\',\n          trigger: this.$platformsTitle,\n          once: true,\n          onEnter: function onEnter() {\n            var words = _this4.$platformsTitle.querySelectorAll(\'.word\');\n\n            for (var i = 0; i < words.length; i++) {\n              node_modules_gsap/* default.to */.ZP.to(words[i], {\n                opacity: 1,\n                y: \'0%\',\n                rotationX: \'0deg\',\n                ease: \'expo.inOut\',\n                duration: 1.2,\n                delay: 0.2 + i * 0.01\n              });\n            }\n\n            if (_this4.appStore.isDesktop) {\n              var $stroke = _this4.$platformsTitle.querySelector(\'.stroke\');\n\n              node_modules_gsap/* default.to */.ZP.to($stroke, {\n                scaleX: 1,\n                duration: 1.2,\n                ease: \'expo.inOut\',\n                delay: 0.5\n              });\n            }\n          }\n        });\n      }\n    }\n  }, {\n    key: "initData",\n    value: function initData() {\n      var _this5 = this;\n\n      // Selectors\n      this.$dataLines = this.$data.querySelectorAll(\'.dataline\');\n      this.$dataItems = this.$data.querySelectorAll(\'.columns__item\'); // const _padding = window.innerWidth * 0.3;\n      // Set animation\n\n      node_modules_gsap/* default.set */.ZP.set(this.$dataLines, {\n        drawSVG: 0\n      });\n      node_modules_gsap/* default.set */.ZP.set(this.$dataItems, {\n        opacity: 0.0001\n      }); // Create lines trigger\n\n      this._dataTimeline = node_modules_gsap/* default.timeline */.ZP.timeline({\n        defaults: {\n          ease: \'none\',\n          duration: 1\n        },\n        scrollTrigger: {\n          trigger: this.$data,\n          start: \'top 70%\',\n          end: \'80% bottom\',\n          scrub: true\n        }\n      }); // Lines in/out animation\n\n      this._dataTimeline.to(this.$dataLines[0], {\n        drawSVG: \'100%\',\n        duration: 0.5\n      }, 0);\n\n      this._dataTimeline.to(this.$dataLines[1], {\n        drawSVG: \'100%\',\n        duration: 0.5\n      }, 0.5);\n\n      this._dataTimeline.to(this.$dataLines[2], {\n        drawSVG: \'100%\',\n        duration: 0.35\n      }, 1); // First image trigger and animation\n\n\n      ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$dataLines[0],\n        start: \'top 70%\',\n        end: \'bottom bottom\',\n        scrub: true,\n        onEnter: function onEnter() {\n          node_modules_gsap/* default.to */.ZP.to(_this5.$dataItems[0], {\n            opacity: 1,\n            duration: 0.4,\n            ease: \'power2.out\'\n          });\n        },\n        onEnterBack: function onEnterBack() {\n          node_modules_gsap/* default.to */.ZP.to(_this5.$dataItems[0], {\n            opacity: 0.0001,\n            duration: 0.4,\n            ease: \'power2.out\'\n          });\n        }\n      }); // Second image trigger and animation\n\n      ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$dataLines[1],\n        start: \'top 55%\',\n        end: \'bottom bottom\',\n        scrub: true,\n        onEnter: function onEnter() {\n          node_modules_gsap/* default.to */.ZP.to(_this5.$dataItems[1], {\n            opacity: 1,\n            duration: 0.4,\n            ease: \'power2.out\'\n          });\n        },\n        onEnterBack: function onEnterBack() {\n          node_modules_gsap/* default.to */.ZP.to(_this5.$dataItems[1], {\n            opacity: 0.0001,\n            duration: 0.4,\n            ease: \'power2.out\'\n          });\n        }\n      }); // Third image trigger and animation\n\n      ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$dataLines[2],\n        start: \'top 48%\',\n        end: \'bottom bottom\',\n        scrub: true,\n        onEnter: function onEnter() {\n          node_modules_gsap/* default.to */.ZP.to(_this5.$dataItems[2], {\n            opacity: 1,\n            duration: 0.4,\n            ease: \'power2.out\'\n          });\n        },\n        onEnterBack: function onEnterBack() {\n          node_modules_gsap/* default.to */.ZP.to(_this5.$dataItems[2], {\n            opacity: 0.0001,\n            duration: 0.4,\n            ease: \'power2.out\'\n          });\n        }\n      });\n    }\n  }, {\n    key: "initDataDraggableMobile",\n    value: function initDataDraggableMobile() {\n      var _this6 = this;\n\n      // Selectors\n      this.$dataSlider = this.$data.querySelector(\'.slider\');\n      this.$dataSliderItems = this.$dataSlider.querySelectorAll(\'.slider__item\');\n      this.$dataSliderProgress = this.$dataSlider.querySelector(\'.slider__progress\'); // Compare items height\n\n      this._maxHeight = 0;\n      this._arrayItems = Array.from(this.$dataSliderItems);\n\n      for (var i = 0; i < this._arrayItems.length; i++) {\n        var _elementHeight = this._arrayItems[i].getBoundingClientRect().height;\n\n        if (_elementHeight > this._maxHeight) this._maxHeight = _elementHeight;\n      } // Auto height\n\n\n      this.$dataSlider.style.height = this._maxHeight + 40 + \'px\'; // Create draggable\n\n      this._dataDraggable = new superDraggable_default({\n        el: this.$data,\n        snap: false,\n        snapTo: \'center\',\n        dots: false,\n        onRaf: function onRaf(percent, progress, progressOrigin) {\n          node_modules_gsap/* default.to */.ZP.to(_this6.$dataSliderProgress.children[0], {\n            scaleX: progressOrigin + progress\n          });\n        }\n      });\n    }\n  }, {\n    key: "openServicesMobile",\n    value: function openServicesMobile(a, e, el, index) {\n      if (this.appUi.isAnimating) return;\n      this.appUi.isAnimating = true; // Selectors\n\n      this.$servicesInfo = this.$servicesItem[index].querySelector(\'.info\');\n      this.$servicesText = this.$servicesItem[index].querySelector(\'.columns\'); // Animate in\n\n      node_modules_gsap/* default.to */.ZP.to(this.$servicesInfo, {\n        y: \'0px\',\n        duration: 0.6,\n        ease: \'expo.out\'\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$servicesText, {\n        opacity: 1,\n        duration: 0.6,\n        ease: \'power2.out\'\n      });\n    }\n  }, {\n    key: "closeServicesMobile",\n    value: function closeServicesMobile(a, e, el, index) {\n      var _this7 = this;\n\n      // Selectors\n      this.$servicesInfo = this.$servicesItem[index].querySelector(\'.info\');\n      this.$servicesText = this.$servicesItem[index].querySelector(\'.columns\');\n      var _height = this.$servicesInfo.querySelector(\'.columns\').getBoundingClientRect().height;\n\n      var _movement = _height - window.innerWidth * 0.1;\n\n      node_modules_gsap/* default.to */.ZP.to(this.$servicesInfo, {\n        y: _movement + \'px\',\n        duration: 0.6,\n        ease: \'expo.out\'\n      });\n      node_modules_gsap/* default.to */.ZP.to(this.$servicesText, {\n        opacity: 0.0001,\n        duration: 0.6,\n        ease: \'power2.out\',\n        onComplete: function onComplete() {\n          _this7.appUi.isAnimating = false;\n        }\n      });\n    }\n  }, {\n    key: "initSolutionsFeautures",\n    value: function initSolutionsFeautures() {\n      this.$solutionsFeatures = this.$solutions.querySelector(\'.features\');\n      this.$solutionsFeaturesItems = this.$solutionsFeatures.querySelectorAll(\'.features__item\');\n\n      for (var i = 0; i < this.$solutionsFeaturesItems.length; i++) {\n        node_modules_gsap/* default.set */.ZP.set(this.$solutionsFeaturesItems[i], {\n          opacity: 0.0001\n        });\n      }\n\n      this._featuresTrigger = node_modules_gsap/* default.timeline */.ZP.timeline({\n        defaults: {\n          duration: 2,\n          ease: \'power2.out\'\n        },\n        scrollTrigger: {\n          trigger: this.$solutionsFeatures,\n          start: \'top 80%\',\n          end: \'bottom 70%\',\n          scrub: true\n        }\n      });\n\n      this._featuresTrigger.to(this.$solutionsFeaturesItems[0], {\n        opacity: 1\n      }, 0.25);\n\n      this._featuresTrigger.to(this.$solutionsFeaturesItems[1], {\n        opacity: 1\n      }, 0.5);\n\n      this._featuresTrigger.to(this.$solutionsFeaturesItems[2], {\n        opacity: 1\n      }, 0.75);\n\n      this._featuresTrigger.to(this.$solutionsFeaturesItems[3], {\n        opacity: 1\n      }, 1);\n\n      this._featuresTrigger.to(this.$solutionsFeaturesItems[4], {\n        opacity: 1\n      }, 1.25);\n\n      this._featuresTrigger.to(this.$solutionsFeaturesItems[5], {\n        opacity: 1\n      }, 1.5);\n\n      this._featuresTrigger.to(this.$solutionsFeaturesItems[6], {\n        opacity: 1\n      }, 1.75);\n\n      this._featuresTrigger.to(this.$solutionsFeaturesItems[7], {\n        opacity: 1\n      }, 2);\n    }\n  }, {\n    key: "initSolutionsSlider",\n    value: function initSolutionsSlider() {\n      this._solutionsSlider = new sliderSolutions_default({\n        el: this.$solutions,\n        target: this.$solutions.querySelector(\'.slider--solutions\'),\n        autoplay: true,\n        autoplaySpeed: 3,\n        duration: 1.2\n      });\n    }\n  }, {\n    key: "initSolutionsDraggableMobile",\n    value: function initSolutionsDraggableMobile() {\n      var _this8 = this;\n\n      this.$solutionsDraggable = this.$solutions.querySelector(\'.slider--draggable\');\n      this.$solutionsDraggableProgress = this.$solutionsDraggable.querySelector(\'.slider__progress\');\n      this._solutionsDraggable = new superDraggable_default({\n        el: this.$solutions,\n        snap: false,\n        snapTo: \'center\',\n        dots: false,\n        onRaf: function onRaf(percent, progress, progressOrigin) {\n          node_modules_gsap/* default.to */.ZP.to(_this8.$solutionsDraggableProgress.children[0], {\n            scaleX: progressOrigin + progress\n          });\n        }\n      });\n    }\n  }, {\n    key: "initParallaxCards",\n    value: function initParallaxCards() {\n      this.$technologyCards = this.$technology.querySelectorAll(\'.card\');\n      var parallaxCards = node_modules_gsap/* default.timeline */.ZP.timeline({\n        defaults: {\n          duration: 1,\n          ease: \'none\'\n        },\n        scrollTrigger: {\n          trigger: this.$technology.querySelector(\'.container--large\'),\n          start: \'top bottom\',\n          end: this.$technology.querySelector(\'.container--large\').offsetHeight + window.innerWidth * 0.1 + \' top\',\n          scrub: true,\n          markers: false\n        }\n      }); // Set\n\n      parallaxCards.set([this.$technologyCards[0]], {\n        y: \'0vw\'\n      }, 0);\n      parallaxCards.set([this.$technologyCards[1]], {\n        y: \'2.5vw\'\n      }, 0);\n      parallaxCards.set([this.$technologyCards[2]], {\n        y: \'0vw\'\n      }, 0);\n      parallaxCards.set([this.$technologyCards[3]], {\n        y: \'2.5vw\'\n      }, 0); // Animation\n\n      parallaxCards.to([this.$technologyCards[0]], {\n        y: \'2.5vw\'\n      }, 0);\n      parallaxCards.to([this.$technologyCards[1]], {\n        y: \'0vw\'\n      }, 0);\n      parallaxCards.to([this.$technologyCards[2]], {\n        y: \'2.5vw\'\n      }, 0);\n      parallaxCards.to([this.$technologyCards[3]], {\n        y: \'0vw\'\n      }, 0);\n    }\n  }, {\n    key: "initTechnologyCards",\n    value: function initTechnologyCards() {\n      var _this9 = this;\n\n      // Selectors\n      this.$technologyCards = this.$technology.querySelectorAll(\'.card\');\n\n      var _loop2 = function _loop2(i) {\n        if (_this9.appStore.isDesktop) {\n          _this9.domEvents.add(_this9.$technologyCards[i], \'mouseenter\', function (a, e, el) {\n            if (el.querySelector(\'.info\')) {\n              node_modules_gsap/* default.killTweensOf */.ZP.killTweensOf(el.querySelector(\'.info\'));\n              node_modules_gsap/* default.set */.ZP.set(el.querySelector(\'.info\'), {\n                display: \'flex\'\n              });\n              node_modules_gsap/* default.to */.ZP.to(el.querySelector(\'.info\'), {\n                opacity: 1,\n                duration: 0.6,\n                ease: \'expo.out\'\n              });\n            } else {\n              el.style.pointerEvents = \'none\';\n            }\n          });\n\n          _this9.domEvents.add(_this9.$technologyCards[i], \'mouseleave\', function (a, e, el) {\n            if (el.querySelector(\'.info\')) {\n              node_modules_gsap/* default.killTweensOf */.ZP.killTweensOf(el.querySelector(\'.info\'));\n              node_modules_gsap/* default.to */.ZP.to(el.querySelector(\'.info\'), {\n                opacity: 0.0001,\n                duration: 0.6,\n                ease: \'expo.out\',\n                onComplete: function onComplete() {\n                  node_modules_gsap/* default.set */.ZP.set(el.querySelector(\'.info\'), {\n                    display: \'none\'\n                  });\n                }\n              });\n            } else {\n              el.style.pointerEvents = \'none\';\n            }\n          });\n        } else {\n          // Open and close info\n          if (_this9.$technologyCards[i].querySelector(\'.icon\')) {\n            _this9.domEvents.add(_this9.$technologyCards[i].querySelector(\'.icon\'), \'click\', function (e) {\n              node_modules_gsap/* default.set */.ZP.set(_this9.$technologyCards[i].querySelector(\'.info\'), {\n                display: \'flex\'\n              });\n              node_modules_gsap/* default.to */.ZP.to(_this9.$technologyCards[i].querySelector(\'.info\'), {\n                opacity: 1,\n                duration: 0.8,\n                ease: \'expo.out\'\n              });\n            });\n\n            if (_this9.$technologyCards[i].querySelector(\'.closer\')) {\n              _this9.domEvents.add(_this9.$technologyCards[i].querySelector(\'.closer\'), \'click\', function (e) {\n                node_modules_gsap/* default.to */.ZP.to(_this9.$technologyCards[i].querySelector(\'.info\'), {\n                  opacity: 0.0001,\n                  duration: 0.8,\n                  ease: \'expo.out\',\n                  onComplete: function onComplete() {\n                    node_modules_gsap/* default.set */.ZP.set(_this9.$technologyCards[i].querySelector(\'.info\'), {\n                      display: \'none\'\n                    });\n                  }\n                });\n              });\n            }\n          } // Selectors\n\n\n          _this9.$technologySlider = _this9.$technology.querySelector(\'.slider\');\n          _this9._technologyDraggable = new superDraggable_default({\n            el: _this9.$technology,\n            snap: false,\n            snapTo: \'center\',\n            dots: false\n          });\n        }\n      };\n\n      for (var i = 0; i < this.$technologyCards.length; i++) {\n        _loop2(i);\n      }\n    }\n  }, {\n    key: "initTechnologyPin",\n    value: function initTechnologyPin() {\n      var _this10 = this;\n\n      this.$technologyWords = this.$technology.querySelector(\'.words\');\n      this.$technologyWordsInner = this.$technologyWords.querySelector(\'.words__inner\');\n      this.$technologyWordsGradient = this.$technologyWords.querySelector(\'.words__gradient\');\n      this.$technologyLabel = this.$technology.querySelector(\'.label--1\');\n\n      var _offset = this.$technologyWordsInner.offsetHeight - this.$technologyWordsGradient.offsetHeight;\n\n      this._technologyPin = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$technologyWords,\n        start: \'top top\',\n        end: \'bottom bottom\',\n        scrub: true,\n        markers: false,\n        onUpdate: function onUpdate(self) {\n          node_modules_gsap/* default.set */.ZP.set(_this10.$technologyLabel, {\n            y: _offset * self.progress + \'px\'\n          });\n          node_modules_gsap/* default.set */.ZP.set(_this10.$technologyWordsGradient, {\n            y: _offset * self.progress + \'px\'\n          });\n        },\n        onEnter: function onEnter() {\n          node_modules_gsap/* default.to */.ZP.to(_this10.$technologyWordsGradient, {\n            opacity: 1,\n            duration: 0.4,\n            ease: \'power2.out\'\n          });\n        },\n        onEnterBack: function onEnterBack() {\n          node_modules_gsap/* default.to */.ZP.to(_this10.$technologyWordsGradient, {\n            opacity: 1,\n            duration: 0.4,\n            ease: \'power2.out\'\n          });\n        }\n      });\n    }\n  }, {\n    key: "initPlatformsDraggable",\n    value: function initPlatformsDraggable() {\n      // Selectors\n      this.$platformsSlider = this.$platforms.querySelector(\'.slider\');\n      this.$platformsSliderItems = this.$platformsSlider.querySelectorAll(\'.slider__item\');\n\n      if (this.appStore.isDesktop) {\n        if (this.$platformsSliderItems.length > 4) {\n          this._platformsDraggable = new superDraggable_default({\n            el: this.$platforms,\n            snap: false,\n            snapTo: \'center\',\n            dots: false\n          });\n        }\n      } else {\n        this._platformsDraggable = new superDraggable_default({\n          el: this.$platforms,\n          snap: false,\n          snapTo: \'center\',\n          dots: true\n        });\n      }\n    }\n  }, {\n    key: "raf",\n    value: function raf() {} // eslint-disable-line\n\n  }, {\n    key: "resize",\n    value: function resize(width, height) {\n      if (this._platformsDraggable) this._platformsDraggable.resize();\n\n      if (this.appStore.isDesktop) {\n        if (this.home1) this.home1.onResize();\n        if (this.home2) this.home2.onResize();\n        if (this.home3) this.home3.onResize();\n        if (this.home4) this.home4.onResize();\n      } else {\n        if (this._dataDraggable) this._dataDraggable.resize();\n        if (this._solutionsDraggable) this._solutionsDraggable.resize();\n        if (this._technologyDraggable) this._technologyDraggable.resize();\n      }\n    }\n  }, {\n    key: "leave",\n    value: function leave() {\n      if (this.appStore.isDesktop) {\n        this.home1.kill();\n        this.home1 = null;\n        this.home2.kill();\n        this.home2 = null;\n        this.home3.kill();\n        this.home3 = null;\n        this.home4.kill();\n        this.home4 = null;\n      } else {\n        this.home1_m.kill();\n        this.home1_m = null;\n        this.home2a_m.kill();\n        this.home2a_m = null;\n        this.home2b_m.kill();\n        this.home2b_m = null;\n      }\n    }\n  }]);\n\n  return RendererHome;\n}(renderer); // Don\'t forget to export your renderer\n\n\n/* harmony default export */ const rendererHome = (RendererHome);\n;// CONCATENATED MODULE: ./app/src/js/webgl/EventProcess.js\nfunction EventProcess_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction EventProcess_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction EventProcess_createClass(Constructor, protoProps, staticProps) { if (protoProps) EventProcess_defineProperties(Constructor.prototype, protoProps); if (staticProps) EventProcess_defineProperties(Constructor, staticProps); return Constructor; }\n\n//import * as THREE from "three"\n\n\n\nvar EventProcess_events = __webpack_require__(7187);\n\nvar EventProcess = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  function EventProcess(obj) {\n    EventProcess_classCallCheck(this, EventProcess);\n\n    //console.log("(EventProcess.CONSTRUCTORA): ", obj)\n    this.timeSec = obj.timeSec || 1; //--\n\n    this.processTimeSec = null;\n    this.refTimeSec = null;\n    this.process = 0;\n    this.t = 0;\n    this.ticker = null; //--\n\n    this.emitter = new EventProcess_events.EventEmitter();\n  }\n\n  EventProcess_createClass(EventProcess, [{\n    key: "start",\n    value: function start(easingFunc, pauseSecs) {\n      var _this = this;\n\n      //console.log("(EventProcess.start): ", pauseSecs)\n      if (pauseSecs == 0) {\n        this.easingFunc = easingFunc || Easing.Linear.None; //--\n\n        gsap.ticker.remove(this.onTick); //console.log(this.easingFunc)\n\n        this.onTick = this._update.bind(this);\n        this.refTimeSec = this._get_tickerTime();\n        gsap.ticker.add(this.onTick);\n      } else {\n        //this.binded_start = this.start.bind(this)\n        gsap.delayedCall(pauseSecs, function () {\n          return _this.start(easingFunc, 0);\n        });\n      }\n    }\n  }, {\n    key: "get_process",\n    value: function get_process() {\n      return this.process;\n    } //-----------------------------------------\n\n  }, {\n    key: "_get_tickerTime",\n    value: function _get_tickerTime() {\n      return gsap.ticker.time;\n    }\n  }, {\n    key: "_update",\n    value: function _update() {\n      var tickerTime = this._get_tickerTime();\n\n      this.processTimeSec = tickerTime - this.refTimeSec;\n\n      if (this.processTimeSec >= this.timeSec) {\n        this.processTimeSec = this.timeSec;\n        gsap.ticker.remove(this.onTick); //--\n\n        this.emitter.emit("onProcessEnd");\n      }\n\n      this.t = this.processTimeSec / this.timeSec;\n      this.process = this.easingFunc(this.t); //console.log("t: "+this.t+" - process: "+this.process)\n    }\n  }]);\n\n  return EventProcess;\n}()));\n\n/* harmony default export */ const webgl_EventProcess = ((/* unused pure expression or super */ null && (EventProcess)));\n;// CONCATENATED MODULE: ./app/src/js/webgl/solutions1/Solutions1Geometry.js\nfunction Solutions1Geometry_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Solutions1Geometry_typeof = function _typeof(obj) { return typeof obj; }; } else { Solutions1Geometry_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Solutions1Geometry_typeof(obj); }\n\nfunction Solutions1Geometry_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Solutions1Geometry_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Solutions1Geometry_createClass(Constructor, protoProps, staticProps) { if (protoProps) Solutions1Geometry_defineProperties(Constructor.prototype, protoProps); if (staticProps) Solutions1Geometry_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Solutions1Geometry_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Solutions1Geometry_setPrototypeOf(subClass, superClass); }\n\nfunction Solutions1Geometry_setPrototypeOf(o, p) { Solutions1Geometry_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Solutions1Geometry_setPrototypeOf(o, p); }\n\nfunction Solutions1Geometry_createSuper(Derived) { var hasNativeReflectConstruct = Solutions1Geometry_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Solutions1Geometry_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Solutions1Geometry_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Solutions1Geometry_possibleConstructorReturn(this, result); }; }\n\nfunction Solutions1Geometry_possibleConstructorReturn(self, call) { if (call && (Solutions1Geometry_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Solutions1Geometry_assertThisInitialized(self); }\n\nfunction Solutions1Geometry_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Solutions1Geometry_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Solutions1Geometry_getPrototypeOf(o) { Solutions1Geometry_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Solutions1Geometry_getPrototypeOf(o); }\n\n//import * as THREE from "three"\n//import gsap from "gsap"\n//import {GLTFLoader, GLTLoader} from "three/examples/jsm/loaders/GLTFLoader"\nvar Solutions1Geometry_EventEmitter = __webpack_require__(7187);\n\nvar Solutions1Geometry = /*#__PURE__*/function (_EventEmitter) {\n  Solutions1Geometry_inherits(Solutions1Geometry, _EventEmitter);\n\n  var _super = Solutions1Geometry_createSuper(Solutions1Geometry);\n\n  function Solutions1Geometry(obj) {\n    var _this;\n\n    Solutions1Geometry_classCallCheck(this, Solutions1Geometry);\n\n    //console.log("(Solutions1Geometry.CONSTRUCTORA): ", obj)\n    _this = _super.call(this); //--\n\n    _this.factor = obj.factor; //6\n\n    _this.incr_radio = obj.incr_radio; //25\n\n    _this.numOrbits = obj.numOrbits; //37\n\n    _this.array_triangular = obj.array_triangular;\n    _this.numDots = obj.numDots; //--\n\n    _this.attributes = {\n      a_posiciones: new Float32Array(_this.numDots * 3),\n      a_dot_num: new Float32Array(_this.numDots * 1),\n      a_orbital: new Float32Array(_this.numDots * 1),\n      a_pos_orbita: new Float32Array(_this.numDots * 1),\n      a_incr_anguloRad: new Float32Array(_this.numDots * 1),\n      a_anguloRad: new Float32Array(_this.numDots * 1),\n      a_radio: new Float32Array(_this.numDots * 1),\n      a_dir: new Float32Array(_this.numDots * 1),\n      a_incr: new Float32Array(_this.numDots * 1),\n      a_x: new Float32Array(_this.numDots * 1),\n      a_y: new Float32Array(_this.numDots * 1),\n      a_z: new Float32Array(_this.numDots * 1),\n      a_dotFactor: new Float32Array(_this.numDots * 1)\n    }; //--\n\n    for (var i = 0; i < _this.numDots; i++) {\n      var dot = _this._get_dot(i);\n\n      var i3 = i * 3;\n      _this.attributes.a_posiciones[i3] = dot.x;\n      _this.attributes.a_posiciones[i3 + 1] = dot.y;\n      _this.attributes.a_posiciones[i3 + 2] = dot.z; //--\n\n      _this.attributes.a_dot_num[i] = i;\n      _this.attributes.a_orbital[i] = dot.orbital;\n      _this.attributes.a_pos_orbita[i] = dot.pos_orbita;\n      _this.attributes.a_incr_anguloRad[i] = dot.incr_anguloRad;\n      _this.attributes.a_anguloRad[i] = dot.anguloRad;\n      _this.attributes.a_radio[i] = dot.radio;\n      _this.attributes.a_dir[i] = dot.dir;\n      _this.attributes.a_incr[i] = dot.incr;\n      _this.attributes.a_x[i] = dot.y;\n      _this.attributes.a_y[i] = dot.y;\n      _this.attributes.a_z[i] = dot.z;\n      _this.attributes.a_dotFactor[i] = i / _this.numDots; // El punto mas interior tiene 1 y el mas exterior tiene 0\n    } //--\n\n\n    _this.loaded = false; //console.log(this.attributes.a_dot_num)\n\n    return _this;\n  }\n\n  Solutions1Geometry_createClass(Solutions1Geometry, [{\n    key: "init",\n    value: function init() {\n      //console.log("(Solutions1Geometry.init)!")\n      //--\n      //--\n      this.emit("onMeshLoaded", {\n        ref: this\n      });\n    } //------------------------------------------\n    // PRIVADAS\n\n  }, {\n    key: "_get_dot",\n    value: function _get_dot(num) {\n      // Devuelve un objeto con la informaciín de un punto de la geometria "orbital MIOTI"\n      var obj = {\n        num: num,\n        x: 0,\n        y: 0,\n        z: 0,\n        orbital: 0,\n        co_orbitantes: 0,\n        pos_orbita: 0,\n        incr_anguloRad: 0,\n        anguloRad: 0,\n        radio: 0\n      }; //--\n\n      for (var i = 0; i <= this.array_triangular.length; i++) {\n        var limSup = this.array_triangular[i]; //console.log("limSup: "+limSup)\n\n        if (num > limSup) {\n          // console.log("*")\n          obj.orbital = i + 1;\n          obj.co_orbitantes = (i + 1) * this.factor;\n          obj.pos_orbita = num - limSup - 1;\n          obj.incr_anguloRad = 2 * Math.PI / obj.co_orbitantes;\n\n          if (obj.orbital % 2 == 0) {\n            obj.dir = 1;\n            obj.incr = 0;\n            obj.anguloRad = obj.pos_orbita * obj.incr_anguloRad;\n          } else {\n            obj.dir = -1;\n            obj.incr = 1;\n            obj.anguloRad = obj.pos_orbita * obj.incr_anguloRad + obj.incr_anguloRad / 2;\n          }\n\n          obj.radio = obj.orbital * this.incr_radio; //--\n\n          obj.x = Math.cos(obj.anguloRad) * obj.radio;\n          obj.y = Math.sin(obj.anguloRad) * obj.radio;\n          obj.z = 0;\n        } //break\n\n      }\n\n      return obj;\n    }\n  }]);\n\n  return Solutions1Geometry;\n}(Solutions1Geometry_EventEmitter);\n\n/* harmony default export */ const solutions1_Solutions1Geometry = (Solutions1Geometry);\n;// CONCATENATED MODULE: ./app/src/js/webgl/solutions1/shaders/solutions1_dots_vertex.glsl\n/* harmony default export */ const solutions1_dots_vertex = ("#define GLSLIFY 1\\nattribute vec3 a_randomness;\\nattribute vec3 a_geo1_position;\\nattribute float a_geo1_dot_num;\\nattribute float a_geo1_orbital;\\nattribute float a_geo1_pos_orbita;\\nattribute float a_geo1_incr_anguloRad;\\nattribute float a_geo1_anguloRad;\\nattribute float a_geo1_incr;\\nattribute float a_geo1_dir;\\nattribute float a_geo1_radio;\\nattribute float a_geo1_dotFactor;\\n\\nattribute vec3 a_geo2_position;\\nattribute vec3 a_geo3_position;\\n\\nuniform float uTime;\\nuniform float uCamaraDistance;\\nuniform float uScrollSpeed;\\nuniform float uScale;\\nuniform float uResponsiveScale;\\nuniform float uScrollDelta;\\nuniform float uScrollProgress;\\nuniform float uMorphingProgress;\\nuniform float uIntroProgress;\\nuniform float uTransitionProgress;\\nuniform float uWidth;\\nuniform float uHeight;\\n\\nuniform float uRotation1;\\nuniform float uRotation2;\\nuniform float uRotation3;\\nuniform float uRotationInner;\\nuniform float uRotationOutter;\\n\\n// varying vec3 vPosition;\\n//varying vec2 vUv;\\nvarying vec3 v_randomness;\\nvarying float v_colorStrength;\\n\\nvarying float v_alpha; // Es el alpha de los puntos determinado sobre si estan en orbitales ocultos o visibles\\nvarying float v_activePulse;\\nvarying float v_activePulseProgress;\\nvarying float v_test;\\n\\n#define PI 3.1415926538\\n//#define PI 3.1415926535897932384626433832795\\n\\n//\\tClassic Perlin 3D Noise \\n//\\tby Stefan Gustavson\\n//\\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\\n\\nfloat cnoise(vec3 P){\\n  vec3 Pi0 = floor(P); // Integer part for indexing\\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\\n  Pi0 = mod(Pi0, 289.0);\\n  Pi1 = mod(Pi1, 289.0);\\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n  vec4 iz0 = Pi0.zzzz;\\n  vec4 iz1 = Pi1.zzzz;\\n\\n  vec4 ixy = permute(permute(ix) + iy);\\n  vec4 ixy0 = permute(ixy + iz0);\\n  vec4 ixy1 = permute(ixy + iz1);\\n\\n  vec4 gx0 = ixy0 / 7.0;\\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\\n  gx0 = fract(gx0);\\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n  vec4 sz0 = step(gz0, vec4(0.0));\\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n\\n  vec4 gx1 = ixy1 / 7.0;\\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\\n  gx1 = fract(gx1);\\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n  vec4 sz1 = step(gz1, vec4(0.0));\\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n\\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\n\\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n  g000 *= norm0.x;\\n  g010 *= norm0.y;\\n  g100 *= norm0.z;\\n  g110 *= norm0.w;\\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n  g001 *= norm1.x;\\n  g011 *= norm1.y;\\n  g101 *= norm1.z;\\n  g111 *= norm1.w;\\n\\n  float n000 = dot(g000, Pf0);\\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n  float n111 = dot(g111, Pf1);\\n\\n  vec3 fade_xyz = fade(Pf0);\\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \\n  return 2.2 * n_xyz;\\n}\\n\\nvec3 get_pos1(float anguloRad){\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(1.*a_geo1_dir*0.2);\\n    float x = cos(anguloRad)*a_geo1_radio;\\n    float y = sin(anguloRad)*a_geo1_radio;\\n    float z = 0.0;\\n    vec3 newPos = vec3(x, y, z);\\n    return newPos;\\n}\\n\\nvec3 get_posScrollSpeed(vec3 pos){\\n    float factor = mix(1.0, 2.0, uScrollSpeed);\\n    pos = pos*factor;\\n    return pos;\\n}\\n\\nfloat get_escalaNoise(float x, float y, float amplitudMapa, float progress){\\n    float valor = cnoise(vec3(x/amplitudMapa, y/amplitudMapa, progress));\\n    valor = 0.5+(valor/2.);\\n    valor *=2.;\\n    return valor;\\n}\\n\\nfloat get_escalaOndaRadial(float orbital, float progress){\\n    float frecuencia = 0.5; // Valores bajos ondas mas largas, valores altos ondas mas cortas\\n    float seno = (sin((progress+orbital)*frecuencia)+1.)/2.;\\n\\n    float valor = 0.5+(seno*0.5);\\n\\n    return valor;\\n}\\n\\nfloat get_escalaEdge(float orbital){\\n    float value = 1.;\\n    float orbitalMax = 37.;\\n    float fadeLimit = 22.;\\n    float fadeScale = 1.;\\n    float rango = orbitalMax -fadeLimit;\\n    if(orbital >= fadeLimit){\\n        float orbitalRel = orbital -fadeLimit;\\n        float ratio = orbitalRel/rango;\\n        fadeScale = fadeScale-ratio;\\n    }\\n    return fadeScale;\\n}\\n\\nvec3 randomizePosition(vec3 oldPos, vec3 randomness, float time, float amplitude, float amount, float speed){\\n    time = time*speed;\\n    vec3 newPos = oldPos;\\n    newPos.x += sin(time * randomness.x) * (amplitude*amount);\\n    newPos.y += cos(time * randomness.y) * (amplitude*amount);\\n    newPos.z += cos(time * randomness.z) * (amplitude*amount);\\n    return newPos;\\n}\\n\\nfloat quinticOut(float t) {\\n  return (pow(t - 1.0, 5.0));\\n}\\n\\nfloat quadraticOut(float t) {\\n  return -t * (t - 2.0);\\n}\\n\\nfloat quarticOut(float t) {\\n  return pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\\n}\\n\\nfloat cubicIn(float t) {\\n  return t * t * t;\\n}\\nfloat cubicOut(float t) {\\n  float f = t - 1.0;\\n  return f * f * f + 1.0;\\n}\\n\\nmat4 rotationMatrix(vec3 axis, float angle) {\\n    axis = normalize(axis);\\n    float s = sin(angle);\\n    float c = cos(angle);\\n    float oc = 1.0 - c;\\n    \\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\\n                0.0,                                0.0,                                0.0,                                1.0);\\n}\\n\\nvec3 rotate(vec3 v, vec3 axis, float angle) {\\n\\tmat4 m = rotationMatrix(axis, angle);\\n\\treturn (m * vec4(v, 1.0)).xyz;\\n}\\n\\nvoid main() {\\n\\n    //----------------------------------------------------------\\n    // DECLARATIONS:\\n    //float twentiethX = (uWidth/20.);\\n    float twentiethX = (1920./20.); //1920. es el this.REF_RESOLUTION.width\\n    float anguloRad_time = a_geo1_anguloRad;\\n\\n    vec3 POSITION_ORIGINAL;\\n    vec3 POSITION_1;\\n    vec3 POSITION_1B;\\n    vec3 POSITION_2;\\n\\n    float SIZE_1 = 0.0;\\n    float SIZE_2 = 5.0;\\n\\n    v_alpha = 0.05;\\n\\n    //----------------------------------------------------------\\n    // SORTING\\n    //float rotation1_5 = mix(uRotation1, uRotation3, 0.5);\\n    float hardDotSpeedFactor = 200.;\\n    float softDotSpeedFactor = 36.;\\n    float rotation5 = mix(uRotationInner, uRotationOutter, ((a_geo1_orbital)*0.5)/softDotSpeedFactor);\\n    float rotation10 = mix(uRotationInner, uRotationOutter, ((a_geo1_orbital)*0.5)/softDotSpeedFactor);\\n    float rotation15 = mix(uRotationInner, uRotationOutter, ((a_geo1_orbital)*0.5)/softDotSpeedFactor);\\n\\n    vec3 rand = vec3(a_randomness.x*1., -a_randomness.y*1., a_randomness.z*1.);\\n\\n    if(abs(a_geo1_orbital-5.) < 0.5){ // Detecta el orbital 5\\n        anguloRad_time = (a_geo1_anguloRad+rotation5);\\n        SIZE_1 = 3.0;\\n        v_alpha = 1.0;\\n        rand = vec3(0., -1., 0.);\\n\\n    }else if(abs(a_geo1_orbital-10.) < 0.5){ // Detecta el orbital 10\\n        anguloRad_time = -(a_geo1_anguloRad+rotation10);\\n        SIZE_1 = 3.0;\\n        v_alpha = 1.0;\\n        rand = vec3(0., -1., 0.);\\n\\n    }else if(abs(a_geo1_orbital-15.) < 0.5){ // Detecta el orbital 15\\n        anguloRad_time = a_geo1_anguloRad+rotation15;\\n        SIZE_1 = 3.0;\\n        v_alpha = 1.0;\\n        rand = vec3(0., -1., 0.);\\n    }else{\\n        float filteredOrbital = clamp(a_geo1_orbital, 0., 20.);\\n        anguloRad_time =  a_geo1_anguloRad + mix(uRotationInner, uRotationOutter, a_geo1_orbital/softDotSpeedFactor);\\n        //anguloRad_time = a_geo1_anguloRad+rotation15;\\n        //SIZE_1 = 10.0 * uTransitionProgress;\\n        //SIZE_1 = 2.0;\\n        SIZE_1 = mix(2., 10., uTransitionProgress);\\n        //v_alpha = 0.05; // * uTransitionProgress;\\n        //v_alpha = 0.10;//*uTransitionProgress;\\n        v_alpha = mix(0.07, 0.10, uTransitionProgress);\\n\\n    }\\n    //----------------------------------------------------------\\n    // POSITION:\\n    // Geometries presentes:\\n    //--\\n\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(uScrollProgress*a_geo1_dir*2.2);\\n    POSITION_ORIGINAL = get_pos1(anguloRad_time);\\n    POSITION_1 = POSITION_ORIGINAL;\\n    //POSITION_1 = rotate(POSITION_1, vec3(0., -1, 0.), 0.5*PI);\\n    POSITION_1.x += -twentiethX*2.;\\n\\n    POSITION_1B = POSITION_ORIGINAL;\\n    POSITION_1B *= 1.;\\n    POSITION_1B.x += twentiethX*10.; \\n\\n    // float orbitalFactor = a_geo1_orbital/37.;\\n    // float foo = mix(1., 10., orbitalFactor);\\n    // float ease = cubicOut(uTransitionProgress*foo);\\n    // ease = clamp(ease, 0., 1.);\\n    POSITION_1 = mix(POSITION_1, POSITION_1B, uTransitionProgress);\\n\\n    float angle = mix(-PI, 0., uTransitionProgress);\\n    POSITION_1 = rotate(POSITION_1, rand, angle);\\n\\n    POSITION_2 = a_geo2_position;\\n    POSITION_2 = randomizePosition(POSITION_2, a_randomness, uTime, 5.0, uMorphingProgress, 5.);\\n    // Z modifications:\\n\\n    // Solo\\n    \\n    // Ondas de seno:\\n    //float senoFx = sin((-uTime+a_geo1_orbital))*0.5*0.5;\\n    //float escalaFx = mix(0.98, 1.02, senoFx);\\n    //POSITION_1 *= escalaFx;\\n    // Morphing:\\n    float clamped_morpingProgress = clamp(0., 0.95, uMorphingProgress);\\n    POSITION_1 = mix(POSITION_1, POSITION_2, clamped_morpingProgress);\\n    // Randomized position while in POSITION_2\\n    POSITION_1 = randomizePosition(POSITION_1, a_randomness*2., uTime, 5.0, uMorphingProgress, 2.5);\\n    // Escala por scroll delta:\\n    //POSITION_1 *= 1.+(uScrollDelta*0.2);\\n    // Escalado incial:\\n    //POSITION_1 *= mix(5., 1., quinticOut(uIntroProgress));\\n    //POSITION_1 *= mix(5., 1., quadraticOut(uIntroProgress));\\n    //float clamped_uIntroProgress;\\n    // clamped_uIntroProgress = uIntroProgress;\\n    //clamped_uIntroProgress = clamp(uIntroProgress, 0., 1.);\\n    //POSITION_1 *= mix(5., 1., quarticOut(clamped_uIntroProgress));\\n    POSITION_1 *= mix(5., 1., uIntroProgress);\\n    // Responsive Scale:\\n    POSITION_1 *= uResponsiveScale;\\n    //\\n    POSITION_1 = mix(POSITION_1, POSITION_2, uMorphingProgress);\\n    //----------------------------------------------------------\\n\\n    //----------------------------------------------------------\\n    // SIZE:\\n    \\n\\n    // Solo se ven los obitales 5, 10 y 15\\n\\n    // Los puntos son mas pequeños en los orbitales de la periferia\\n    float esclaEdege = get_escalaEdge(a_geo1_orbital); \\n    float rango = 1.-esclaEdege;\\n    SIZE_1 *= (esclaEdege + (rango*0.0));\\n    // Los puntos se escalan en base a un mapa de ruido\\n    //SIZE_1 *= mix(1., get_escalaNoise(POSITION_1.x, POSITION_1.y, 500., uProgress0), uProgress0b);\\n    //SIZE_1 *= mix(1., get_escalaNoise(POSITION_1.x, POSITION_1.y, 500., 1.0), 1.0);\\n    // Los puntos se escalan en base a ondas concentricas de seno:\\n    //SIZE_1 *= mix(1., get_escalaOndaRadial(a_geo1_orbital, -uTime*10.), uProgress4b);\\n    //SIZE_1 *= mix(1., get_escalaOndaRadial(a_geo1_orbital, -uTime*10.), 1.0);\\n    // Los puntos se escalan por pulson random:\\n    //SIZE_1 *= mix(1., 1.5, v_activePulseProgress);\\n    // Los puntos se escalan junto con la geometria con el scrolldelta\\n    //SIZE_1 *= 1.+(uScrollDelta);\\n\\n    \\n\\n    \\n    // \\n    float zDepthNorm = (POSITION_2.z+600.)/(600.*2.); // de -600 a 600 de un valor normalizado (sin clamp, es decir que puede ser <0 y >1) de la posicion z\\n    float zDepthAlpha = mix(0.2, 0.9, zDepthNorm);\\n    float zDepthScale = mix(0.8, 2.5, zDepthNorm);\\n    float randomSize = SIZE_2 *0.5+(a_randomness.x*0.9);\\n    randomSize *= zDepthScale;\\n    SIZE_2 = mix(SIZE_2, randomSize, uMorphingProgress);\\n    \\n    \\n    float SIZE = mix(SIZE_1, SIZE_2, uMorphingProgress);\\n    // Los puntos se escalan si se redimensona el lienzo\\n    SIZE *= uResponsiveScale;\\n    \\n    \\n    //----------------------------------------------------------\\n\\n    //----------------------------------------------------------\\n    // VERTEX\\n    vec4 mvPosition = modelViewMatrix * vec4( POSITION_1, 1.0 );\\n    gl_Position = projectionMatrix * mvPosition;\\n    gl_PointSize = SIZE*(uCamaraDistance/-mvPosition.z);\\n    //----------------------------------------------------------\\n\\n    \\n\\n    //----------------------------------------------------------\\n    // VARYINGS:\\n    v_randomness = a_randomness;\\n    v_colorStrength = get_escalaNoise(POSITION_1.x, POSITION_1.y, 200., sin(uTime));\\n    v_colorStrength = mix(1., v_colorStrength, uMorphingProgress);\\n\\n}");\n;// CONCATENATED MODULE: ./app/src/js/webgl/solutions1/shaders/solutions1_dots_fragment.glsl\n/* harmony default export */ const solutions1_dots_fragment = ("#define GLSLIFY 1\\nuniform vec3 uColor1;\\nuniform vec3 uColor2;\\nuniform vec3 uColorHero;\\nuniform float uIntroProgress;\\nuniform float uMorphingProgress;\\n\\nvarying float v_alpha; // Es el alpha de los puntos determinado sobre si estan en orbitales ocultos o visibles\\nvarying float v_colorStrength;\\n\\nfloat circulizar(float radio){\\n    // radio es un valor entre 0 y 1. 0 es 0 de radio y 1 es el maximo del radio dentro de\\n    radio = 1.0-(0.5*radio);\\n    float result = distance(gl_PointCoord, vec2(0.5, 0.5));\\n    result = 1. -result;\\n    result = pow(result, 1.);\\n    result = step(radio, result);\\n    return result;\\n}\\n\\nvoid main() {\\n\\n    //-------------------------------------------\\n    // COLOR:\\n    // Calculamos el color en la parte footer (cuando forma la M del logo)\\n    vec3 COLOR_FOOTER = mix(uColor2, uColor1, v_colorStrength);\\n    // En función del morphinPrpgress calculamos el color de ese momento\\n    vec3 COLOR = mix(uColorHero, COLOR_FOOTER, uMorphingProgress);\\n    //-------------------------------------------\\n\\n    //-------------------------------------------\\n    // ALPHA:\\n    // Creamos la forma circular:\\n    float ALPHA = circulizar(1.0);\\n    ALPHA *=  mix(v_alpha, 1., uMorphingProgress);\\n    // En la intro pasa de transparenta a corpóreo\\n    //ALPHA = mix(0., ALPHA, uIntroProgress);\\n    //-------------------------------------------\\n\\n    gl_FragColor = vec4(COLOR, ALPHA);\\n\\n}");\n;// CONCATENATED MODULE: ./app/src/js/webgl/solutions1/Solutions1Dots.js\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Solutions1Dots_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Solutions1Dots_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Solutions1Dots_createClass(Constructor, protoProps, staticProps) { if (protoProps) Solutions1Dots_defineProperties(Constructor.prototype, protoProps); if (staticProps) Solutions1Dots_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar Solutions1Dots = /*#__PURE__*/function () {\n  function Solutions1Dots(obj) {\n    var _this = this;\n\n    Solutions1Dots_classCallCheck(this, Solutions1Dots);\n\n    //console.log("(Solutions1Dots.CONSTRUCTORA)!")\n    //console.log(obj)\n    this.worldGL = obj.worldGL; //--\n\n    this.scene = this.worldGL.scene;\n    this.cameraDistance = this.worldGL.cameraDistance; //--\n\n    this.material = null;\n    this.geometry = null;\n    this.mesh = null;\n    this.numParticles = null;\n    this.allLoaded = false;\n    this.created = false;\n    this.clock = new three_module/* Clock */.SUY();\n    this.startTime = null;\n    this.introTime = 1;\n    this.rotationX = 0;\n    this.rotationY = 0;\n    this.rotationWantedX = 0;\n    this.rotationWantedY = 0;\n    this.morphingProgress = 0; //--\n\n    this.transitionProgress = 0; //--\n\n    this.eventProgress_intro = new webgl_EventProgress();\n    this.hero_transition_done = false; //--\n\n    this.eased_rotation = new webgl_EasedOutValue(0, 0.05);\n    this.eased_scrollDelta = new webgl_EasedOutValue(this.worldGL.settings.scroll_normalizedDelta * 0.3, 0.05);\n    this.eased_scrollDelta_fast = new webgl_EasedOutValue(this.worldGL.settings.scroll_normalizedDelta * 0.5, 0.1);\n    this.eased_scrollProgress = new webgl_EasedOutValue(this.worldGL.settings.scroll_progress, 0.05); //--\n\n    this._setup_settings(); //--\n\n\n    this.orbital_geometry = new solutions1_Solutions1Geometry(this.settings); //--\n\n    this.M_geometry = new webgl_LoadedGeometry({\n      id: "M_geometry",\n      file: "",\n      isDraco: false,\n      scale: 600 //rotationY : -Math.PI*0.25\n\n    }, this.settings);\n    this.M_geometry.on("onMeshLoaded", function (data) {\n      _this._eval_allLoaded();\n    }); //--\n\n    this.resize(); //--\n\n    this.M_geometry.init();\n  } //------------------------------------\n  // PUBLICAS: \n\n\n  Solutions1Dots_createClass(Solutions1Dots, [{\n    key: "create",\n    value: function create() {\n      //console.log("(Solutions1Dots._create)!")\n      //--\n      this.material = new three_module/* ShaderMaterial */.jyz({\n        depthWrite: false,\n        blending: three_module/* AdditiveBlending */.WMw,\n        //blending: THREE.NormalBlending,\n        //blending: THREE.MultiplyBlending,\n        vertexColors: true,\n        vertexShader: solutions1_dots_vertex,\n        fragmentShader: solutions1_dots_fragment,\n        transparent: true,\n        uniforms: {\n          uColor1: {\n            value: new three_module/* Color */.Ilk("#170e41")\n          },\n          //801c65\n          uColor2: {\n            value: new three_module/* Color */.Ilk("#801c65")\n          },\n          uColorHero: {\n            value: new three_module/* Color */.Ilk(this.worldGL.dotColor)\n          },\n          uTime: {\n            value: 0\n          },\n          uCamaraDistance: {\n            value: this.cameraDistance\n          },\n          uWidth: {\n            value: this.worldGL.width\n          },\n          uHeight: {\n            value: this.worldGL.height\n          },\n          uScrollDelta: {\n            value: 0\n          },\n          uScrollProgress: {\n            value: 1\n          },\n          uResponsiveScale: {\n            value: 1\n          },\n          uRotation1: {\n            value: 0\n          },\n          uRotation2: {\n            value: 0\n          },\n          uRotation3: {\n            value: 0\n          },\n          uRotationInner: {\n            value: 0\n          },\n          uRotationOutter: {\n            value: 0\n          },\n          uMorphingProgress: {\n            value: 0\n          },\n          uIntroProgress: {\n            value: 0\n          },\n          uTransitionProgress: {\n            value: 0\n          }\n        }\n      }); //--\n      //console.log(this.orbital_geometry.attributes.a_posiciones)\n      //--\n\n      this.geometry = new three_module/* BufferGeometry */.u9r();\n      this.geometry.setAttribute(\'position\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_geo1_position\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_geo1_dot_num\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_dot_num, 1));\n      this.geometry.setAttribute(\'a_geo1_orbital\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_orbital, 1));\n      this.geometry.setAttribute(\'a_geo1_pos_orbita\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_pos_orbita, 1));\n      this.geometry.setAttribute(\'a_geo1_incr_anguloRad\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_incr_anguloRad, 1));\n      this.geometry.setAttribute(\'a_geo1_anguloRad\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_anguloRad, 1));\n      this.geometry.setAttribute(\'a_geo1_radio\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_radio, 1));\n      this.geometry.setAttribute(\'a_geo1_dir\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_dir, 1));\n      this.geometry.setAttribute(\'a_geo1_incr\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_incr, 1));\n      this.geometry.setAttribute(\'a_geo1_x\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_x, 1));\n      this.geometry.setAttribute(\'a_geo1_y\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_y, 1));\n      this.geometry.setAttribute(\'a_geo1_z\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_z, 1));\n      this.geometry.setAttribute(\'a_geo1_dotFactor\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_dotFactor, 1)); // El punto mas interior tiene 1 y el mas exterior tiene 0\n\n      this.geometry.setAttribute(\'a_geo2_position\', new three_module/* BufferAttribute */.TlE(this.M_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_randomness\', new three_module/* BufferAttribute */.TlE(this.M_geometry.attributes.a_randomness, 3));\n      this.mesh = new three_module/* Points */.woe(this.geometry, this.material); //this.mesh.rotation.set(Math.PI, 0, 0)\n      //this.mesh.rotation.set(0, 0, 0.5*Math.PI)\n\n      this.scene.add(this.mesh);\n      this.resize();\n    }\n  }, {\n    key: "onMouseUpdate",\n    value: function onMouseUpdate(mouseNormX, mouseNormY) {\n      //console.log("(Solutions1Dots.onMouseUpdate): "+this.morphingProgress)\n      if (this.morphingProgress > 0) {\n        //console.log("*")\n        this._mouseUpdateX(mouseNormX);\n\n        this._mouseUpdateY(mouseNormY);\n      }\n    }\n  }, {\n    key: "update_transitionProgress",\n    value: function update_transitionProgress(progress) {\n      this.transitionProgress = progress;\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      if (this.allLoaded) {\n        //console.log("(Solutions1Dots.render)!")\n        //--\n        if (this.startTime == null) {\n          this.startTime = this.clock.getElapsedTime();\n        }\n\n        var introProgress = webgl_WebGLUtils.clamp((this.clock.getElapsedTime() - this.startTime) / this.introTime, 0, 1);\n        introProgress = easing_functions_default().Quartic.Out(introProgress);\n        this.material.uniforms.uIntroProgress.value = introProgress; //--\n\n        var rotationEasedY = this.rotationY + (this.rotationWantedY - this.rotationY) * 0.05;\n        this.rotationY = rotationEasedY;\n        this.mesh.rotation.y = rotationEasedY; ////--\n\n        var rotationEasedX = this.rotationX + (this.rotationWantedX - this.rotationX) * 0.05;\n        this.rotationX = rotationEasedX;\n        this.mesh.rotation.x = rotationEasedX; //--\n\n        this.material.uniforms.uTransitionProgress.value = easing_functions_default().Quartic.InOut(this.transitionProgress); //--\n        //const  meshRotation = Math.PI - (Math.PI*this.transitionProgress)\n        //this.mesh.rotation.set(meshRotation, 0, 0)\n        //--\n        //const rotationEased = this.rotation +((this.rotationWanted - this.rotation)*0.05)\n        //this.rotation = rotationEased\n        //this.mesh.rotation.y = rotationEased\n        //--\n\n        this.material.uniforms.uTime.value = this.clock.getElapsedTime();\n        this.material.uniforms.uCamaraDistance.value = this.worldGL.cameraDistance;\n        this.material.uniforms.uResponsiveScale.value = this.worldGL.responsiveScale;\n        this.material.uniforms.uScrollDelta.value = -this.eased_scrollDelta.get(this.worldGL.settings.scroll_normalizedDelta * 0.5);\n        this.material.uniforms.uScrollProgress.value = this.worldGL.settings.scroll_progress;\n\n        if (this.worldGL.settings.morphingProgress <= 0.5) {\n          this.morphingProgress = 0;\n\n          this._mouseUpdateX(0);\n\n          this._mouseUpdateY(0);\n        } else {\n          this.morphingProgress = (this.worldGL.settings.morphingProgress - 0.5) * 2;\n        } //console.log("this.morphingProgress: "+this.morphingProgress)\n        //--\n\n\n        this.material.uniforms.uMorphingProgress.value = this.morphingProgress;\n        var extraSpeed = 1 + Math.abs(this.eased_scrollDelta_fast.get(this.worldGL.settings.scroll_normalizedDelta * 0.5) * 10);\n        this.settings.rotation1 += this.settings.speedRotation1 * extraSpeed;\n        this.settings.rotation2 += this.settings.speedRotation2 * extraSpeed;\n        this.settings.rotation3 += this.settings.speedRotation3 * extraSpeed; //--\n\n        this.settings.rotationInner += this.settings.speedRotationInner * extraSpeed;\n        this.settings.rotationOutter += this.settings.speedRotationOutter * extraSpeed; //console.log("extraSpeed: "+extraSpeed)\n        //console.log(this.settings.rotation1)\n\n        this.material.uniforms.uRotation1.value = this.settings.rotation1;\n        this.material.uniforms.uRotation2.value = -this.settings.rotation2;\n        this.material.uniforms.uRotation3.value = this.settings.rotation3; //--\n\n        this.material.uniforms.uRotationInner.value = this.settings.rotationInner;\n        this.material.uniforms.uRotationOutter.value = this.settings.rotationOutter;\n      }\n    }\n  }, {\n    key: "resize",\n    value: function resize() {// NADA\n    } //------------------------------------\n    // PRIVADAS: \n\n  }, {\n    key: "_mouseUpdateX",\n    value: function _mouseUpdateX(mouseNormX) {\n      var maxAngleRad = Math.PI * 0.25;\n      this.rotationWantedY = maxAngleRad * mouseNormX * this.morphingProgress;\n    }\n  }, {\n    key: "_mouseUpdateY",\n    value: function _mouseUpdateY(mouseNormY) {\n      var maxAngleRad = Math.PI * 0.1;\n      this.rotationWantedX = maxAngleRad * mouseNormY * this.morphingProgress;\n    }\n  }, {\n    key: "_eval_allLoaded",\n    value: function _eval_allLoaded() {\n      if (this.M_geometry.loaded) {\n        this.allLoaded = true;\n        this.worldGL.eval_start(); //this._create()\n      }\n    }\n  }, {\n    key: "_setup_settings",\n    value: function _setup_settings() {\n      var _this$settings;\n\n      var speedBase = 0.002;\n      var speedBase2 = 0.0002; //console.log("(Solutions1Dots._setup_settings)!")\n\n      this.settings = (_this$settings = {\n        factor: 6,\n        incr_radio: 25,\n        numOrbits: 37,\n        arrayOrbits: [5, 10, 15],\n        //--\n        rotationInner: 0,\n        speedRotationInner: 20 * speedBase2,\n        rotationOutter: 0,\n        speedRotationOutter: 1 * speedBase2,\n        //--\n        speedRotation1: 3 * speedBase,\n        rotation1: 0\n      }, _defineProperty(_this$settings, "speedRotation1", 3 * speedBase), _defineProperty(_this$settings, "rotation2", 2), _defineProperty(_this$settings, "speedRotation2", 2 * speedBase), _defineProperty(_this$settings, "rotation3", 0), _defineProperty(_this$settings, "speedRotation3", 1 * speedBase), _this$settings);\n      this.settings.array_triangular = this._get_array_triangular(this.settings.factor, this.settings.numOrbits);\n      this.settings.numDots = this.settings.array_triangular[this.settings.array_triangular.length - 1];\n    }\n  }, {\n    key: "_get_array_triangular",\n    value: function _get_array_triangular(_factor, _numObits) {\n      // Genera una array de progresión triangular (* factor).\n      // Una progresión triangular es: 1, 3, 6, 10, 15 (https://significativa.org/diccionarios/numeros-figurados/#:~:text=3.1.1.1.-,Definici%C3%B3n,anterior%20no%20obtenemos%20una%20constante.)\n      var miArray = [];\n\n      for (var i = 0; i <= _numObits; i++) {\n        //array_numTriagulares.push(i*(i+1)/2)\n        miArray.push(i * (i + 1) / 2 * _factor);\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_get_array_dotPos",\n    value: function _get_array_dotPos(_arrayOrbits, _array_triangular, _array_triangular_dots_x_orbita) {\n      var miArray = [];\n\n      for (var i = 0; i < _arrayOrbits.length; i++) {\n        var orbitNum = _arrayOrbits[i];\n        var dots_x_orbit = _array_triangular_dots_x_orbita[i];\n        var dotNum_base = _array_triangular[_arrayOrbits[i] - 1]; // console.log("orbitNum: "+orbitNum)\n        // console.log("dots_x_orbit: "+dots_x_orbit)\n        // console.log("dotNum_base: "+dotNum_base)\n\n        for (var j = 0; j < dots_x_orbit; j++) {\n          miArray.push(dotNum_base + j + 1);\n        }\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_get_numDots",\n    value: function _get_numDots(_array_triangular_dots_x_orbita) {\n      var numDots = 0;\n\n      for (var i = 0; i <= _array_triangular_dots_x_orbita.length - 1; i++) {\n        numDots += _array_triangular_dots_x_orbita[i];\n      }\n\n      return numDots;\n    }\n  }, {\n    key: "_get_array_triangular_dots_x_orbita",\n    value: function _get_array_triangular_dots_x_orbita(_array_triangular, _arrayOrbits) {\n      // Genera una array basada en la progresión triangular (* factor).\n      // ... donde se indica el numero de dots por orbital\n      // Una progresión triangular es: 1, 3, 6, 10, 15 (https://significativa.org/diccionarios/numeros-figurados/#:~:text=3.1.1.1.-,Definici%C3%B3n,anterior%20no%20obtenemos%20una%20constante.)\n      var miArray = [];\n\n      for (var i = 0; i <= _arrayOrbits.length - 1; i++) {\n        //array_numTriagulares.push(i*(i+1)/2)\n        var numDots_orbita_actual = _array_triangular[_arrayOrbits[i]];\n        var numDots_orbita_anterior = _array_triangular[_arrayOrbits[i] - 1];\n        var numDots_orbita = numDots_orbita_actual - numDots_orbita_anterior;\n        miArray.push(numDots_orbita);\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_createcube",\n    value: function _createcube(_scene) {\n      var geometry = new three_module/* SphereGeometry */.xo$(100 * this.worldGL.responsiveScale, 100, 100);\n      var material = new three_module/* MeshBasicMaterial */.vBJ({\n        color: 0x00ff00\n      });\n      var cube = new three_module/* Mesh */.Kj0(geometry, material);\n      cube.position.setX(this.worldGL.width * 0.5);\n      cube.position.setY(this.worldGL.height * 0.5);\n      cube.quaternion.copy(this.worldGL.camera.quaternion);\n\n      _scene.add(cube);\n    }\n  }]);\n\n  return Solutions1Dots;\n}();\n\n/* harmony default export */ const solutions1_Solutions1Dots = (Solutions1Dots);\n;// CONCATENATED MODULE: ./app/src/js/webgl/solutions1/Solutions1App.js\nfunction Solutions1App_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Solutions1App_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Solutions1App_createClass(Constructor, protoProps, staticProps) { if (protoProps) Solutions1App_defineProperties(Constructor.prototype, protoProps); if (staticProps) Solutions1App_defineProperties(Constructor, staticProps); return Constructor; }\n\n// FPS-Meter:\n//(function(){var script=document.createElement(\'script\');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src=\'//cdn.jsdelivr.net/gh/Kevnz/stats.js/build/stats.min.js\';document.head.appendChild(script);})()\n\n\n\n\n\n\nvar Solutions1App_EventEmitter = __webpack_require__(7187);\n\n\n\n\n\nvar Solutions1App = /*#__PURE__*/function () {\n  function Solutions1App(obj) {\n    var _this = this;\n\n    Solutions1App_classCallCheck(this, Solutions1App);\n\n    //console.log("(Solutions1App.CONSTRUCTORA)!", obj) \n    this.hw_renderer = obj.renderer; // Rederer/pagina de HighWay. No confundir con el render/renderer de Three.js\n\n    this.$container = obj.domElement;\n    this.dotColor = obj.dotColor; //--\n\n    this.events = new Solutions1App_EventEmitter(); //--\n\n    this.REF_RESOLUTION = {\n      width: 1920,\n      height: 947\n    };\n    this.REF_CAMERA_DISTANCE = 500; //--\n\n    this.initialized = false; //--\n\n    this.width = this.$container.offsetWidth;\n    this.height = this.$container.offsetHeight;\n    this.responsiveScale = this.width / this.REF_RESOLUTION.width;\n    this.cameraDistance = this.REF_CAMERA_DISTANCE * (this.height / this.REF_RESOLUTION.height); //--\n    //this.$main = document.querySelector(\'.inner\')\n    //this.$hero = document.querySelector(\'.hero\')\n    //this.$footer = document.querySelector(\'.footer\')\n    //this.$image = document.querySelector(\'.ai__hero .image\')\n    //var rect = this.$image.getBoundingClientRect();\n    //console.log(rect.top, rect.right, rect.bottom, rect.left);\n\n    document.addEventListener(\'mousemove\', function (self) {\n      _this.onMouseUpdate(self);\n    }, false);\n    document.addEventListener(\'wheel\', function (self) {\n      _this.onMouseUpdate(self);\n    }, false); //--\n\n    this.MAIN_ACTIVE = false;\n    this.FOOTER_ACTIVE = false; //--\n\n    this.mouseNorm = {\n      x: 0,\n      y: 0\n    }; //--\n    //--\n\n    this.settings = {\n      scroll_lastInnerY: 0,\n      // Ultima posición del elemento de referencia\n      scroll_delta: 0,\n      // Incremento de pixels del scroll\n      scroll_limitedDelta: 0,\n      // Limita los valores a -20 -> +20\n      scroll_normalizedDelta: 0,\n      // Pasa el delta a -1 -> +1\n      scroll_factordDelta: 1,\n      // Valores absolutos de 0 -> 1\n      scroll_direction: 1,\n      // Direccion del delta. 1 si está parado\n      scroll_hero_progress: 0,\n      scroll_footer_progress: 0,\n      morphingProgress: 0\n    }; //--\n    // Scene\n\n    this.scene = new three_module/* Scene */.xsS(); //this.scene.background = new THREE.Color(0x333333)\n    //--\n    // Camera\n    //PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )\n\n    this.camera = new three_module/* PerspectiveCamera */.cPb(30, this.width / this.height, 0.1, 2000);\n    this.camera.position.z = this.cameraDistance; //console.log("this.camera.fov: "+this.camera.fov)\n\n    this.camera.fov = 2 * Math.atan(this.height / 2 / this.cameraDistance) * (180 / Math.PI); //console.log("this.camera.fov: "+this.camera.fov)\n    //--\n    // Renderer\n\n    this.renderer = new three_module/* WebGL1Renderer */.b5g({\n      antialias: true,\n      alpha: true\n    }); //this.renderer.autoClear = false // Vamos a usar 2 scenas (una para el background y otra para los puntos) que implicarán usar 2 acciones de render. Con autoclear false permitimos que la segunda no borre la primera.\n\n    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1)); //--\n    //console.log("this.$container: ",this.$container)\n\n    this.$container.appendChild(this.renderer.domElement); //--\n    //--\n\n    /*\n    this.background = new Solutions1Background({\n        worldGL:this,\n    })\n    */\n    //--\n\n    this.dots = new solutions1_Solutions1Dots({\n      worldGL: this\n    }); //--\n\n    this._resize(); //this._render();\n    //this._init_scrollListeners()\n\n  } //---------------------------\n  // PUBLICAS:\n\n\n  Solutions1App_createClass(Solutions1App, [{\n    key: "init",\n    value: function init() {\n      //console.log("(Solutions1App.init)!") \n      this.initialized = true;\n      this.eval_start();\n    }\n  }, {\n    key: "eval_start",\n    value: function eval_start() {\n      //console.log("(Solutions1App.eval_start): "+this.initialized+":"+this.dots.allLoaded) \n      if (this.initialized && this.dots.allLoaded) {\n        //console.log("START!")\n        //--\n        this.$main = document.querySelector(\'.inner\');\n        this.$hero = document.querySelector(\'.hero\');\n        this.$footer = document.querySelector(\'.footer\');\n        this.$image = document.querySelector(\'.ai__hero .image\'); //--\n\n        this.dots.create();\n\n        this._render();\n\n        this._init_scrollListeners();\n      }\n    }\n  }, {\n    key: "kill",\n    value: function kill() {\n      //console.log("(Solutions1App.kill)!") \n      this.$inner_trigger.kill();\n      this.$hero_trigger.kill();\n      node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this._binded_render);\n      node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this._binded_eval_scroll);\n      this.dots = null;\n    } //---------------------------\n\n  }, {\n    key: "onResize",\n    value: function onResize() {\n      //console.log("(Solutions1App.onResize)!")\n      this._resize();\n    }\n  }, {\n    key: "onMouseUpdate",\n    value: function onMouseUpdate(e) {\n      if (this.FOOTER_ACTIVE) {\n        //console.log("(Solutions1App.onMouseUpdate)!")\n        this.mouseNorm.x = e.pageX / this.width * 2 - 1;\n        this.mouseNorm.y = e.pageY / this.height * 2 - 1;\n\n        if (this.dots) {\n          this.dots.onMouseUpdate(this.mouseNorm.x, this.mouseNorm.y);\n        }\n      }\n    } //---------------------------\n    // PRIVADAS:\n\n  }, {\n    key: "_init_scrollListeners",\n    value: function _init_scrollListeners() {\n      var _this2 = this;\n\n      //console.log("(Solutions1App._init_scrollListeners)!")\n      var binded_render = function binded_render() {\n        _this2._render();\n      };\n\n      this._binded_render = binded_render;\n\n      var binded_eval_scroll = function binded_eval_scroll() {\n        _this2._eval_inertia_scroll(_this2.$inner_trigger.progress);\n\n        _this2._eval_hero_scroll(_this2.$hero_trigger.progress);\n\n        _this2._eval_footer_scroll(_this2.$footer_trigger.progress);\n      };\n\n      this._binded_eval_scroll = binded_eval_scroll;\n      var that = this;\n      this.$inner_trigger = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$main,\n        start: \'top-=10 top\',\n        end: \'bottom bottom\',\n        scrub: true,\n        // Scrub: Genera eventos en una franja mas que en un punto.\n        // markers: true,\n        onToggle: function onToggle(self) {\n          if (self.isActive) {\n            //console.log("MAIN ACTIVE")\n            that.MAIN_ACTIVE = true;\n            node_modules_gsap/* default.ticker.add */.ZP.ticker.add(binded_render);\n            node_modules_gsap/* default.ticker.add */.ZP.ticker.add(binded_eval_scroll);\n          } else {\n            that.MAIN_ACTIVE = false; //console.log("MAIN NOT ACTIVE")\n            //gsap.ticker.remove(binded_render) // El fondo webgl persiste siempre. No lo desactivamos nunca.\n\n            node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(binded_eval_scroll); // El fondo webgl persiste siempre. No lo desactivamos nunca.\n          }\n        }\n      });\n      this.$hero_trigger = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$hero,\n        start: \'bottom bottom\',\n        end: \'bottom+=2000 top\',\n        scrub: true,\n        // Scrub: Genera eventos en una franja mas que en un punto.\n        // markers: true,\n        onUpdate: function onUpdate(self) {\n          //console.log("progress: "+self.progress)\n          if (_this2.dots) {\n            _this2.dots.update_transitionProgress(self.progress);\n          }\n        }\n      });\n      this.$hero2_trigger = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$hero,\n        start: \'bottom center\',\n        end: \'bottom top\',\n        //scrub: true, // Scrub: Genera eventos en una franja mas que en un punto.\n        // markers: true,\n        onEnter: function onEnter(self) {//console.log("onEnter.isActive: ",self)\n          //this.dots.onDoHeroTransition()\n        },\n        onEnterBack: function onEnterBack(self) {//console.log("onEnterBack.isActive: ",self)\n          //this.dots.onUndoHeroTransition()\n        },\n        onLeaveBack: function onLeaveBack(self) {//console.log("onEnterBack.isActive: ",self)\n          //this.dots.onUndoHeroTransition()\n        } // onUpdate: (self) =>{\n        //     //console.log("progress: "+self.progress)\n        // }\n\n      });\n      this.$footer_trigger = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$footer,\n        start: \'top bottom\',\n        end: \'bottom+=10 bottom\',\n        scrub: true,\n        // Scrub: Genera eventos en una franja mas que en un punto.\n        // markers: true,\n        onToggle: function onToggle(self) {\n          if (self.isActive) {\n            //console.log("FOOTER ACTIVE")\n            that.FOOTER_ACTIVE = true;\n          } else {\n            //console.log("FOOTER NOT ACTIVE")\n            that.FOOTER_ACTIVE = false;\n          }\n        }\n      });\n    }\n  }, {\n    key: "_eval_inertia_scroll",\n    value: function _eval_inertia_scroll(progress) {\n      var innerData = this.$main.getBoundingClientRect();\n      var newInnerY = innerData.y;\n      this.settings.scroll_progress = progress;\n      this.settings.scroll_delta = newInnerY - this.settings.scroll_lastInnerY;\n      this.settings.scroll_lastInnerY = newInnerY;\n      this.settings.scroll_limitedDelta = webgl_WebGLUtils.clamp(this.settings.scroll_delta, -20, 20); // Limita los valores a -20 -> +20\n\n      this.settings.scroll_normalizedDelta = (this.settings.scroll_limitedDelta / 20).toFixed(3); // Pasa el delta a -1 -> +1\n\n      this.settings.scroll_factordDelta = Math.abs(this.settings.scroll_normalizedDelta) + 0; // Valores absolutos de 0 -> 1\n\n      this.settings.scroll_direction = 1;\n\n      if (this.settings.scroll_normalizedDelta < 0) {\n        this.settings.scroll_direction = -1;\n      }\n    }\n  }, {\n    key: "_eval_footer_scroll",\n    value: function _eval_footer_scroll(progress) {\n      //console.log("(Solutions1App._eval_footer_scroll): "+progress)\n      this.settings.scroll_footer_progress = progress;\n      this.settings.morphingProgress = progress;\n    }\n  }, {\n    key: "_eval_hero_scroll",\n    value: function _eval_hero_scroll(progress) {\n      //console.log("(Solutions1App._eval_hero_scroll): "+progress)\n      this.settings.scroll_hero_progress = progress;\n    }\n  }, {\n    key: "_resize",\n    value: function _resize() {\n      //console.log("(Solutions1App._resize)!")\n      this.width = this.$container.offsetWidth;\n      this.height = this.$container.offsetHeight;\n      this.responsiveScale = this.width / this.REF_RESOLUTION.width;\n      this.cameraDistance = this.REF_CAMERA_DISTANCE * (this.height / this.REF_RESOLUTION.height); //console.log("this.width: "+this.width)\n      //console.log("this.height: "+this.height)\n\n      this.renderer.setSize(this.width, this.height);\n      this.camera.aspect = this.width / this.height;\n      this.camera.position.z = this.cameraDistance;\n      this.camera.fov = 2 * Math.atan(this.height / 2 / this.cameraDistance) * (180 / Math.PI); //--\n      // console.log("this.width: "+this.width)\n      // console.log("this.height: "+this.height)\n      // console.log("this.responsiveScale: "+this.responsiveScale)\n      // console.log("this.camera.aspect: "+this.camera.aspect)\n      // console.log("this.camera.position.z: "+this.camera.position.z)\n      // console.log("this.camera.fov: "+this.camera.fov)\n      //--\n\n      this.camera.updateProjectionMatrix(); //--\n\n      /*\n      if(this.background){\n          this.background.resize(this.width, this.height);\n      }\n      */\n\n      if (this.dots) {\n        this.dots.resize();\n      }\n    }\n  }, {\n    key: "_render",\n    value: function _render() {\n      //console.log("(Solutions1App._render): "+this.settings.scroll_progress+":"+this.settings.scroll_footer_progress)\n      if (this.height != this.$container.offsetHeight || this.width != this.$container.offsetWidth) {\n        this._resize();\n      }\n      /*\n      if(this.background){\n          this.background.render()\n      }\n      */\n\n\n      if (this.dots) {\n        this.dots.render();\n      }\n\n      this.renderer.render(this.scene, this.camera); //requestAnimationFrame(this.render.bind(this))\n    }\n  }]);\n\n  return Solutions1App;\n}();\n\n/* harmony default export */ const solutions1_Solutions1App = (Solutions1App);\n;// CONCATENATED MODULE: ./app/src/js/renderers/rendererAI.js\nfunction rendererAI_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rendererAI_typeof = function _typeof(obj) { return typeof obj; }; } else { rendererAI_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rendererAI_typeof(obj); }\n\nfunction rendererAI_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rendererAI_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rendererAI_createClass(Constructor, protoProps, staticProps) { if (protoProps) rendererAI_defineProperties(Constructor.prototype, protoProps); if (staticProps) rendererAI_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rendererAI_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rendererAI_setPrototypeOf(subClass, superClass); }\n\nfunction rendererAI_setPrototypeOf(o, p) { rendererAI_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rendererAI_setPrototypeOf(o, p); }\n\nfunction rendererAI_createSuper(Derived) { var hasNativeReflectConstruct = rendererAI_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rendererAI_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rendererAI_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rendererAI_possibleConstructorReturn(this, result); }; }\n\nfunction rendererAI_possibleConstructorReturn(self, call) { if (call && (rendererAI_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return rendererAI_assertThisInitialized(self); }\n\nfunction rendererAI_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rendererAI_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rendererAI_getPrototypeOf(o) { rendererAI_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rendererAI_getPrototypeOf(o); }\n\n// GSAP Library\n\n\nnode_modules_gsap/* default.registerPlugin */.ZP.registerPlugin(ScrollTrigger/* default */.Z);\n\nnode_modules_gsap/* default.registerPlugin */.ZP.registerPlugin((DrawSVGPlugin_min_default())); // Import Renderer\n\n // Webgl\n\n\n // Utilities\n\n\n\n\n\nvar RendererAI = /*#__PURE__*/function (_Renderer) {\n  rendererAI_inherits(RendererAI, _Renderer);\n\n  var _super = rendererAI_createSuper(RendererAI);\n\n  function RendererAI() {\n    rendererAI_classCallCheck(this, RendererAI);\n\n    return _super.apply(this, arguments);\n  }\n\n  rendererAI_createClass(RendererAI, [{\n    key: "selectors",\n    value: function selectors() {\n      // Sections\n      this.$hero = this.$el.querySelector(\'.ai__hero\');\n      this.$content = this.$el.querySelector(\'.ai__content\'); // Selectors\n\n      if (this.$content) {\n        this.$contentMenu = this.$content.querySelector(\'.category\');\n        this.$contentCases = this.$content.querySelector(\'.cases\');\n        this.$contentCards = this.$content.querySelectorAll(\'.card--large\');\n      }\n\n      this.$canvas_ai_solutions1 = this.$el.querySelector(\'#webgl_ai_solutions1\');\n      this.$canvas_ai_solutions1_m = this.$el.querySelector(\'#webgl_ai_solutions1_m\');\n    }\n  }, {\n    key: "events",\n    value: function events() {\n      var _this = this;\n\n      if (this.$contentCards && this.appStore.isDesktop) {\n        for (var i = 0; i < this.$contentCards.length; i++) {\n          this.domEvents.add(this.$contentCards[i], \'mouseenter\', function (a, e, el) {\n            _this.enterCards(a, e, el);\n          });\n          this.domEvents.add(this.$contentCards[i], \'mouseleave\', function (a, e, el) {\n            _this.leaveCards(a, e, el);\n          });\n        }\n      }\n    }\n  }, {\n    key: "preload",\n    value: function preload() {\n      // this.preloadDelay = 1;\n      this.preloadItems = {\n        main: [],\n        secondary: []\n      };\n    }\n  }, {\n    key: "beforeEnter",\n    value: function beforeEnter() {\n      // Webgl\n      if (this.appStore.isDesktop) {\n        this.solutions1 = new solutions1_Solutions1App({\n          renderer: this,\n          domElement: this.$canvas_ai_solutions1,\n          dotColor: \'#007EFF\'\n        });\n      } else {\n        this.solutions1_m = new home2_m_Home2App_m({\n          renderer: this,\n          domElement: this.$canvas_ai_solutions1_m,\n          dotColor: \'#007EFF\',\n          incr_radio: 12\n        });\n      }\n    }\n  }, {\n    key: "enter",\n    value: function enter() {\n      // Start functions\n      this.init();\n    }\n  }, {\n    key: "init",\n    value: function init() {\n      if (this.appStore.isDesktop) {\n        this.initPinCategoriesMenu();\n        this.initUpdateCategoriesMenu();\n        this.initMoveWebGLCanvas();\n        this.initParallaxCards(); // WebGL\n\n        this.solutions1.init();\n      } else {\n        this.initDraggableMobile(); // WebGL\n\n        this.solutions1_m.init();\n      }\n    }\n  }, {\n    key: "initMoveWebGLCanvas",\n    value: function initMoveWebGLCanvas() {\n      var _this2 = this;\n\n      // Move canvas so it stay fixed\n      this._canvasPin = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$inner,\n        start: \'top top\',\n        end: \'bottom bottom\',\n        scrub: true,\n        onUpdate: function onUpdate(self) {\n          _this2.moveWebGLCanvas();\n        }\n      });\n    }\n  }, {\n    key: "moveWebGLCanvas",\n    value: function moveWebGLCanvas() {\n      // Its called from ScrollTrigger onUpdate and on Resize callbacks\n      var _offset2 = this.$inner.offsetHeight - this.$canvas_ai_solutions1.offsetHeight;\n\n      node_modules_gsap/* default.set */.ZP.set(this.$canvas_ai_solutions1, {\n        y: _offset2 * this._canvasPin.progress + \'px\'\n      });\n    }\n  }, {\n    key: "initPinCategoriesMenu",\n    value: function initPinCategoriesMenu() {\n      var _this3 = this;\n\n      this._offset = 0;\n      this._pinCategories = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$contentCases,\n        start: \'top 50%\',\n        end: \'bottom bottom\',\n        scrub: true,\n        onRefresh: function onRefresh(self) {\n          _this3._offset = self.end - self.start;\n        },\n        onUpdate: function onUpdate(self) {\n          node_modules_gsap/* default.set */.ZP.set(_this3.$contentMenu, {\n            y: self.progress * _this3._offset\n          });\n        }\n      });\n    }\n  }, {\n    key: "initUpdateCategoriesMenu",\n    value: function initUpdateCategoriesMenu() {\n      var _this4 = this;\n\n      // Selectors\n      this.$contentMenuLinks = this.$contentMenu.querySelectorAll(\'a\');\n      this.$contentMenuCircles = this.$contentMenu.querySelectorAll(\'.ico--circle\');\n      this.$contentMenuArrows = this.$contentMenu.querySelectorAll(\'.ico--arrow\'); // Set\n\n      node_modules_gsap/* default.set */.ZP.set(this.$contentMenuLinks, {\n        opacity: 0.4\n      });\n      node_modules_gsap/* default.set */.ZP.set(this.$contentMenuCircles, {\n        drawSVG: 0\n      });\n      var $cases = this.$el.querySelectorAll(\'.cases__item\');\n      this._sections = [];\n      $cases.forEach(function (el, index, element) {\n        var _caseTrigger = ScrollTrigger/* default.create */.Z.create({\n          trigger: el,\n          start: \'top 50%\',\n          end: \'bottom 50%\',\n          scrub: true,\n          onUpdate: function onUpdate(self) {\n            node_modules_gsap/* default.set */.ZP.set(_this4.$contentMenuCircles[index], {\n              drawSVG: self.progress * 100 + \'%\'\n            });\n          },\n          onEnter: function onEnter(self) {\n            node_modules_gsap/* default.set */.ZP.set(_this4.$contentMenuCircles[index], {\n              opacity: 1\n            });\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuCircles[index], {\n              rotation: 0,\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuArrows[index], {\n              fill: \'#ffffff\',\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuLinks[index], {\n              opacity: 1,\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n          },\n          onEnterBack: function onEnterBack() {\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuArrows[index], {\n              fill: \'#ffffff\',\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuCircles[index], {\n              opacity: 1,\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuLinks[index], {\n              opacity: 1,\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n          },\n          onLeave: function onLeave() {\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuLinks[index], {\n              opacity: 0.4,\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuCircles[index], {\n              opacity: 0.001,\n              duration: 0.5,\n              ease: \'power2.out\',\n              transformOrigin: \'center center\'\n            });\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuArrows[index], {\n              fill: \'#000A33\',\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n          },\n          onLeaveBack: function onLeaveBack() {\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuLinks[index], {\n              opacity: 0.4,\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuArrows[index], {\n              fill: \'#000A33\',\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n          }\n        });\n\n        _this4._sections.push(_caseTrigger);\n      });\n    }\n  }, {\n    key: "initDraggableMobile",\n    value: function initDraggableMobile() {\n      var _this5 = this;\n\n      // Selectors\n      this.$casesItems = this.$content.querySelectorAll(\'.cases__item\');\n\n      if (this.$casesItems) {\n        var _loop = function _loop(i) {\n          _this5.$casesSliders = _this5.$casesItems[i].querySelector(\'.slider\');\n          _this5.$casesSlidersInner = _this5.$casesItems[i].querySelector(\'.slider__inner\');\n          _this5._casesDraggable = new superDraggable_default({\n            el: _this5.$casesItems[i],\n            target: _this5.$casesSliders,\n            snap: false,\n            snapTo: \'center\',\n            dots: false,\n            onRaf: function onRaf(percent, progress, progressOrigin) {\n              node_modules_gsap/* default.to */.ZP.to(_this5.$casesItems[i].querySelector(\'.slider__progress\').children[0], {\n                scaleX: progressOrigin + progress\n              });\n            }\n          });\n        };\n\n        for (var i = 0; i < this.$casesItems.length; i++) {\n          _loop(i);\n        }\n      }\n    }\n  }, {\n    key: "initParallaxCards",\n    value: function initParallaxCards() {\n      // Selectors\n      this.$cards = this.$el.querySelectorAll(\'.card\');\n\n      if (this.$cards) {\n        for (var i = 0; i < this.$cards.length; i++) {\n          this._cardsTimeline = node_modules_gsap/* default.timeline */.ZP.timeline({\n            defaults: {\n              ease: \'none\',\n              duration: 1\n            },\n            scrollTrigger: {\n              trigger: this.$cards[i],\n              start: \'top bottom\',\n              end: \'bottom top\',\n              scrub: true\n            }\n          });\n\n          this._cardsTimeline.fromTo(this.$cards[i].querySelector(\'.background\').children[0], {\n            y: \'-100px\',\n            scale: 1.1\n          }, {\n            y: \'100px\',\n            scale: 1\n          }, 0);\n        }\n      }\n    }\n  }, {\n    key: "raf",\n    value: function raf() {} // eslint-disable-line\n\n  }, {\n    key: "resize",\n    value: function resize(width, height) {\n      if (this._casesDraggable) this._casesDraggable.resize(); // Webgl\n\n      if (this.appStore.isDesktop) {\n        if (this.solutions1) this.solutions1.onResize();\n      }\n    }\n  }, {\n    key: "leave",\n    value: function leave() {\n      if (this.appStore.isDesktop) {\n        this.solutions1.kill();\n        this.solutions1 = null;\n      } else {\n        this.solutions1_m.kill();\n        this.solutions1_m = null;\n      }\n    }\n  }]);\n\n  return RendererAI;\n}(renderer); // Don\'t forget to export your renderer\n\n\n/* harmony default export */ const rendererAI = (RendererAI);\n;// CONCATENATED MODULE: ./app/src/js/renderers/rendererData.js\nfunction rendererData_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rendererData_typeof = function _typeof(obj) { return typeof obj; }; } else { rendererData_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rendererData_typeof(obj); }\n\nfunction rendererData_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rendererData_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rendererData_createClass(Constructor, protoProps, staticProps) { if (protoProps) rendererData_defineProperties(Constructor.prototype, protoProps); if (staticProps) rendererData_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rendererData_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rendererData_setPrototypeOf(subClass, superClass); }\n\nfunction rendererData_setPrototypeOf(o, p) { rendererData_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rendererData_setPrototypeOf(o, p); }\n\nfunction rendererData_createSuper(Derived) { var hasNativeReflectConstruct = rendererData_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rendererData_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rendererData_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rendererData_possibleConstructorReturn(this, result); }; }\n\nfunction rendererData_possibleConstructorReturn(self, call) { if (call && (rendererData_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return rendererData_assertThisInitialized(self); }\n\nfunction rendererData_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rendererData_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rendererData_getPrototypeOf(o) { rendererData_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rendererData_getPrototypeOf(o); }\n\n// GSAP Library\n\n\nnode_modules_gsap/* default.registerPlugin */.ZP.registerPlugin(ScrollTrigger/* default */.Z);\n\nnode_modules_gsap/* default.registerPlugin */.ZP.registerPlugin((DrawSVGPlugin_min_default())); // Import Renderer\n\n // Webgl\n\n\n // Utilities\n\n\n\n\n\nvar RendererData = /*#__PURE__*/function (_Renderer) {\n  rendererData_inherits(RendererData, _Renderer);\n\n  var _super = rendererData_createSuper(RendererData);\n\n  function RendererData() {\n    rendererData_classCallCheck(this, RendererData);\n\n    return _super.apply(this, arguments);\n  }\n\n  rendererData_createClass(RendererData, [{\n    key: "selectors",\n    value: function selectors() {\n      // Sections\n      this.$hero = this.$el.querySelector(\'.data__hero\');\n      this.$content = this.$el.querySelector(\'.data__content\'); // Selectors\n\n      if (this.$content) {\n        this.$contentMenu = this.$content.querySelector(\'.category\');\n        this.$contentCases = this.$content.querySelector(\'.cases\');\n        this.$contentCards = this.$content.querySelectorAll(\'.card--large\');\n      }\n\n      this.$canvas_data_solutions1 = this.$el.querySelector(\'#webgl_data_solutions1\');\n      this.$canvas_data_solutions1_m = this.$el.querySelector(\'#webgl_data_solutions1_m\');\n    }\n  }, {\n    key: "events",\n    value: function events() {\n      var _this = this;\n\n      if (this.$contentCards && this.appStore.isDesktop) {\n        for (var i = 0; i < this.$contentCards.length; i++) {\n          this.domEvents.add(this.$contentCards[i], \'mouseenter\', function (a, e, el) {\n            _this.enterCards(a, e, el);\n          });\n          this.domEvents.add(this.$contentCards[i], \'mouseleave\', function (a, e, el) {\n            _this.leaveCards(a, e, el);\n          });\n        }\n      }\n    }\n  }, {\n    key: "preload",\n    value: function preload() {\n      // this.preloadDelay = 1;\n      this.preloadItems = {\n        main: [],\n        secondary: []\n      };\n    }\n  }, {\n    key: "beforeEnter",\n    value: function beforeEnter() {\n      // Webgl\n      if (this.appStore.isDesktop) {\n        this.solutions1 = new solutions1_Solutions1App({\n          renderer: this,\n          domElement: this.$canvas_data_solutions1,\n          dotColor: \'#e84371\'\n        });\n      } else {\n        this.solutions1_m = new home2_m_Home2App_m({\n          renderer: this,\n          domElement: this.$canvas_data_solutions1_m,\n          dotColor: \'#e84371\',\n          incr_radio: 12\n        });\n      }\n    }\n  }, {\n    key: "enter",\n    value: function enter() {\n      // Start functions\n      this.init();\n    }\n  }, {\n    key: "init",\n    value: function init() {\n      if (this.appStore.isDesktop) {\n        this.initPinCategoriesMenu();\n        this.initUpdateCategoriesMenu();\n        this.initMoveWebGLCanvas();\n        this.initParallaxCards(); // WebGL\n\n        this.solutions1.init();\n      } else {\n        this.initDraggableMobile(); // WebGL\n\n        this.solutions1_m.init();\n      }\n    }\n  }, {\n    key: "initMoveWebGLCanvas",\n    value: function initMoveWebGLCanvas() {\n      var _this2 = this;\n\n      // Move canvas so it stay fixed\n      this._canvasPin = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$inner,\n        start: \'top top\',\n        end: \'bottom bottom\',\n        scrub: true,\n        onUpdate: function onUpdate(self) {\n          _this2.moveWebGLCanvas();\n        }\n      });\n    }\n  }, {\n    key: "moveWebGLCanvas",\n    value: function moveWebGLCanvas() {\n      // Its called from ScrollTrigger onUpdate and on Resize callbacks\n      var _offset2 = this.$inner.offsetHeight - this.$canvas_data_solutions1.offsetHeight;\n\n      node_modules_gsap/* default.set */.ZP.set(this.$canvas_data_solutions1, {\n        y: _offset2 * this._canvasPin.progress + \'px\'\n      });\n    }\n  }, {\n    key: "initPinCategoriesMenu",\n    value: function initPinCategoriesMenu() {\n      var _this3 = this;\n\n      this._offset = 0;\n      this._pinCategories = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$contentCases,\n        start: \'top 50%\',\n        end: \'bottom bottom\',\n        scrub: true,\n        onRefresh: function onRefresh(self) {\n          _this3._offset = self.end - self.start;\n        },\n        onUpdate: function onUpdate(self) {\n          node_modules_gsap/* default.set */.ZP.set(_this3.$contentMenu, {\n            y: self.progress * _this3._offset\n          });\n        }\n      });\n    }\n  }, {\n    key: "initUpdateCategoriesMenu",\n    value: function initUpdateCategoriesMenu() {\n      var _this4 = this;\n\n      // Selectors\n      this.$contentMenuLinks = this.$contentMenu.querySelectorAll(\'a\');\n      this.$contentMenuCircles = this.$contentMenu.querySelectorAll(\'.ico--circle\');\n      this.$contentMenuArrows = this.$contentMenu.querySelectorAll(\'.ico--arrow\'); // Set\n\n      node_modules_gsap/* default.set */.ZP.set(this.$contentMenuLinks, {\n        opacity: 0.4\n      });\n      node_modules_gsap/* default.set */.ZP.set(this.$contentMenuCircles, {\n        drawSVG: 0\n      });\n      var $cases = this.$el.querySelectorAll(\'.cases__item\');\n      this._sections = [];\n      $cases.forEach(function (el, index, element) {\n        var _caseTrigger = ScrollTrigger/* default.create */.Z.create({\n          trigger: el,\n          start: \'top 50%\',\n          end: \'bottom 50%\',\n          scrub: true,\n          onUpdate: function onUpdate(self) {\n            node_modules_gsap/* default.set */.ZP.set(_this4.$contentMenuCircles[index], {\n              drawSVG: self.progress * 100 + \'%\'\n            });\n          },\n          onEnter: function onEnter(self) {\n            node_modules_gsap/* default.set */.ZP.set(_this4.$contentMenuCircles[index], {\n              opacity: 1\n            });\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuCircles[index], {\n              rotation: 0,\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuArrows[index], {\n              fill: \'#ffffff\',\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuLinks[index], {\n              opacity: 1,\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n          },\n          onEnterBack: function onEnterBack() {\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuArrows[index], {\n              fill: \'#ffffff\',\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuCircles[index], {\n              opacity: 1,\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuLinks[index], {\n              opacity: 1,\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n          },\n          onLeave: function onLeave() {\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuLinks[index], {\n              opacity: 0.4,\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuCircles[index], {\n              opacity: 0.001,\n              duration: 0.5,\n              ease: \'power2.out\',\n              transformOrigin: \'center center\'\n            });\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuArrows[index], {\n              fill: \'#000A33\',\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n          },\n          onLeaveBack: function onLeaveBack() {\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuLinks[index], {\n              opacity: 0.4,\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n            node_modules_gsap/* default.to */.ZP.to(_this4.$contentMenuArrows[index], {\n              fill: \'#000A33\',\n              duration: 0.5,\n              ease: \'power2.out\'\n            });\n          }\n        });\n\n        _this4._sections.push(_caseTrigger);\n      });\n    }\n  }, {\n    key: "initDraggableMobile",\n    value: function initDraggableMobile() {\n      var _this5 = this;\n\n      // Selectors\n      this.$casesItems = this.$content.querySelectorAll(\'.cases__item\');\n\n      if (this.$casesItems) {\n        var _loop = function _loop(i) {\n          _this5.$casesSliders = _this5.$casesItems[i].querySelector(\'.slider\');\n          _this5.$casesSlidersInner = _this5.$casesItems[i].querySelector(\'.slider__inner\');\n          _this5._casesDraggable = new superDraggable_default({\n            el: _this5.$casesItems[i],\n            target: _this5.$casesSlidersInner,\n            snap: false,\n            snapTo: \'center\',\n            dots: false,\n            onRaf: function onRaf(percent, progress, progressOrigin) {\n              node_modules_gsap/* default.to */.ZP.to(_this5.$casesItems[i].querySelector(\'.slider__progress\').children[0], {\n                scaleX: progressOrigin + progress\n              });\n            }\n          });\n        };\n\n        for (var i = 0; i < this.$casesItems.length; i++) {\n          _loop(i);\n        }\n      }\n    }\n  }, {\n    key: "initParallaxCards",\n    value: function initParallaxCards() {\n      // Selectors\n      this.$cards = this.$el.querySelectorAll(\'.card\');\n\n      if (this.$cards) {\n        for (var i = 0; i < this.$cards.length; i++) {\n          this._cardsTimeline = node_modules_gsap/* default.timeline */.ZP.timeline({\n            defaults: {\n              ease: \'none\',\n              duration: 1\n            },\n            scrollTrigger: {\n              trigger: this.$cards[i],\n              start: \'top bottom\',\n              end: \'bottom top\',\n              scrub: true\n            }\n          });\n\n          this._cardsTimeline.fromTo(this.$cards[i].querySelector(\'.background\').children[0], {\n            y: \'-100px\',\n            scale: 1.1\n          }, {\n            y: \'100px\',\n            scale: 1\n          }, 0);\n        }\n      }\n    }\n  }, {\n    key: "raf",\n    value: function raf() {} // eslint-disable-line\n\n  }, {\n    key: "resize",\n    value: function resize(width, height) {\n      if (this._casesDraggable) this._casesDraggable.resize(); // Webgl\n\n      if (this.appStore.isDesktop) {\n        if (this.solutions1) this.solutions1.onResize();\n      }\n    }\n  }, {\n    key: "leave",\n    value: function leave() {\n      if (this.appStore.isDesktop) {\n        this.solutions1.kill();\n        this.solutions1 = null;\n      } else {\n        this.solutions1_m.kill();\n        this.solutions1_m = null;\n      }\n    }\n  }]);\n\n  return RendererData;\n}(renderer); // Don\'t forget to export your renderer\n\n\n/* harmony default export */ const rendererData = (RendererData);\n;// CONCATENATED MODULE: ./app/src/js/utils/paths.js\n/*!\n * paths 3.2.6\n * https://greensock.com\n *\n * Copyright 2008-2020, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar _svgPathExp = /[achlmqstvz]|(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n    _numbersExp = /(?:(-)?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n    _scientific = /[\\+\\-]?\\d*\\.?\\d+e[\\+\\-]?\\d+/ig,\n    _selectorExp = /(^[#\\.][a-z]|[a-y][a-z])/i,\n    _DEG2RAD = Math.PI / 180,\n    _RAD2DEG = 180 / Math.PI,\n    _sin = Math.sin,\n    _cos = Math.cos,\n    _abs = Math.abs,\n    _sqrt = Math.sqrt,\n    _atan2 = Math.atan2,\n    _largeNum = 1e8,\n    paths_isString = function _isString(value) {\n  return typeof value === "string";\n},\n    paths_isNumber = function _isNumber(value) {\n  return typeof value === "number";\n},\n    _isUndefined = function _isUndefined(value) {\n  return typeof value === "undefined";\n},\n    _temp = {},\n    _temp2 = {},\n    _roundingNum = 1e5,\n    _wrapProgress = function _wrapProgress(progress) {\n  return Math.round((progress + _largeNum) % 1 * _roundingNum) / _roundingNum || (progress < 0 ? 0 : 1);\n},\n    //if progress lands on 1, the % will make it 0 which is why we || 1, but not if it\'s negative because it makes more sense for motion to end at 0 in that case.\npaths_round = function _round(value) {\n  return Math.round(value * _roundingNum) / _roundingNum || 0;\n},\n    _splitSegment = function _splitSegment(rawPath, segIndex, i, t) {\n  var segment = rawPath[segIndex],\n      shift = t === 1 ? 6 : subdivideSegment(segment, i, t);\n\n  if (shift && shift + i + 2 < segment.length) {\n    rawPath.splice(segIndex, 0, segment.slice(0, i + shift + 2));\n    segment.splice(0, i + shift);\n    return 1;\n  }\n},\n    _reverseRawPath = function _reverseRawPath(rawPath, skipOuter) {\n  var i = rawPath.length;\n\n  if (!skipOuter) {\n    rawPath.reverse();\n  }\n\n  while (i--) {\n    if (!rawPath[i].reversed) {\n      reverseSegment(rawPath[i]);\n    }\n  }\n},\n    _copyMetaData = function _copyMetaData(source, copy) {\n  copy.totalLength = source.totalLength;\n\n  if (source.samples) {\n    //segment\n    copy.samples = source.samples.slice(0);\n    copy.lookup = source.lookup.slice(0);\n    copy.minLength = source.minLength;\n    copy.resolution = source.resolution;\n  } else {\n    //rawPath\n    copy.totalPoints = source.totalPoints;\n  }\n\n  return copy;\n},\n    //pushes a new segment into a rawPath, but if its starting values match the ending values of the last segment, it\'ll merge it into that same segment (to reduce the number of segments)\n_appendOrMerge = function _appendOrMerge(rawPath, segment) {\n  var index = rawPath.length,\n      prevSeg = rawPath[index - 1] || [],\n      l = prevSeg.length;\n\n  if (segment[0] === prevSeg[l - 2] && segment[1] === prevSeg[l - 1]) {\n    segment = prevSeg.concat(segment.slice(2));\n    index--;\n  }\n\n  rawPath[index] = segment;\n},\n    _bestDistance;\n/* TERMINOLOGY\n - RawPath - an array of arrays, one for each Segment. A single RawPath could have multiple "M" commands, defining Segments (paths aren\'t always connected).\n - Segment - an array containing a sequence of Cubic Bezier coordinates in alternating x, y, x, y format. Starting anchor, then control point 1, control point 2, and ending anchor, then the next control point 1, control point 2, anchor, etc. Uses less memory than an array with a bunch of {x, y} points.\n - Bezier - a single cubic Bezier with a starting anchor, two control points, and an ending anchor.\n - the variable "t" is typically the position along an individual Bezier path (time) and it\'s NOT linear, meaning it could accelerate/decelerate based on the control points whereas the "p" or "progress" value is linearly mapped to the whole path, so it shouldn\'t really accelerate/decelerate based on control points. So a progress of 0.2 would be almost exactly 20% along the path. "t" is ONLY in an individual Bezier piece.\n */\n//accepts basic selector text, a path instance, a RawPath instance, or a Segment and returns a RawPath (makes it easy to homogenize things). If an element or selector text is passed in, it\'ll also cache the value so that if it\'s queried again, it\'ll just take the path data from there instead of parsing it all over again (as long as the path data itself hasn\'t changed - it\'ll check).\n\n\nfunction getRawPath(value) {\n  value = paths_isString(value) && _selectorExp.test(value) ? document.querySelector(value) || value : value;\n  var e = value.getAttribute ? value : 0,\n      rawPath;\n\n  if (e && (value = value.getAttribute("d"))) {\n    //implements caching\n    if (!e._gsPath) {\n      e._gsPath = {};\n    }\n\n    rawPath = e._gsPath[value];\n    return rawPath && !rawPath._dirty ? rawPath : e._gsPath[value] = stringToRawPath(value);\n  }\n\n  return !value ? console.warn("Expecting a <path> element or an SVG path data string") : paths_isString(value) ? stringToRawPath(value) : paths_isNumber(value[0]) ? [value] : value;\n} //copies a RawPath WITHOUT the length meta data (for speed)\n\nfunction copyRawPath(rawPath) {\n  var a = [],\n      i = 0;\n\n  for (; i < rawPath.length; i++) {\n    a[i] = _copyMetaData(rawPath[i], rawPath[i].slice(0));\n  }\n\n  return _copyMetaData(rawPath, a);\n}\nfunction reverseSegment(segment) {\n  var i = 0,\n      y;\n  segment.reverse(); //this will invert the order y, x, y, x so we must flip it back.\n\n  for (; i < segment.length; i += 2) {\n    y = segment[i];\n    segment[i] = segment[i + 1];\n    segment[i + 1] = y;\n  }\n\n  segment.reversed = !segment.reversed;\n}\n\nvar _createPath = function _createPath(e, ignore) {\n  var path = document.createElementNS("http://www.w3.org/2000/svg", "path"),\n      attr = [].slice.call(e.attributes),\n      i = attr.length,\n      name;\n  ignore = "," + ignore + ",";\n\n  while (--i > -1) {\n    name = attr[i].nodeName.toLowerCase(); //in Microsoft Edge, if you don\'t set the attribute with a lowercase name, it doesn\'t render correctly! Super weird.\n\n    if (ignore.indexOf("," + name + ",") < 0) {\n      path.setAttributeNS(null, name, attr[i].nodeValue);\n    }\n  }\n\n  return path;\n},\n    _typeAttrs = {\n  rect: "rx,ry,x,y,width,height",\n  circle: "r,cx,cy",\n  ellipse: "rx,ry,cx,cy",\n  line: "x1,x2,y1,y2"\n},\n    _attrToObj = function _attrToObj(e, attrs) {\n  var props = attrs ? attrs.split(",") : [],\n      obj = {},\n      i = props.length;\n\n  while (--i > -1) {\n    obj[props[i]] = +e.getAttribute(props[i]) || 0;\n  }\n\n  return obj;\n}; //converts an SVG shape like <circle>, <rect>, <polygon>, <polyline>, <ellipse>, etc. to a <path>, swapping it in and copying the attributes to match.\n\n\nfunction paths_convertToPath(element, swap) {\n  var type = element.tagName.toLowerCase(),\n      circ = 0.552284749831,\n      data,\n      x,\n      y,\n      r,\n      ry,\n      path,\n      rcirc,\n      rycirc,\n      points,\n      w,\n      h,\n      x2,\n      x3,\n      x4,\n      x5,\n      x6,\n      y2,\n      y3,\n      y4,\n      y5,\n      y6,\n      attr;\n\n  if (type === "path" || !element.getBBox) {\n    return element;\n  }\n\n  path = _createPath(element, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points");\n  attr = _attrToObj(element, _typeAttrs[type]);\n\n  if (type === "rect") {\n    r = attr.rx;\n    ry = attr.ry;\n    x = attr.x;\n    y = attr.y;\n    w = attr.width - r * 2;\n    h = attr.height - ry * 2;\n\n    if (r || ry) {\n      //if there are rounded corners, render cubic beziers\n      x2 = x + r * (1 - circ);\n      x3 = x + r;\n      x4 = x3 + w;\n      x5 = x4 + r * circ;\n      x6 = x4 + r;\n      y2 = y + ry * (1 - circ);\n      y3 = y + ry;\n      y4 = y3 + h;\n      y5 = y4 + ry * circ;\n      y6 = y4 + ry;\n      data = "M" + x6 + "," + y3 + " V" + y4 + " C" + [x6, y5, x5, y6, x4, y6, x4 - (x4 - x3) / 3, y6, x3 + (x4 - x3) / 3, y6, x3, y6, x2, y6, x, y5, x, y4, x, y4 - (y4 - y3) / 3, x, y3 + (y4 - y3) / 3, x, y3, x, y2, x2, y, x3, y, x3 + (x4 - x3) / 3, y, x4 - (x4 - x3) / 3, y, x4, y, x5, y, x6, y2, x6, y3].join(",") + "z";\n    } else {\n      data = "M" + (x + w) + "," + y + " v" + h + " h" + -w + " v" + -h + " h" + w + "z";\n    }\n  } else if (type === "circle" || type === "ellipse") {\n    if (type === "circle") {\n      r = ry = attr.r;\n      rycirc = r * circ;\n    } else {\n      r = attr.rx;\n      ry = attr.ry;\n      rycirc = ry * circ;\n    }\n\n    x = attr.cx;\n    y = attr.cy;\n    rcirc = r * circ;\n    data = "M" + (x + r) + "," + y + " C" + [x + r, y + rycirc, x + rcirc, y + ry, x, y + ry, x - rcirc, y + ry, x - r, y + rycirc, x - r, y, x - r, y - rycirc, x - rcirc, y - ry, x, y - ry, x + rcirc, y - ry, x + r, y - rycirc, x + r, y].join(",") + "z";\n  } else if (type === "line") {\n    data = "M" + attr.x1 + "," + attr.y1 + " L" + attr.x2 + "," + attr.y2; //previously, we just converted to "Mx,y Lx,y" but Safari has bugs that cause that not to render properly when using a stroke-dasharray that\'s not fully visible! Using a cubic bezier fixes that issue.\n  } else if (type === "polyline" || type === "polygon") {\n    points = (element.getAttribute("points") + "").match(_numbersExp) || [];\n    x = points.shift();\n    y = points.shift();\n    data = "M" + x + "," + y + " L" + points.join(",");\n\n    if (type === "polygon") {\n      data += "," + x + "," + y + "z";\n    }\n  }\n\n  path.setAttribute("d", rawPathToString(path._gsRawPath = stringToRawPath(data)));\n\n  if (swap && element.parentNode) {\n    element.parentNode.insertBefore(path, element);\n    element.parentNode.removeChild(element);\n  }\n\n  return path;\n} //returns the rotation (in degrees) at a particular progress on a rawPath (the slope of the tangent)\n\nfunction getRotationAtProgress(rawPath, progress) {\n  var d = getProgressData(rawPath, progress >= 1 ? 1 - 1e-9 : progress ? progress : 1e-9);\n  return getRotationAtBezierT(d.segment, d.i, d.t);\n}\n\nfunction getRotationAtBezierT(segment, i, t) {\n  var a = segment[i],\n      b = segment[i + 2],\n      c = segment[i + 4],\n      x;\n  a += (b - a) * t;\n  b += (c - b) * t;\n  a += (b - a) * t;\n  x = b + (c + (segment[i + 6] - c) * t - b) * t - a;\n  a = segment[i + 1];\n  b = segment[i + 3];\n  c = segment[i + 5];\n  a += (b - a) * t;\n  b += (c - b) * t;\n  a += (b - a) * t;\n  return paths_round(_atan2(b + (c + (segment[i + 7] - c) * t - b) * t - a, x) * _RAD2DEG);\n}\n\nfunction sliceRawPath(rawPath, start, end) {\n  if (_isUndefined(end)) {\n    end = 1;\n  }\n\n  start = start || 0;\n  var reverse = start > end,\n      loops = Math.max(0, ~~(_abs(end - start) - 1e-8));\n\n  if (reverse) {\n    reverse = end;\n    end = start;\n    start = reverse;\n    reverse = 1;\n    loops -= loops ? 1 : 0;\n  }\n\n  if (start < 0 || end < 0) {\n    var offset = ~~Math.min(start, end) + 1;\n    start += offset;\n    end += offset;\n  }\n\n  var path = copyRawPath(rawPath.totalLength ? rawPath : cacheRawPathMeasurements(rawPath)),\n      wrap = end > 1,\n      s = getProgressData(path, start, _temp, true),\n      e = getProgressData(path, end, _temp2),\n      eSeg = e.segment,\n      sSeg = s.segment,\n      eSegIndex = e.segIndex,\n      sSegIndex = s.segIndex,\n      ei = e.i,\n      si = s.i,\n      sameSegment = sSegIndex === eSegIndex,\n      sameBezier = ei === si && sameSegment,\n      invertedOrder = sameSegment && si > ei || sameBezier && s.t > e.t,\n      sShift,\n      eShift,\n      i,\n      copy,\n      totalSegments,\n      l,\n      j;\n\n  if (wrap || loops) {\n    if (_splitSegment(path, sSegIndex, si, s.t)) {\n      sShift = 1;\n      sSegIndex++;\n\n      if (sameBezier) {\n        if (invertedOrder) {\n          e.t /= s.t;\n        } else {\n          e.t = (e.t - s.t) / (1 - s.t);\n          eSegIndex++;\n          ei = 0;\n        }\n      } else if (sSegIndex <= eSegIndex + 1 && !invertedOrder) {\n        eSegIndex++;\n\n        if (sameSegment) {\n          ei -= si;\n        }\n      }\n    }\n\n    if (!e.t) {\n      eSegIndex--;\n\n      if (reverse) {\n        sSegIndex--;\n      }\n    } else if (_splitSegment(path, eSegIndex, ei, e.t)) {\n      if (invertedOrder && sShift) {\n        sSegIndex++;\n      }\n\n      if (reverse) {\n        eSegIndex++;\n      }\n    }\n\n    copy = [];\n    totalSegments = path.length;\n    l = 1 + totalSegments * loops;\n    j = sSegIndex;\n\n    if (reverse) {\n      eSegIndex = (eSegIndex || totalSegments) - 1;\n      l += (totalSegments - eSegIndex + sSegIndex) % totalSegments;\n\n      for (i = 0; i < l; i++) {\n        _appendOrMerge(copy, path[j]);\n\n        j = (j || totalSegments) - 1;\n      }\n    } else {\n      l += (totalSegments - sSegIndex + eSegIndex) % totalSegments;\n\n      for (i = 0; i < l; i++) {\n        _appendOrMerge(copy, path[j++ % totalSegments]);\n      }\n    }\n\n    path = copy;\n  } else {\n    eShift = e.t === 1 ? 6 : subdivideSegment(eSeg, ei, e.t);\n\n    if (start !== end) {\n      sShift = subdivideSegment(sSeg, si, sameBezier ? s.t / e.t : s.t);\n\n      if (sameSegment) {\n        eShift += sShift;\n      }\n\n      eSeg.splice(ei + eShift + 2);\n\n      if (sShift || si) {\n        sSeg.splice(0, si + sShift);\n      }\n\n      i = path.length;\n\n      while (i--) {\n        //chop off any extra segments\n        if (i < sSegIndex || i > eSegIndex) {\n          path.splice(i, 1);\n        }\n      }\n    } else {\n      eSeg.angle = getRotationAtBezierT(eSeg, ei + eShift, 0); //record the value before we chop because it\'ll be impossible to determine the angle after its length is 0!\n\n      ei += eShift;\n      s = eSeg[ei];\n      e = eSeg[ei + 1];\n      eSeg.length = eSeg.totalLength = 0;\n      eSeg.totalPoints = path.totalPoints = 8;\n      eSeg.push(s, e, s, e, s, e, s, e);\n    }\n  }\n\n  if (reverse) {\n    _reverseRawPath(path, wrap || loops);\n  }\n\n  path.totalLength = 0;\n  return path;\n} //measures a Segment according to its resolution (so if segment.resolution is 6, for example, it\'ll take 6 samples equally across each Bezier) and create/populate a "samples" array that has the length up to each of those sample points (always increasing from the start) as well as a "lookup" array that\'s broken up according to the smallest distance between 2 samples. This gives us a very fast way of looking up a progress position rather than looping through all the points/Beziers. You can optionally have it only measure a subset, starting at startIndex and going for a specific number of beziers (remember, there are 3 x/y pairs each, for a total of 6 elements for each Bezier). It will also populate a "totalLength" property, but that\'s not generally super accurate because by default it\'ll only take 6 samples per Bezier. But for performance reasons, it\'s perfectly adequate for measuring progress values along the path. If you need a more accurate totalLength, either increase the resolution or use the more advanced bezierToPoints() method which keeps adding points until they don\'t deviate by more than a certain precision value.\n\nfunction measureSegment(segment, startIndex, bezierQty) {\n  startIndex = startIndex || 0;\n\n  if (!segment.samples) {\n    segment.samples = [];\n    segment.lookup = [];\n  }\n\n  var resolution = ~~segment.resolution || 12,\n      inc = 1 / resolution,\n      endIndex = bezierQty ? startIndex + bezierQty * 6 + 1 : segment.length,\n      x1 = segment[startIndex],\n      y1 = segment[startIndex + 1],\n      samplesIndex = startIndex ? startIndex / 6 * resolution : 0,\n      samples = segment.samples,\n      lookup = segment.lookup,\n      min = (startIndex ? segment.minLength : _largeNum) || _largeNum,\n      prevLength = samples[samplesIndex + bezierQty * resolution - 1],\n      length = startIndex ? samples[samplesIndex - 1] : 0,\n      i,\n      j,\n      x4,\n      x3,\n      x2,\n      xd,\n      xd1,\n      y4,\n      y3,\n      y2,\n      yd,\n      yd1,\n      inv,\n      t,\n      lengthIndex,\n      l,\n      segLength;\n  samples.length = lookup.length = 0;\n\n  for (j = startIndex + 2; j < endIndex; j += 6) {\n    x4 = segment[j + 4] - x1;\n    x3 = segment[j + 2] - x1;\n    x2 = segment[j] - x1;\n    y4 = segment[j + 5] - y1;\n    y3 = segment[j + 3] - y1;\n    y2 = segment[j + 1] - y1;\n    xd = xd1 = yd = yd1 = 0;\n\n    if (_abs(x4) < 1e-5 && _abs(y4) < 1e-5 && _abs(x2) + _abs(y2) < 1e-5) {\n      //dump points that are sufficiently close (basically right on top of each other, making a bezier super tiny or 0 length)\n      if (segment.length > 8) {\n        segment.splice(j, 6);\n        j -= 6;\n        endIndex -= 6;\n      }\n    } else {\n      for (i = 1; i <= resolution; i++) {\n        t = inc * i;\n        inv = 1 - t;\n        xd = xd1 - (xd1 = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t);\n        yd = yd1 - (yd1 = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t);\n        l = _sqrt(yd * yd + xd * xd);\n\n        if (l < min) {\n          min = l;\n        }\n\n        length += l;\n        samples[samplesIndex++] = length;\n      }\n    }\n\n    x1 += x4;\n    y1 += y4;\n  }\n\n  if (prevLength) {\n    prevLength -= length;\n\n    for (; samplesIndex < samples.length; samplesIndex++) {\n      samples[samplesIndex] += prevLength;\n    }\n  }\n\n  if (samples.length && min) {\n    segment.totalLength = segLength = samples[samples.length - 1] || 0;\n    segment.minLength = min;\n    l = lengthIndex = 0;\n\n    for (i = 0; i < segLength; i += min) {\n      lookup[l++] = samples[lengthIndex] < i ? ++lengthIndex : lengthIndex;\n    }\n  } else {\n    segment.totalLength = samples[0] = 0;\n  }\n\n  return startIndex ? length - samples[startIndex / 2 - 1] : length;\n}\n\nfunction cacheRawPathMeasurements(rawPath, resolution) {\n  var pathLength, points, i;\n\n  for (i = pathLength = points = 0; i < rawPath.length; i++) {\n    rawPath[i].resolution = ~~resolution || 12; //steps per Bezier curve (anchor, 2 control points, to anchor)\n\n    points += rawPath[i].length;\n    pathLength += measureSegment(rawPath[i]);\n  }\n\n  rawPath.totalPoints = points;\n  rawPath.totalLength = pathLength;\n  return rawPath;\n} //divide segment[i] at position t (value between 0 and 1, progress along that particular cubic bezier segment that starts at segment[i]). Returns how many elements were spliced into the segment array (either 0 or 6)\n\nfunction subdivideSegment(segment, i, t) {\n  if (t <= 0 || t >= 1) {\n    return 0;\n  }\n\n  var ax = segment[i],\n      ay = segment[i + 1],\n      cp1x = segment[i + 2],\n      cp1y = segment[i + 3],\n      cp2x = segment[i + 4],\n      cp2y = segment[i + 5],\n      bx = segment[i + 6],\n      by = segment[i + 7],\n      x1a = ax + (cp1x - ax) * t,\n      x2 = cp1x + (cp2x - cp1x) * t,\n      y1a = ay + (cp1y - ay) * t,\n      y2 = cp1y + (cp2y - cp1y) * t,\n      x1 = x1a + (x2 - x1a) * t,\n      y1 = y1a + (y2 - y1a) * t,\n      x2a = cp2x + (bx - cp2x) * t,\n      y2a = cp2y + (by - cp2y) * t;\n  x2 += (x2a - x2) * t;\n  y2 += (y2a - y2) * t;\n  segment.splice(i + 2, 4, paths_round(x1a), //first control point\n  paths_round(y1a), paths_round(x1), //second control point\n  paths_round(y1), paths_round(x1 + (x2 - x1) * t), //new fabricated anchor on line\n  paths_round(y1 + (y2 - y1) * t), paths_round(x2), //third control point\n  paths_round(y2), paths_round(x2a), //fourth control point\n  paths_round(y2a));\n\n  if (segment.samples) {\n    segment.samples.splice(i / 6 * segment.resolution | 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n\n  return 6;\n} // returns an object {path, segment, segIndex, i, t}\n\nfunction getProgressData(rawPath, progress, decoratee, pushToNextIfAtEnd) {\n  decoratee = decoratee || {};\n\n  if (!rawPath.totalLength) {\n    cacheRawPathMeasurements(rawPath);\n  }\n\n  if (progress < 0 || progress > 1) {\n    progress = _wrapProgress(progress);\n  }\n\n  var segIndex = 0,\n      segment = rawPath[0],\n      samples,\n      resolution,\n      length,\n      min,\n      max,\n      i,\n      t;\n\n  if (rawPath.length > 1) {\n    //speed optimization: most of the time, there\'s only one segment so skip the recursion.\n    length = rawPath.totalLength * progress;\n    max = i = 0;\n\n    while ((max += rawPath[i++].totalLength) < length) {\n      segIndex = i;\n    }\n\n    segment = rawPath[segIndex];\n    min = max - segment.totalLength;\n    progress = (length - min) / (max - min) || 0;\n  }\n\n  samples = segment.samples;\n  resolution = segment.resolution; //how many samples per cubic bezier chunk\n\n  length = segment.totalLength * progress;\n  i = segment.lookup[~~(length / segment.minLength)] || 0;\n  min = i ? samples[i - 1] : 0;\n  max = samples[i];\n\n  if (max < length) {\n    min = max;\n    max = samples[++i];\n  }\n\n  t = 1 / resolution * ((length - min) / (max - min) + i % resolution);\n  i = ~~(i / resolution) * 6;\n\n  if (pushToNextIfAtEnd && t === 1) {\n    if (i + 6 < segment.length) {\n      i += 6;\n      t = 0;\n    } else if (segIndex + 1 < rawPath.length) {\n      i = t = 0;\n      segment = rawPath[++segIndex];\n    }\n  }\n\n  decoratee.t = t;\n  decoratee.i = i;\n  decoratee.path = rawPath;\n  decoratee.segment = segment;\n  decoratee.segIndex = segIndex;\n  return decoratee;\n}\n\nfunction getPositionOnPath(rawPath, progress, includeAngle, point) {\n  var segment = rawPath[0],\n      result = point || {},\n      samples,\n      resolution,\n      length,\n      min,\n      max,\n      i,\n      t,\n      a,\n      inv;\n\n  if (progress < 0 || progress > 1) {\n    progress = _wrapProgress(progress);\n  }\n\n  if (rawPath.length > 1) {\n    //speed optimization: most of the time, there\'s only one segment so skip the recursion.\n    length = rawPath.totalLength * progress;\n    max = i = 0;\n\n    while ((max += rawPath[i++].totalLength) < length) {\n      segment = rawPath[i];\n    }\n\n    min = max - segment.totalLength;\n    progress = (length - min) / (max - min) || 0;\n  }\n\n  samples = segment.samples;\n  resolution = segment.resolution;\n  length = segment.totalLength * progress;\n  i = segment.lookup[~~(length / segment.minLength)] || 0;\n  min = i ? samples[i - 1] : 0;\n  max = samples[i];\n\n  if (max < length) {\n    min = max;\n    max = samples[++i];\n  }\n\n  t = 1 / resolution * ((length - min) / (max - min) + i % resolution) || 0;\n  inv = 1 - t;\n  i = ~~(i / resolution) * 6;\n  a = segment[i];\n  result.x = paths_round((t * t * (segment[i + 6] - a) + 3 * inv * (t * (segment[i + 4] - a) + inv * (segment[i + 2] - a))) * t + a);\n  result.y = paths_round((t * t * (segment[i + 7] - (a = segment[i + 1])) + 3 * inv * (t * (segment[i + 5] - a) + inv * (segment[i + 3] - a))) * t + a);\n\n  if (includeAngle) {\n    result.angle = segment.totalLength ? getRotationAtBezierT(segment, i, t >= 1 ? 1 - 1e-9 : t ? t : 1e-9) : segment.angle || 0;\n  }\n\n  return result;\n} //applies a matrix transform to RawPath (or a segment in a RawPath) and returns whatever was passed in (it transforms the values in the array(s), not a copy).\n\nfunction transformRawPath(rawPath, a, b, c, d, tx, ty) {\n  var j = rawPath.length,\n      segment,\n      l,\n      i,\n      x,\n      y;\n\n  while (--j > -1) {\n    segment = rawPath[j];\n    l = segment.length;\n\n    for (i = 0; i < l; i += 2) {\n      x = segment[i];\n      y = segment[i + 1];\n      segment[i] = x * a + y * c + tx;\n      segment[i + 1] = x * b + y * d + ty;\n    }\n  }\n\n  rawPath._dirty = 1;\n  return rawPath;\n} // translates SVG arc data into a segment (cubic beziers). Angle is in degrees.\n\nfunction arcToSegment(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {\n  if (lastX === x && lastY === y) {\n    return;\n  }\n\n  rx = _abs(rx);\n  ry = _abs(ry);\n\n  var angleRad = angle % 360 * _DEG2RAD,\n      cosAngle = _cos(angleRad),\n      sinAngle = _sin(angleRad),\n      PI = Math.PI,\n      TWOPI = PI * 2,\n      dx2 = (lastX - x) / 2,\n      dy2 = (lastY - y) / 2,\n      x1 = cosAngle * dx2 + sinAngle * dy2,\n      y1 = -sinAngle * dx2 + cosAngle * dy2,\n      x1_sq = x1 * x1,\n      y1_sq = y1 * y1,\n      radiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);\n\n  if (radiiCheck > 1) {\n    rx = _sqrt(radiiCheck) * rx;\n    ry = _sqrt(radiiCheck) * ry;\n  }\n\n  var rx_sq = rx * rx,\n      ry_sq = ry * ry,\n      sq = (rx_sq * ry_sq - rx_sq * y1_sq - ry_sq * x1_sq) / (rx_sq * y1_sq + ry_sq * x1_sq);\n\n  if (sq < 0) {\n    sq = 0;\n  }\n\n  var coef = (largeArcFlag === sweepFlag ? -1 : 1) * _sqrt(sq),\n      cx1 = coef * (rx * y1 / ry),\n      cy1 = coef * -(ry * x1 / rx),\n      sx2 = (lastX + x) / 2,\n      sy2 = (lastY + y) / 2,\n      cx = sx2 + (cosAngle * cx1 - sinAngle * cy1),\n      cy = sy2 + (sinAngle * cx1 + cosAngle * cy1),\n      ux = (x1 - cx1) / rx,\n      uy = (y1 - cy1) / ry,\n      vx = (-x1 - cx1) / rx,\n      vy = (-y1 - cy1) / ry,\n      temp = ux * ux + uy * uy,\n      angleStart = (uy < 0 ? -1 : 1) * Math.acos(ux / _sqrt(temp)),\n      angleExtent = (ux * vy - uy * vx < 0 ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt(temp * (vx * vx + vy * vy)));\n\n  if (isNaN(angleExtent)) {\n    //rare edge case. Math.cos(-1) is NaN.\n    angleExtent = PI;\n  }\n\n  if (!sweepFlag && angleExtent > 0) {\n    angleExtent -= TWOPI;\n  } else if (sweepFlag && angleExtent < 0) {\n    angleExtent += TWOPI;\n  }\n\n  angleStart %= TWOPI;\n  angleExtent %= TWOPI;\n\n  var segments = Math.ceil(_abs(angleExtent) / (TWOPI / 4)),\n      rawPath = [],\n      angleIncrement = angleExtent / segments,\n      controlLength = 4 / 3 * _sin(angleIncrement / 2) / (1 + _cos(angleIncrement / 2)),\n      ma = cosAngle * rx,\n      mb = sinAngle * rx,\n      mc = sinAngle * -ry,\n      md = cosAngle * ry,\n      i;\n\n  for (i = 0; i < segments; i++) {\n    angle = angleStart + i * angleIncrement;\n    x1 = _cos(angle);\n    y1 = _sin(angle);\n    ux = _cos(angle += angleIncrement);\n    uy = _sin(angle);\n    rawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);\n  } //now transform according to the actual size of the ellipse/arc (the beziers were noramlized, between 0 and 1 on a circle).\n\n\n  for (i = 0; i < rawPath.length; i += 2) {\n    x1 = rawPath[i];\n    y1 = rawPath[i + 1];\n    rawPath[i] = x1 * ma + y1 * mc + cx;\n    rawPath[i + 1] = x1 * mb + y1 * md + cy;\n  }\n\n  rawPath[i - 2] = x; //always set the end to exactly where it\'s supposed to be\n\n  rawPath[i - 1] = y;\n  return rawPath;\n} //Spits back a RawPath with absolute coordinates. Each segment starts with a "moveTo" command (x coordinate, then y) and then 2 control points (x, y, x, y), then anchor. The goal is to minimize memory and maximize speed.\n\n\nfunction stringToRawPath(d) {\n  var a = (d + "").replace(_scientific, function (m) {\n    var n = +m;\n    return n < 0.0001 && n > -0.0001 ? 0 : n;\n  }).match(_svgPathExp) || [],\n      //some authoring programs spit out very small numbers in scientific notation like "1e-5", so make sure we round that down to 0 first.\n  path = [],\n      relativeX = 0,\n      relativeY = 0,\n      twoThirds = 2 / 3,\n      elements = a.length,\n      points = 0,\n      errorMessage = "ERROR: malformed path: " + d,\n      i,\n      j,\n      x,\n      y,\n      command,\n      isRelative,\n      segment,\n      startX,\n      startY,\n      difX,\n      difY,\n      beziers,\n      prevCommand,\n      flag1,\n      flag2,\n      line = function line(sx, sy, ex, ey) {\n    difX = (ex - sx) / 3;\n    difY = (ey - sy) / 3;\n    segment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);\n  };\n\n  if (!d || !isNaN(a[0]) || isNaN(a[1])) {\n    console.log(errorMessage);\n    return path;\n  }\n\n  for (i = 0; i < elements; i++) {\n    prevCommand = command;\n\n    if (isNaN(a[i])) {\n      command = a[i].toUpperCase();\n      isRelative = command !== a[i]; //lower case means relative\n    } else {\n      //commands like "C" can be strung together without any new command characters between.\n      i--;\n    }\n\n    x = +a[i + 1];\n    y = +a[i + 2];\n\n    if (isRelative) {\n      x += relativeX;\n      y += relativeY;\n    }\n\n    if (!i) {\n      startX = x;\n      startY = y;\n    } // "M" (move)\n\n\n    if (command === "M") {\n      if (segment) {\n        if (segment.length < 8) {\n          //if the path data was funky and just had a M with no actual drawing anywhere, skip it.\n          path.length -= 1;\n        } else {\n          points += segment.length;\n        }\n      }\n\n      relativeX = startX = x;\n      relativeY = startY = y;\n      segment = [x, y];\n      path.push(segment);\n      i += 2;\n      command = "L"; //an "M" with more than 2 values gets interpreted as "lineTo" commands ("L").\n      // "C" (cubic bezier)\n    } else if (command === "C") {\n      if (!segment) {\n        segment = [0, 0];\n      }\n\n      if (!isRelative) {\n        relativeX = relativeY = 0;\n      } //note: "*1" is just a fast/short way to cast the value as a Number. WAAAY faster in Chrome, slightly slower in Firefox.\n\n\n      segment.push(x, y, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, relativeX += a[i + 5] * 1, relativeY += a[i + 6] * 1);\n      i += 6; // "S" (continuation of cubic bezier)\n    } else if (command === "S") {\n      difX = relativeX;\n      difY = relativeY;\n\n      if (prevCommand === "C" || prevCommand === "S") {\n        difX += relativeX - segment[segment.length - 4];\n        difY += relativeY - segment[segment.length - 3];\n      }\n\n      if (!isRelative) {\n        relativeX = relativeY = 0;\n      }\n\n      segment.push(difX, difY, x, y, relativeX += a[i + 3] * 1, relativeY += a[i + 4] * 1);\n      i += 4; // "Q" (quadratic bezier)\n    } else if (command === "Q") {\n      difX = relativeX + (x - relativeX) * twoThirds;\n      difY = relativeY + (y - relativeY) * twoThirds;\n\n      if (!isRelative) {\n        relativeX = relativeY = 0;\n      }\n\n      relativeX += a[i + 3] * 1;\n      relativeY += a[i + 4] * 1;\n      segment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);\n      i += 4; // "T" (continuation of quadratic bezier)\n    } else if (command === "T") {\n      difX = relativeX - segment[segment.length - 4];\n      difY = relativeY - segment[segment.length - 3];\n      segment.push(relativeX + difX, relativeY + difY, x + (relativeX + difX * 1.5 - x) * twoThirds, y + (relativeY + difY * 1.5 - y) * twoThirds, relativeX = x, relativeY = y);\n      i += 2; // "H" (horizontal line)\n    } else if (command === "H") {\n      line(relativeX, relativeY, relativeX = x, relativeY);\n      i += 1; // "V" (vertical line)\n    } else if (command === "V") {\n      //adjust values because the first (and only one) isn\'t x in this case, it\'s y.\n      line(relativeX, relativeY, relativeX, relativeY = x + (isRelative ? relativeY - relativeX : 0));\n      i += 1; // "L" (line) or "Z" (close)\n    } else if (command === "L" || command === "Z") {\n      if (command === "Z") {\n        x = startX;\n        y = startY;\n        segment.closed = true;\n      }\n\n      if (command === "L" || _abs(relativeX - x) > 0.5 || _abs(relativeY - y) > 0.5) {\n        line(relativeX, relativeY, x, y);\n\n        if (command === "L") {\n          i += 2;\n        }\n      }\n\n      relativeX = x;\n      relativeY = y; // "A" (arc)\n    } else if (command === "A") {\n      flag1 = a[i + 4];\n      flag2 = a[i + 5];\n      difX = a[i + 6];\n      difY = a[i + 7];\n      j = 7;\n\n      if (flag1.length > 1) {\n        // for cases when the flags are merged, like "a8 8 0 018 8" (the 0 and 1 flags are WITH the x value of 8, but it could also be "a8 8 0 01-8 8" so it may include x or not)\n        if (flag1.length < 3) {\n          difY = difX;\n          difX = flag2;\n          j--;\n        } else {\n          difY = flag2;\n          difX = flag1.substr(2);\n          j -= 2;\n        }\n\n        flag2 = flag1.charAt(1);\n        flag1 = flag1.charAt(0);\n      }\n\n      beziers = arcToSegment(relativeX, relativeY, +a[i + 1], +a[i + 2], +a[i + 3], +flag1, +flag2, (isRelative ? relativeX : 0) + difX * 1, (isRelative ? relativeY : 0) + difY * 1);\n      i += j;\n\n      if (beziers) {\n        for (j = 0; j < beziers.length; j++) {\n          segment.push(beziers[j]);\n        }\n      }\n\n      relativeX = segment[segment.length - 2];\n      relativeY = segment[segment.length - 1];\n    } else {\n      console.log(errorMessage);\n    }\n  }\n\n  i = segment.length;\n\n  if (i < 6) {\n    //in case there\'s odd SVG like a M0,0 command at the very end.\n    path.pop();\n    i = 0;\n  } else if (segment[0] === segment[i - 2] && segment[1] === segment[i - 1]) {\n    segment.closed = true;\n  }\n\n  path.totalPoints = points + i;\n  return path;\n} //populates the points array in alternating x/y values (like [x, y, x, y...] instead of individual point objects [{x, y}, {x, y}...] to conserve memory and stay in line with how we\'re handling segment arrays\n\nfunction bezierToPoints(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {\n  var x12 = (x1 + x2) / 2,\n      y12 = (y1 + y2) / 2,\n      x23 = (x2 + x3) / 2,\n      y23 = (y2 + y3) / 2,\n      x34 = (x3 + x4) / 2,\n      y34 = (y3 + y4) / 2,\n      x123 = (x12 + x23) / 2,\n      y123 = (y12 + y23) / 2,\n      x234 = (x23 + x34) / 2,\n      y234 = (y23 + y34) / 2,\n      x1234 = (x123 + x234) / 2,\n      y1234 = (y123 + y234) / 2,\n      dx = x4 - x1,\n      dy = y4 - y1,\n      d2 = _abs((x2 - x4) * dy - (y2 - y4) * dx),\n      d3 = _abs((x3 - x4) * dy - (y3 - y4) * dx),\n      length;\n\n  if (!points) {\n    points = [x1, y1, x4, y4];\n    index = 2;\n  }\n\n  points.splice(index || points.length - 2, 0, x1234, y1234);\n\n  if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {\n    length = points.length;\n    bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);\n    bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 2 + (points.length - length));\n  }\n\n  return points;\n}\n/*\nfunction getAngleBetweenPoints(x0, y0, x1, y1, x2, y2) { //angle between 3 points in radians\n\tvar dx1 = x1 - x0,\n\t\tdy1 = y1 - y0,\n\t\tdx2 = x2 - x1,\n\t\tdy2 = y2 - y1,\n\t\tdx3 = x2 - x0,\n\t\tdy3 = y2 - y0,\n\t\ta = dx1 * dx1 + dy1 * dy1,\n\t\tb = dx2 * dx2 + dy2 * dy2,\n\t\tc = dx3 * dx3 + dy3 * dy3;\n\treturn Math.acos( (a + b - c) / _sqrt(4 * a * b) );\n},\n*/\n//pointsToSegment() doesn\'t handle flat coordinates (where y is always 0) the way we need (the resulting control points are always right on top of the anchors), so this function basically makes the control points go directly up and down, varying in length based on the curviness (more curvy, further control points)\n\nfunction flatPointsToSegment(points, curviness) {\n  if (curviness === void 0) {\n    curviness = 1;\n  }\n\n  var x = points[0],\n      y = 0,\n      segment = [x, y],\n      i = 2;\n\n  for (; i < points.length; i += 2) {\n    segment.push(x, y, points[i], y = (points[i] - x) * curviness / 2, x = points[i], -y);\n  }\n\n  return segment;\n} //points is an array of x/y points, like [x, y, x, y, x, y]\n\nfunction pointsToSegment(points, curviness, cornerThreshold) {\n  //points = simplifyPoints(points, tolerance);\n  var l = points.length - 2,\n      x = +points[0],\n      y = +points[1],\n      nextX = +points[2],\n      nextY = +points[3],\n      segment = [x, y, x, y],\n      dx2 = nextX - x,\n      dy2 = nextY - y,\n      prevX,\n      prevY,\n      angle,\n      slope,\n      i,\n      dx1,\n      dx3,\n      dy1,\n      dy3,\n      d1,\n      d2,\n      a,\n      b,\n      c;\n\n  if (isNaN(cornerThreshold)) {\n    cornerThreshold = Math.PI / 10;\n  }\n\n  curviness = curviness || curviness === 0 ? +curviness : 1;\n\n  for (i = 2; i < l; i += 2) {\n    prevX = x;\n    prevY = y;\n    x = nextX;\n    y = nextY;\n    nextX = +points[i + 2];\n    nextY = +points[i + 3];\n    dx1 = dx2;\n    dy1 = dy2;\n    dx2 = nextX - x;\n    dy2 = nextY - y;\n    dx3 = nextX - prevX;\n    dy3 = nextY - prevY;\n    a = dx1 * dx1 + dy1 * dy1;\n    b = dx2 * dx2 + dy2 * dy2;\n    c = dx3 * dx3 + dy3 * dy3;\n    angle = Math.acos((a + b - c) / _sqrt(4 * a * b)); //angle between the 3 points\n\n    d2 = angle / Math.PI * curviness; //temporary precalculation for speed (reusing d2 variable)\n\n    d1 = _sqrt(a) * d2; //the tighter the angle, the shorter we make the handles in proportion.\n\n    d2 *= _sqrt(b);\n\n    if (x !== prevX || y !== prevY) {\n      if (angle > cornerThreshold) {\n        slope = _atan2(dy3, dx3);\n        segment.push(paths_round(x - _cos(slope) * d1), //first control point\n        paths_round(y - _sin(slope) * d1), paths_round(x), //anchor\n        paths_round(y), paths_round(x + _cos(slope) * d2), //second control point\n        paths_round(y + _sin(slope) * d2));\n      } else {\n        slope = _atan2(dy1, dx1);\n        segment.push(paths_round(x - _cos(slope) * d1), //first control point\n        paths_round(y - _sin(slope) * d1));\n        slope = _atan2(dy2, dx2);\n        segment.push(paths_round(x), //anchor\n        paths_round(y), paths_round(x + _cos(slope) * d2), //second control point\n        paths_round(y + _sin(slope) * d2));\n      }\n    }\n  }\n\n  segment.push(paths_round(nextX), paths_round(nextY), paths_round(nextX), paths_round(nextY));\n  return segment;\n} //returns the squared distance between an x/y coordinate and a segment between x1/y1 and x2/y2\n\nfunction pointToSegDist(x, y, x1, y1, x2, y2) {\n  var dx = x2 - x1,\n      dy = y2 - y1,\n      t;\n\n  if (dx || dy) {\n    t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x1 = x2;\n      y1 = y2;\n    } else if (t > 0) {\n      x1 += dx * t;\n      y1 += dy * t;\n    }\n  }\n\n  return Math.pow(x - x1, 2) + Math.pow(y - y1, 2);\n}\n\nfunction simplifyStep(points, first, last, tolerance, simplified) {\n  var maxSqDist = tolerance,\n      firstX = points[first],\n      firstY = points[first + 1],\n      lastX = points[last],\n      lastY = points[last + 1],\n      index,\n      i,\n      d;\n\n  for (i = first + 2; i < last; i += 2) {\n    d = pointToSegDist(points[i], points[i + 1], firstX, firstY, lastX, lastY);\n\n    if (d > maxSqDist) {\n      index = i;\n      maxSqDist = d;\n    }\n  }\n\n  if (maxSqDist > tolerance) {\n    if (index - first > 2) {\n      simplifyStep(points, first, index, tolerance, simplified);\n    }\n\n    simplified.push(points[index], points[index + 1]);\n\n    if (last - index > 2) {\n      simplifyStep(points, index, last, tolerance, simplified);\n    }\n  }\n} //points is an array of x/y values like [x, y, x, y, x, y]\n\n\nfunction simplifyPoints(points, tolerance) {\n  var prevX = parseFloat(points[0]),\n      prevY = parseFloat(points[1]),\n      temp = [prevX, prevY],\n      l = points.length - 2,\n      i,\n      x,\n      y,\n      dx,\n      dy,\n      result,\n      last;\n  tolerance = Math.pow(tolerance || 1, 2);\n\n  for (i = 2; i < l; i += 2) {\n    x = parseFloat(points[i]);\n    y = parseFloat(points[i + 1]);\n    dx = prevX - x;\n    dy = prevY - y;\n\n    if (dx * dx + dy * dy > tolerance) {\n      temp.push(x, y);\n      prevX = x;\n      prevY = y;\n    }\n  }\n\n  temp.push(parseFloat(points[l]), parseFloat(points[l + 1]));\n  last = temp.length - 2;\n  result = [temp[0], temp[1]];\n  simplifyStep(temp, 0, last, tolerance, result);\n  result.push(temp[last], temp[last + 1]);\n  return result;\n}\n\nfunction getClosestProgressOnBezier(iterations, px, py, start, end, slices, x0, y0, x1, y1, x2, y2, x3, y3) {\n  var inc = (end - start) / slices,\n      best = 0,\n      t = start,\n      x,\n      y,\n      d,\n      dx,\n      dy,\n      inv;\n  _bestDistance = _largeNum;\n\n  while (t <= end) {\n    inv = 1 - t;\n    x = inv * inv * inv * x0 + 3 * inv * inv * t * x1 + 3 * inv * t * t * x2 + t * t * t * x3;\n    y = inv * inv * inv * y0 + 3 * inv * inv * t * y1 + 3 * inv * t * t * y2 + t * t * t * y3;\n    dx = x - px;\n    dy = y - py;\n    d = dx * dx + dy * dy;\n\n    if (d < _bestDistance) {\n      _bestDistance = d;\n      best = t;\n    }\n\n    t += inc;\n  }\n\n  return iterations > 1 ? getClosestProgressOnBezier(iterations - 1, px, py, Math.max(best - inc, 0), Math.min(best + inc, 1), slices, x0, y0, x1, y1, x2, y2, x3, y3) : best;\n}\n\nfunction getClosestData(rawPath, x, y, slices) {\n  //returns an object with the closest j, i, and t (j is the segment index, i is the index of the point in that segment, and t is the time/progress along that bezier)\n  var closest = {\n    j: 0,\n    i: 0,\n    t: 0\n  },\n      bestDistance = _largeNum,\n      i,\n      j,\n      t,\n      segment;\n\n  for (j = 0; j < rawPath.length; j++) {\n    segment = rawPath[j];\n\n    for (i = 0; i < segment.length; i += 6) {\n      t = getClosestProgressOnBezier(1, x, y, 0, 1, slices || 20, segment[i], segment[i + 1], segment[i + 2], segment[i + 3], segment[i + 4], segment[i + 5], segment[i + 6], segment[i + 7]);\n\n      if (bestDistance > _bestDistance) {\n        bestDistance = _bestDistance;\n        closest.j = j;\n        closest.i = i;\n        closest.t = t;\n      }\n    }\n  }\n\n  return closest;\n} //subdivide a Segment closest to a specific x,y coordinate\n\nfunction subdivideSegmentNear(x, y, segment, slices, iterations) {\n  var l = segment.length,\n      bestDistance = _largeNum,\n      bestT = 0,\n      bestSegmentIndex = 0,\n      t,\n      i;\n  slices = slices || 20;\n  iterations = iterations || 3;\n\n  for (i = 0; i < l; i += 6) {\n    t = getClosestProgressOnBezier(1, x, y, 0, 1, slices, segment[i], segment[i + 1], segment[i + 2], segment[i + 3], segment[i + 4], segment[i + 5], segment[i + 6], segment[i + 7]);\n\n    if (bestDistance > _bestDistance) {\n      bestDistance = _bestDistance;\n      bestT = t;\n      bestSegmentIndex = i;\n    }\n  }\n\n  t = getClosestProgressOnBezier(iterations, x, y, bestT - 0.05, bestT + 0.05, slices, segment[bestSegmentIndex], segment[bestSegmentIndex + 1], segment[bestSegmentIndex + 2], segment[bestSegmentIndex + 3], segment[bestSegmentIndex + 4], segment[bestSegmentIndex + 5], segment[bestSegmentIndex + 6], segment[bestSegmentIndex + 7]);\n  subdivideSegment(segment, bestSegmentIndex, t);\n  return bestSegmentIndex + 6;\n}\n/*\nTakes any of the following and converts it to an all Cubic Bezier SVG data string:\n- A <path> data string like "M0,0 L2,4 v20,15 H100"\n- A RawPath, like [[x, y, x, y, x, y, x, y][[x, y, x, y, x, y, x, y]]\n- A Segment, like [x, y, x, y, x, y, x, y]\n\nNote: all numbers are rounded down to the closest 0.001 to minimize memory, maximize speed, and avoid odd numbers like 1e-13\n*/\n\nfunction rawPathToString(rawPath) {\n  if (paths_isNumber(rawPath[0])) {\n    //in case a segment is passed in instead\n    rawPath = [rawPath];\n  }\n\n  var result = "",\n      l = rawPath.length,\n      sl,\n      s,\n      i,\n      segment;\n\n  for (s = 0; s < l; s++) {\n    segment = rawPath[s];\n    result += "M" + paths_round(segment[0]) + "," + paths_round(segment[1]) + " C";\n    sl = segment.length;\n\n    for (i = 2; i < sl; i++) {\n      result += paths_round(segment[i++]) + "," + paths_round(segment[i++]) + " " + paths_round(segment[i++]) + "," + paths_round(segment[i++]) + " " + paths_round(segment[i++]) + "," + paths_round(segment[i]) + " ";\n    }\n\n    if (segment.closed) {\n      result += "z";\n    }\n  }\n\n  return result;\n}\n/*\n// takes a segment with coordinates [x, y, x, y, ...] and converts the control points into angles and lengths [x, y, angle, length, angle, length, x, y, angle, length, ...] so that it animates more cleanly and avoids odd breaks/kinks. For example, if you animate from 1 o\'clock to 6 o\'clock, it\'d just go directly/linearly rather than around. So the length would be very short in the middle of the tween.\nexport function cpCoordsToAngles(segment, copy) {\n\tvar result = copy ? segment.slice(0) : segment,\n\t\tx, y, i;\n\tfor (i = 0; i < segment.length; i+=6) {\n\t\tx = segment[i+2] - segment[i];\n\t\ty = segment[i+3] - segment[i+1];\n\t\tresult[i+2] = Math.atan2(y, x);\n\t\tresult[i+3] = Math.sqrt(x * x + y * y);\n\t\tx = segment[i+6] - segment[i+4];\n\t\ty = segment[i+7] - segment[i+5];\n\t\tresult[i+4] = Math.atan2(y, x);\n\t\tresult[i+5] = Math.sqrt(x * x + y * y);\n\t}\n\treturn result;\n}\n\n// takes a segment that was converted with cpCoordsToAngles() to have angles and lengths instead of coordinates for the control points, and converts it BACK into coordinates.\nexport function cpAnglesToCoords(segment, copy) {\n\tvar result = copy ? segment.slice(0) : segment,\n\t\tlength = segment.length,\n\t\trnd = 1000,\n\t\tangle, l, i, j;\n\tfor (i = 0; i < length; i+=6) {\n\t\tangle = segment[i+2];\n\t\tl = segment[i+3]; //length\n\t\tresult[i+2] = (((segment[i] + Math.cos(angle) * l) * rnd) | 0) / rnd;\n\t\tresult[i+3] = (((segment[i+1] + Math.sin(angle) * l) * rnd) | 0) / rnd;\n\t\tangle = segment[i+4];\n\t\tl = segment[i+5]; //length\n\t\tresult[i+4] = (((segment[i+6] - Math.cos(angle) * l) * rnd) | 0) / rnd;\n\t\tresult[i+5] = (((segment[i+7] - Math.sin(angle) * l) * rnd) | 0) / rnd;\n\t}\n\treturn result;\n}\n\n//adds an "isSmooth" array to each segment and populates it with a boolean value indicating whether or not it\'s smooth (the control points have basically the same slope). For any smooth control points, it converts the coordinates into angle (x, in radians) and length (y) and puts them into the same index value in a smoothData array.\nexport function populateSmoothData(rawPath) {\n\tlet j = rawPath.length,\n\t\tsmooth, segment, x, y, x2, y2, i, l, a, a2, isSmooth, smoothData;\n\twhile (--j > -1) {\n\t\tsegment = rawPath[j];\n\t\tisSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];\n\t\tsmoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];\n\t\tisSmooth.length = 4;\n\t\tl = segment.length - 2;\n\t\tfor (i = 6; i < l; i += 6) {\n\t\t\tx = segment[i] - segment[i - 2];\n\t\t\ty = segment[i + 1] - segment[i - 1];\n\t\t\tx2 = segment[i + 2] - segment[i];\n\t\t\ty2 = segment[i + 3] - segment[i + 1];\n\t\t\ta = _atan2(y, x);\n\t\t\ta2 = _atan2(y2, x2);\n\t\t\tsmooth = (Math.abs(a - a2) < 0.09);\n\t\t\tif (smooth) {\n\t\t\t\tsmoothData[i - 2] = a;\n\t\t\t\tsmoothData[i + 2] = a2;\n\t\t\t\tsmoothData[i - 1] = _sqrt(x * x + y * y);\n\t\t\t\tsmoothData[i + 3] = _sqrt(x2 * x2 + y2 * y2);\n\t\t\t}\n\t\t\tisSmooth.push(smooth, smooth, 0, 0, smooth, smooth);\n\t\t}\n\t\t//if the first and last points are identical, check to see if there\'s a smooth transition. We must handle this a bit differently due to their positions in the array.\n\t\tif (segment[l] === segment[0] && segment[l+1] === segment[1]) {\n\t\t\tx = segment[0] - segment[l-2];\n\t\t\ty = segment[1] - segment[l-1];\n\t\t\tx2 = segment[2] - segment[0];\n\t\t\ty2 = segment[3] - segment[1];\n\t\t\ta = _atan2(y, x);\n\t\t\ta2 = _atan2(y2, x2);\n\t\t\tif (Math.abs(a - a2) < 0.09) {\n\t\t\t\tsmoothData[l-2] = a;\n\t\t\t\tsmoothData[2] = a2;\n\t\t\t\tsmoothData[l-1] = _sqrt(x * x + y * y);\n\t\t\t\tsmoothData[3] = _sqrt(x2 * x2 + y2 * y2);\n\t\t\t\tisSmooth[l-2] = isSmooth[l-1] = true; //don\'t change indexes 2 and 3 because we\'ll trigger everything from the END, and this will optimize file size a bit.\n\t\t\t}\n\t\t}\n\t}\n\treturn rawPath;\n}\nexport function pointToScreen(svgElement, point) {\n\tif (arguments.length < 2) { //by default, take the first set of coordinates in the path as the point\n\t\tlet rawPath = getRawPath(svgElement);\n\t\tpoint = svgElement.ownerSVGElement.createSVGPoint();\n\t\tpoint.x = rawPath[0][0];\n\t\tpoint.y = rawPath[0][1];\n\t}\n\treturn point.matrixTransform(svgElement.getScreenCTM());\n}\n\n*/\n;// CONCATENATED MODULE: ./app/src/js/classes/morphSVGPlugin.js\nfunction morphSVGPlugin_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { morphSVGPlugin_typeof = function _typeof(obj) { return typeof obj; }; } else { morphSVGPlugin_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return morphSVGPlugin_typeof(obj); }\n\n/*!\n * MorphSVGPlugin 3.2.6\n * https://greensock.com\n *\n * @license Copyright 2008-2020, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\n\n\nvar morphSVGPlugin_gsap,\n    morphSVGPlugin_toArray,\n    _lastLinkedAnchor,\n    morphSVGPlugin_doc,\n    morphSVGPlugin_coreInitted,\n    PluginClass,\n    morphSVGPlugin_getGSAP = function _getGSAP() {\n  return morphSVGPlugin_gsap || typeof window !== "undefined" && (morphSVGPlugin_gsap = window.gsap) && morphSVGPlugin_gsap.registerPlugin && morphSVGPlugin_gsap;\n},\n    morphSVGPlugin_atan2 = Math.atan2,\n    morphSVGPlugin_cos = Math.cos,\n    morphSVGPlugin_sin = Math.sin,\n    morphSVGPlugin_sqrt = Math.sqrt,\n    _PI = Math.PI,\n    _2PI = _PI * 2,\n    _angleMin = _PI * 0.3,\n    _angleMax = _PI * 0.7,\n    morphSVGPlugin_bigNum = 1e20,\n    _numExp = /[-+=\\.]*\\d+[\\.e\\-\\+]*\\d*[e\\-\\+]*\\d*/gi,\n    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\nmorphSVGPlugin_selectorExp = /(^[#\\.][a-z]|[a-y][a-z])/gi,\n    _commands = /[achlmqstvz]/ig,\n    _log = function _log(message) {\n  return console && console.warn(message);\n},\n    morphSVGPlugin_bonusValidated = 1,\n    //<name>MorphSVGPlugin</name>\n_getAverageXY = function _getAverageXY(segment) {\n  var l = segment.length,\n      x = 0,\n      y = 0,\n      i;\n\n  for (i = 0; i < l; i++) {\n    x += segment[i++];\n    y += segment[i];\n  }\n\n  return [x / (l / 2), y / (l / 2)];\n},\n    _getSize = function _getSize(segment) {\n  //rough estimate of the bounding box (based solely on the anchors) of a single segment. sets "size", "centerX", and "centerY" properties on the bezier array itself, and returns the size (width * height)\n  var l = segment.length,\n      xMax = segment[0],\n      xMin = xMax,\n      yMax = segment[1],\n      yMin = yMax,\n      x,\n      y,\n      i;\n\n  for (i = 6; i < l; i += 6) {\n    x = segment[i];\n    y = segment[i + 1];\n\n    if (x > xMax) {\n      xMax = x;\n    } else if (x < xMin) {\n      xMin = x;\n    }\n\n    if (y > yMax) {\n      yMax = y;\n    } else if (y < yMin) {\n      yMin = y;\n    }\n  }\n\n  segment.centerX = (xMax + xMin) / 2;\n  segment.centerY = (yMax + yMin) / 2;\n  return segment.size = (xMax - xMin) * (yMax - yMin);\n},\n    _getTotalSize = function _getTotalSize(rawPath, samplesPerBezier) {\n  if (samplesPerBezier === void 0) {\n    samplesPerBezier = 3;\n  } //rough estimate of the bounding box of the entire list of Bezier segments (based solely on the anchors). sets "size", "centerX", and "centerY" properties on the bezier array itself, and returns the size (width * height)\n\n\n  var j = rawPath.length,\n      xMax = rawPath[0][0],\n      xMin = xMax,\n      yMax = rawPath[0][1],\n      yMin = yMax,\n      inc = 1 / samplesPerBezier,\n      l,\n      x,\n      y,\n      i,\n      segment,\n      k,\n      t,\n      inv,\n      x1,\n      y1,\n      x2,\n      x3,\n      x4,\n      y2,\n      y3,\n      y4;\n\n  while (--j > -1) {\n    segment = rawPath[j];\n    l = segment.length;\n\n    for (i = 6; i < l; i += 6) {\n      x1 = segment[i];\n      y1 = segment[i + 1];\n      x2 = segment[i + 2] - x1;\n      y2 = segment[i + 3] - y1;\n      x3 = segment[i + 4] - x1;\n      y3 = segment[i + 5] - y1;\n      x4 = segment[i + 6] - x1;\n      y4 = segment[i + 7] - y1;\n      k = samplesPerBezier;\n\n      while (--k > -1) {\n        t = inc * k;\n        inv = 1 - t;\n        x = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t + x1;\n        y = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t + y1;\n\n        if (x > xMax) {\n          xMax = x;\n        } else if (x < xMin) {\n          xMin = x;\n        }\n\n        if (y > yMax) {\n          yMax = y;\n        } else if (y < yMin) {\n          yMin = y;\n        }\n      }\n    }\n  }\n\n  rawPath.centerX = (xMax + xMin) / 2;\n  rawPath.centerY = (yMax + yMin) / 2;\n  rawPath.left = xMin;\n  rawPath.width = xMax - xMin;\n  rawPath.top = yMin;\n  rawPath.height = yMax - yMin;\n  return rawPath.size = (xMax - xMin) * (yMax - yMin);\n},\n    _sortByComplexity = function _sortByComplexity(a, b) {\n  return b.length - a.length;\n},\n    _sortBySize = function _sortBySize(a, b) {\n  var sizeA = a.size || _getSize(a),\n      sizeB = b.size || _getSize(b);\n\n  return Math.abs(sizeB - sizeA) < (sizeA + sizeB) / 20 ? b.centerX - a.centerX || b.centerY - a.centerY : sizeB - sizeA; //if the size is within 10% of each other, prioritize position from left to right, then top to bottom.\n},\n    _offsetSegment = function _offsetSegment(segment, shapeIndex) {\n  var a = segment.slice(0),\n      l = segment.length,\n      wrap = l - 2,\n      i,\n      index;\n  shapeIndex = shapeIndex | 0;\n\n  for (i = 0; i < l; i++) {\n    index = (i + shapeIndex) % wrap;\n    segment[i++] = a[index];\n    segment[i] = a[index + 1];\n  }\n},\n    _getTotalMovement = function _getTotalMovement(sb, eb, shapeIndex, offsetX, offsetY) {\n  var l = sb.length,\n      d = 0,\n      wrap = l - 2,\n      index,\n      i,\n      x,\n      y;\n  shapeIndex *= 6;\n\n  for (i = 0; i < l; i += 6) {\n    index = (i + shapeIndex) % wrap;\n    y = sb[index] - (eb[i] - offsetX);\n    x = sb[index + 1] - (eb[i + 1] - offsetY);\n    d += morphSVGPlugin_sqrt(x * x + y * y);\n  }\n\n  return d;\n},\n    _getClosestShapeIndex = function _getClosestShapeIndex(sb, eb, checkReverse) {\n  //finds the index in a closed cubic bezier array that\'s closest to the angle provided (angle measured from the center or average x/y).\n  var l = sb.length,\n      sCenter = _getAverageXY(sb),\n      //when comparing distances, adjust the coordinates as if the shapes are centered with each other.\n  eCenter = _getAverageXY(eb),\n      offsetX = eCenter[0] - sCenter[0],\n      offsetY = eCenter[1] - sCenter[1],\n      min = _getTotalMovement(sb, eb, 0, offsetX, offsetY),\n      minIndex = 0,\n      copy,\n      d,\n      i;\n\n  for (i = 6; i < l; i += 6) {\n    d = _getTotalMovement(sb, eb, i / 6, offsetX, offsetY);\n\n    if (d < min) {\n      min = d;\n      minIndex = i;\n    }\n  }\n\n  if (checkReverse) {\n    copy = sb.slice(0);\n    reverseSegment(copy);\n\n    for (i = 6; i < l; i += 6) {\n      d = _getTotalMovement(copy, eb, i / 6, offsetX, offsetY);\n\n      if (d < min) {\n        min = d;\n        minIndex = -i;\n      }\n    }\n  }\n\n  return minIndex / 6;\n},\n    _getClosestAnchor = function _getClosestAnchor(rawPath, x, y) {\n  //finds the x/y of the anchor that\'s closest to the provided x/y coordinate (returns an array, like [x, y]). The bezier should be the top-level type that contains an array for each segment.\n  var j = rawPath.length,\n      closestDistance = morphSVGPlugin_bigNum,\n      closestX = 0,\n      closestY = 0,\n      segment,\n      dx,\n      dy,\n      d,\n      i,\n      l;\n\n  while (--j > -1) {\n    segment = rawPath[j];\n    l = segment.length;\n\n    for (i = 0; i < l; i += 6) {\n      dx = segment[i] - x;\n      dy = segment[i + 1] - y;\n      d = morphSVGPlugin_sqrt(dx * dx + dy * dy);\n\n      if (d < closestDistance) {\n        closestDistance = d;\n        closestX = segment[i];\n        closestY = segment[i + 1];\n      }\n    }\n  }\n\n  return [closestX, closestY];\n},\n    _getClosestSegment = function _getClosestSegment(bezier, pool, startIndex, sortRatio, offsetX, offsetY) {\n  //matches the bezier to the closest one in a pool (array) of beziers, assuming they are in order of size and we shouldn\'t drop more than 20% of the size, otherwise prioritizing location (total distance to the center). Extracts the segment out of the pool array and returns it.\n  var l = pool.length,\n      index = 0,\n      minSize = Math.min(bezier.size || _getSize(bezier), pool[startIndex].size || _getSize(pool[startIndex])) * sortRatio,\n      //limit things based on a percentage of the size of either the bezier or the next element in the array, whichever is smaller.\n  min = morphSVGPlugin_bigNum,\n      cx = bezier.centerX + offsetX,\n      cy = bezier.centerY + offsetY,\n      size,\n      i,\n      dx,\n      dy,\n      d;\n\n  for (i = startIndex; i < l; i++) {\n    size = pool[i].size || _getSize(pool[i]);\n\n    if (size < minSize) {\n      break;\n    }\n\n    dx = pool[i].centerX - cx;\n    dy = pool[i].centerY - cy;\n    d = morphSVGPlugin_sqrt(dx * dx + dy * dy);\n\n    if (d < min) {\n      index = i;\n      min = d;\n    }\n  }\n\n  d = pool[index];\n  pool.splice(index, 1);\n  return d;\n},\n    _subdivideSegmentQty = function _subdivideSegmentQty(segment, quantity) {\n  var tally = 0,\n      max = 0.999999,\n      l = segment.length,\n      newPointsPerSegment = quantity / ((l - 2) / 6),\n      ax,\n      ay,\n      cp1x,\n      cp1y,\n      cp2x,\n      cp2y,\n      bx,\n      by,\n      x1,\n      y1,\n      x2,\n      y2,\n      i,\n      t;\n\n  for (i = 2; i < l; i += 6) {\n    tally += newPointsPerSegment;\n\n    while (tally > max) {\n      //compare with 0.99999 instead of 1 in order to prevent rounding errors\n      ax = segment[i - 2];\n      ay = segment[i - 1];\n      cp1x = segment[i];\n      cp1y = segment[i + 1];\n      cp2x = segment[i + 2];\n      cp2y = segment[i + 3];\n      bx = segment[i + 4];\n      by = segment[i + 5];\n      t = 1 / ((Math.floor(tally) || 1) + 1); //progress along the bezier (value between 0 and 1)\n\n      x1 = ax + (cp1x - ax) * t;\n      x2 = cp1x + (cp2x - cp1x) * t;\n      x1 += (x2 - x1) * t;\n      x2 += (cp2x + (bx - cp2x) * t - x2) * t;\n      y1 = ay + (cp1y - ay) * t;\n      y2 = cp1y + (cp2y - cp1y) * t;\n      y1 += (y2 - y1) * t;\n      y2 += (cp2y + (by - cp2y) * t - y2) * t;\n      segment.splice(i, 4, ax + (cp1x - ax) * t, //first control point\n      ay + (cp1y - ay) * t, x1, //second control point\n      y1, x1 + (x2 - x1) * t, //new fabricated anchor on line\n      y1 + (y2 - y1) * t, x2, //third control point\n      y2, cp2x + (bx - cp2x) * t, //fourth control point\n      cp2y + (by - cp2y) * t);\n      i += 6;\n      l += 6;\n      tally--;\n    }\n  }\n\n  return segment;\n},\n    _equalizeSegmentQuantity = function _equalizeSegmentQuantity(start, end, shapeIndex, map, fillSafe) {\n  //returns an array of shape indexes, 1 for each segment.\n  var dif = end.length - start.length,\n      longer = dif > 0 ? end : start,\n      shorter = dif > 0 ? start : end,\n      added = 0,\n      sortMethod = map === "complexity" ? _sortByComplexity : _sortBySize,\n      sortRatio = map === "position" ? 0 : typeof map === "number" ? map : 0.8,\n      i = shorter.length,\n      shapeIndices = morphSVGPlugin_typeof(shapeIndex) === "object" && shapeIndex.push ? shapeIndex.slice(0) : [shapeIndex],\n      reverse = shapeIndices[0] === "reverse" || shapeIndices[0] < 0,\n      log = shapeIndex === "log",\n      eb,\n      sb,\n      b,\n      x,\n      y,\n      offsetX,\n      offsetY;\n\n  if (!shorter[0]) {\n    return;\n  }\n\n  if (longer.length > 1) {\n    start.sort(sortMethod);\n    end.sort(sortMethod);\n    offsetX = longer.size || _getTotalSize(longer); //ensures centerX and centerY are defined (used below).\n\n    offsetX = shorter.size || _getTotalSize(shorter);\n    offsetX = longer.centerX - shorter.centerX;\n    offsetY = longer.centerY - shorter.centerY;\n\n    if (sortMethod === _sortBySize) {\n      for (i = 0; i < shorter.length; i++) {\n        longer.splice(i, 0, _getClosestSegment(shorter[i], longer, i, sortRatio, offsetX, offsetY));\n      }\n    }\n  }\n\n  if (dif) {\n    if (dif < 0) {\n      dif = -dif;\n    }\n\n    if (longer[0].length > shorter[0].length) {\n      //since we use shorter[0] as the one to map the origination point of any brand new fabricated segments, do any subdividing first so that there are more points to choose from (if necessary)\n      _subdivideSegmentQty(shorter[0], (longer[0].length - shorter[0].length) / 6 | 0);\n    }\n\n    i = shorter.length;\n\n    while (added < dif) {\n      x = longer[i].size || _getSize(longer[i]); //just to ensure centerX and centerY are calculated which we use on the next line.\n\n      b = _getClosestAnchor(shorter, longer[i].centerX, longer[i].centerY);\n      x = b[0];\n      y = b[1];\n      shorter[i++] = [x, y, x, y, x, y, x, y];\n      shorter.totalPoints += 8;\n      added++;\n    }\n  }\n\n  for (i = 0; i < start.length; i++) {\n    eb = end[i];\n    sb = start[i];\n    dif = eb.length - sb.length;\n\n    if (dif < 0) {\n      _subdivideSegmentQty(eb, -dif / 6 | 0);\n    } else if (dif > 0) {\n      _subdivideSegmentQty(sb, dif / 6 | 0);\n    }\n\n    if (reverse && fillSafe !== false && !sb.reversed) {\n      reverseSegment(sb);\n    }\n\n    shapeIndex = shapeIndices[i] || shapeIndices[i] === 0 ? shapeIndices[i] : "auto";\n\n    if (shapeIndex) {\n      //if start shape is closed, find the closest point to the start/end, and re-organize the bezier points accordingly so that the shape morphs in a more intuitive way.\n      if (sb.closed || Math.abs(sb[0] - sb[sb.length - 2]) < 0.5 && Math.abs(sb[1] - sb[sb.length - 1]) < 0.5) {\n        if (shapeIndex === "auto" || shapeIndex === "log") {\n          shapeIndices[i] = shapeIndex = _getClosestShapeIndex(sb, eb, !i || fillSafe === false);\n\n          if (shapeIndex < 0) {\n            reverse = true;\n            reverseSegment(sb);\n            shapeIndex = -shapeIndex;\n          }\n\n          _offsetSegment(sb, shapeIndex * 6);\n        } else if (shapeIndex !== "reverse") {\n          if (i && shapeIndex < 0) {\n            //only happens if an array is passed as shapeIndex and a negative value is defined for an index beyond 0. Very rare, but helpful sometimes.\n            reverseSegment(sb);\n          }\n\n          _offsetSegment(sb, (shapeIndex < 0 ? -shapeIndex : shapeIndex) * 6);\n        } //otherwise, if it\'s not a closed shape, consider reversing it if that would make the overall travel less\n\n      } else if (!reverse && (shapeIndex === "auto" && Math.abs(eb[0] - sb[0]) + Math.abs(eb[1] - sb[1]) + Math.abs(eb[eb.length - 2] - sb[sb.length - 2]) + Math.abs(eb[eb.length - 1] - sb[sb.length - 1]) > Math.abs(eb[0] - sb[sb.length - 2]) + Math.abs(eb[1] - sb[sb.length - 1]) + Math.abs(eb[eb.length - 2] - sb[0]) + Math.abs(eb[eb.length - 1] - sb[1]) || shapeIndex % 2)) {\n        reverseSegment(sb);\n        shapeIndices[i] = -1;\n        reverse = true;\n      } else if (shapeIndex === "auto") {\n        shapeIndices[i] = 0;\n      } else if (shapeIndex === "reverse") {\n        shapeIndices[i] = -1;\n      }\n\n      if (sb.closed !== eb.closed) {\n        //if one is closed and one isn\'t, don\'t close either one otherwise the tweening will look weird (but remember, the beginning and final states will honor the actual values, so this only affects the inbetween state)\n        sb.closed = eb.closed = false;\n      }\n    }\n  }\n\n  if (log) {\n    _log("shapeIndex:[" + shapeIndices.join(",") + "]");\n  }\n\n  start.shapeIndex = shapeIndices;\n  return shapeIndices;\n},\n    _pathFilter = function _pathFilter(a, shapeIndex, map, precompile, fillSafe) {\n  var start = stringToRawPath(a[0]),\n      end = stringToRawPath(a[1]);\n\n  if (!_equalizeSegmentQuantity(start, end, shapeIndex || shapeIndex === 0 ? shapeIndex : "auto", map, fillSafe)) {\n    return; //malformed path data or null target\n  }\n\n  a[0] = rawPathToString(start);\n  a[1] = rawPathToString(end);\n\n  if (precompile === "log" || precompile === true) {\n    _log(\'precompile:["\' + a[0] + \'","\' + a[1] + \'"]\');\n  }\n},\n    _offsetPoints = function _offsetPoints(text, offset) {\n  if (!offset) {\n    return text;\n  }\n\n  var a = text.match(_numExp) || [],\n      l = a.length,\n      s = "",\n      inc,\n      i,\n      j;\n\n  if (offset === "reverse") {\n    i = l - 1;\n    inc = -2;\n  } else {\n    i = ((parseInt(offset, 10) || 0) * 2 + 1 + l * 100) % l;\n    inc = 2;\n  }\n\n  for (j = 0; j < l; j += 2) {\n    s += a[i - 1] + "," + a[i] + " ";\n    i = (i + inc) % l;\n  }\n\n  return s;\n},\n    //adds a certain number of points while maintaining the polygon/polyline shape (so that the start/end values can have a matching quantity of points to animate). Returns the revised string.\n_equalizePointQuantity = function _equalizePointQuantity(a, quantity) {\n  var tally = 0,\n      x = parseFloat(a[0]),\n      y = parseFloat(a[1]),\n      s = x + "," + y + " ",\n      max = 0.999999,\n      newPointsPerSegment,\n      i,\n      l,\n      j,\n      factor,\n      nextX,\n      nextY;\n  l = a.length;\n  newPointsPerSegment = quantity * 0.5 / (l * 0.5 - 1);\n\n  for (i = 0; i < l - 2; i += 2) {\n    tally += newPointsPerSegment;\n    nextX = parseFloat(a[i + 2]);\n    nextY = parseFloat(a[i + 3]);\n\n    if (tally > max) {\n      //compare with 0.99999 instead of 1 in order to prevent rounding errors\n      factor = 1 / (Math.floor(tally) + 1);\n      j = 1;\n\n      while (tally > max) {\n        s += (x + (nextX - x) * factor * j).toFixed(2) + "," + (y + (nextY - y) * factor * j).toFixed(2) + " ";\n        tally--;\n        j++;\n      }\n    }\n\n    s += nextX + "," + nextY + " ";\n    x = nextX;\n    y = nextY;\n  }\n\n  return s;\n},\n    _pointsFilter = function _pointsFilter(a) {\n  var startNums = a[0].match(_numExp) || [],\n      endNums = a[1].match(_numExp) || [],\n      dif = endNums.length - startNums.length;\n\n  if (dif > 0) {\n    a[0] = _equalizePointQuantity(startNums, dif);\n  } else {\n    a[1] = _equalizePointQuantity(endNums, -dif);\n  }\n},\n    _buildPointsFilter = function _buildPointsFilter(shapeIndex) {\n  return !isNaN(shapeIndex) ? function (a) {\n    _pointsFilter(a);\n\n    a[1] = _offsetPoints(a[1], parseInt(shapeIndex, 10));\n  } : _pointsFilter;\n},\n    _parseShape = function _parseShape(shape, forcePath, target) {\n  var isString = typeof shape === "string",\n      e,\n      type;\n\n  if (!isString || morphSVGPlugin_selectorExp.test(shape) || (shape.match(_numExp) || []).length < 3) {\n    e = morphSVGPlugin_toArray(shape)[0];\n\n    if (e) {\n      type = (e.nodeName + "").toUpperCase();\n\n      if (forcePath && type !== "PATH") {\n        //if we were passed an element (or selector text for an element) that isn\'t a path, convert it.\n        e = paths_convertToPath(e, false);\n        type = "PATH";\n      }\n\n      shape = e.getAttribute(type === "PATH" ? "d" : "points") || "";\n\n      if (e === target) {\n        //if the shape matches the target element, the user wants to revert to the original which should have been stored in the data-original attribute\n        shape = e.getAttributeNS(null, "data-original") || shape;\n      }\n    } else {\n      _log("WARNING: invalid morph to: " + shape);\n\n      shape = false;\n    }\n  }\n\n  return shape;\n},\n    //adds an "isSmooth" array to each segment and populates it with a boolean value indicating whether or not it\'s smooth (the control points have basically the same slope). For any smooth control points, it converts the coordinates into angle (x, in radians) and length (y) and puts them into the same index value in a smoothData array.\n_populateSmoothData = function _populateSmoothData(rawPath, tolerance) {\n  var j = rawPath.length,\n      limit = 0.2 * (tolerance || 1),\n      smooth,\n      segment,\n      x,\n      y,\n      x2,\n      y2,\n      i,\n      l,\n      a,\n      a2,\n      isSmooth,\n      smoothData;\n\n  while (--j > -1) {\n    segment = rawPath[j];\n    isSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];\n    smoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];\n    isSmooth.length = 4;\n    l = segment.length - 2;\n\n    for (i = 6; i < l; i += 6) {\n      x = segment[i] - segment[i - 2];\n      y = segment[i + 1] - segment[i - 1];\n      x2 = segment[i + 2] - segment[i];\n      y2 = segment[i + 3] - segment[i + 1];\n      a = morphSVGPlugin_atan2(y, x);\n      a2 = morphSVGPlugin_atan2(y2, x2);\n      smooth = Math.abs(a - a2) < limit;\n\n      if (smooth) {\n        smoothData[i - 2] = a;\n        smoothData[i + 2] = a2;\n        smoothData[i - 1] = morphSVGPlugin_sqrt(x * x + y * y);\n        smoothData[i + 3] = morphSVGPlugin_sqrt(x2 * x2 + y2 * y2);\n      }\n\n      isSmooth.push(smooth, smooth, 0, 0, smooth, smooth);\n    } //if the first and last points are identical, check to see if there\'s a smooth transition. We must handle this a bit differently due to their positions in the array.\n\n\n    if (segment[l] === segment[0] && segment[l + 1] === segment[1]) {\n      x = segment[0] - segment[l - 2];\n      y = segment[1] - segment[l - 1];\n      x2 = segment[2] - segment[0];\n      y2 = segment[3] - segment[1];\n      a = morphSVGPlugin_atan2(y, x);\n      a2 = morphSVGPlugin_atan2(y2, x2);\n\n      if (Math.abs(a - a2) < limit) {\n        smoothData[l - 2] = a;\n        smoothData[2] = a2;\n        smoothData[l - 1] = morphSVGPlugin_sqrt(x * x + y * y);\n        smoothData[3] = morphSVGPlugin_sqrt(x2 * x2 + y2 * y2);\n        isSmooth[l - 2] = isSmooth[l - 1] = true; //don\'t change indexes 2 and 3 because we\'ll trigger everything from the END, and this will optimize file size a bit.\n      }\n    }\n  }\n\n  return rawPath;\n},\n    _parseOriginFactors = function _parseOriginFactors(v) {\n  var a = v.trim().split(" "),\n      x = ~v.indexOf("left") ? 0 : ~v.indexOf("right") ? 100 : isNaN(parseFloat(a[0])) ? 50 : parseFloat(a[0]),\n      y = ~v.indexOf("top") ? 0 : ~v.indexOf("bottom") ? 100 : isNaN(parseFloat(a[1])) ? 50 : parseFloat(a[1]);\n  return {\n    x: x / 100,\n    y: y / 100\n  };\n},\n    _shortAngle = function _shortAngle(dif) {\n  return dif !== dif % _PI ? dif + (dif < 0 ? _2PI : -_2PI) : dif;\n},\n    _morphMessage = "Use MorphSVGPlugin.convertToPath() to convert to a path before morphing.",\n    _tweenRotation = function _tweenRotation(start, end, i, linkedPT) {\n  var so = this._origin,\n      //starting origin\n  eo = this._eOrigin,\n      //ending origin\n  dx = start[i] - so.x,\n      dy = start[i + 1] - so.y,\n      d = morphSVGPlugin_sqrt(dx * dx + dy * dy),\n      //length from starting origin to starting point\n  sa = morphSVGPlugin_atan2(dy, dx),\n      angleDif,\n      _short;\n\n  dx = end[i] - eo.x;\n  dy = end[i + 1] - eo.y;\n  angleDif = morphSVGPlugin_atan2(dy, dx) - sa;\n  _short = _shortAngle(angleDif); //in the case of control points, we ALWAYS link them to their anchor so that they don\'t get torn apart and rotate the opposite direction. If it\'s not a control point, we look at the most recently linked point as long as they\'re within a certain rotational range of each other.\n\n  if (!linkedPT && _lastLinkedAnchor && Math.abs(_short + _lastLinkedAnchor.ca) < _angleMin) {\n    linkedPT = _lastLinkedAnchor;\n  }\n\n  return this._anchorPT = _lastLinkedAnchor = {\n    _next: this._anchorPT,\n    t: start,\n    sa: sa,\n    //starting angle\n    ca: linkedPT && _short * linkedPT.ca < 0 && Math.abs(_short) > _angleMax ? angleDif : _short,\n    //change in angle\n    sl: d,\n    //starting length\n    cl: morphSVGPlugin_sqrt(dx * dx + dy * dy) - d,\n    //change in length\n    i: i\n  };\n},\n    morphSVGPlugin_initCore = function _initCore(required) {\n  morphSVGPlugin_gsap = morphSVGPlugin_getGSAP();\n  PluginClass = PluginClass || morphSVGPlugin_gsap && morphSVGPlugin_gsap.plugins.morphSVG;\n\n  if (morphSVGPlugin_gsap && PluginClass) {\n    morphSVGPlugin_toArray = morphSVGPlugin_gsap.utils.toArray;\n    morphSVGPlugin_doc = document;\n    PluginClass.prototype._tweenRotation = _tweenRotation;\n    morphSVGPlugin_coreInitted = 1;\n  } else if (required) {\n    _log("Please gsap.registerPlugin(MorphSVGPlugin)");\n  }\n};\n\nvar MorphSVGPlugin = {\n  version: "3.2.6",\n  name: "morphSVG",\n  register: function register(core, Plugin) {\n    morphSVGPlugin_gsap = core;\n    PluginClass = Plugin;\n\n    morphSVGPlugin_initCore();\n  },\n  init: function init(target, value, tween, index, targets) {\n    var cs = target.nodeType ? window.getComputedStyle(target) : {},\n        fill = cs.fill + "",\n        fillSafe = !(fill === "none" || (fill.match(_numExp) || [])[3] === "0" || cs.fillRule === "evenodd"),\n        origins = (value.origin || "50 50").split(","),\n        type,\n        p,\n        pt,\n        shape,\n        isPoly,\n        shapeIndex,\n        map,\n        startSmooth,\n        endSmooth,\n        start,\n        end,\n        i,\n        j,\n        l,\n        startSeg,\n        endSeg,\n        precompiled,\n        sData,\n        eData,\n        originFactors,\n        useRotation,\n        offset;\n\n    if (!morphSVGPlugin_coreInitted) {\n      morphSVGPlugin_initCore(1);\n    }\n\n    type = (target.nodeName + "").toUpperCase();\n    isPoly = type === "POLYLINE" || type === "POLYGON";\n\n    if (type !== "PATH" && !isPoly && !value.prop) {\n      _log("Cannot morph a <" + type + "> element. " + _morphMessage);\n\n      return false;\n    }\n\n    p = type === "PATH" ? "d" : "points";\n\n    if (typeof value === "string" || value.getBBox || value[0]) {\n      value = {\n        shape: value\n      };\n    }\n\n    if (!value.prop && typeof target.setAttribute !== "function") {\n      return false;\n    }\n\n    shape = _parseShape(value.shape || value.d || value.points || "", p === "d", target);\n\n    if (isPoly && _commands.test(shape)) {\n      _log("A <" + type + "> cannot accept path data. " + _morphMessage);\n\n      return false;\n    }\n\n    shapeIndex = value.shapeIndex || value.shapeIndex === 0 ? value.shapeIndex : "auto";\n    map = value.map || MorphSVGPlugin.defaultMap;\n    this._prop = value.prop;\n    this._render = value.render || MorphSVGPlugin.defaultRender;\n    this._apply = "updateTarget" in value ? value.updateTarget : MorphSVGPlugin.defaultUpdateTarget;\n    this._rnd = Math.pow(10, isNaN(value.precision) ? 2 : +value.precision);\n    this._tween = tween;\n\n    if (shape) {\n      this._target = target;\n      precompiled = morphSVGPlugin_typeof(value.precompile) === "object";\n      start = this._prop ? target[this._prop] : target.getAttribute(p);\n\n      if (!this._prop && !target.getAttributeNS(null, "data-original")) {\n        target.setAttributeNS(null, "data-original", start); //record the original state in a data-original attribute so that we can revert to it later.\n      }\n\n      if (p === "d" || this._prop) {\n        start = stringToRawPath(precompiled ? value.precompile[0] : start);\n        end = stringToRawPath(precompiled ? value.precompile[1] : shape);\n\n        if (!precompiled && !_equalizeSegmentQuantity(start, end, shapeIndex, map, fillSafe)) {\n          return false; //malformed path data or null target\n        }\n\n        if (value.precompile === "log" || value.precompile === true) {\n          _log(\'precompile:["\' + rawPathToString(start) + \'","\' + rawPathToString(end) + \'"]\');\n        }\n\n        useRotation = (value.type || MorphSVGPlugin.defaultType) !== "linear";\n\n        if (useRotation) {\n          start = _populateSmoothData(start, value.smoothTolerance);\n          end = _populateSmoothData(end, value.smoothTolerance);\n\n          if (!start.size) {\n            _getTotalSize(start); //adds top/left/width/height values\n\n          }\n\n          if (!end.size) {\n            _getTotalSize(end);\n          }\n\n          originFactors = _parseOriginFactors(origins[0]);\n          this._origin = start.origin = {\n            x: start.left + originFactors.x * start.width,\n            y: start.top + originFactors.y * start.height\n          };\n\n          if (origins[1]) {\n            originFactors = _parseOriginFactors(origins[1]);\n          }\n\n          this._eOrigin = {\n            x: end.left + originFactors.x * end.width,\n            y: end.top + originFactors.y * end.height\n          };\n        }\n\n        this._rawPath = target._gsRawPath = start;\n        j = start.length;\n\n        while (--j > -1) {\n          startSeg = start[j];\n          endSeg = end[j];\n          startSmooth = startSeg.isSmooth || [];\n          endSmooth = endSeg.isSmooth || [];\n          l = startSeg.length;\n          _lastLinkedAnchor = 0; //reset; we use _lastLinkedAnchor in the _tweenRotation() method to help make sure that close points don\'t get ripped apart and rotate opposite directions. Typically we want to go the shortest direction, but if the previous anchor is going a different direction, we override this logic (within certain thresholds)\n\n          for (i = 0; i < l; i += 2) {\n            if (endSeg[i] !== startSeg[i] || endSeg[i + 1] !== startSeg[i + 1]) {\n              if (useRotation) {\n                if (startSmooth[i] && endSmooth[i]) {\n                  //if BOTH starting and ending values are smooth (meaning control points have basically the same slope), interpolate the rotation and length instead of the coordinates (this is what makes things smooth).\n                  sData = startSeg.smoothData;\n                  eData = endSeg.smoothData;\n                  offset = i + (i === l - 4 ? 7 - l : 5); //helps us accommodate wrapping (like if the end and start anchors are identical and the control points are smooth).\n\n                  this._controlPT = {\n                    _next: this._controlPT,\n                    i: i,\n                    j: j,\n                    l1s: sData[i + 1],\n                    l1c: eData[i + 1] - sData[i + 1],\n                    l2s: sData[offset],\n                    l2c: eData[offset] - sData[offset]\n                  };\n                  pt = this._tweenRotation(startSeg, endSeg, i + 2);\n\n                  this._tweenRotation(startSeg, endSeg, i, pt);\n\n                  this._tweenRotation(startSeg, endSeg, offset - 1, pt);\n\n                  i += 4;\n                } else {\n                  this._tweenRotation(startSeg, endSeg, i);\n                }\n              } else {\n                pt = this.add(startSeg, i, startSeg[i], endSeg[i]);\n                pt = this.add(startSeg, i + 1, startSeg[i + 1], endSeg[i + 1]) || pt;\n              }\n            }\n          }\n        }\n      } else {\n        pt = this.add(target, "setAttribute", target.getAttribute(p) + "", shape + "", index, targets, 0, _buildPointsFilter(shapeIndex), p);\n      }\n\n      if (useRotation) {\n        this.add(this._origin, "x", this._origin.x, this._eOrigin.x);\n        pt = this.add(this._origin, "y", this._origin.y, this._eOrigin.y);\n      }\n\n      if (pt) {\n        this._props.push("morphSVG");\n\n        pt.end = shape;\n        pt.endProp = p;\n      }\n    }\n\n    return morphSVGPlugin_bonusValidated;\n  },\n  render: function render(ratio, data) {\n    var rawPath = data._rawPath,\n        controlPT = data._controlPT,\n        anchorPT = data._anchorPT,\n        rnd = data._rnd,\n        target = data._target,\n        pt = data._pt,\n        s,\n        space,\n        easeInOut,\n        segment,\n        l,\n        angle,\n        i,\n        j,\n        x,\n        y,\n        sin,\n        cos,\n        offset;\n\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n\n    if (ratio === 1 && data._apply) {\n      pt = data._pt;\n\n      while (pt) {\n        if (pt.end) {\n          if (data._prop) {\n            target[data._prop] = pt.end;\n          } else {\n            target.setAttribute(pt.endProp, pt.end); //make sure the end value is exactly as specified (in case we had to add fabricated points during the tween)\n          }\n        }\n\n        pt = pt._next;\n      }\n    } else if (rawPath) {\n      //rotationally position the anchors\n      while (anchorPT) {\n        angle = anchorPT.sa + ratio * anchorPT.ca;\n        l = anchorPT.sl + ratio * anchorPT.cl; //length\n\n        anchorPT.t[anchorPT.i] = data._origin.x + morphSVGPlugin_cos(angle) * l;\n        anchorPT.t[anchorPT.i + 1] = data._origin.y + morphSVGPlugin_sin(angle) * l;\n        anchorPT = anchorPT._next;\n      } //smooth out the control points\n\n\n      easeInOut = ratio < 0.5 ? 2 * ratio * ratio : (4 - 2 * ratio) * ratio - 1;\n\n      while (controlPT) {\n        i = controlPT.i;\n        segment = rawPath[controlPT.j];\n        offset = i + (i === segment.length - 4 ? 7 - segment.length : 5); //accommodates wrapping around of smooth points, like if the start and end anchors are on top of each other and their handles are smooth.\n\n        angle = morphSVGPlugin_atan2(segment[offset] - segment[i + 1], segment[offset - 1] - segment[i]); //average the angles\n\n        sin = morphSVGPlugin_sin(angle);\n        cos = morphSVGPlugin_cos(angle);\n        x = segment[i + 2];\n        y = segment[i + 3];\n        l = controlPT.l1s + easeInOut * controlPT.l1c; //length\n\n        segment[i] = x - cos * l;\n        segment[i + 1] = y - sin * l;\n        l = controlPT.l2s + easeInOut * controlPT.l2c;\n        segment[offset - 1] = x + cos * l;\n        segment[offset] = y + sin * l;\n        controlPT = controlPT._next;\n      }\n\n      target._gsRawPath = rawPath;\n\n      if (data._apply) {\n        s = "";\n        space = " ";\n\n        for (j = 0; j < rawPath.length; j++) {\n          segment = rawPath[j];\n          l = segment.length;\n          s += "M" + (segment[0] * rnd | 0) / rnd + space + (segment[1] * rnd | 0) / rnd + " C";\n\n          for (i = 2; i < l; i++) {\n            //this is actually faster than just doing a join() on the array, possibly because the numbers have so many decimal places\n            s += (segment[i] * rnd | 0) / rnd + space;\n          }\n        }\n\n        if (data._prop) {\n          target[data._prop] = s;\n        } else {\n          target.setAttribute("d", s);\n        }\n      }\n    }\n\n    if (data._render && rawPath) {\n      data._render.call(data._tween, rawPath, target);\n    }\n  },\n  kill: function kill(property) {\n    this._pt = this._rawPath = 0;\n  },\n  getRawPath: getRawPath,\n  stringToRawPath: stringToRawPath,\n  rawPathToString: rawPathToString,\n  pathFilter: _pathFilter,\n  pointsFilter: _pointsFilter,\n  getTotalSize: _getTotalSize,\n  equalizeSegmentQuantity: _equalizeSegmentQuantity,\n  convertToPath: function convertToPath(targets, swap) {\n    return morphSVGPlugin_toArray(targets).map(function (target) {\n      return paths_convertToPath(target, swap !== false);\n    });\n  },\n  defaultType: "linear",\n  defaultUpdateTarget: true,\n  defaultMap: "size"\n};\nmorphSVGPlugin_getGSAP() && morphSVGPlugin_gsap.registerPlugin(MorphSVGPlugin);\n\n;// CONCATENATED MODULE: ./app/src/js/webgl/about1/About1Geometry.js\nfunction About1Geometry_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { About1Geometry_typeof = function _typeof(obj) { return typeof obj; }; } else { About1Geometry_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return About1Geometry_typeof(obj); }\n\nfunction About1Geometry_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction About1Geometry_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction About1Geometry_createClass(Constructor, protoProps, staticProps) { if (protoProps) About1Geometry_defineProperties(Constructor.prototype, protoProps); if (staticProps) About1Geometry_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction About1Geometry_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) About1Geometry_setPrototypeOf(subClass, superClass); }\n\nfunction About1Geometry_setPrototypeOf(o, p) { About1Geometry_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return About1Geometry_setPrototypeOf(o, p); }\n\nfunction About1Geometry_createSuper(Derived) { var hasNativeReflectConstruct = About1Geometry_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = About1Geometry_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = About1Geometry_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return About1Geometry_possibleConstructorReturn(this, result); }; }\n\nfunction About1Geometry_possibleConstructorReturn(self, call) { if (call && (About1Geometry_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return About1Geometry_assertThisInitialized(self); }\n\nfunction About1Geometry_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction About1Geometry_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction About1Geometry_getPrototypeOf(o) { About1Geometry_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return About1Geometry_getPrototypeOf(o); }\n\n//import * as THREE from "three"\n//import gsap from "gsap"\n//import {GLTFLoader, GLTLoader} from "three/examples/jsm/loaders/GLTFLoader"\nvar About1Geometry_EventEmitter = __webpack_require__(7187);\n\nvar About1Geometry_About1Geometry = /*#__PURE__*/function (_EventEmitter) {\n  About1Geometry_inherits(About1Geometry, _EventEmitter);\n\n  var _super = About1Geometry_createSuper(About1Geometry);\n\n  function About1Geometry(obj) {\n    var _this;\n\n    About1Geometry_classCallCheck(this, About1Geometry);\n\n    //console.log("(About1Geometry.CONSTRUCTORA): ", obj)\n    _this = _super.call(this); //--\n\n    _this.factor = obj.factor; //6\n\n    _this.incr_radio = obj.incr_radio; //25\n\n    _this.numOrbits = obj.numOrbits; //37\n\n    _this.array_triangular = obj.array_triangular;\n    _this.numDots = obj.numDots; //--\n\n    _this.attributes = {\n      a_posiciones: new Float32Array(_this.numDots * 3),\n      a_dot_num: new Float32Array(_this.numDots * 1),\n      a_orbital: new Float32Array(_this.numDots * 1),\n      a_pos_orbita: new Float32Array(_this.numDots * 1),\n      a_incr_anguloRad: new Float32Array(_this.numDots * 1),\n      a_anguloRad: new Float32Array(_this.numDots * 1),\n      a_radio: new Float32Array(_this.numDots * 1),\n      a_dir: new Float32Array(_this.numDots * 1),\n      a_incr: new Float32Array(_this.numDots * 1),\n      a_x: new Float32Array(_this.numDots * 1),\n      a_y: new Float32Array(_this.numDots * 1),\n      a_z: new Float32Array(_this.numDots * 1)\n    }; //--\n\n    for (var i = 0; i < _this.numDots; i++) {\n      var dot = _this._get_dot(i);\n\n      var i3 = i * 3;\n      _this.attributes.a_posiciones[i3] = dot.x;\n      _this.attributes.a_posiciones[i3 + 1] = dot.y;\n      _this.attributes.a_posiciones[i3 + 2] = dot.z; //--\n\n      _this.attributes.a_dot_num[i] = i;\n      _this.attributes.a_orbital[i] = dot.orbital;\n      _this.attributes.a_pos_orbita[i] = dot.pos_orbita;\n      _this.attributes.a_incr_anguloRad[i] = dot.incr_anguloRad;\n      _this.attributes.a_anguloRad[i] = dot.anguloRad;\n      _this.attributes.a_radio[i] = dot.radio;\n      _this.attributes.a_dir[i] = dot.dir;\n      _this.attributes.a_incr[i] = dot.incr;\n      _this.attributes.a_x[i] = dot.y;\n      _this.attributes.a_y[i] = dot.y;\n      _this.attributes.a_z[i] = dot.z;\n    } //--\n\n\n    _this.loaded = false; //console.log(this.attributes.a_dot_num)\n\n    return _this;\n  }\n\n  About1Geometry_createClass(About1Geometry, [{\n    key: "init",\n    value: function init() {\n      //console.log("(About1Geometry.init)!")\n      //--\n      //--\n      this.emit("onMeshLoaded", {\n        ref: this\n      });\n    } //------------------------------------------\n    // PRIVADAS\n\n  }, {\n    key: "_get_dot",\n    value: function _get_dot(num) {\n      // Devuelve un objeto con la informaciín de un punto de la geometria "orbital MIOTI"\n      var obj = {\n        num: num,\n        x: 0,\n        y: 0,\n        z: 0,\n        orbital: 0,\n        co_orbitantes: 0,\n        pos_orbita: 0,\n        incr_anguloRad: 0,\n        anguloRad: 0,\n        radio: 0\n      }; //--\n\n      for (var i = 0; i <= this.array_triangular.length; i++) {\n        var limSup = this.array_triangular[i]; //console.log("limSup: "+limSup)\n\n        if (num > limSup) {\n          // console.log("*")\n          obj.orbital = i + 1;\n          obj.co_orbitantes = (i + 1) * this.factor;\n          obj.pos_orbita = num - limSup - 1;\n          obj.incr_anguloRad = 2 * Math.PI / obj.co_orbitantes;\n\n          if (obj.orbital % 2 == 0) {\n            obj.dir = 1;\n            obj.incr = 0;\n            obj.anguloRad = obj.pos_orbita * obj.incr_anguloRad;\n          } else {\n            obj.dir = -1;\n            obj.incr = 1;\n            obj.anguloRad = obj.pos_orbita * obj.incr_anguloRad + obj.incr_anguloRad / 2;\n          }\n\n          obj.radio = obj.orbital * this.incr_radio; //--\n\n          obj.x = Math.cos(obj.anguloRad) * obj.radio;\n          obj.y = Math.sin(obj.anguloRad) * obj.radio;\n          obj.z = 0;\n        } //break\n\n      }\n\n      return obj;\n    }\n  }]);\n\n  return About1Geometry;\n}(About1Geometry_EventEmitter);\n\n/* harmony default export */ const about1_About1Geometry = (About1Geometry_About1Geometry);\n;// CONCATENATED MODULE: ./app/src/js/webgl/about1/About1DotPulse.js\nfunction About1DotPulse_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction About1DotPulse_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction About1DotPulse_createClass(Constructor, protoProps, staticProps) { if (protoProps) About1DotPulse_defineProperties(Constructor.prototype, protoProps); if (staticProps) About1DotPulse_defineProperties(Constructor, staticProps); return Constructor; }\n\n//import Datos from \'../Datos\';\nvar About1DotPulse = /*#__PURE__*/function () {\n  function About1DotPulse(obj) {\n    About1DotPulse_classCallCheck(this, About1DotPulse);\n\n    //console.log("(About1DotPulse.CONSTRUCTORA): ", obj)\n    this.pulses = obj.pulses;\n    this.dotGeom = obj.dotGeom;\n    this.pulsePos = obj.pulsePos;\n    this.pulseId = obj.pulseId;\n    this.dotPos = obj.dotPos; //--\n\n    this.lifeTime = 3;\n    this.startTime = this.dotGeom.clock.getElapsedTime();\n    this.endTime = this.startTime + this.lifeTime; //--\n    //this.settings = this.dotGeom.settings\n    //--\n    //this.settings["pulseNum_"+this.pulsePos] = Math.floor(Math.random()*1000)\n    //this.settings["pulseInitTime_"+this.pulsePos] = this.dotGeom.clock.getElapsedTime()\n    //this.settings["pulseProgress_"+this.pulsePos] = 0\n    //--\n  } //------------------\n  // PUBLICOS:\n\n\n  About1DotPulse_createClass(About1DotPulse, [{\n    key: "get_progress",\n    value: function get_progress(uTime) {\n      var t = uTime - this.startTime;\n      var timeProgress = (uTime - this.startTime) / this.lifeTime;\n      var progress;\n\n      if (timeProgress < 0.5) {\n        progress = this._easeInOutQuad(t, 0, 1, this.lifeTime / 2);\n      } else if (timeProgress >= 0.5 && timeProgress < 1) {\n        var t2 = t - this.lifeTime / 2;\n        progress = 1 - this._easeInOutQuad(t2, 0, 1, this.lifeTime / 2);\n      } else if (timeProgress >= 1) {\n        progress = 0;\n\n        this._initKill();\n      }\n\n      return progress;\n    } //------------------------\n    // PRIVADOS\n\n  }, {\n    key: "_initKill",\n    value: function _initKill() {\n      this.pulses.killPulse(this);\n    }\n  }, {\n    key: "_easeInOutQuad",\n    value: function _easeInOutQuad(t, b, c, d) {\n      //t is current time\n      //b is start value\n      //c is change in value\n      //d is duration\n      t /= d / 2;\n      if (t < 1) return c / 2 * t * t + b;\n      t--;\n      return -c / 2 * (t * (t - 2) - 1) + b;\n    }\n  }]);\n\n  return About1DotPulse;\n}();\n\n/* harmony default export */ const about1_About1DotPulse = (About1DotPulse);\n;// CONCATENATED MODULE: ./app/src/js/webgl/about1/About1Pulses.js\nfunction About1Pulses_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction About1Pulses_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction About1Pulses_createClass(Constructor, protoProps, staticProps) { if (protoProps) About1Pulses_defineProperties(Constructor.prototype, protoProps); if (staticProps) About1Pulses_defineProperties(Constructor, staticProps); return Constructor; }\n\n //import Datos from \'./Datos\';\n\n\n\nvar About1Pulses = /*#__PURE__*/function () {\n  function About1Pulses(obj) {\n    About1Pulses_classCallCheck(this, About1Pulses);\n\n    //console.log("(About1Pulses.CONSTRUCTORA)!: ", obj)\n    this.dotGeom = obj.dotGeom; //--\n\n    this.maxPulses = 10;\n    this.timeMin = 0;\n    this.timeMax = 0.7;\n    this.autoNum = 0;\n    this.arrayPulseSlots = [];\n\n    for (var i = 0; i < this.maxPulses; i++) {\n      this.arrayPulseSlots.push(null);\n    } //this.arrayPulseSlots = [null, null, null, null, null, null, null, null, null, null]\n\n\n    this.arrayDotPos = []; //--\n\n    this._init();\n  } //------------------------\n  // PUBLICOS\n\n\n  About1Pulses_createClass(About1Pulses, [{\n    key: "get_dotPos",\n    value: function get_dotPos(pulsePos) {\n      if (this.arrayPulseSlots[pulsePos]) {\n        return this.arrayPulseSlots[pulsePos].dotPos;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: "get_progress",\n    value: function get_progress(pulsePos, uTime) {\n      if (this.arrayPulseSlots[pulsePos]) {\n        return this.arrayPulseSlots[pulsePos].get_progress(uTime);\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: "killPulse",\n    value: function killPulse(pulse) {\n      var _this = this;\n\n      //console.log("(About1Pulses.killPulse): "+pulse.pulseId)\n      var posArray = this.arrayDotPos.indexOf(pulse.dotPos);\n      this.arrayDotPos.splice(posArray, 1);\n      this.arrayPulseSlots[pulse.pulsePos] = null; //--\n\n      node_modules_gsap/* default.delayedCall */.ZP.delayedCall(this._get_randomDelay(), function () {\n        _this._eval_createPulse();\n      });\n    } //------------------------\n    // PRIVADOS\n\n  }, {\n    key: "_init",\n    value: function _init() {\n      var _this2 = this;\n\n      for (var i = 0; i < this.maxPulses; i++) {\n        node_modules_gsap/* default.delayedCall */.ZP.delayedCall(this._get_randomDelay(), function () {\n          _this2._eval_createPulse();\n        });\n      }\n    }\n  }, {\n    key: "_eval_createPulse",\n    value: function _eval_createPulse() {\n      var pulsePos = this._get_pulsePos(); //console.log("pulsePos: "+pulsePos)\n\n\n      if (pulsePos != null) {\n        this._createPulse(pulsePos);\n      }\n    }\n  }, {\n    key: "_createPulse",\n    value: function _createPulse(pulsePos) {\n      //console.log("(About1Pulses._createPulse): ", this.arrayDotPos)\n      var pulseId = "pulse_" + this.autoNum;\n\n      var dotPos = this._get_dotPos();\n\n      this.arrayDotPos.push(dotPos);\n      this.autoNum++;\n      var pulse = new about1_About1DotPulse({\n        pulses: this,\n        dotGeom: this.dotGeom,\n        pulsePos: pulsePos,\n        pulseId: pulseId,\n        dotPos: dotPos\n      });\n      this.arrayPulseSlots[pulsePos] = pulse;\n    } //------\n\n  }, {\n    key: "_get_pulsePos",\n    value: function _get_pulsePos() {\n      // Busca un slot libre y devuelve su posición.\n      // Si no hay slot libres devuelve null\n      for (var i = 0; i < this.arrayPulseSlots.length; i++) {\n        if (this.arrayPulseSlots[i] == null) {\n          return i;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: "_get_dotPos",\n    value: function _get_dotPos() {\n      // Escoje un punto al azar y comprueba que no está activo en otro pulse y lo devuelve.\n      // Y el punto escogido si está activo lanza de nuevo los dados.\n      for (var i = 0; i < 9999; i++) {\n        var dotPos = Math.floor(Math.random() * 3000);\n\n        if (this.arrayDotPos.indexOf(dotPos) == -1) {\n          return dotPos;\n        }\n      }\n    }\n  }, {\n    key: "_get_randomDelay",\n    value: function _get_randomDelay() {\n      var rndRange = this.timeMax - this.timeMin;\n      return this.timeMin + Math.random() * rndRange;\n    }\n  }]);\n\n  return About1Pulses;\n}();\n\n/* harmony default export */ const about1_About1Pulses = (About1Pulses);\n;// CONCATENATED MODULE: ./app/src/js/webgl/about1/shaders/aboutDots_vertex.glsl\n/* harmony default export */ const aboutDots_vertex = ("#define GLSLIFY 1\\nattribute vec3 a_randomness;\\nattribute vec3 a_geo1_position;\\nattribute float a_geo1_dot_num;\\nattribute float a_geo1_orbital;\\nattribute float a_geo1_pos_orbita;\\nattribute float a_geo1_incr_anguloRad;\\nattribute float a_geo1_anguloRad;\\nattribute float a_geo1_incr;\\nattribute float a_geo1_dir;\\nattribute float a_geo1_radio;\\n\\nattribute vec3 a_geo2_position;\\nattribute vec3 a_geo3_position;\\n\\nuniform float uTime;\\nuniform float uCamaraDistance;\\nuniform float uScrollSpeed;\\nuniform float uScale;\\nuniform float uResponsiveScale;\\nuniform float uScrollDelta;\\nuniform float uScrollProgress;\\nuniform float uMorphingProgress;\\nuniform float uIntroProgress;\\n\\nuniform float uRotationInner;\\nuniform float uRotationOutter;\\n\\nuniform float uPulseNum_0;\\nuniform float uPulseProgress_0;\\nuniform float uPulseNum_1;\\nuniform float uPulseProgress_1;\\nuniform float uPulseNum_2;\\nuniform float uPulseProgress_2;\\nuniform float uPulseNum_3;\\nuniform float uPulseProgress_3;\\nuniform float uPulseNum_4;\\nuniform float uPulseProgress_4;\\nuniform float uPulseNum_5;\\nuniform float uPulseProgress_5;\\nuniform float uPulseNum_6;\\nuniform float uPulseProgress_6;\\nuniform float uPulseNum_7;\\nuniform float uPulseProgress_7;\\nuniform float uPulseNum_8;\\nuniform float uPulseProgress_8;\\nuniform float uPulseNum_9;\\nuniform float uPulseProgress_9;\\n\\nuniform float uProgress0;\\nuniform float uProgress0b;\\n\\nuniform float uProgress1;\\nuniform float uProgress2;\\nuniform float uProgress3;\\nuniform float uProgress4;\\nuniform float uProgress4b;\\nuniform float uProgress5;\\nuniform float uProgress6;\\nuniform float uProgress6b;\\n\\n// varying vec3 vPosition;\\n//varying vec2 vUv;\\nvarying vec3 v_randomness;\\nvarying float v_colorStrength;\\n\\nvarying float v_activePulse;\\nvarying float v_activePulseProgress;\\nvarying float v_test;\\n\\n//\\tClassic Perlin 3D Noise \\n//\\tby Stefan Gustavson\\n//\\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\\n\\nfloat cnoise(vec3 P){\\n  vec3 Pi0 = floor(P); // Integer part for indexing\\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\\n  Pi0 = mod(Pi0, 289.0);\\n  Pi1 = mod(Pi1, 289.0);\\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n  vec4 iz0 = Pi0.zzzz;\\n  vec4 iz1 = Pi1.zzzz;\\n\\n  vec4 ixy = permute(permute(ix) + iy);\\n  vec4 ixy0 = permute(ixy + iz0);\\n  vec4 ixy1 = permute(ixy + iz1);\\n\\n  vec4 gx0 = ixy0 / 7.0;\\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\\n  gx0 = fract(gx0);\\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n  vec4 sz0 = step(gz0, vec4(0.0));\\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n\\n  vec4 gx1 = ixy1 / 7.0;\\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\\n  gx1 = fract(gx1);\\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n  vec4 sz1 = step(gz1, vec4(0.0));\\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n\\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\n\\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n  g000 *= norm0.x;\\n  g010 *= norm0.y;\\n  g100 *= norm0.z;\\n  g110 *= norm0.w;\\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n  g001 *= norm1.x;\\n  g011 *= norm1.y;\\n  g101 *= norm1.z;\\n  g111 *= norm1.w;\\n\\n  float n000 = dot(g000, Pf0);\\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n  float n111 = dot(g111, Pf1);\\n\\n  vec3 fade_xyz = fade(Pf0);\\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \\n  return 2.2 * n_xyz;\\n}\\n\\nvec3 get_pos1(float anguloRad){\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(1.*a_geo1_dir*0.2);\\n    float x = cos(anguloRad)*a_geo1_radio;\\n    float y = sin(anguloRad)*a_geo1_radio;\\n    float z = 0.0;\\n    vec3 newPos = vec3(x, y, z);\\n    return newPos;\\n}\\n\\nvec3 get_posScrollSpeed(vec3 pos){\\n    float factor = mix(1.0, 2.0, uScrollSpeed);\\n    pos = pos*factor;\\n    return pos;\\n}\\n\\nfloat get_escalaNoise(float x, float y, float amplitudMapa, float progress){\\n    float valor = cnoise(vec3(x/amplitudMapa, y/amplitudMapa, progress));\\n    valor = 0.5+(valor/2.);\\n    valor *=2.;\\n    return valor;\\n}\\n\\nfloat get_escalaOndaRadial(float orbital, float progress){\\n    float frecuencia = 0.5; // Valores bajos ondas mas largas, valores altos ondas mas cortas\\n    float seno = (sin((progress+orbital)*frecuencia)+1.)/2.;\\n\\n    float valor = 0.5+(seno*0.5);\\n\\n    return valor;\\n}\\n\\nfloat get_escalaEdge(float orbital){\\n    float value = 1.;\\n    float orbitalMax = 37.;\\n    float fadeLimit = 22.;\\n    float fadeScale = 1.;\\n    float rango = orbitalMax -fadeLimit;\\n    if(orbital >= fadeLimit){\\n        float orbitalRel = orbital -fadeLimit;\\n        float ratio = orbitalRel/rango;\\n        fadeScale = fadeScale-ratio;\\n    }\\n    return fadeScale;\\n}\\n\\nvec3 randomizePosition(vec3 oldPos, vec3 randomness, float time, float amplitude, float amount, float speed){\\n    time = time*speed;\\n    vec3 newPos = oldPos;\\n    newPos.x += sin(time * randomness.x) * (amplitude*amount);\\n    newPos.y += cos(time * randomness.y) * (amplitude*amount);\\n    newPos.z += cos(time * randomness.z) * (amplitude*amount);\\n    return newPos;\\n}\\n\\nfloat quinticOut(float t) {\\n  return (pow(t - 1.0, 5.0));\\n}\\n\\nfloat quadraticOut(float t) {\\n  return -t * (t - 2.0);\\n}\\n\\nfloat quarticOut(float t) {\\n  return pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\\n}\\n\\nvoid main() {\\n\\n    // float time = uTime * 4.;    \\n\\n    //vec3 pos = mix(position, a_geo1_position, uProgress);\\n    // vec3 pos = a_geo2_position;\\n    //vec3 pos = position;\\n    //vec3 pos1 = get_pos1();\\n    //pos1 = pos1*(sin((-uTime+a_geo1_orbital)*0.5)+2.)*0.1;\\n\\n    //float senoFx = sin((-uTime+a_geo1_orbital))*0.5*0.5;\\n    //float escalaFx = mix(0.98, 1.02, senoFx);\\n    //pos1 = pos1*escalaFx;\\n    //pos1 = get_posScrollSpeed(pos1);\\n\\n    //vec3 endPos = mix(a_geo2_position, a_geo3_position, 0.);\\n    //vec3 endPos = a_geo2_position;\\n    //vec3 pos = mix(pos1, a_geo2_position, uProgress1);\\n    //pos = randomizePosition(pos, a_randomness, uTime, 5.0, uProgress1, 5.);\\n    // pos.x += sin(time * a_randomness.x) *0.02;\\n    // pos.y += cos(time * a_randomness.y) *0.02;\\n    // pos.z += cos(time * a_randomness.z) *0.02;\\n    \\n    // pos *= uScale;\\n    // vPosition = pos;\\n\\n    \\n\\n    //----------------------------------------------------------\\n    // PULSOS:\\n    v_activePulseProgress = 0.0;\\n    float resta;\\n    float factor;\\n    resta = abs(a_geo1_dot_num - uPulseNum_0); // Devuelve valores positivos donde en el caso de coincidir el float será < 0.5 y sino será >0.5\\n    factor = 1.0-(step(0.5, resta)); // Creamos un valor para <0.5 ACTIVO sea 1. y >0.5 DESACTIVO sea 0\\n    v_activePulse += 1.0*factor;\\n    v_activePulseProgress += uPulseProgress_0*factor;\\n    //--\\n    //--\\n    resta = abs(a_geo1_dot_num - uPulseNum_1); // Devuelve valores positivos donde en el caso de coincidir el float será < 0.5 y sino será >0.5\\n    factor = 1.0-(step(0.5, resta)); // Creamos un valor para <0.5 ACTIVO sea 1. y >0.5 DESACTIVO sea 0\\n    v_activePulse += 1.0*factor;\\n    v_activePulseProgress += uPulseProgress_1*factor;\\n    //--\\n    resta = abs(a_geo1_dot_num - uPulseNum_2); // Devuelve valores positivos donde en el caso de coincidir el float será < 0.5 y sino será >0.5\\n    factor = 1.0-(step(0.5, resta)); // Creamos un valor para <0.5 ACTIVO sea 1. y >0.5 DESACTIVO sea 0\\n    v_activePulse += 1.0*factor;\\n    v_activePulseProgress += uPulseProgress_2*factor;\\n    //--\\n    resta = abs(a_geo1_dot_num - uPulseNum_3); // Devuelve valores positivos donde en el caso de coincidir el float será < 0.5 y sino será >0.5\\n    factor = 1.0-(step(0.5, resta)); // Creamos un valor para <0.5 ACTIVO sea 1. y >0.5 DESACTIVO sea 0\\n    v_activePulse += 1.0*factor;\\n    v_activePulseProgress += uPulseProgress_3*factor;\\n    //--\\n    resta = abs(a_geo1_dot_num - uPulseNum_4); // Devuelve valores positivos donde en el caso de coincidir el float será < 0.5 y sino será >0.5\\n    factor = 1.0-(step(0.5, resta)); // Creamos un valor para <0.5 ACTIVO sea 1. y >0.5 DESACTIVO sea 0\\n    v_activePulse += 1.0*factor;\\n    v_activePulseProgress += uPulseProgress_4*factor;\\n    //--\\n    resta = abs(a_geo1_dot_num - uPulseNum_5); // Devuelve valores positivos donde en el caso de coincidir el float será < 0.5 y sino será >0.5\\n    factor = 1.0-(step(0.5, resta)); // Creamos un valor para <0.5 ACTIVO sea 1. y >0.5 DESACTIVO sea 0\\n    v_activePulse += 1.0*factor;\\n    v_activePulseProgress += uPulseProgress_5*factor;\\n    //--\\n    resta = abs(a_geo1_dot_num - uPulseNum_6); // Devuelve valores positivos donde en el caso de coincidir el float será < 0.5 y sino será >0.5\\n    factor = 1.0-(step(0.5, resta)); // Creamos un valor para <0.5 ACTIVO sea 1. y >0.5 DESACTIVO sea 0\\n    v_activePulse += 1.0*factor;\\n    v_activePulseProgress += uPulseProgress_6*factor;\\n    //--\\n    resta = abs(a_geo1_dot_num - uPulseNum_7); // Devuelve valores positivos donde en el caso de coincidir el float será < 0.5 y sino será >0.5\\n    factor = 1.0-(step(0.5, resta)); // Creamos un valor para <0.5 ACTIVO sea 1. y >0.5 DESACTIVO sea 0\\n    v_activePulse += 1.0*factor;\\n    v_activePulseProgress += uPulseProgress_7*factor;\\n    //--\\n    resta = abs(a_geo1_dot_num - uPulseNum_8); // Devuelve valores positivos donde en el caso de coincidir el float será < 0.5 y sino será >0.5\\n    factor = 1.0-(step(0.5, resta)); // Creamos un valor para <0.5 ACTIVO sea 1. y >0.5 DESACTIVO sea 0\\n    v_activePulse += 1.0*factor;\\n    v_activePulseProgress += uPulseProgress_8*factor;\\n    //--\\n    resta = abs(a_geo1_dot_num - uPulseNum_9); // Devuelve valores positivos donde en el caso de coincidir el float será < 0.5 y sino será >0.5\\n    factor = 1.0-(step(0.5, resta)); // Creamos un valor para <0.5 ACTIVO sea 1. y >0.5 DESACTIVO sea 0\\n    v_activePulse += 1.0*factor;\\n    v_activePulseProgress += uPulseProgress_9*factor;\\n    // PULSOS:\\n    //----------------------------------------------------------\\n\\n    //----------------------------------------------------------\\n    // POSITION:\\n    float rotation = mix(uRotationInner, uRotationOutter, ((a_geo1_orbital)*1.)/37.);\\n    float anguloRad_time = (a_geo1_anguloRad+rotation);\\n    // Geometries present:\\n    //float anguloRad = a_geo1_pos_orbita*a_geo1_incr_anguloRad+((a_geo1_incr_anguloRad/2.)*a_geo1_incr)+(uScrollProgress*a_geo1_dir*2.2);\\n    vec3 POSITION_1 = get_pos1(anguloRad_time);\\n    //vec3 POSITION_1 = position;\\n    vec3 POSITION_2 = a_geo2_position;\\n    POSITION_2 = randomizePosition(POSITION_2, a_randomness, uTime, 5.0, uMorphingProgress, 5.);\\n    // Z modifications:\\n    \\n    // Ondas de seno:\\n    float senoFx = sin((-uTime+a_geo1_orbital))*0.5*0.5;\\n    float escalaFx = mix(0.98, 1.02, senoFx);\\n    //POSITION_1 *= escalaFx;\\n    // Morphing:\\n    float clamped_morpingProgress = clamp(0., 0.95, uMorphingProgress);\\n    POSITION_1 = mix(POSITION_1, POSITION_2, clamped_morpingProgress);\\n    // Randomized position while in POSITION_2\\n    POSITION_1 = randomizePosition(POSITION_1, a_randomness*2., uTime, 5.0, uMorphingProgress, 2.5);\\n    // Escala por scroll delta:\\n    //POSITION_1 *= 1.+(uScrollDelta);\\n    // Escalado incial:\\n    //POSITION_1 *= mix(5., 1., quinticOut(uIntroProgress));\\n    //POSITION_1 *= mix(5., 1., quadraticOut(uIntroProgress));\\n    float clamped_uIntroProgress;\\n    // clamped_uIntroProgress = uIntroProgress;\\n    clamped_uIntroProgress = clamp(uIntroProgress, 0., 1.);\\n    //POSITION_1 *= mix(10., 1., quarticOut(clamped_uIntroProgress));\\n    POSITION_1 *= mix(10., 1., uIntroProgress);\\n    // Responsive Scale:\\n    POSITION_1 *= uResponsiveScale;\\n    //\\n    POSITION_1 = mix(POSITION_1, POSITION_2, uMorphingProgress);\\n    //----------------------------------------------------------\\n\\n    //----------------------------------------------------------\\n    // SIZE:\\n    float SIZE_1 = 8.;\\n    // Los puntos son mas pequeños en los orbitales de la periferia\\n    float esclaEdege = get_escalaEdge(a_geo1_orbital); \\n    float rango = 1.-esclaEdege;\\n    SIZE_1 *= (esclaEdege + (rango*uProgress1));\\n    // Los puntos se escalan en base a un mapa de ruido\\n    SIZE_1 *= mix(1., get_escalaNoise(POSITION_1.x, POSITION_1.y, 500., uProgress0), uProgress0b);\\n    // Los puntos se escalan en base a ondas concentricas de seno:\\n    SIZE_1 *= mix(1., get_escalaOndaRadial(a_geo1_orbital, -uTime*10.), uProgress4b);\\n    // Los puntos se escalan por pulson random:\\n    SIZE_1 *= mix(1., 1.5, v_activePulseProgress);\\n    // Los puntos se escalan junto con la geometria con el scrolldelta\\n    SIZE_1 *= 1.+(uScrollDelta);\\n\\n    float SIZE_2 = 5.; \\n    // \\n    float zDepthNorm = (POSITION_2.z+600.)/(600.*2.); // de -600 a 600 de un valor normalizado (sin clamp, es decir que puede ser <0 y >1) de la posicion z\\n    float zDepthAlpha = mix(0.2, 0.9, zDepthNorm);\\n    float zDepthScale = mix(0.8, 2.5, zDepthNorm);\\n    float randomSize = SIZE_2 *0.5+(a_randomness.x*0.9);\\n    randomSize *= zDepthScale;\\n    SIZE_2 = mix(SIZE_2, randomSize, uMorphingProgress);\\n    \\n    \\n    float SIZE = mix(SIZE_1, SIZE_2, uMorphingProgress);\\n    // Los puntos se escalan si se redimensona el lienzo\\n    SIZE *= uResponsiveScale;\\n    \\n    \\n    //----------------------------------------------------------\\n\\n    //----------------------------------------------------------\\n    // VERTEX\\n    vec4 mvPosition = modelViewMatrix * vec4( POSITION_1, 1.0 );\\n    gl_Position = projectionMatrix * mvPosition;\\n    gl_PointSize = SIZE*(uCamaraDistance/-mvPosition.z);\\n    //----------------------------------------------------------\\n\\n    \\n\\n    //----------------------------------------------------------\\n    // VARYINGS:\\n    v_randomness = a_randomness;\\n    v_colorStrength = get_escalaNoise(POSITION_1.x, POSITION_1.y, 200., sin(uTime));\\n    v_colorStrength = mix(1., v_colorStrength, uMorphingProgress);\\n\\n}");\n;// CONCATENATED MODULE: ./app/src/js/webgl/about1/shaders/aboutDots_fragment.glsl\n/* harmony default export */ const aboutDots_fragment = ("#define GLSLIFY 1\\n// varying vec3 vPosition;\\n// varying vec2 vUv;\\n\\nvarying vec3 v_randomness;\\nvarying float v_colorStrength;\\n\\nuniform vec3 uColor1;\\nuniform vec3 uColor2;\\nuniform vec3 uColor3;\\n\\nuniform float uProgress1;\\nuniform float uProgress2;\\nuniform float uProgress3;\\nuniform float uIntroProgress;\\n\\nvarying float v_activePulse;\\nvarying float v_activePulseProgress; \\nvarying float v_test;\\n\\nfloat quarticOut(float t) {\\n  return pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\\n}\\n\\nfloat circulizar(float radio){\\n    // radio es un valor entre 0 y 1. 0 es 0 de radio y 1 es el maximo del radio dentro de\\n    radio = 1.0-(0.5*radio);\\n    float result = distance(gl_PointCoord, vec2(0.5, 0.5));\\n    result = 1. -result;\\n    result = pow(result, 1.);\\n    result = step(radio, result);\\n    return result;\\n}\\n\\nvoid main() {\\n\\n    float randomnessCir = v_randomness.x*uProgress1;\\n    randomnessCir = mix(1., randomnessCir, uProgress1);\\n    //float alpha = circulizar(1.0*randomnessCir);\\n    float alpha = circulizar(1.0);\\n\\n    //alpha *= mix(-2., 1., quarticOut(uIntroProgress));\\n    alpha *= mix(0.8, 1., uIntroProgress);\\n\\n    vec3 finalColor = mix(uColor2, uColor1, v_colorStrength);\\n\\n    vec3 colorWhite = vec3(1.0, 1.0, 1.0);\\n    vec3 mixActiveColor = mix(finalColor, uColor3, v_activePulse);\\n\\n    vec3 white = vec3(1., 1., 1.);\\n\\n    finalColor =  mix(finalColor, white, v_activePulseProgress*0.15);\\n\\n    gl_FragColor = vec4(finalColor, alpha);\\n\\n}");\n;// CONCATENATED MODULE: ./app/src/js/webgl/about1/About1Dots.js\nfunction About1Dots_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction About1Dots_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction About1Dots_createClass(Constructor, protoProps, staticProps) { if (protoProps) About1Dots_defineProperties(Constructor.prototype, protoProps); if (staticProps) About1Dots_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\n\n\n\n\n\nvar About1Dots = /*#__PURE__*/function () {\n  function About1Dots(obj) {\n    var _this = this;\n\n    About1Dots_classCallCheck(this, About1Dots);\n\n    //console.log("(About1Dots.CONSTRUCTORA)!")\n    //console.log(obj)\n    this.worldGL = obj.worldGL; //--\n\n    this.scene = this.worldGL.scene;\n    this.cameraDistance = this.worldGL.cameraDistance; //--\n\n    this.material = null;\n    this.geometry = null;\n    this.mesh = null;\n    this.numParticles = null;\n    this.allLoaded = false;\n    this.created = false;\n    this.clock = new three_module/* Clock */.SUY();\n    this.startTime = null;\n    this.introTime = 1.2;\n    this.rotationX = 0;\n    this.rotationY = 0;\n    this.rotationWantedX = 0;\n    this.rotationWantedY = 0;\n    this.morphingProgress = 0; //--\n\n    this.eased_rotation = new webgl_EasedOutValue(0, 0.05);\n    this.eased_scrollDelta = new webgl_EasedOutValue(this.worldGL.settings.scroll_normalizedDelta * 0.3, 0.05);\n    this.eased_scrollDelta_fast = new webgl_EasedOutValue(this.worldGL.settings.scroll_normalizedDelta * 0.5, 0.1);\n    this.eased_scrollProgress = new webgl_EasedOutValue(this.worldGL.settings.scroll_progress, 0.05); //--\n\n    this._setup_settings(); //--\n\n\n    this.pulses = new about1_About1Pulses({\n      dotGeom: this\n    }); //--\n\n    this.orbital_geometry = new about1_About1Geometry(this.settings); //--\n\n    this.M_geometry = new webgl_LoadedGeometry({\n      id: "M_geometry",\n      file: "",\n      isDraco: false,\n      scale: 600 //rotationY : -Math.PI*0.25\n\n    }, this.settings);\n    this.M_geometry.on("onMeshLoaded", function (data) {\n      _this._eval_allLoaded();\n    }); //--\n\n    this.resize(); //--\n\n    this.M_geometry.init();\n  } //------------------------------------\n  // PUBLICAS: \n\n\n  About1Dots_createClass(About1Dots, [{\n    key: "create",\n    value: function create() {\n      //console.log("(About1Dots._create)!")\n      //--\n      this.material = new three_module/* ShaderMaterial */.jyz({\n        depthWrite: false,\n        blending: three_module/* AdditiveBlending */.WMw,\n        //blending: THREE.NormalBlending,\n        //blending: THREE.MultiplyBlending,\n        vertexColors: true,\n        vertexShader: aboutDots_vertex,\n        fragmentShader: aboutDots_fragment,\n        transparent: true,\n        uniforms: {\n          uColor1: {\n            value: new three_module/* Color */.Ilk("#170e41")\n          },\n          //801c65\n          uColor2: {\n            value: new three_module/* Color */.Ilk("#801c65")\n          },\n          uColor3: {\n            value: new three_module/* Color */.Ilk("#880364")\n          },\n          uTime: {\n            value: 0\n          },\n          uCamaraDistance: {\n            value: this.cameraDistance\n          },\n          uScrollDelta: {\n            value: 0\n          },\n          uScrollProgress: {\n            value: 1\n          },\n          uResponsiveScale: {\n            value: 1\n          },\n          uRotation1: {\n            value: 0\n          },\n          uRotation2: {\n            value: 0\n          },\n          uRotation3: {\n            value: 0\n          },\n          uRotationInner: {\n            value: 0\n          },\n          uRotationOutter: {\n            value: 0\n          },\n          uMorphingProgress: {\n            value: 0\n          },\n          uIntroProgress: {\n            value: 0\n          },\n          uScrollSpeed: {\n            value: 0\n          },\n          uPulseNum_0: {\n            value: 0\n          },\n          uPulseProgress_0: {\n            value: 0\n          },\n          uPulseNum_1: {\n            value: 0\n          },\n          uPulseProgress_1: {\n            value: 0\n          },\n          uPulseNum_2: {\n            value: 0\n          },\n          uPulseProgress_2: {\n            value: 0\n          },\n          uPulseNum_3: {\n            value: 0\n          },\n          uPulseProgress_3: {\n            value: 0\n          },\n          uPulseNum_4: {\n            value: 0\n          },\n          uPulseProgress_4: {\n            value: 0\n          },\n          uPulseNum_5: {\n            value: 0\n          },\n          uPulseProgress_5: {\n            value: 0\n          },\n          uPulseNum_6: {\n            value: 0\n          },\n          uPulseProgress_6: {\n            value: 0\n          },\n          uPulseNum_7: {\n            value: 0\n          },\n          uPulseProgress_7: {\n            value: 0\n          },\n          uPulseNum_8: {\n            value: 0\n          },\n          uPulseProgress_8: {\n            value: 0\n          },\n          uPulseNum_9: {\n            value: 0\n          },\n          uPulseProgress_9: {\n            value: 0\n          },\n          uProgress0: {\n            value: 0\n          },\n          uProgress0b: {\n            value: 1\n          },\n          uProgress1: {\n            value: 0\n          },\n          uProgress2: {\n            value: 0\n          },\n          uProgress3: {\n            value: 0\n          },\n          uProgress4: {\n            value: 0\n          },\n          uProgress4b: {\n            value: 0\n          },\n          uProgress5: {\n            value: 0\n          },\n          uProgress6: {\n            value: 0\n          },\n          uProgress6b: {\n            value: 0\n          } //uScale: {value: 1},\n          //uSize: {value: 30 * this.renderer.getPixelRatio()}\n\n        }\n      }); //--\n      //console.log(this.orbital_geometry.attributes.a_posiciones)\n      //--\n\n      this.geometry = new three_module/* BufferGeometry */.u9r();\n      this.geometry.setAttribute(\'position\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_geo1_position\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_geo1_dot_num\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_dot_num, 1));\n      this.geometry.setAttribute(\'a_geo1_orbital\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_orbital, 1));\n      this.geometry.setAttribute(\'a_geo1_pos_orbita\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_pos_orbita, 1));\n      this.geometry.setAttribute(\'a_geo1_incr_anguloRad\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_incr_anguloRad, 1));\n      this.geometry.setAttribute(\'a_geo1_anguloRad\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_anguloRad, 1));\n      this.geometry.setAttribute(\'a_geo1_radio\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_radio, 1));\n      this.geometry.setAttribute(\'a_geo1_dir\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_dir, 1));\n      this.geometry.setAttribute(\'a_geo1_incr\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_incr, 1));\n      this.geometry.setAttribute(\'a_geo1_x\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_x, 1));\n      this.geometry.setAttribute(\'a_geo1_y\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_y, 1));\n      this.geometry.setAttribute(\'a_geo1_z\', new three_module/* BufferAttribute */.TlE(this.orbital_geometry.attributes.a_z, 1));\n      this.geometry.setAttribute(\'a_geo2_position\', new three_module/* BufferAttribute */.TlE(this.M_geometry.attributes.a_posiciones, 3));\n      this.geometry.setAttribute(\'a_randomness\', new three_module/* BufferAttribute */.TlE(this.M_geometry.attributes.a_randomness, 3));\n      this.mesh = new three_module/* Points */.woe(this.geometry, this.material);\n      this.scene.add(this.mesh);\n    }\n  }, {\n    key: "onMouseUpdate",\n    value: function onMouseUpdate(mouseNormX, mouseNormY) {\n      //console.log("(Home4Dots.onMouseUpdate): "+mouseNormX)\n      if (this.morphingProgress > 0) {\n        //console.log("*")\n        this._mouseUpdateX(mouseNormX);\n\n        this._mouseUpdateY(mouseNormY);\n      }\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      if (this.allLoaded) {\n        //console.log("(About1Dots.render)!")\n        //--\n        if (this.startTime == null) {\n          this.startTime = this.clock.getElapsedTime();\n        }\n\n        var introProgress = webgl_WebGLUtils.clamp((this.clock.getElapsedTime() - this.startTime) / this.introTime, 0, 1);\n        introProgress = easing_functions_default().Quartic.Out(introProgress);\n        this.material.uniforms.uIntroProgress.value = introProgress; //--\n\n        var rotationEasedY = this.rotationY + (this.rotationWantedY - this.rotationY) * 0.05;\n        this.rotationY = rotationEasedY;\n        this.mesh.rotation.y = rotationEasedY; //--\n\n        var rotationEasedX = this.rotationX + (this.rotationWantedX - this.rotationX) * 0.05;\n        this.rotationX = rotationEasedX;\n        this.mesh.rotation.x = rotationEasedX; //--\n\n        this.material.uniforms.uTime.value = this.clock.getElapsedTime();\n        this.material.uniforms.uCamaraDistance.value = this.worldGL.cameraDistance;\n        this.material.uniforms.uResponsiveScale.value = this.worldGL.responsiveScale;\n        this.material.uniforms.uScrollDelta.value = -this.eased_scrollDelta.get(this.worldGL.settings.scroll_normalizedDelta * 0.5);\n        this.material.uniforms.uScrollProgress.value = this.worldGL.settings.scroll_progress;\n\n        if (this.worldGL.settings.morphingProgress <= 0.5) {\n          this.morphingProgress = 0;\n\n          this._mouseUpdateX(0);\n\n          this._mouseUpdateY(0);\n        } else {\n          this.morphingProgress = (this.worldGL.settings.morphingProgress - 0.5) * 2;\n        } //console.log("this.morphingProgress: "+this.morphingProgress)\n        //--\n\n\n        this.material.uniforms.uMorphingProgress.value = this.morphingProgress;\n        var extraSpeed = 1 + Math.abs(this.eased_scrollDelta_fast.get(this.worldGL.settings.scroll_normalizedDelta * 0.5) * 10);\n        this.settings.rotation1 += this.settings.speedRotation1 * extraSpeed;\n        this.settings.rotation2 += this.settings.speedRotation2 * extraSpeed;\n        this.settings.rotation3 += this.settings.speedRotation3 * extraSpeed;\n        this.material.uniforms.uRotation1.value = this.settings.rotation1;\n        this.material.uniforms.uRotation2.value = -this.settings.rotation2;\n        this.material.uniforms.uRotation3.value = this.settings.rotation3;\n        this.settings.rotationInner += this.settings.speedRotationInner * extraSpeed;\n        this.settings.rotationOutter += this.settings.speedRotationOutter * extraSpeed;\n        this.material.uniforms.uRotationInner.value = this.settings.rotationInner;\n        this.material.uniforms.uRotationOutter.value = this.settings.rotationOutter;\n        this.material.uniforms.uProgress0.value = this.settings.progress0;\n        this.material.uniforms.uProgress0b.value = this.settings.progress0b;\n        this.material.uniforms.uProgress1.value = this.settings.progress1;\n        this.material.uniforms.uProgress2.value = this.settings.progress2;\n        this.material.uniforms.uProgress3.value = this.settings.progress3;\n        this.material.uniforms.uProgress4.value = this.settings.progress4;\n        this.material.uniforms.uProgress4b.value = this.settings.progress4b;\n        this.material.uniforms.uProgress5.value = this.settings.progress5;\n        this.material.uniforms.uProgress6.value = this.settings.progress6;\n        this.material.uniforms.uProgress6b.value = this.settings.progress6b;\n        this.material.uniforms.uScrollSpeed.value = this.settings.scrollSpeedFiltered;\n\n        for (var i = 0; i < this.pulses.maxPulses; i++) {\n          this.material.uniforms["uPulseNum_" + i].value = this.pulses.get_dotPos(i);\n          this.material.uniforms["uPulseProgress_" + i].value = this.pulses.get_progress(i, this.clock.getElapsedTime());\n        } //--\n\n\n        this.settings.rotationInner += this.settings.speedRotationInner * extraSpeed;\n        this.settings.rotationOutter += this.settings.speedRotationOutter * extraSpeed; //--\n        //console.log("uIntroProgress: "+this.material.uniforms.uIntroProgress.value+"   uResponsiveScale: "+this.material.uniforms.uResponsiveScale.value+"   uTime: "+this.material.uniforms.uTime.value+"   uMorphingProgress: "+this.material.uniforms.uMorphingProgress.value+"   uRotationInner/Outter: "+this.material.uniforms.uRotationInner.value+"-"+this.material.uniforms.uRotationOutter.value)\n      }\n    }\n  }, {\n    key: "resize",\n    value: function resize() {//NADA\n    } //------------------------------------\n    // PRIVADAS: \n\n  }, {\n    key: "_mouseUpdateX",\n    value: function _mouseUpdateX(mouseNormX) {\n      var maxAngleRad = Math.PI * 0.25;\n      this.rotationWantedY = maxAngleRad * mouseNormX * this.morphingProgress;\n    }\n  }, {\n    key: "_mouseUpdateY",\n    value: function _mouseUpdateY(mouseNormY) {\n      var maxAngleRad = Math.PI * 0.1;\n      this.rotationWantedX = maxAngleRad * mouseNormY * this.morphingProgress;\n    }\n  }, {\n    key: "_eval_allLoaded",\n    value: function _eval_allLoaded() {\n      if (this.M_geometry.loaded) {\n        this.allLoaded = true;\n        this.worldGL.eval_start(); //this._create()\n      }\n    }\n  }, {\n    key: "_setup_settings3",\n    value: function _setup_settings3() {\n      //console.log("(Home4Dots._setup_settings)!")\n      this.settings = {\n        factor: 6,\n        incr_radio: 25,\n        numOrbits: 26,\n        //arrayOrbits: [12, 19, 26]\n        arrayOrbits: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26] //arrayOrbits: [1, 3]\n\n      };\n      this.settings.array_triangular = this._get_array_triangular(this.settings.factor, this.settings.numOrbits);\n      this.settings.array_triangular_dots_x_orbita = this._get_array_triangular_dots_x_orbita(this.settings.array_triangular, this.settings.arrayOrbits);\n      this.settings.array_dotPos = this._get_array_dotPos(this.settings.arrayOrbits, this.settings.array_triangular, this.settings.array_triangular_dots_x_orbita);\n      this.settings.numDots = this.settings.array_dotPos.length;\n    }\n  }, {\n    key: "_setup_settings",\n    value: function _setup_settings() {\n      //console.log("(About1Dots._setup_settings)!")\n      var speedBase = 0.00005; //--\n\n      this.settings = {\n        //--\n        rotationInner: 0,\n        speedRotationInner: 37 * speedBase,\n        rotationOutter: 0,\n        speedRotationOutter: 1 * speedBase,\n        //--\n        factor: 6,\n        incr_radio: 25,\n        numOrbits: 37,\n        pulseArray: [],\n        pulseMax: 1,\n        pulseNum_0: 0,\n        pulseInitTime_0: 0,\n        pulseProgress_0: 0,\n        progress0: 0,\n        progress0b: 1,\n        progress1: 0,\n        progress2: 0,\n        progress3: 0,\n        progress4: 0,\n        progress4b: 1,\n        progress5: 0,\n        progress6: 0,\n        progress6b: 1,\n        scrollSpeed: 0,\n        scrollSpeedFiltered: 0\n      };\n      this.settings.array_triangular = this._get_array_triangular(this.settings.factor, this.settings.numOrbits);\n      this.settings.numDots = this.settings.array_triangular[this.settings.array_triangular.length - 1];\n    }\n  }, {\n    key: "_get_array_triangular",\n    value: function _get_array_triangular(_factor, _numObits) {\n      // Genera una array de progresión triangular (* factor).\n      // Una progresión triangular es: 1, 3, 6, 10, 15 (https://significativa.org/diccionarios/numeros-figurados/#:~:text=3.1.1.1.-,Definici%C3%B3n,anterior%20no%20obtenemos%20una%20constante.)\n      var miArray = [];\n\n      for (var i = 0; i <= _numObits; i++) {\n        //array_numTriagulares.push(i*(i+1)/2)\n        miArray.push(i * (i + 1) / 2 * _factor);\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_get_array_dotPos",\n    value: function _get_array_dotPos(_arrayOrbits, _array_triangular, _array_triangular_dots_x_orbita) {\n      var miArray = [];\n\n      for (var i = 0; i < _arrayOrbits.length; i++) {\n        var orbitNum = _arrayOrbits[i];\n        var dots_x_orbit = _array_triangular_dots_x_orbita[i];\n        var dotNum_base = _array_triangular[_arrayOrbits[i] - 1]; // console.log("orbitNum: "+orbitNum)\n        // console.log("dots_x_orbit: "+dots_x_orbit)\n        // console.log("dotNum_base: "+dotNum_base)\n\n        for (var j = 0; j < dots_x_orbit; j++) {\n          miArray.push(dotNum_base + j + 1);\n        }\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_get_numDots",\n    value: function _get_numDots(_array_triangular_dots_x_orbita) {\n      var numDots = 0;\n\n      for (var i = 0; i <= _array_triangular_dots_x_orbita.length - 1; i++) {\n        numDots += _array_triangular_dots_x_orbita[i];\n      }\n\n      return numDots;\n    }\n  }, {\n    key: "_get_array_triangular_dots_x_orbita",\n    value: function _get_array_triangular_dots_x_orbita(_array_triangular, _arrayOrbits) {\n      // Genera una array basada en la progresión triangular (* factor).\n      // ... donde se indica el numero de dots por orbital\n      // Una progresión triangular es: 1, 3, 6, 10, 15 (https://significativa.org/diccionarios/numeros-figurados/#:~:text=3.1.1.1.-,Definici%C3%B3n,anterior%20no%20obtenemos%20una%20constante.)\n      var miArray = [];\n\n      for (var i = 0; i <= _arrayOrbits.length - 1; i++) {\n        //array_numTriagulares.push(i*(i+1)/2)\n        var numDots_orbita_actual = _array_triangular[_arrayOrbits[i]];\n        var numDots_orbita_anterior = _array_triangular[_arrayOrbits[i] - 1];\n        var numDots_orbita = numDots_orbita_actual - numDots_orbita_anterior;\n        miArray.push(numDots_orbita);\n      }\n\n      return miArray;\n    }\n  }, {\n    key: "_createcube",\n    value: function _createcube(_scene) {\n      var geometry = new three_module/* BoxGeometry */.DvJ(100, 100, 100);\n      var material = new three_module/* MeshBasicMaterial */.vBJ({\n        color: 0x00ff00\n      });\n      var cube = new three_module/* Mesh */.Kj0(geometry, material);\n\n      _scene.add(cube);\n    }\n  }]);\n\n  return About1Dots;\n}();\n\n/* harmony default export */ const about1_About1Dots = (About1Dots);\n;// CONCATENATED MODULE: ./app/src/js/webgl/about1/shaders/gradientBackground_vertex.glsl\n/* harmony default export */ const gradientBackground_vertex = ("#define GLSLIFY 1\\nuniform vec3 uColor0;\\nuniform vec3 uColor1;\\nuniform vec3 uColor2;\\nuniform vec3 uColor3;\\nuniform float uTime;\\nuniform float uScrollProgress;\\nuniform float uScrollTotalRange;\\nuniform float uAspectRatio;\\nuniform float uResponsiveScale;\\n\\nvarying vec2 vUv;\\nvarying vec3 v_position;\\nvarying float v_noise;\\nvarying float v_colorStrength1;\\nvarying float v_colorStrength2;\\nvarying float v_colorStrength3;\\n\\n//\\tClassic Perlin 3D Noise \\n//\\tby Stefan Gustavson\\n//\\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\\n\\nfloat cnoise(vec3 P){\\n  vec3 Pi0 = floor(P); // Integer part for indexing\\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\\n  Pi0 = mod(Pi0, 289.0);\\n  Pi1 = mod(Pi1, 289.0);\\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n  vec4 iz0 = Pi0.zzzz;\\n  vec4 iz1 = Pi1.zzzz;\\n\\n  vec4 ixy = permute(permute(ix) + iy);\\n  vec4 ixy0 = permute(ixy + iz0);\\n  vec4 ixy1 = permute(ixy + iz1);\\n\\n  vec4 gx0 = ixy0 / 7.0;\\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\\n  gx0 = fract(gx0);\\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n  vec4 sz0 = step(gz0, vec4(0.0));\\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n\\n  vec4 gx1 = ixy1 / 7.0;\\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\\n  gx1 = fract(gx1);\\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n  vec4 sz1 = step(gz1, vec4(0.0));\\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n\\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\n\\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n  g000 *= norm0.x;\\n  g010 *= norm0.y;\\n  g100 *= norm0.z;\\n  g110 *= norm0.w;\\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n  g001 *= norm1.x;\\n  g011 *= norm1.y;\\n  g101 *= norm1.z;\\n  g111 *= norm1.w;\\n\\n  float n000 = dot(g000, Pf0);\\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n  float n111 = dot(g111, Pf1);\\n\\n  vec3 fade_xyz = fade(Pf0);\\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \\n  return 2.2 * n_xyz;\\n}\\n\\nfloat get_escalaNoise(float x, float y, float amplitudMapa, float progress){\\n    float valor = cnoise(vec3(x/amplitudMapa, y/amplitudMapa, progress));\\n    valor = -0.5+(valor*2.);\\n    //valor = valor*2.; // x2 Intesifica el contraste\\n    return valor;\\n}\\n\\nvoid main() {\\n    float scrollPos = -uScrollTotalRange*uScrollProgress*0.001;\\n    float newPositionY = (position.y+scrollPos)/uAspectRatio;\\n\\n    vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\\n\\tgl_Position = projectionMatrix * modelViewPosition;\\n\\n    float uTimeSlow0  = uTime; \\n    float uTimeSlow1 = uTime*0.1; // Modificamos la velocidad en la que evolucionan los gradientes\\n    float uTimeSlow2 = uTime*0.1; // Modificamos la velocidad en la que evolucionan los gradientes\\n    float uTimeSlow3 = uTime*0.2; // Modificamos la velocidad en la que evolucionan los gradientes\\n\\n    //v_noise = cnoise(vec3(position.x/0.01, position.y/0.01, uTimeSlow0*1.));\\n\\n    v_colorStrength1 = get_escalaNoise(position.x-1000., newPositionY+0., 1.2/uResponsiveScale, uTimeSlow1+100.)*1.;\\n    v_colorStrength1 = clamp(v_colorStrength1, 0., 1.5 ); // clamp(valor, min, max)\\n\\n    v_colorStrength2 = get_escalaNoise(position.x-2000., newPositionY+200., 1.2/uResponsiveScale, uTimeSlow2+200.)*1.;\\n    v_colorStrength2 = clamp(v_colorStrength2, 0., 1.5 ); // clamp(valor, min, max)\\n\\n    v_colorStrength3 = get_escalaNoise(position.x-3000., newPositionY+400., 2.2/uResponsiveScale, uTimeSlow3+400.)*1.;\\n    v_colorStrength3 = clamp(v_colorStrength3, 0., 1.5 ); // clamp(valor, min, max)\\n\\n    //v_colorStrength3 = get_escalaNoise(position.x, position.y, 1., uTimeSlow+200.)*2.;\\n\\n    vUv = uv;\\n    v_position = position;\\n\\n}");\n;// CONCATENATED MODULE: ./app/src/js/webgl/about1/shaders/gradientBackground_fragment.glsl\n/* harmony default export */ const gradientBackground_fragment = ("#define GLSLIFY 1\\n//#pragma glslify: blur1 = require(\'glsl-fast-gaussian-blur/13\')\\n// varying vec3 vPosition;\\n// varying vec2 vUv;\\nuniform float uTime;\\nuniform vec3 uColor0;\\nuniform vec3 uColor1;\\nuniform vec3 uColor2;\\nuniform vec3 uColor3;\\nuniform vec3 uColorTouch;\\nuniform float uFooterProgress;\\n\\nvarying vec2 vUv;\\nvarying vec3 v_position;\\nvarying float v_noise;\\nvarying float v_colorStrength1;\\nvarying float v_colorStrength2;\\nvarying float v_colorStrength3;\\n\\nvarying float vPulseNum_0;\\nvarying float vPulseProgress_0;\\n\\n//#pragma glslify: snoise2 = require(glsl-noise/simplex/2d)\\n\\nfloat random2(vec2 c){\\n    return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\\n}\\n// float randomNoise(vec2 p) {\\n//   return (random2(p - vec2(sin(time))) * 2.0 - 1.0) * max(length(acceleration), 0.08);\\n// }\\n\\nvoid main() {\\n\\n    float incr = 0.0;\\n    float random = random2(vec2(v_position.x+incr, v_position.y+incr));\\n    vec3 rndColor = vec3(random/1., random/1., random/1.);\\n    float randomStrength = (v_colorStrength1+v_colorStrength2+v_colorStrength3)/3.;\\n\\n    vec3 colorBlanco = vec3(1.0, 1.0, 1.0);\\n    vec3 mixColor = uColor0;\\n    mixColor = mix(mixColor, uColor1, v_colorStrength1);\\n    mixColor = mix(mixColor, uColor2, v_colorStrength2);\\n    mixColor = mix(mixColor, uColor3, v_colorStrength3*0.5);\\n    mixColor = mix(mixColor, rndColor, 0.03+(randomStrength*0.3));\\n    mixColor = mix(mixColor, uColorTouch, uFooterProgress);\\n\\n    //mixColor = mix(mixColor, vec3(v_noise, v_noise, v_noise), 1.);\\n\\n    //mixColor = mix(mixColor, uColor0, centralColor);\\n    //gl_FragColor = vec4(v_noise, 0.0, 0.0, 1.0);\\n    //gl_FragColor = vec4(mixColor, 1.0);\\n    gl_FragColor = vec4(mixColor, 1.0);\\n}\\n\\n");\n;// CONCATENATED MODULE: ./app/src/js/webgl/about1/About1Background.js\nfunction About1Background_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction About1Background_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction About1Background_createClass(Constructor, protoProps, staticProps) { if (protoProps) About1Background_defineProperties(Constructor.prototype, protoProps); if (staticProps) About1Background_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\nvar GradientBackground = /*#__PURE__*/function () {\n  function GradientBackground(obj) {\n    About1Background_classCallCheck(this, GradientBackground);\n\n    //console.log("(GradientBackground.CONSTRUCTORA)--------------- ", obj)\n    this.worldGL = obj.worldGL; //--       \n\n    this.settings = {\n      initialized: false,\n      scrollNew: 0,\n      scrollLast: 0,\n      //--\n      uScrollTotalRange: null,\n      uScrollProgress: 0,\n      uScrollDelta: 0,\n      uTime: 0\n    };\n  } //-----------------------------\n  // PUBLICOS;  \n\n\n  About1Background_createClass(GradientBackground, [{\n    key: "create",\n    value: function create() {\n      this.settings.initialized = true; //--\n\n      this.$scrollTrigger = document.querySelector(\'.inner\');\n      this.scrollTotalRange = this.$scrollTrigger.offsetHeight;\n      this.settings.uScrollTotalRange = this.scrollTotalRange; //--\n\n      this.clock = new three_module/* Clock */.SUY();\n      this.renderer = this.worldGL.renderer; //--\n\n      this.camera = new three_module/* OrthographicCamera */.iKG(-1, // left\n      1, // right\n      1, // top\n      -1, // bottom\n      -1, // near,\n      0);\n      this.scene = new three_module/* Scene */.xsS(); //this.scene.background = new THREE.Color( 0xff0000 );\n      //---------------\n      // GEOMETRY:\n\n      var geometry = new three_module/* PlaneBufferGeometry */.BKK(2, 2, 100, 100); //---------------\n      // MATERIAL:\n      // Test Naterial:  Only for dev testings\n      //const material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );\n      //--\n\n      this.material = new three_module/* ShaderMaterial */.jyz({\n        //depthWrite: false,\n        //blending: THREE.AdditiveBlending,\n        //vertexColors: true,\n        vertexShader: gradientBackground_vertex,\n        fragmentShader: gradientBackground_fragment,\n        //wireframe:true,\n        uniforms: {\n          uColor0: {\n            value: new three_module/* Color */.Ilk("#01155c")\n          },\n          //0f307d\n          uColor1: {\n            value: new three_module/* Color */.Ilk("#176bb3")\n          },\n          uColor2: {\n            value: new three_module/* Color */.Ilk("#7e08ac")\n          },\n          uColor3: {\n            value: new three_module/* Color */.Ilk("#b9112a")\n          },\n          uColorTouch: {\n            value: new three_module/* Color */.Ilk("#000A33")\n          },\n          uTime: {\n            value: 0\n          },\n          uScrollProgress: {\n            value: 0\n          },\n          uFooterProgress: {\n            value: 0\n          },\n          uScrollDelta: {\n            value: 0\n          },\n          uScrollTotalRange: {\n            value: this.settings.uScrollTotalRange\n          },\n          uAspectRatio: {\n            value: this.worldGL.width / this.worldGL.height\n          },\n          uResponsiveScale: {\n            value: this.worldGL.responsiveScale\n          }\n        }\n      }); //---------------\n      // MESH:\n\n      this.plane = new three_module/* Mesh */.Kj0(geometry, this.material);\n      this.scene.add(this.plane);\n    } //--  \n\n  }, {\n    key: "resize",\n    value: function resize() {\n      if (this.settings.initialized) {\n        //console.log("(GradientBackground.resize)!")\n        if (this.$scrollTrigger) {\n          this.settings.uScrollTotalRange = this.$scrollTrigger.offsetHeight;\n        }\n\n        this.renderer.setSize(this.worldGL.width, this.worldGL.height, false);\n      }\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      if (this.settings.initialized) {\n        this.material.uniforms.uTime.value = this.clock.getElapsedTime();\n        this.material.uniforms.uScrollProgress.value = this.worldGL.settings.scroll_progress;\n        this.material.uniforms.uFooterProgress.value = this.worldGL.settings.scroll_footer_progress;\n        this.material.uniforms.uAspectRatio.value = this.worldGL.width / this.worldGL.height;\n        this.material.uniforms.uScrollTotalRange.value = this.settings.uScrollTotalRange;\n        this.material.uniforms.uResponsiveScale.value = this.worldGL.responsiveScale;\n        this.renderer.render(this.scene, this.camera); //console.log(this.material.uniforms)\n        //console.log("uScrollProgress:"+this.material.uniforms.uScrollProgress.value+"  ---  uScrollTotalRange:"+this.material.uniforms.uScrollTotalRange.value+"  --- uAspectRatio:"+ this.material.uniforms.uAspectRatio.value)\n      }\n    } //-----------------------------\n    // PRIVADOS:\n\n  }]);\n\n  return GradientBackground;\n}();\n\n/* harmony default export */ const About1Background = (GradientBackground);\n;// CONCATENATED MODULE: ./app/src/js/webgl/about1/About1App.js\nfunction About1App_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction About1App_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction About1App_createClass(Constructor, protoProps, staticProps) { if (protoProps) About1App_defineProperties(Constructor.prototype, protoProps); if (staticProps) About1App_defineProperties(Constructor, staticProps); return Constructor; }\n\n// FPS-Meter:\n//(function(){var script=document.createElement(\'script\');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src=\'//cdn.jsdelivr.net/gh/Kevnz/stats.js/build/stats.min.js\';document.head.appendChild(script);})()\n\n\n\n\n\n\n //import About1Dots from \'../home1/Home1Dots\';\n\n\n\nvar About1App = /*#__PURE__*/function () {\n  function About1App(obj) {\n    var _this = this;\n\n    About1App_classCallCheck(this, About1App);\n\n    //console.log("(About1App.CONSTRUCTORA)!", obj) \n    this.hw_renderer = obj.renderer; // Rederer/pagina de HighWay. No confundir con el render/renderer de Three.js\n\n    this.$container = obj.domElement;\n    this.refResolution = obj.refResolution; //-- \n    //this.$main = document.querySelector(\'.inner\')\n    //this.$footer = document.querySelector(\'.footer\')\n    //--\n\n    this.REF_RESOLUTION = this.refResolution;\n    this.REF_CAMERA_DISTANCE = 500; //--\n\n    this.initialized = false; //--\n\n    this.width;\n    this.height;\n    this.responsiveScale;\n    this.cameraDistance; //--\n\n    document.addEventListener(\'mousemove\', function (self) {\n      _this.onMouseUpdate(self);\n    }, false);\n    document.addEventListener(\'wheel\', function (self) {\n      _this.onMouseUpdate(self);\n    }, false); //--\n\n    this.MAIN_ACTIVE = false;\n    this.FOOTER_ACTIVE = false; //--\n\n    this.mouseNorm = {\n      x: 0,\n      y: 0\n    }; //--\n    //this.refResolution = 1920;\n    //this.refResolution = 450;\n    //this.responsiveScale = this.width/this.refResolution;\n    //--\n    //this.cameraDistance = 500\n    //--\n\n    this.settings = {\n      scroll_lastInnerY: 0,\n      // Ultima posición del elemento de referencia\n      scroll_delta: 0,\n      // Incremento de pixels del scroll\n      scroll_limitedDelta: 0,\n      // Limita los valores a -20 -> +20\n      scroll_normalizedDelta: 0,\n      // Pasa el delta a -1 -> +1\n      scroll_factordDelta: 1,\n      // Valores absolutos de 0 -> 1\n      scroll_direction: 1,\n      // Direccion del delta. 1 si está parado\n      scroll_footer_progress: 0,\n      morphingProgress: 0\n    }; //--\n\n    this._update_dimensions(); //--\n    // Scene\n\n\n    this.scene = new three_module/* Scene */.xsS(); //this.scene.background = new THREE.Color(0x333333)\n    //--\n    // Camera\n    //PerspectiveCamera( fov : Number, aspect : Number, near : Number, far : Number )\n\n    this.camera = new three_module/* PerspectiveCamera */.cPb(30, this.width / this.height, 0.1, 2000);\n    this.camera.position.z = this.cameraDistance; //console.log("this.camera.fov: "+this.camera.fov)\n\n    this.camera.fov = 2 * Math.atan(this.height / 2 / this.cameraDistance) * (180 / Math.PI); //console.log("this.camera.fov: "+this.camera.fov)\n    //--\n    // Renderer\n\n    this.renderer = new three_module/* WebGL1Renderer */.b5g({\n      antialias: true,\n      alpha: true\n    });\n    this.renderer.autoClear = false; // Vamos a usar 2 scenas (una para el background y otra para los puntos) que implicarán usar 2 acciones de render. Con autoclear false permitimos que la segunda no borre la primera.\n\n    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1)); //--\n\n    this.$container.appendChild(this.renderer.domElement); //--\n    //--\n\n    this.background = new About1Background({\n      worldGL: this\n    }); //--\n\n    this.dots = new about1_About1Dots({\n      worldGL: this\n    }); //--\n\n    this._resize(); //this._render();\n    //this._init_scrollListeners()\n\n  } //---------------------------\n  // PUBLICAS:\n\n\n  About1App_createClass(About1App, [{\n    key: "init",\n    value: function init() {\n      //console.log("(About1App.init)!") \n      this.initialized = true;\n      this.eval_start();\n    }\n  }, {\n    key: "eval_start",\n    value: function eval_start() {\n      //console.log("(About1App.eval_start): "+this.initialized+":"+this.dots.allLoaded) \n      if (this.initialized && this.dots.allLoaded) {\n        //console.log("START!")\n        //--\n        this.$main = document.querySelector(\'.inner\');\n        this.$footer = document.querySelector(\'.footer\'); //--\n\n        if (this.background) {\n          this.background.create();\n        }\n\n        if (this.dots) {\n          this.dots.create();\n        }\n\n        this._render();\n\n        this._init_scrollListeners();\n      }\n    }\n  }, {\n    key: "kill",\n    value: function kill() {\n      //console.log("(About1App.kill)!") \n      this.$inner_trigger.kill();\n      this.$footer_trigger.kill();\n      node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this._binded_render);\n      node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(this._binded_eval_scroll);\n      this.dots = null;\n    } //---------------------------\n\n  }, {\n    key: "onResize",\n    value: function onResize() {\n      //console.log("(About1App.onResize)!")\n      this._resize();\n    }\n  }, {\n    key: "onMouseUpdate",\n    value: function onMouseUpdate(e) {\n      if (this.FOOTER_ACTIVE) {\n        this.mouseNorm.x = e.pageX / this.width * 2 - 1;\n        this.mouseNorm.y = e.pageY / this.height * 2 - 1;\n\n        if (this.dots) {\n          this.dots.onMouseUpdate(this.mouseNorm.x, this.mouseNorm.y);\n        }\n      }\n    } //---------------------------\n    // PRIVADAS:\n\n  }, {\n    key: "_update_dimensions",\n    value: function _update_dimensions() {\n      // console.log("(Home2App_m._update_dimensions)!", this.renderer)\n      this.width = this.$container.offsetWidth;\n      this.height = this.$container.offsetHeight;\n      this.responsiveScale = this.width / this.REF_RESOLUTION.width;\n      this.cameraDistance = this.REF_CAMERA_DISTANCE * this.responsiveScale; //--\n\n      if (this.renderer) {\n        this.renderer.setSize(this.width, this.height); //--\n\n        this.camera.aspect = this.width / this.height;\n        this.cameraDistance = this.camera.position.z;\n        this.camera.fov = 2 * Math.atan(this.height / 2 / this.cameraDistance) * (180 / Math.PI);\n        this.camera.updateProjectionMatrix();\n      } //--\n\n    }\n  }, {\n    key: "_init_scrollListeners",\n    value: function _init_scrollListeners() {\n      var _this2 = this;\n\n      var binded_render = function binded_render() {\n        _this2._render();\n      };\n\n      this._binded_render = binded_render;\n\n      var binded_eval_scroll = function binded_eval_scroll() {\n        _this2._eval_inertia_scroll(_this2.$inner_trigger.progress);\n\n        _this2._eval_footer_scroll(_this2.$footer_trigger.progress);\n      };\n\n      this._binded_eval_scroll = binded_eval_scroll;\n      var that = this;\n      this.$inner_trigger = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$main,\n        start: \'top-=10 top\',\n        end: \'bottom bottom\',\n        scrub: true,\n        // Scrub: Genera eventos en una franja mas que en un punto.\n        // markers: true,\n        onToggle: function onToggle(self) {\n          if (self.isActive) {\n            //console.log("MAIN ACTIVE")\n            that.MAIN_ACTIVE = true;\n            node_modules_gsap/* default.ticker.add */.ZP.ticker.add(binded_render);\n            node_modules_gsap/* default.ticker.add */.ZP.ticker.add(binded_eval_scroll);\n          } else {\n            that.MAIN_ACTIVE = false; //console.log("MAIN NOT ACTIVE")\n            //gsap.ticker.remove(binded_render) // El fondo webgl persiste siempre. No lo desactivamos nunca.\n\n            node_modules_gsap/* default.ticker.remove */.ZP.ticker.remove(binded_eval_scroll); // El fondo webgl persiste siempre. No lo desactivamos nunca.\n          }\n        }\n      });\n      this.$footer_trigger = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$footer,\n        start: \'top bottom\',\n        end: \'bottom+=10 bottom\',\n        scrub: true,\n        // Scrub: Genera eventos en una franja mas que en un punto.\n        // markers: true,\n        onToggle: function onToggle(self) {\n          if (self.isActive) {\n            //console.log("FOOTER ACTIVE")\n            that.FOOTER_ACTIVE = true;\n          } else {\n            //console.log("FOOTER NOT ACTIVE")\n            that.FOOTER_ACTIVE = false;\n          }\n        }\n      });\n    }\n  }, {\n    key: "_eval_inertia_scroll",\n    value: function _eval_inertia_scroll(progress) {\n      var innerData = this.$main.getBoundingClientRect();\n      var newInnerY = innerData.y;\n      this.settings.scroll_progress = progress;\n      this.settings.scroll_delta = newInnerY - this.settings.scroll_lastInnerY;\n      this.settings.scroll_lastInnerY = newInnerY;\n      this.settings.scroll_limitedDelta = webgl_WebGLUtils.clamp(this.settings.scroll_delta, -20, 20); // Limita los valores a -20 -> +20\n\n      this.settings.scroll_normalizedDelta = (this.settings.scroll_limitedDelta / 20).toFixed(3); // Pasa el delta a -1 -> +1\n\n      this.settings.scroll_factordDelta = Math.abs(this.settings.scroll_normalizedDelta) + 0; // Valores absolutos de 0 -> 1\n\n      this.settings.scroll_direction = 1;\n\n      if (this.settings.scroll_normalizedDelta < 0) {\n        this.settings.scroll_direction = -1;\n      }\n    }\n  }, {\n    key: "_eval_footer_scroll",\n    value: function _eval_footer_scroll(progress) {\n      //console.log("(About1App._eval_footer_scroll): "+progress)\n      this.settings.scroll_footer_progress = progress;\n      this.settings.morphingProgress = progress;\n    }\n  }, {\n    key: "_resize",\n    value: function _resize() {\n      //console.log("(About1Dots.resize)!")\n      //--\n      this._update_dimensions(); //--\n\n\n      if (this.background) {\n        this.background.resize();\n      }\n\n      if (this.dots) {\n        this.dots.resize();\n      }\n    }\n  }, {\n    key: "_render",\n    value: function _render() {\n      //console.log("(About1App._render): "+this.settings.scroll_progress+":"+this.settings.scroll_footer_progress)\n      if (this.height != this.$container.offsetHeight || this.width != this.$container.offsetWidth) {\n        this._resize();\n      }\n\n      if (this.background) {\n        this.background.render();\n      }\n\n      if (this.dots) {\n        this.dots.render();\n      }\n\n      this.renderer.render(this.scene, this.camera); //requestAnimationFrame(this.render.bind(this))\n    }\n  }]);\n\n  return About1App;\n}();\n\n/* harmony default export */ const about1_About1App = (About1App);\n;// CONCATENATED MODULE: ./app/src/js/renderers/rendererAbout.js\nfunction rendererAbout_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rendererAbout_typeof = function _typeof(obj) { return typeof obj; }; } else { rendererAbout_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rendererAbout_typeof(obj); }\n\nfunction rendererAbout_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rendererAbout_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rendererAbout_createClass(Constructor, protoProps, staticProps) { if (protoProps) rendererAbout_defineProperties(Constructor.prototype, protoProps); if (staticProps) rendererAbout_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rendererAbout_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rendererAbout_setPrototypeOf(subClass, superClass); }\n\nfunction rendererAbout_setPrototypeOf(o, p) { rendererAbout_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rendererAbout_setPrototypeOf(o, p); }\n\nfunction rendererAbout_createSuper(Derived) { var hasNativeReflectConstruct = rendererAbout_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rendererAbout_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rendererAbout_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rendererAbout_possibleConstructorReturn(this, result); }; }\n\nfunction rendererAbout_possibleConstructorReturn(self, call) { if (call && (rendererAbout_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return rendererAbout_assertThisInitialized(self); }\n\nfunction rendererAbout_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rendererAbout_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rendererAbout_getPrototypeOf(o) { rendererAbout_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rendererAbout_getPrototypeOf(o); }\n\n// GSAP Library\n\n\nnode_modules_gsap/* default.registerPlugin */.ZP.registerPlugin(ScrollTrigger/* default */.Z);\n\nnode_modules_gsap/* default.registerPlugin */.ZP.registerPlugin(MorphSVGPlugin); // Webgl\n\n // Import Renderer\n\n // Utilities\n\n\n\n\n\nvar RendererAbout = /*#__PURE__*/function (_Renderer) {\n  rendererAbout_inherits(RendererAbout, _Renderer);\n\n  var _super = rendererAbout_createSuper(RendererAbout);\n\n  function RendererAbout() {\n    rendererAbout_classCallCheck(this, RendererAbout);\n\n    return _super.apply(this, arguments);\n  }\n\n  rendererAbout_createClass(RendererAbout, [{\n    key: "selectors",\n    value: function selectors() {\n      // Sections\n      this.$hero = this.$el.querySelector(\'.about__hero\');\n      this.$team = this.$el.querySelector(\'.about__team\');\n      this.$clients = this.$el.querySelector(\'.about__clients\');\n      this.$canvas = this.$el.querySelector(\'#webgl_background_about\');\n    }\n  }, {\n    key: "events",\n    value: function events() {} // eslint-disable-line\n\n  }, {\n    key: "preload",\n    value: function preload() {\n      this.preloadItems = {\n        main: [],\n        secondary: []\n      };\n    }\n  }, {\n    key: "beforeEnter",\n    value: function beforeEnter() {\n      // Webgl\n      if (this.appStore.isDesktop) {\n        this.renderBg = new about1_About1App({\n          renderer: this,\n          domElement: this.$canvas,\n          refResolution: {\n            width: 1920,\n            height: 947\n          }\n        });\n      } else {\n        this.renderBg = new about1_About1App({\n          renderer: this,\n          domElement: this.$canvas,\n          refResolution: {\n            width: 850,\n            height: 850\n          }\n        });\n      }\n    }\n  }, {\n    key: "enter",\n    value: function enter() {\n      var _this = this;\n\n      // Start functions\n      this.init(); // Move canvas\n\n      var _offset2 = this.$inner.offsetHeight - this.$canvas.offsetHeight;\n\n      this._canvasPin = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$inner,\n        start: \'top top\',\n        end: \'bottom bottom\',\n        scrub: true,\n        onUpdate: function onUpdate(self) {\n          if (_this.appStore.isDesktop) node_modules_gsap/* default.set */.ZP.set(_this.$canvas, {\n            y: _offset2 * self.progress + \'px\'\n          });\n        }\n      });\n    }\n  }, {\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      this.initHeroCards();\n      this.renderBg.init();\n\n      if (this.appStore.isDesktop) {\n        node_modules_gsap/* default.delayedCall */.ZP.delayedCall(1.5, function () {\n          _this2.initHeroPin();\n        });\n        this.initParallaxCards();\n      } else {\n        this.initTeamDraggableMobile();\n      }\n    }\n  }, {\n    key: "initParallaxCards",\n    value: function initParallaxCards() {\n      this.$heroCards = this.$hero.querySelectorAll(\'.card\');\n      var parallaxCards = node_modules_gsap/* default.timeline */.ZP.timeline({\n        defaults: {\n          duration: 1,\n          ease: \'none\'\n        },\n        scrollTrigger: {\n          trigger: this.$hero.querySelector(\'.container--large\'),\n          start: \'top bottom\',\n          end: this.$hero.querySelector(\'.container--large\').offsetHeight + window.innerWidth * 0.1 + \' top\',\n          scrub: true,\n          markers: false\n        }\n      }); // Set\n\n      parallaxCards.set([this.$heroCards[0]], {\n        y: \'0vw\'\n      }, 0);\n      parallaxCards.set([this.$heroCards[1]], {\n        y: \'2.5vw\'\n      }, 0);\n      parallaxCards.set([this.$heroCards[2]], {\n        y: \'0vw\'\n      }, 0);\n      parallaxCards.set([this.$heroCards[3]], {\n        y: \'2.5vw\'\n      }, 0); // Animation\n\n      parallaxCards.to([this.$heroCards[0]], {\n        y: \'2.5vw\'\n      }, 0);\n      parallaxCards.to([this.$heroCards[1]], {\n        y: \'0vw\'\n      }, 0);\n      parallaxCards.to([this.$heroCards[2]], {\n        y: \'2.5vw\'\n      }, 0);\n      parallaxCards.to([this.$heroCards[3]], {\n        y: \'0vw\'\n      }, 0);\n    }\n  }, {\n    key: "initHeroCards",\n    value: function initHeroCards() {\n      var _this3 = this;\n\n      // Selectors\n      this.$heroCards = this.$hero.querySelectorAll(\'.card\');\n\n      var _loop = function _loop(i) {\n        if (_this3.appStore.isDesktop) {\n          _this3.domEvents.add(_this3.$heroCards[i], \'mouseenter\', function (a, e, el) {\n            if (el.querySelector(\'.info\')) {\n              node_modules_gsap/* default.killTweensOf */.ZP.killTweensOf(el.querySelector(\'.info\'));\n              node_modules_gsap/* default.set */.ZP.set(el.querySelector(\'.info\'), {\n                display: \'flex\'\n              });\n              node_modules_gsap/* default.to */.ZP.to(el.querySelector(\'.info\'), {\n                opacity: 1,\n                duration: 0.6,\n                ease: \'expo.out\'\n              });\n            } else {\n              el.style.pointerEvents = \'none\';\n            }\n          });\n\n          _this3.domEvents.add(_this3.$heroCards[i], \'mouseleave\', function (a, e, el) {\n            if (el.querySelector(\'.info\')) {\n              node_modules_gsap/* default.killTweensOf */.ZP.killTweensOf(el.querySelector(\'.info\'));\n              node_modules_gsap/* default.to */.ZP.to(el.querySelector(\'.info\'), {\n                opacity: 0.0001,\n                duration: 0.6,\n                ease: \'expo.out\',\n                onComplete: function onComplete() {\n                  node_modules_gsap/* default.set */.ZP.set(el.querySelector(\'.info\'), {\n                    display: \'none\'\n                  });\n                }\n              });\n            } else {\n              el.style.pointerEvents = \'none\';\n            }\n          });\n        } else {\n          // Open and close info\n          if (_this3.$heroCards[i].querySelector(\'.info\')) {\n            _this3.domEvents.add(_this3.$heroCards[i].querySelector(\'.icon\'), \'click\', function (e) {\n              node_modules_gsap/* default.set */.ZP.set(_this3.$heroCards[i].querySelector(\'.info\'), {\n                display: \'flex\'\n              });\n              node_modules_gsap/* default.to */.ZP.to(_this3.$heroCards[i].querySelector(\'.info\'), {\n                opacity: 1,\n                duration: 0.8,\n                ease: \'expo.out\'\n              });\n            });\n\n            if (_this3.$heroCards[i].querySelector(\'.closer\')) {\n              _this3.domEvents.add(_this3.$heroCards[i].querySelector(\'.closer\'), \'click\', function (e) {\n                node_modules_gsap/* default.to */.ZP.to(_this3.$heroCards[i].querySelector(\'.info\'), {\n                  opacity: 0.0001,\n                  duration: 0.8,\n                  ease: \'expo.out\',\n                  onComplete: function onComplete() {\n                    node_modules_gsap/* default.set */.ZP.set(_this3.$heroCards[i].querySelector(\'.info\'), {\n                      display: \'none\'\n                    });\n                  }\n                });\n              });\n            }\n          } // Selectors\n\n\n          _this3.$heroSlider = _this3.$hero.querySelector(\'.slider\');\n          _this3._heroDraggable = new superDraggable_default({\n            el: _this3.$hero,\n            snap: false,\n            snapTo: \'center\',\n            dots: false\n          });\n        }\n      };\n\n      for (var i = 0; i < this.$heroCards.length; i++) {\n        _loop(i);\n      }\n    }\n  }, {\n    key: "initHeroPin",\n    value: function initHeroPin() {\n      var _this4 = this;\n\n      this.$heroWords = this.$hero.querySelector(\'.words\');\n      this.$heroWordsInner = this.$hero.querySelector(\'.words__inner\');\n      this.$heroWordsGradient = this.$hero.querySelector(\'.words__gradient\');\n      this.$heroLabel = this.$hero.querySelector(\'.label--1\');\n\n      var _offset = this.$heroWordsInner.offsetHeight - this.$heroWordsGradient.offsetHeight;\n\n      this._heroPin = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$heroWords,\n        start: \'top top\',\n        end: \'bottom bottom\',\n        scrub: true,\n        markers: false,\n        onUpdate: function onUpdate(self) {\n          node_modules_gsap/* default.set */.ZP.set(_this4.$heroLabel, {\n            y: _offset * self.progress + \'px\'\n          });\n          node_modules_gsap/* default.set */.ZP.set(_this4.$heroWordsGradient, {\n            y: _offset * self.progress + \'px\'\n          });\n        },\n        onEnter: function onEnter() {\n          node_modules_gsap/* default.to */.ZP.to(_this4.$heroWordsGradient, {\n            opacity: 1,\n            duration: 0.4,\n            ease: \'power2.out\'\n          });\n        },\n        onEnterBack: function onEnterBack() {\n          node_modules_gsap/* default.to */.ZP.to(_this4.$heroWordsGradient, {\n            opacity: 1,\n            duration: 0.4,\n            ease: \'power2.out\'\n          });\n        }\n      }); // Move canvas\n\n      var _offset2 = this.$inner.offsetHeight - this.$canvas.offsetHeight;\n\n      this._canvasPin = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$inner,\n        start: \'top top\',\n        end: \'bottom bottom\',\n        scrub: true,\n        onUpdate: function onUpdate(self) {\n          node_modules_gsap/* default.set */.ZP.set(_this4.$canvas, {\n            y: _offset2 * self.progress + \'px\'\n          });\n        }\n      }); // Create a linear gradient that works with webGl background\n\n      var canvas = this.$heroWordsGradient;\n      var ctx = canvas.getContext(\'2d\'); // The start gradient point is at x = 20, y = 0 / The end gradient point is at x = 220, y = 0\n\n      var gradient = ctx.createLinearGradient(20, 0, 220, 0); // Set the fill style and draw a rectangle\n\n      ctx.fillStyle = gradient;\n      ctx.fillRect(20, 20, 200, 100);\n    }\n  }, {\n    key: "initTeamDraggableMobile",\n    value: function initTeamDraggableMobile() {\n      this.$teamSlider = this.$team.querySelector(\'.slider\');\n      this.$teamSliderProgress = this.$teamSlider.querySelector(\'.slider__progress\');\n      this._teamDraggable = new superDraggable_default({\n        el: this.$team,\n        snap: false,\n        snapTo: \'center\',\n        dots: false\n      });\n    }\n  }, {\n    key: "raf",\n    value: function raf() {} // eslint-disable-line\n\n  }, {\n    key: "resize",\n    value: function resize(width, height) {\n      if (!this.appStore.isDesktop) {\n        if (this._heroDraggable) this._heroDraggable.resize();\n        if (this._teamDraggable) this._teamDraggable.resize();\n      }\n    }\n  }, {\n    key: "leave",\n    value: function leave() {\n      this.renderBg.kill();\n    }\n  }]);\n\n  return RendererAbout;\n}(renderer); // Don\'t forget to export your renderer\n\n\n/* harmony default export */ const rendererAbout = (RendererAbout);\n;// CONCATENATED MODULE: ./app/src/js/renderers/rendererSingleCase.js\nfunction rendererSingleCase_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rendererSingleCase_typeof = function _typeof(obj) { return typeof obj; }; } else { rendererSingleCase_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rendererSingleCase_typeof(obj); }\n\nfunction rendererSingleCase_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rendererSingleCase_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rendererSingleCase_createClass(Constructor, protoProps, staticProps) { if (protoProps) rendererSingleCase_defineProperties(Constructor.prototype, protoProps); if (staticProps) rendererSingleCase_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rendererSingleCase_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rendererSingleCase_setPrototypeOf(subClass, superClass); }\n\nfunction rendererSingleCase_setPrototypeOf(o, p) { rendererSingleCase_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rendererSingleCase_setPrototypeOf(o, p); }\n\nfunction rendererSingleCase_createSuper(Derived) { var hasNativeReflectConstruct = rendererSingleCase_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rendererSingleCase_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rendererSingleCase_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rendererSingleCase_possibleConstructorReturn(this, result); }; }\n\nfunction rendererSingleCase_possibleConstructorReturn(self, call) { if (call && (rendererSingleCase_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return rendererSingleCase_assertThisInitialized(self); }\n\nfunction rendererSingleCase_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rendererSingleCase_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rendererSingleCase_getPrototypeOf(o) { rendererSingleCase_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rendererSingleCase_getPrototypeOf(o); }\n\n// GSAP Library\n\n\nnode_modules_gsap/* default.registerPlugin */.ZP.registerPlugin(ScrollTrigger/* default */.Z); // Import Renderer\n\n //WebGl:\n\n // Utilities\n\n\n\n\n\nvar RendererSingleCase = /*#__PURE__*/function (_Renderer) {\n  rendererSingleCase_inherits(RendererSingleCase, _Renderer);\n\n  var _super = rendererSingleCase_createSuper(RendererSingleCase);\n\n  function RendererSingleCase() {\n    rendererSingleCase_classCallCheck(this, RendererSingleCase);\n\n    return _super.apply(this, arguments);\n  }\n\n  rendererSingleCase_createClass(RendererSingleCase, [{\n    key: "selectors",\n    value: function selectors() {\n      // Sections\n      this.$hero = this.$el.querySelector(\'.singlecase__hero\');\n      this.$flexible = this.$el.querySelector(\'.singlecase__flexible\');\n      this.$footer = this.$el.querySelector(\'.singlecase__footer\');\n      this.$hubspot = this.$el.querySelector(\'.hubspot\');\n      this.$canvasFooter = this.$el.querySelector(\'#webgl_footer\'); // Flexible\n\n      if (this.$flexible) {\n        this.$flexibleText = this.$flexible.querySelectorAll(\'.flexible__text\');\n        this.$flexibleImage = this.$flexible.querySelectorAll(\'.flexible__image\');\n        this.$flexibleVideo = this.$flexible.querySelectorAll(\'.flexible__video\');\n        this.$flexibleGallery = this.$flexible.querySelectorAll(\'.flexible__gallery\');\n      }\n\n      if (this.$flexibleVideo) {\n        // this.$videoModal = document.getElementById(\'videomodal\');\n        // this.$videoModalCloser = this.$videoModal.querySelector(\'.closer\');\n        for (var i = 0; i < this.$flexibleVideo.length; i++) {\n          this.$flexibleVideoModal = this.$flexibleVideo[i].querySelector(\'.video--modal\');\n          this.$videoModalCloser = this.$flexibleVideoModal.querySelector(\'.video__closer\');\n          this.$flexibleVideoVisible = this.$flexibleVideo[i].querySelector(\'.video--visible\');\n          this.$videoVisiblePlayer = this.$flexibleVideoVisible.querySelector(\'.video__player\');\n          this.$videoVisibleTrigger = this.$flexibleVideoVisible.querySelector(\'.video__trigger\');\n          this.$videoVisiblePoster = this.$flexibleVideoVisible.querySelector(\'.video__poster\');\n        }\n      }\n    }\n  }, {\n    key: "events",\n    value: function events() {\n      var _this = this;\n\n      if (this.$flexibleVideo) {\n        for (var i = 0; i < this.$flexibleVideo.length; i++) {\n          if (this.$flexibleVideoModal.dataset.type === \'default\') {\n            this.domEvents.add(this.$flexibleVideo[i].querySelector(\'.video__trigger\'), \'click\', function () {\n              _this.openVideoDefault(_this.$flexibleVideoModal, _this.$flexibleVideoModal.dataset.type);\n            }, this);\n          }\n\n          if (!this.appStore.isDesktop) this.domEvents.add(this.$videoModalCloser, \'click\', function () {\n            _this.closeVideoDefault();\n          });\n        }\n      }\n    }\n  }, {\n    key: "preload",\n    value: function preload() {\n      var _main = [];\n      if (this.$hero.querySelector(\'.background__bg\')) _main.push(this.$hero.querySelector(\'.background__bg\').style.backgroundImage.substring(5, this.$hero.querySelector(\'.background__bg\').style.backgroundImage.length - 2));\n      this.preloadItems = {\n        main: _main,\n        secondary: []\n      };\n    }\n  }, {\n    key: "beforeEnter",\n    value: function beforeEnter() {\n      if (this.$hubspot) {\n        this.$hubspotContent = this.$hubspot.querySelector(\'.hubspot__content\');\n        var _id = this.$hubspotContent.querySelector(\'.hubspotform\').dataset.id;\n        if (_id === \'\') this.appUi.$requestButton.style.pointerEvents = \'none\';\n      }\n\n      if (this.$flexibleVideo) {\n        this.video = {\n          isAnimating: false,\n          isPlaying: false\n        };\n\n        for (var i = 0; i < this.$flexibleVideo.length; i++) {\n          if (this.$flexibleVideo[i].querySelector(\'.video--modal\').dataset.type === \'youtube\') this.setVideoYoutube();\n        }\n      } // Webgl\n\n\n      if (this.appStore.isDesktop) {\n        this.webgl_footer = new home4_Home4App({\n          renderer: this,\n          domElement: this.$canvasFooter\n        });\n      }\n    }\n  }, {\n    key: "enter",\n    value: function enter() {\n      // Start functions\n      this.init();\n    }\n  }, {\n    key: "init",\n    value: function init() {\n      this.initGalleryDraggable();\n\n      if (this.appStore.isDesktop) {\n        this.initFooterCanvasPin();\n        this.webgl_footer.init(); // this.webgl_footer = new Home4App({\n        //     renderer: this,\n        //     domElement: this.$canvasFooter\n        // });\n      }\n    }\n  }, {\n    key: "setVideoYoutube",\n    value: function setVideoYoutube() {\n      var _this2 = this;\n\n      if (!window.YT.loaded) {\n        setTimeout(function () {\n          _this2.setVideoYoutube();\n        }, 10);\n        return;\n      }\n\n      this.$videoYoutube = this.$el.querySelectorAll(\'.video__player--youtube\');\n\n      if (this.$videoYoutube) {\n        var _loop = function _loop(i) {\n          var _id = _this2.$videoYoutube[i].children[0].id;\n          var obj = new YT.Player(_id, {\n            playerVars: {\n              rel: 0,\n              showinfo: 0,\n              ecver: 2\n            },\n            videoId: _id,\n            events: {\n              onReady: function onReady(event) {\n                // const _ratio = (obj.i.height / obj.i.width) * 100;\n                // this.$videoYoutube[i].querySelector(\'.video__player\').style.setProperty(\'--ratio\', _ratio + \'%\');\n                if (_this2.superScroller) _this2.superScroller.resize();\n              },\n              onStateChange: function onStateChange(event) {\n                if (event.data === 0) _this2.closeVideoYoutube(_this2.$videoYoutube[i], obj);\n              }\n            }\n          });\n          _this2.$videoYoutube[_id] = obj;\n\n          var _loop2 = function _loop2(_i) {\n            _this2.domEvents.add(_this2.$videoVisibleTrigger, \'click\', function (a, e, el) {\n              _this2.openVideoYoutube(_this2.$videoYoutube[_i], obj);\n            }, _this2);\n          };\n\n          for (var _i = 0; _i < _this2.$flexibleVideo.length; _i++) {\n            _loop2(_i);\n          }\n\n          _this2.domEvents.add(_this2.$videoModalCloser, \'click\', function (a, e, el) {\n            _this2.closeVideoYoutube(_this2.$videoYoutube[i], obj);\n          }, _this2);\n        };\n\n        for (var i = 0; i < this.$videoYoutube.length; i++) {\n          _loop(i);\n        }\n      }\n    }\n  }, {\n    key: "openVideoDefault",\n    value: function openVideoDefault(element, type) {\n      var _this3 = this;\n\n      if (this.video.isAnimating) return;\n      this.video.isAnimating = true;\n\n      if (this.appStore.isDesktop) {\n        // Selectors\n        this.$videoVisibleEl = this.$flexibleVideoVisible.querySelector(\'video\'); // Animate in\n\n        node_modules_gsap/* default.to */.ZP.to(this.$videoVisiblePlayer, {\n          display: \'block\'\n        });\n        node_modules_gsap/* default.to */.ZP.to(this.$videoVisibleTrigger, {\n          opacity: 0.0001,\n          duration: 0.4,\n          ease: \'power2.out\'\n        });\n        node_modules_gsap/* default.to */.ZP.to(this.$videoVisiblePoster, {\n          opacity: 0.0001,\n          duration: 0.4,\n          ease: \'power2.out\',\n          onComplete: function onComplete() {\n            node_modules_gsap/* default.set */.ZP.set([_this3.$videoVisibleTrigger, _this3.$videoVisiblePoster], {\n              display: \'none\'\n            });\n          }\n        }); // Play video\n\n        this.$videoVisibleEl.play();\n        this.$videoVisibleEl.muted = false;\n        this.domEvents.add(this.$videoVisibleEl, \'ended\', function (e) {\n          _this3.closeVideoDefault();\n        });\n      } else {\n        // Animate in\n        node_modules_gsap/* default.set */.ZP.set(this.$videoModal, {\n          display: \'block\',\n          zIndex: 9999\n        });\n        node_modules_gsap/* default.to */.ZP.to(this.$videoModal, {\n          y: \'-50%\',\n          duration: 1.2,\n          ease: \'expo.inOut\'\n        });\n        node_modules_gsap/* default.to */.ZP.to(this.$videoModalCloser, {\n          opacity: 1,\n          duration: 0.4,\n          ease: \'power2.out\',\n          delay: 0.8\n        }); // Disable scroll\n\n        this.appUi.disableScroll(); // Play video\n\n        this.$videoModal.querySelector(\'video\').play();\n        this.$videoModal.querySelector(\'video\').muted = false;\n        this.domEvents.add(this.$videoModal.querySelector(\'video\'), \'ended\', function (e) {\n          _this3.closeVideoDefault(element, type);\n        });\n      }\n    }\n  }, {\n    key: "closeVideoDefault",\n    value: function closeVideoDefault(element, type) {\n      var _this4 = this;\n\n      // Pause video\n      this.$videoVisibleEl.pause();\n      this.$videoVisibleEl.muted = true;\n\n      if (this.appStore.isDesktop) {\n        // Animate out\n        node_modules_gsap/* default.set */.ZP.set([this.$videoVisibleTrigger, this.$videoVisiblePoster], {\n          display: \'block\'\n        });\n        node_modules_gsap/* default.to */.ZP.to(this.$videoVisibleTrigger, {\n          opacity: 1,\n          duration: 0.4,\n          ease: \'power2.out\'\n        });\n        node_modules_gsap/* default.to */.ZP.to(this.$videoVisiblePoster, {\n          opacity: 1,\n          duration: 0.4,\n          ease: \'power2.out\',\n          onComplete: function onComplete() {\n            node_modules_gsap/* default.to */.ZP.to(_this4.$videoVisiblePlayer, {\n              display: \'none\'\n            });\n          }\n        });\n      } else {\n        // Animation out\n        node_modules_gsap/* default.to */.ZP.to(this.$videoModalCloser, {\n          opacity: 0.0001,\n          duration: 0.4,\n          ease: \'power2.out\'\n        });\n        node_modules_gsap/* default.to */.ZP.to(this.$videoModal, {\n          y: \'-150%\',\n          duration: 1.2,\n          ease: \'expo.inOut\',\n          onComplete: function onComplete() {\n            // Enable scroll\n            _this4.appUi.enableScroll(); // Set animation\n\n\n            node_modules_gsap/* default.set */.ZP.set(_this4.$videoModal, {\n              display: \'none\',\n              y: \'100%\',\n              zIndex: 0\n            });\n            _this4.video.isAnimating = false;\n          }\n        });\n      }\n    }\n  }, {\n    key: "openVideoYoutube",\n    value: function openVideoYoutube(element, obj) {\n      var _this5 = this;\n\n      if (this.video.isAnimating) return;\n      this.video.isAnimating = true;\n\n      if (this.appStore.isDesktop) {\n        // Animate in\n        node_modules_gsap/* default.to */.ZP.to(this.$videoVisiblePlayer, {\n          display: \'block\'\n        });\n        node_modules_gsap/* default.to */.ZP.to(this.$videoVisibleTrigger, {\n          opacity: 0.0001,\n          duration: 0.4,\n          ease: \'power2.out\'\n        });\n        node_modules_gsap/* default.to */.ZP.to(this.$videoVisiblePoster, {\n          opacity: 0.0001,\n          duration: 0.4,\n          ease: \'power2.out\',\n          onComplete: function onComplete() {\n            node_modules_gsap/* default.set */.ZP.set([_this5.$videoVisibleTrigger, _this5.$videoVisiblePoster], {\n              display: \'none\'\n            });\n          }\n        }); // Play YT video\n\n        obj.playVideo();\n      } else {\n        // Animate in\n        node_modules_gsap/* default.set */.ZP.set(this.$flexibleVideoModal, {\n          display: \'block\',\n          zIndex: 9999\n        });\n        node_modules_gsap/* default.to */.ZP.to(this.$flexibleVideoModal, {\n          y: \'-50%\',\n          duration: 1.2,\n          ease: \'expo.inOut\'\n        });\n        node_modules_gsap/* default.to */.ZP.to(this.$videoModalCloser, {\n          opacity: 1,\n          duration: 0.4,\n          ease: \'power2.out\',\n          delay: 0.8\n        }); // Enable scroll\n\n        this.appUi.disableScroll(); // Play YT video \n\n        node_modules_gsap/* default.delayedCall */.ZP.delayedCall(0.8, function () {\n          obj.playVideo();\n        });\n      }\n    }\n  }, {\n    key: "closeVideoYoutube",\n    value: function closeVideoYoutube(element, obj) {\n      var _this6 = this;\n\n      // Play YT video \n      obj.pauseVideo();\n\n      if (this.appStore.isDesktop) {\n        // Animate out\n        node_modules_gsap/* default.set */.ZP.set([this.$videoVisibleTrigger, this.$videoVisiblePoster], {\n          display: \'block\'\n        });\n        node_modules_gsap/* default.to */.ZP.to(this.$videoVisibleTrigger, {\n          opacity: 1,\n          duration: 0.4,\n          ease: \'power2.out\'\n        });\n        node_modules_gsap/* default.to */.ZP.to(this.$videoVisiblePoster, {\n          opacity: 1,\n          duration: 0.4,\n          ease: \'power2.out\',\n          onComplete: function onComplete() {\n            node_modules_gsap/* default.to */.ZP.to(_this6.$videoVisiblePlayer, {\n              display: \'none\'\n            });\n          }\n        });\n      } else {\n        // Animation out\n        node_modules_gsap/* default.to */.ZP.to(this.$videoModalCloser, {\n          opacity: 0.0001,\n          duration: 0.4,\n          ease: \'power2.out\'\n        });\n        node_modules_gsap/* default.to */.ZP.to(this.$flexibleVideoModal, {\n          y: \'-150%\',\n          duration: 1.2,\n          ease: \'expo.inOut\',\n          onComplete: function onComplete() {\n            // Enable scroll\n            _this6.appUi.enableScroll(); // Set animation\n\n\n            node_modules_gsap/* default.set */.ZP.set(_this6.$flexibleVideoModal, {\n              display: \'none\',\n              y: \'100%\',\n              zIndex: 0\n            });\n            _this6.video.isAnimating = false;\n          }\n        });\n      }\n    }\n  }, {\n    key: "initGalleryDraggable",\n    value: function initGalleryDraggable() {\n      var _this7 = this;\n\n      if (this.$flexibleGallery) {\n        var _loop3 = function _loop3(i) {\n          _this7.$gallerySlider = _this7.$flexibleGallery[i].querySelectorAll(\'.slider\');\n          _this7.$gallerySliderInner = _this7.$flexibleGallery[i].querySelectorAll(\'.slider__inner\');\n          _this7.$gallerySliderItems = _this7.$flexibleGallery[i].querySelectorAll(\'.slider__item\');\n\n          for (var j = 0; j < _this7.$gallerySlider.length; j++) {\n            if (_this7.appStore.isDesktop) {\n              _this7.$gallerySliderItems = _this7.$gallerySlider[j].querySelectorAll(\'.slider__item\');\n\n              if (_this7.$gallerySliderItems.length > 2) {\n                _this7._galleryDraggable = new superDraggable_default({\n                  el: _this7.$flexibleGallery[i],\n                  snap: false,\n                  snapTo: \'center\',\n                  dots: false\n                });\n              }\n            } else {\n              _this7._galleryDraggable = new superDraggable_default({\n                el: _this7.$flexibleGallery[i],\n                target: _this7.$gallerySliderInner,\n                snap: false,\n                snapTo: \'center\',\n                dots: false,\n                onRaf: function onRaf(percent, progress, progressOrigin) {\n                  node_modules_gsap/* default.to */.ZP.to(_this7.$flexibleGallery[i].querySelector(\'.slider__progress\').children[0], {\n                    scaleX: progressOrigin + progress\n                  });\n                }\n              });\n            }\n          }\n        };\n\n        for (var i = 0; i < this.$flexibleGallery.length; i++) {\n          _loop3(i);\n        }\n      }\n    }\n  }, {\n    key: "initFooterCanvasPin",\n    value: function initFooterCanvasPin() {\n      var _this8 = this;\n\n      this._footerCanvasPin = ScrollTrigger/* default.create */.Z.create({\n        trigger: this.$footer,\n        start: \'top bottom\',\n        end: \'bottom bottom\',\n        scrub: true,\n        onUpdate: function onUpdate(self) {\n          var posY = -_this8.$canvasFooter.offsetHeight + _this8.$canvasFooter.offsetHeight * 2 * self.progress;\n          node_modules_gsap/* default.set */.ZP.set(_this8.$canvasFooter, {\n            y: posY + \'px\'\n          });\n        }\n      });\n    }\n  }, {\n    key: "raf",\n    value: function raf() {} // eslint-disable-line\n\n  }, {\n    key: "resize",\n    value: function resize(width, height) {\n      if (this._galleryDraggable) this._galleryDraggable.resize();\n    }\n  }, {\n    key: "leave",\n    value: function leave() {\n      //console.log("renderAI.leave!--------------------")\n      if (this.appStore.isDesktop) {\n        this.webgl_footer.kill();\n        this.webgl_footer = null;\n      }\n    }\n  }]);\n\n  return RendererSingleCase;\n}(renderer); // Don\'t forget to export your renderer\n\n\n/* harmony default export */ const rendererSingleCase = (RendererSingleCase);\n;// CONCATENATED MODULE: ./app/src/js/renderers/rendererThanks.js\nfunction rendererThanks_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rendererThanks_typeof = function _typeof(obj) { return typeof obj; }; } else { rendererThanks_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rendererThanks_typeof(obj); }\n\nfunction rendererThanks_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rendererThanks_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rendererThanks_createClass(Constructor, protoProps, staticProps) { if (protoProps) rendererThanks_defineProperties(Constructor.prototype, protoProps); if (staticProps) rendererThanks_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rendererThanks_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rendererThanks_setPrototypeOf(subClass, superClass); }\n\nfunction rendererThanks_setPrototypeOf(o, p) { rendererThanks_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rendererThanks_setPrototypeOf(o, p); }\n\nfunction rendererThanks_createSuper(Derived) { var hasNativeReflectConstruct = rendererThanks_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rendererThanks_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rendererThanks_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rendererThanks_possibleConstructorReturn(this, result); }; }\n\nfunction rendererThanks_possibleConstructorReturn(self, call) { if (call && (rendererThanks_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return rendererThanks_assertThisInitialized(self); }\n\nfunction rendererThanks_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction rendererThanks_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction rendererThanks_getPrototypeOf(o) { rendererThanks_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rendererThanks_getPrototypeOf(o); }\n\n// GSAP Library\n\n\nnode_modules_gsap/* default.registerPlugin */.ZP.registerPlugin(ScrollTrigger/* default */.Z); // Import Renderer\n\n // Utilities\n\n\n\n\nvar rendererThanks = /*#__PURE__*/function (_Renderer) {\n  rendererThanks_inherits(rendererThanks, _Renderer);\n\n  var _super = rendererThanks_createSuper(rendererThanks);\n\n  function rendererThanks() {\n    rendererThanks_classCallCheck(this, rendererThanks);\n\n    return _super.apply(this, arguments);\n  }\n\n  rendererThanks_createClass(rendererThanks, [{\n    key: "selectors",\n    value: function selectors() {} // eslint-disable-line\n\n  }, {\n    key: "events",\n    value: function events() {} // eslint-disable-line\n\n  }, {\n    key: "preload",\n    value: function preload() {\n      // this.preloadDelay = 1;\n      this.preloadItems = {\n        main: [],\n        secondary: []\n      };\n    }\n  }, {\n    key: "beforeEnter",\n    value: function beforeEnter() {} // eslint-disable-line\n\n  }, {\n    key: "enter",\n    value: function enter() {} // eslint-disable-line\n\n  }, {\n    key: "raf",\n    value: function raf() {} // eslint-disable-line\n\n  }, {\n    key: "resize",\n    value: function resize(width, height) {} // eslint-disable-line\n\n  }]);\n\n  return rendererThanks;\n}(renderer); // Don\'t forget to export your renderer\n\n\n/* harmony default export */ const renderers_rendererThanks = (rendererThanks);\n;// CONCATENATED MODULE: ./app/src/js/transitions/transition.js\nfunction transition_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { transition_typeof = function _typeof(obj) { return typeof obj; }; } else { transition_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return transition_typeof(obj); }\n\nfunction transition_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction transition_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction transition_createClass(Constructor, protoProps, staticProps) { if (protoProps) transition_defineProperties(Constructor.prototype, protoProps); if (staticProps) transition_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction transition_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) transition_setPrototypeOf(subClass, superClass); }\n\nfunction transition_setPrototypeOf(o, p) { transition_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return transition_setPrototypeOf(o, p); }\n\nfunction transition_createSuper(Derived) { var hasNativeReflectConstruct = transition_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = transition_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = transition_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return transition_possibleConstructorReturn(this, result); }; }\n\nfunction transition_possibleConstructorReturn(self, call) { if (call && (transition_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return transition_assertThisInitialized(self); }\n\nfunction transition_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction transition_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction transition_getPrototypeOf(o) { transition_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return transition_getPrototypeOf(o); }\n\n// App\n\n\n // Highway\n\n // Preload\n\n // GSAP Library Library\n\n // Transition\n\nvar Transition = /*#__PURE__*/function (_Highway$Transition) {\n  transition_inherits(Transition, _Highway$Transition);\n\n  var _super = transition_createSuper(Transition);\n\n  function Transition() {\n    transition_classCallCheck(this, Transition);\n\n    return _super.apply(this, arguments);\n  }\n\n  transition_createClass(Transition, [{\n    key: "out",\n    value: function out(_ref) {\n      var from = _ref.from,\n          done = _ref.done;\n      // Store\n      this.appStore = appStore; // App references\n\n      this.appCore = new app_appCore();\n      this.appUi = new app_appUi();\n      if (this.preloadMain) this.preloadMain.cancel();\n      if (this.preloadSecondary) this.preloadSecondary.cancel(); // Out animation\n\n      this.outAnimation(from, done);\n    }\n  }, {\n    key: "outAnimation",\n    value: function outAnimation(from, done) {} // eslint-disable-line\n\n  }, {\n    key: "in",\n    value: function _in(_ref2) {\n      var _this = this;\n\n      var from = _ref2.from,\n          to = _ref2.to,\n          done = _ref2.done;\n      // Store\n      this.appStore = appStore; // App references\n\n      this.appCore = new app_appCore();\n      this.appUi = new app_appUi(); // Preloader\n\n      this.preloadMain = null;\n      this.preloadSecondary = null;\n      this.preloadDelay = 0; // Lazy load\n\n      this.lazyLoad = null; // Remove Old View\n\n      from.remove(); // Reset Scroll\n\n      window.scrollTo(0, 0); // Set animation\n\n      this.setAnimation(from, to);\n      this.preloadItems = this.appCore.highway.To.preloadItems;\n\n      if (this.preloadItems.main.length > 0) {\n        var _preloadOn = new Date().getTime();\n\n        this.preloadMain = preload_it_default()();\n        this.preloadMain.fetch(this.preloadItems.main); // this.preloadMain.onprogress = (event) => { console.log(\'Primary: \' + event.progress + \'%\'); };\n\n        this.preloadMain.oncomplete = function (items) {\n          var _preloadOff = new Date().getTime();\n\n          var _preloadDifference = (_preloadOff - _preloadOn) / 1000;\n\n          var _preloadDelay = Math.max(0, _this.preloadDelay - _preloadDifference);\n\n          node_modules_gsap/* default.delayedCall */.ZP.delayedCall(_preloadDelay, function () {\n            // In animation\n            done();\n\n            _this.inAnimation(from, to, done);\n          });\n        };\n\n        if (this.preloadItems.secondary.length > 0) {\n          this.preloadSecondary = preload_it_default()();\n          this.preloadSecondary.fetch(this.preloadItems.secondary);\n\n          this.preloadSecondary.onprogress = function (event) {\n            console.log(\'Secondary: \' + event.progress + \'%\');\n          };\n        }\n      } else {\n        node_modules_gsap/* default.delayedCall */.ZP.delayedCall(this.preloadDelay, function () {\n          // In animation\n          done();\n\n          _this.inAnimation(from, to, done);\n        });\n      }\n    }\n  }, {\n    key: "setAnimation",\n    value: function setAnimation(from, to) {} // eslint-disable-line\n\n  }, {\n    key: "inAnimation",\n    value: function inAnimation(from, to, done) {} // eslint-disable-line\n\n  }]);\n\n  return Transition;\n}(highway_module/* default.Transition */.Z.Transition);\n\n/* harmony default export */ const transition = (Transition);\n;// CONCATENATED MODULE: ./app/src/js/transitions/transitionFade.js\nfunction transitionFade_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { transitionFade_typeof = function _typeof(obj) { return typeof obj; }; } else { transitionFade_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return transitionFade_typeof(obj); }\n\nfunction transitionFade_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction transitionFade_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction transitionFade_createClass(Constructor, protoProps, staticProps) { if (protoProps) transitionFade_defineProperties(Constructor.prototype, protoProps); if (staticProps) transitionFade_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction transitionFade_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) transitionFade_setPrototypeOf(subClass, superClass); }\n\nfunction transitionFade_setPrototypeOf(o, p) { transitionFade_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return transitionFade_setPrototypeOf(o, p); }\n\nfunction transitionFade_createSuper(Derived) { var hasNativeReflectConstruct = transitionFade_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = transitionFade_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = transitionFade_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return transitionFade_possibleConstructorReturn(this, result); }; }\n\nfunction transitionFade_possibleConstructorReturn(self, call) { if (call && (transitionFade_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return transitionFade_assertThisInitialized(self); }\n\nfunction transitionFade_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction transitionFade_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction transitionFade_getPrototypeOf(o) { transitionFade_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return transitionFade_getPrototypeOf(o); }\n\n// Import Transition\n // GSAP Library Library\n\n // Fade\n\nvar TransitionFade = /*#__PURE__*/function (_Transition) {\n  transitionFade_inherits(TransitionFade, _Transition);\n\n  var _super = transitionFade_createSuper(TransitionFade);\n\n  function TransitionFade() {\n    transitionFade_classCallCheck(this, TransitionFade);\n\n    return _super.apply(this, arguments);\n  }\n\n  transitionFade_createClass(TransitionFade, [{\n    key: "outAnimation",\n    value: function outAnimation(from, done) {\n      this.outDuration = 1.2;\n      node_modules_gsap/* default.fromTo */.ZP.fromTo(from, {\n        opacity: 1\n      }, {\n        opacity: 0.0001,\n        duration: this.outDuration,\n        onComplete: function onComplete() {\n          done();\n        }\n      });\n    }\n  }, {\n    key: "inAnimation",\n    value: function inAnimation(from, to, done) {\n      window.scrollTo(0, 0);\n      document.documentElement.scrollTop = 0;\n      this.inDuration = 0.6;\n      node_modules_gsap/* default.to */.ZP.to(to, {\n        opacity: 1,\n        duration: this.inDuration\n      });\n    }\n  }]);\n\n  return TransitionFade;\n}(transition);\n\n/* harmony default export */ const transitionFade = (TransitionFade);\n;// CONCATENATED MODULE: ./app/src/js/transitions/transitionMask.js\nfunction transitionMask_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { transitionMask_typeof = function _typeof(obj) { return typeof obj; }; } else { transitionMask_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return transitionMask_typeof(obj); }\n\nfunction transitionMask_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction transitionMask_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction transitionMask_createClass(Constructor, protoProps, staticProps) { if (protoProps) transitionMask_defineProperties(Constructor.prototype, protoProps); if (staticProps) transitionMask_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction transitionMask_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) transitionMask_setPrototypeOf(subClass, superClass); }\n\nfunction transitionMask_setPrototypeOf(o, p) { transitionMask_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return transitionMask_setPrototypeOf(o, p); }\n\nfunction transitionMask_createSuper(Derived) { var hasNativeReflectConstruct = transitionMask_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = transitionMask_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = transitionMask_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return transitionMask_possibleConstructorReturn(this, result); }; }\n\nfunction transitionMask_possibleConstructorReturn(self, call) { if (call && (transitionMask_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return transitionMask_assertThisInitialized(self); }\n\nfunction transitionMask_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction transitionMask_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction transitionMask_getPrototypeOf(o) { transitionMask_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return transitionMask_getPrototypeOf(o); }\n\n// Import Transition\n // GSAP Library Library\n\n // Mask\n\nvar TransitionMask = /*#__PURE__*/function (_Transition) {\n  transitionMask_inherits(TransitionMask, _Transition);\n\n  var _super = transitionMask_createSuper(TransitionMask);\n\n  function TransitionMask() {\n    transitionMask_classCallCheck(this, TransitionMask);\n\n    return _super.apply(this, arguments);\n  }\n\n  transitionMask_createClass(TransitionMask, [{\n    key: "outAnimation",\n    value: function outAnimation(from, done) {\n      this.outDuration = 1;\n      node_modules_gsap/* default.set */.ZP.set(this.appUi.$mask, {\n        display: \'block\'\n      });\n      node_modules_gsap/* default.fromTo */.ZP.fromTo(this.appUi.$mask.children[0], {\n        y: \'100%\'\n      }, {\n        y: \'0%\',\n        duration: this.outDuration,\n        ease: \'power4.in\',\n        onComplete: function onComplete() {\n          console.log(\'-- out Done\');\n          done();\n        }\n      });\n    }\n  }, {\n    key: "inAnimation",\n    value: function inAnimation(from, to, done) {\n      var _this = this;\n\n      this.inDuration = 1;\n      node_modules_gsap/* default.to */.ZP.to(this.appUi.$mask.children[0], {\n        y: \'-100%\',\n        duration: this.inDuration,\n        ease: \'power4.out\',\n        onComplete: function onComplete() {\n          console.log(\'-- in Done\');\n          node_modules_gsap/* default.set */.ZP.set(_this.appUi.$mask, {\n            display: \'none\'\n          });\n        }\n      });\n    }\n  }]);\n\n  return TransitionMask;\n}(transition);\n\n/* harmony default export */ const transitionMask = (TransitionMask);\n;// CONCATENATED MODULE: ./app/src/js/app/appCore.js\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = appCore_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }\n\nfunction appCore_toConsumableArray(arr) { return appCore_arrayWithoutHoles(arr) || appCore_iterableToArray(arr) || appCore_unsupportedIterableToArray(arr) || appCore_nonIterableSpread(); }\n\nfunction appCore_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction appCore_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return appCore_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return appCore_arrayLikeToArray(o, minLen); }\n\nfunction appCore_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction appCore_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return appCore_arrayLikeToArray(arr); }\n\nfunction appCore_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction appCore_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction appCore_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction appCore_createClass(Constructor, protoProps, staticProps) { if (protoProps) appCore_defineProperties(Constructor.prototype, protoProps); if (staticProps) appCore_defineProperties(Constructor, staticProps); return Constructor; }\n\n// App\n\n // Classes\n\n // Highway\n\n // Import Renderers\n\n\n\n\n\n\n\n\n // Import Transitions\n\n\n // GSAP Library\n\n\nvar appCore_singleton = null;\n\nvar appCore = /*#__PURE__*/function () {\n  function appCore(data) {\n    appCore_classCallCheck(this, appCore);\n\n    if (!appCore_singleton) {\n      this.data = data;\n      appCore_singleton = this;\n    } else {\n      return appCore_singleton;\n    } // Store\n\n\n    this.appStore = appStore; // App references\n\n    this.appUi = new app_appUi(); // Events\n\n    this.domEvents = new domEvents_default(); // Highway core\n\n    this.highway = null; // Global vars\n\n    this.appStore.isDesktop = window.innerWidth > 1100;\n  }\n\n  appCore_createClass(appCore, [{\n    key: "init",\n    value: function init() {\n      var _this = this;\n\n      // Call Highway.Core once.\n      this.highway = new highway_module/* default.Core */.Z.Core({\n        renderers: {\n          "default": rendererDefault,\n          home: rendererHome,\n          ai: rendererAI,\n          data: rendererData,\n          about: rendererAbout,\n          singlecase: rendererSingleCase,\n          thanks: renderers_rendererThanks\n        },\n        transitions: {\n          "default": transitionFade,\n          contextual: {\n            mask: transitionMask\n          }\n        }\n      }); // On load:\n      // Query admin bar links and detach them from Highway transitions\n\n      var adminBarLinks = document.querySelectorAll(\'#wpadminbar a\');\n      if (adminBarLinks) this.highway.detach(adminBarLinks); // Unset cookies bar links to prevent reload the page\n\n      var cookiesLinks = document.querySelectorAll(\'#cookie-law-info-bar a\');\n      if (cookiesLinks) this.highway.detach(cookiesLinks);\n      this.highway.on(\'NAVIGATE_IN\', function (_ref) {\n        var to = _ref.to,\n            trigger = _ref.trigger,\n            location = _ref.location;\n\n        _this.navigateIn(to, trigger, location);\n      });\n      this.highway.on(\'NAVIGATE_OUT\', function (_ref2) {\n        var from = _ref2.from,\n            trigger = _ref2.trigger,\n            location = _ref2.location;\n\n        _this.navigateOut(from, trigger, location);\n      });\n      this.highway.on(\'NAVIGATE_END\', function (_ref3) {\n        var to = _ref3.to,\n            from = _ref3.from,\n            trigger = _ref3.trigger,\n            location = _ref3.location;\n\n        _this.navigateEnd(to, from, trigger, location);\n      });\n    }\n  }, {\n    key: "navigateStart",\n    value: function navigateStart() {\n      // Start navigation on 0\n      window.scrollTo(0, 0);\n      document.documentElement.scrollTop = 0;\n      if (window.history.scrollRestoration) window.history.scrollRestoration = \'manual\';\n    }\n  }, {\n    key: "navigateOut",\n    value: function navigateOut(from, trigger, location) {\n      this.appStore.from = from.view.dataset.routerView;\n      this.appUi.closeMenu(); // Hide header\n\n      this.appUi.hideHeader();\n    }\n  }, {\n    key: "navigateIn",\n    value: function navigateIn(to, trigger, location) {\n      this.appStore.to = to.view.dataset.routerView;\n      if (!this.appStore.isDesktop) document.documentElement.scrollTop = 0; // Add background color\n\n      if (this.appStore.to === \'home\' || this.appStore.to === \'singlecase\' || this.appStore.to === \'default\') this.appUi.goLight();else this.appUi.goDark(); // Remove active item\n\n      if (this.appUi.$menu.querySelector(\'.is-active\')) this.appUi.$menu.querySelector(\'.is-active\').classList.remove(\'is-active\'); // Add active item\n\n      if (this.appUi.$menu.querySelector(\'.menu-item--\' + this.appStore.to)) this.appUi.$menu.querySelector(\'.menu-item--\' + this.appStore.to).classList.add(\'is-active\');\n    }\n  }, {\n    key: "navigateEnd",\n    value: function navigateEnd(to, from, trigger, location) {\n      var _this2 = this;\n\n      this.appStore.to = to.view.dataset.routerView;\n      if (!this.appStore.isDesktop) document.documentElement.scrollTop = 0; // Set classes\n\n      document.querySelector(\'body\').setAttribute(\'class\', to.page.body.getAttribute(\'class\'));\n      if (this.appStore.to !== \'home\') document.body.classList.add(\'light\');else document.body.classList.remove(\'light\');\n      if (this.appStore.to === \'default\') document.body.classList.remove(\'light\'); // Show header\n\n      if (this.appStore.to !== \'home\') node_modules_gsap/* default.delayedCall */.ZP.delayedCall(1.2, function () {\n        _this2.appUi.showHeader();\n      }); // Add background color\n\n      if (this.appStore.to === \'home\' || this.appStore.to === \'singlecase\' || this.appStore.to === \'default\') this.appUi.goLight();else this.appUi.goDark(); // Query admin bar links, and new page\'s admin bar links\n\n      var adminBarLinks = document.querySelectorAll(\'#wpadminbar a\');\n      var newAdminBarLinks = to.page.body.querySelectorAll(\'#wpadminbar a\'); // Replace every admin bar link\'s href value with new value\n\n      if (adminBarLinks) {\n        for (var i = 0; i < newAdminBarLinks.length; i++) {\n          adminBarLinks[i].href = newAdminBarLinks[i].href;\n        } // Detach admin bar links from Highway transitions\n\n\n        this.highway.detach(adminBarLinks);\n      } // this.manageScripts(to);\n\n    }\n  }, {\n    key: "manageScripts",\n    value: function manageScripts(to) {\n      // Your main JS file, used to prepend other scripts\n      var main = document.querySelector(\'#main-script\');\n\n      var a = appCore_toConsumableArray(to.page.querySelectorAll(\'script:not([data-no-reload])\'));\n\n      var b = appCore_toConsumableArray(document.querySelectorAll(\'script:not([data-no-reload])\')); // Compare Scripts\n\n\n      for (var i = 0; i < b.length; i++) {\n        var c = b[i];\n\n        for (var j = 0; j < a.length; j++) {\n          var d = a[j];\n\n          if (c.outerHTML === d.outerHTML) {\n            // Create Shadow Script\n            var script = document.createElement(c.tagName); // Loop Over Attributes\n\n            for (var k = 0; k < c.attributes.length; k++) {\n              // Get Attribute\n              var attr = c.attributes[k]; // Set Attribute\n\n              script.setAttribute(attr.nodeName, attr.nodeValue);\n            } // Inline Script\n\n\n            if (c.innerHTML) script.innerHTML = c.innerHTML; // Replace\n\n            c.parentNode.replaceChild(script, c); // Clean Arrays\n\n            b.splice(i, 1);\n            a.splice(j, 1); // Exit Loop\n\n            break;\n          }\n        }\n      } // Remove Useless\n\n\n      var _iterator = _createForOfIteratorHelper(b),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _script = _step.value;\n\n          // Remove\n          _script.parentNode.removeChild(_script);\n        } // Add Scripts\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(a),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _script2 = _step2.value;\n          var loc = _script2.parentNode.tagName;\n          if (loc === \'HEAD\') document.head.appendChild(_script2);\n          if (loc === \'BODY\') document.body.insertBefore(_script2, main);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: "selectors",\n    value: function selectors() {} // eslint-disable-line\n\n  }, {\n    key: "events",\n    value: function events() {} // eslint-disable-line\n\n  }, {\n    key: "resize",\n    value: function resize(width, height) {} // eslint-disable-line\n\n  }]);\n\n  return appCore;\n}();\n\n/* harmony default export */ const app_appCore = (appCore);\n;// CONCATENATED MODULE: ./app/src/js/utils/debounce.js\n//Copyright 2018 Vicente Lucendo - vicen@vlucendo.com\n//simple debounce with callback\n/* harmony default export */ function debounce(callback, delay) {\n  var timeout;\n  return function () {\n    clearTimeout(timeout);\n    timeout = setTimeout(callback, delay);\n  };\n}\n;\n// EXTERNAL MODULE: ./node_modules/bowser/es5.js\nvar es5 = __webpack_require__(1206);\nvar es5_default = /*#__PURE__*/__webpack_require__.n(es5);\n;// CONCATENATED MODULE: ./app/src/js/app/app.js\nfunction app_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction app_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction app_createClass(Constructor, protoProps, staticProps) { if (protoProps) app_defineProperties(Constructor.prototype, protoProps); if (staticProps) app_defineProperties(Constructor, staticProps); return Constructor; }\n\n// css\n // eslint-disable-line\n// App\n\n\n\n // Classes\n\n // GSAP Library\n// import gsap from \'gsap\';\n// Utils\n\n\n\n\nvar Application = /*#__PURE__*/function () {\n  function Application(options) {\n    app_classCallCheck(this, Application);\n\n    // Store\n    this.appStore = appStore; // App references\n\n    this.appCore = new app_appCore();\n    this.appUi = new app_appUi(); // Events\n\n    this.domEvents = new domEvents_default(); // Get current url\n\n    this.appStore.rootUrl = window.location.protocol + \'// \' + window.location.host; // Get client info\n\n    var clientInfo = es5_default().getParser(window.navigator.userAgent).parsedResult;\n    this.setOS(clientInfo);\n    this.setDevice(clientInfo);\n    this.checkElements();\n    this.addClasses();\n    this.sayHello();\n    this.selectors();\n    this.events();\n    this.init();\n  }\n\n  app_createClass(Application, [{\n    key: "setOS",\n    value: function setOS(clientInfo) {\n      var os = clientInfo.os.name.toLowerCase(); // Detect mac and ios, default windows\n\n      switch (os) {\n        case \'macos\':\n          this.appStore.client.os = \'mac\';\n          break;\n\n        case \'ios\':\n          this.appStore.client.os = \'ios\';\n          break;\n\n        default:\n          this.appStore.client.os = \'windows\';\n      }\n    }\n  }, {\n    key: "setDevice",\n    value: function setDevice(clientInfo) {\n      // Get device\n      this.appStore.client.device = clientInfo.platform.type === \'desktop\' ? \'desktop\' : \'mobile\'; // Detect browser (only the major ones, default is chrome)\n\n      switch (clientInfo.browser.name) {\n        case \'Internet Explorer\':\n          this.appStore.client.browser = \'explorer\';\n          break;\n\n        case \'Microsoft Edge\':\n          this.appStore.client.browser = \'edge\';\n          break;\n\n        case \'Firefox\':\n          this.appStore.client.browser = \'firefox\';\n          break;\n\n        case \'Safari\':\n          this.appStore.client.browser = \'safari\';\n          break;\n\n        default:\n          this.appStore.client.browser = \'chrome\';\n      }\n    }\n  }, {\n    key: "checkElements",\n    value: function checkElements() {\n      if (this.appStore.isDesktop) {\n        this.$elementsMobile = document.querySelectorAll(\'[data-mobile]\');\n\n        for (var i = 0; i < this.$elementsMobile.length; i++) {\n          this.$elementsMobile[i].remove();\n        }\n      } else {\n        this.$elementsDesktop = document.querySelectorAll(\'[data-desktop]\');\n\n        for (var _i = 0; _i < this.$elementsDesktop.length; _i++) {\n          this.$elementsDesktop[_i].remove();\n        }\n      }\n    }\n  }, {\n    key: "addClasses",\n    value: function addClasses() {\n      document.documentElement.classList.add(this.appStore.client.device);\n      document.documentElement.classList.add(this.appStore.client.os);\n      document.documentElement.classList.add(this.appStore.client.browser);\n    }\n  }, {\n    key: "sayHello",\n    value: function sayHello() {\n      if (this.appStore.client.browser === \'chrome\' || this.appStore.client.browser === \'firefox\') {\n        var args = [\'\\n%c Developed with ♥ by Dgrees® - https:// dgrees.studio %c\\n\', \'display: block; padding: 5px 10px; background: #000022; line-height: 40px; color: #ffffff;\', \'background: #fff;\'];\n        window.console.log.apply(console, args);\n      } else {\n        window.console.log(\'Developed by Dgrees®\');\n      }\n    }\n  }, {\n    key: "selectors",\n    value: function selectors() {\n      this.appCore.selectors();\n      this.appUi.selectors();\n    }\n  }, {\n    key: "events",\n    value: function events() {\n      var _this = this;\n\n      // Bind debounced resize\n      this.domEvents.add(window, \'resize\', debounce(function () {\n        _this.resize(window.innerWidth, window.innerHeight);\n      }, 150));\n      this.appCore.events();\n      this.appUi.events();\n    }\n  }, {\n    key: "init",\n    value: function init() {\n      this.appCore.init();\n      this.appUi.init(); // First we get the viewport height and we multiple it by 1% to get a value for a vh unit\n\n      var vh = window.innerHeight * 0.01;\n      this.appStore.vars.vh = vh * 100;\n      document.documentElement.style.setProperty(\'--vh\', "".concat(vh, "px"));\n      var vho = window.outerHeight * 0.01;\n      this.appStore.vars.vho = vho * 100;\n      document.documentElement.style.setProperty(\'--vho\', "".concat(vho, "px"));\n      var vhr = document.getElementById(\'vhr\').getBoundingClientRect().height * 0.01;\n      this.appStore.vars.vhr = vhr * 100;\n      document.documentElement.style.setProperty(\'--vhr\', "".concat(vhr, "px"));\n      var vhd = vhr - vh;\n      this.appStore.vars.vhd = vhd * 100;\n      document.documentElement.style.setProperty(\'--vhd\', "".concat(vhd, "px"));\n      this.resize(window.innerWidth, window.innerHeight);\n    }\n  }, {\n    key: "resize",\n    value: function resize(width, height) {\n      // First we get the viewport height and we multiple it by 1% to get a value for a vh unit\n      var vh = window.innerHeight * 0.01;\n      document.documentElement.style.setProperty(\'--vh\', "".concat(vh, "px")); // Set size vars\n\n      this.appStore.client.sizes.width = width;\n      this.appStore.client.sizes.height = height;\n      this.appCore.resize(width, height);\n      this.appUi.resize(width, height);\n      if (this.appStore.currentSection !== null) this.appStore.currentSection.beforeResize(width, height);\n    }\n    /* _checkOrientation()\n    {\n        // if it\'s not affected by orientation pass the current one (0: horizontal, 1: vertical)\n        if(this.orientation === orientations.NONE)\n            this.// (this.appStore.client.sizes.width > this.appStore.client.sizes.height ? 0 : 1);\n         if(this.orientation === orientations.VERTICAL)\n        {\n            // if width is bigger than height\n            if(this.appStore.client.sizes.width > this.appStore.client.sizes.height)\n                this.rotateDevice(true);\n            else\n                this.rotateDevice(false);\n        }\n        else if(this.orientation === orientations.HORIZONTAL)\n        {\n            // if height is bigger than width\n            if(this.appStore.client.sizes.height > this.appStore.client.sizes.width)\n                this.rotateDevice(true);\n            else\n                this.rotateDevice(false);\n        }\n    } */\n    // rotateDevice(action){} // eslint-disable-line\n\n  }]);\n\n  return Application;\n}();\n\n/* harmony default export */ const app_app = (Application);\n;// CONCATENATED MODULE: ./app/src/js/loader.js\n// apps\n // on document ready create loader\n\nif (document.readyState !== \'loading\') {\n  var app = new app_app();\n} else {\n  document.addEventListener(\'DOMContentLoaded\', function () {\n    var app = new app_app();\n  }, false); //eslint-disable-line\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQ5NS5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0bUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2p6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxREE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekxBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekxBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdmNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1b0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25YQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL2lDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyZkE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvYXBwL2FwcFN0b3JlLmpzPzkxYmEiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy91dGlscy9zdHJpbmcuanM/ZWUyOCIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3V0aWxzL2lzLmpzP2Y1NGUiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy9jbGFzc2VzL2RvbUV2ZW50cy5qcz9lYTM4Iiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvdXRpbHMvc3RyaW5ncy5qcz80NTFhIiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvY2xhc3Nlcy9zcGxpdFRleHQuanM/NzY3MSIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL2FwcC9hcHBVaS5qcz82MTIyIiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvY2xhc3Nlcy9zdXBlclNjcm9sbGVyLmpzPzA2OGUiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy9yZW5kZXJlcnMvcmVuZGVyZXIuanM/MjgzYyIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3JlbmRlcmVycy9yZW5kZXJlckRlZmF1bHQuanM/ODE2NiIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL1dlYkdMVXRpbHMuanM/MDU0YSIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2hvbWUxL3NoYWRlcnMvaG9tZTFfZG90c192ZXJ0ZXguZ2xzbD9lYTg3Iiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvd2ViZ2wvaG9tZTEvc2hhZGVycy9ob21lMV9kb3RzX2ZyYWdtZW50Lmdsc2w/MzgzYiIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL0V2ZW50UHJvZ3Jlc3MuanM/ZGUyYSIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL0Vhc2VkT3V0VmFsdWUuanM/NjlmNCIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2hvbWUxL0hvbWUxR2VvbWV0cnkuanM/N2U2ZCIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2hvbWUxL0hvbWUxRG90cy5qcz82OTA1Iiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvd2ViZ2wvaG9tZTEvSG9tZTFBcHAuanM/ZTIyMyIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2hvbWUyL0hvbWUyR2VvbWV0cnkuanM/MTM1OCIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2hvbWUyL3NoYWRlcnMvaG9tZTJfZG90c192ZXJ0ZXguZ2xzbD82M2RiIiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvd2ViZ2wvaG9tZTIvc2hhZGVycy9ob21lMl9kb3RzX2ZyYWdtZW50Lmdsc2w/OTIyMiIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2hvbWUyL0hvbWUyRG90cy5qcz8zMDg4Iiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvd2ViZ2wvaG9tZTIvSG9tZTJBcHAuanM/NjEwNSIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2hvbWUzL0hvbWUzR2VvbWV0cnkuanM/MTZmNSIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2hvbWUzL3NoYWRlcnMvaG9tZTNfZG90c192ZXJ0ZXguZ2xzbD9hMzhlIiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvd2ViZ2wvaG9tZTMvc2hhZGVycy9ob21lM19kb3RzX2ZyYWdtZW50Lmdsc2w/M2VhYyIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2hvbWUzL0hvbWUzRG90cy5qcz9mMzc0Iiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvd2ViZ2wvaG9tZTMvSG9tZTNBcHAuanM/Y2U3NiIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL0xvYWRlZEdlb21ldHJ5LmpzPzNhNWIiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy93ZWJnbC9ob21lNC9Ib21lNEdlb21ldHJ5LmpzP2VlYWIiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy93ZWJnbC9ob21lNC9zaGFkZXJzL2hvbWU0X2RvdHNfdmVydGV4Lmdsc2w/YmI1OCIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2hvbWU0L3NoYWRlcnMvaG9tZTRfZG90c19mcmFnbWVudC5nbHNsPzNiY2EiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy93ZWJnbC9ob21lNC9Ib21lNERvdHMuanM/MzZmNyIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2hvbWU0L0hvbWU0QXBwLmpzP2JjZGMiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy93ZWJnbC9ob21lMV9tL0hvbWUxU2Nyb2xsX20uanM/YTFiZSIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2hvbWUxX20vc2hhZGVycy9ob21lMV9kb3RzX3ZlcnRleF9tLmdsc2w/ZGYxYyIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2hvbWUxX20vc2hhZGVycy9ob21lMV9kb3RzX2ZyYWdtZW50X20uZ2xzbD8xNmIyIiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvd2ViZ2wvaG9tZTFfbS9Ib21lMUdlb21ldHJ5X20uanM/YTBlYyIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2hvbWUxX20vSG9tZTFEb3RzX20uanM/ZTk1MyIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2hvbWUxX20vSG9tZTFBcHBfbS5qcz9kMDQxIiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvd2ViZ2wvaG9tZTJfbS9Ib21lMlNjcm9sbF9tLmpzPzcxNzgiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy93ZWJnbC9ob21lMl9tL3NoYWRlcnMvaG9tZTJfZG90c192ZXJ0ZXhfbS5nbHNsPzA2Y2QiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy93ZWJnbC9ob21lMl9tL3NoYWRlcnMvaG9tZTJfZG90c19mcmFnbWVudF9tLmdsc2w/YWNlOSIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2hvbWUyX20vSG9tZTJHZW9tZXRyeV9tLmpzPzMzNTciLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy93ZWJnbC9ob21lMl9tL0hvbWUyRG90c19tLmpzP2UyZDAiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy93ZWJnbC9ob21lMl9tL0hvbWUyQXBwX20uanM/OWJkZSIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3V0aWxzL1ZlbG9jaXR5VHJhY2tlci5qcz9hOGY1Iiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvY2xhc3Nlcy9JbmVydGlhUGx1Z2luLmpzPzg0M2UiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy9jbGFzc2VzL3N1cGVyRHJhZ2dhYmxlLmpzP2Q4ZmEiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy9jb21wb25lbnRzL3NsaWRlclNvbHV0aW9ucy5qcz80YjdlIiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvcmVuZGVyZXJzL3JlbmRlcmVySG9tZS5qcz8yNjlkIiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvd2ViZ2wvRXZlbnRQcm9jZXNzLmpzPzM3ZWYiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy93ZWJnbC9zb2x1dGlvbnMxL1NvbHV0aW9uczFHZW9tZXRyeS5qcz9kNzc5Iiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvd2ViZ2wvc29sdXRpb25zMS9zaGFkZXJzL3NvbHV0aW9uczFfZG90c192ZXJ0ZXguZ2xzbD9hZjM1Iiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvd2ViZ2wvc29sdXRpb25zMS9zaGFkZXJzL3NvbHV0aW9uczFfZG90c19mcmFnbWVudC5nbHNsPzIyZTkiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy93ZWJnbC9zb2x1dGlvbnMxL1NvbHV0aW9uczFEb3RzLmpzPzkwN2QiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy93ZWJnbC9zb2x1dGlvbnMxL1NvbHV0aW9uczFBcHAuanM/M2Y1MiIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3JlbmRlcmVycy9yZW5kZXJlckFJLmpzPzBkMjgiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy9yZW5kZXJlcnMvcmVuZGVyZXJEYXRhLmpzPzRjMzkiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy91dGlscy9wYXRocy5qcz83NWI3Iiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvY2xhc3Nlcy9tb3JwaFNWR1BsdWdpbi5qcz9kZjMwIiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvd2ViZ2wvYWJvdXQxL0Fib3V0MUdlb21ldHJ5LmpzPzk1NDMiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy93ZWJnbC9hYm91dDEvQWJvdXQxRG90UHVsc2UuanM/NzE4MiIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2Fib3V0MS9BYm91dDFQdWxzZXMuanM/OTQ5NSIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2Fib3V0MS9zaGFkZXJzL2Fib3V0RG90c192ZXJ0ZXguZ2xzbD9hZWYwIiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvd2ViZ2wvYWJvdXQxL3NoYWRlcnMvYWJvdXREb3RzX2ZyYWdtZW50Lmdsc2w/YWFlMiIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2Fib3V0MS9BYm91dDFEb3RzLmpzP2VjZjAiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy93ZWJnbC9hYm91dDEvc2hhZGVycy9ncmFkaWVudEJhY2tncm91bmRfdmVydGV4Lmdsc2w/YjMyMyIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3dlYmdsL2Fib3V0MS9zaGFkZXJzL2dyYWRpZW50QmFja2dyb3VuZF9mcmFnbWVudC5nbHNsPzYzZTMiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy93ZWJnbC9hYm91dDEvQWJvdXQxQmFja2dyb3VuZC5qcz8zYTMwIiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvd2ViZ2wvYWJvdXQxL0Fib3V0MUFwcC5qcz9kNTVkIiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvcmVuZGVyZXJzL3JlbmRlcmVyQWJvdXQuanM/NDhmMCIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3JlbmRlcmVycy9yZW5kZXJlclNpbmdsZUNhc2UuanM/NDNjZiIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3JlbmRlcmVycy9yZW5kZXJlclRoYW5rcy5qcz82MWE2Iiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvdHJhbnNpdGlvbnMvdHJhbnNpdGlvbi5qcz9hNTg5Iiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvdHJhbnNpdGlvbnMvdHJhbnNpdGlvbkZhZGUuanM/YWJlOCIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL3RyYW5zaXRpb25zL3RyYW5zaXRpb25NYXNrLmpzP2M3NTEiLCJ3ZWJwYWNrOi8vbWlvdGljb25zdWx0aW5nLy4vYXBwL3NyYy9qcy9hcHAvYXBwQ29yZS5qcz8xNmIwIiwid2VicGFjazovL21pb3RpY29uc3VsdGluZy8uL2FwcC9zcmMvanMvdXRpbHMvZGVib3VuY2UuanM/Zjg0YyIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL2FwcC9hcHAuanM/OTkxNCIsIndlYnBhY2s6Ly9taW90aWNvbnN1bHRpbmcvLi9hcHAvc3JjL2pzL2xvYWRlci5qcz9mOTYzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcbiAgbWFpbjogbnVsbCxcbiAgcm9vdFVybDogbnVsbCxcbiAgaXNEZXNrdG9wOiBudWxsLFxuICBmaXJzdE5hdmlnYXRpb246IG51bGwsXG4gIGZyb206IG51bGwsXG4gIHRvOiBudWxsLFxuICBjdXJyZW50OiBudWxsLFxuICBjdXJyZW50U2VjdGlvbjogbnVsbCxcbiAgY2xpZW50OiB7XG4gICAgYnJvd3NlcjogJycsXG4gICAgZGV2aWNlOiAnJyxcbiAgICBsYW5nOiAnZXMnLFxuICAgIG9zOiAnJyxcbiAgICBzaXplczoge1xuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICB9LFxuICAgIG1vdXNlUG9zaXRpb246IHtcbiAgICAgIHg6IHdpbmRvdy5pbm5lcldpZHRoIC8gMixcbiAgICAgIHk6IHdpbmRvdy5pbm5lckhlaWdodCAvIDJcbiAgICB9XG4gIH0sXG4gIHZhcnM6IHtcbiAgICB2aDogMCxcbiAgICB2aG86IDAsXG4gICAgdmhyOiAwLFxuICAgIHZoZDogMFxuICB9XG59OyIsIi8vQ29weXJpZ2h0IDIwMTggVmljZW50ZSBMdWNlbmRvIC0gdmljZW5Admx1Y2VuZG8uY29tXG5leHBvcnQgdmFyIHN0cmluZyA9IHtcbiAgLy9jb252ZXJ0cyBhIHN0cmluZyBudW1iZXIgJyNGRkZGRkYnIHRvIGhleCAweGZmZmZmZiAtIGl0IGdldHMgdXNlZCBvbiBwaXhpXG4gIHRvSGV4OiBmdW5jdGlvbiB0b0hleChzdHIpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoc3RyLnN1YnN0cmluZygxKSwgMTYpO1xuICB9LFxuICAvL3RydWUgb3IgZmFsc2UgaWYgdGV4dCBpcyBvbiB0aGUgc3RyaW5nXG4gIGNvbnRhaW5zOiBmdW5jdGlvbiBjb250YWlucyhzdHIsIHRleHQpIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2YodGV4dCkgPiAtMTtcbiAgfVxufTsiLCIvL0NvcHlyaWdodCAyMDE4IFZpY2VudGUgTHVjZW5kbyAtIHZpY2VuQHZsdWNlbmRvLmNvbVxuaW1wb3J0IHsgc3RyaW5nIH0gZnJvbSAnLi9zdHJpbmcnO1xuZXhwb3J0IHZhciBpcyA9IHtcbiAgYXJyYXk6IGZ1bmN0aW9uIGFycmF5KGEpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhKTtcbiAgfSxcbiAgb2JqZWN0OiBmdW5jdGlvbiBvYmplY3QoYSkge1xuICAgIHJldHVybiBzdHJpbmcuY29udGFpbnMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpLCAnT2JqZWN0Jyk7XG4gIH0sXG4gIHBhdGg6IGZ1bmN0aW9uIHBhdGgoYSkge1xuICAgIHJldHVybiBpcy5vYmooYSkgJiYgYS5oYXNPd25Qcm9wZXJ0eSgndG90YWxMZW5ndGgnKTtcbiAgfSxcbiAgLy9lc2xpbnQtZGlzYWJsZS1saW5lXG4gIHN2ZzogZnVuY3Rpb24gc3ZnKGEpIHtcbiAgICByZXR1cm4gYSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XG4gIH0sXG4gIG5vZGU6IGZ1bmN0aW9uIG5vZGUoYSkge1xuICAgIHJldHVybiBhLm5vZGVUeXBlIHx8IGlzLnN2ZyhhKTtcbiAgfSxcbiAgbm9kZUxpc3Q6IGZ1bmN0aW9uIG5vZGVMaXN0KGEpIHtcbiAgICByZXR1cm4gYSBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IGEgaW5zdGFuY2VvZiBIVE1MQ29sbGVjdGlvbjtcbiAgfSxcbiAgc3RyaW5nOiBmdW5jdGlvbiBzdHJpbmcoYSkge1xuICAgIHJldHVybiB0eXBlb2YgYSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIG51bWJlcjogZnVuY3Rpb24gbnVtYmVyKGEpIHtcbiAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQoYSkpICYmIGlzRmluaXRlKGEpO1xuICB9LFxuICBcImZ1bmN0aW9uXCI6IGZ1bmN0aW9uIF9mdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhID09PSAnZnVuY3Rpb24nO1xuICB9LFxuICB1bmRlZmluZWQ6IGZ1bmN0aW9uIHVuZGVmaW5lZChhKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhID09PSAndW5kZWZpbmVkJztcbiAgfSxcbiAgaGV4OiBmdW5jdGlvbiBoZXgoYSkge1xuICAgIHJldHVybiAvKF4jWzAtOUEtRl17Nn0kKXwoXiNbMC05QS1GXXszfSQpL2kudGVzdChhKTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbiByZ2IoYSkge1xuICAgIHJldHVybiAvXnJnYi8udGVzdChhKTtcbiAgfSxcbiAgaHNsOiBmdW5jdGlvbiBoc2woYSkge1xuICAgIHJldHVybiAvXmhzbC8udGVzdChhKTtcbiAgfSxcbiAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKGEpIHtcbiAgICByZXR1cm4gaXMuaGV4KGEpIHx8IGlzLnJnYihhKSB8fCBpcy5oc2woYSk7XG4gIH1cbn07IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vL0NvcHlyaWdodCAyMDE4IFZpY2VudGUgTHVjZW5kbyAtIHZpY2VuQHZsdWNlbmRvLmNvbVxuaW1wb3J0IHsgaXMgfSBmcm9tICcuLi91dGlscy9pcyc7XG5cbnZhciBfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICB0aGlzLl9ldmVudENhY2hlID0gW107XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcIl9yZW1vdmVFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRXZlbnQoaW5kZXgpIHtcbiAgICAgIC8vcmVtb3ZlIGV2ZW50IGxpc3RlbmVyXG4gICAgICB0aGlzLl9ldmVudENhY2hlW2luZGV4XS5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fZXZlbnRDYWNoZVtpbmRleF0uYWN0aW9uLCB0aGlzLl9ldmVudENhY2hlW2luZGV4XS5jYik7IC8vcmVtb3ZlIGVsZW1lbnQgZnJvbSBldmVudGNhY2hlXG5cblxuICAgICAgdGhpcy5fZXZlbnRDYWNoZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKG5vZGUsIGV2ZW50TmFtZSwgX2Z1bmMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICAgIHZhciBhcmcgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuICAgICAgdmFyIHJMaW5rID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBmYWxzZTtcblxuICAgICAgLy9ub2RlbGlzdCBvciBzaW5nbGUgbm9kZT9cbiAgICAgIHZhciBfbm9kZXMgPSBpcy5ub2RlTGlzdChub2RlKSB8fCBpcy5hcnJheShub2RlKSA/IG5vZGUgOiBbbm9kZV07IC8vbG9vcCB0aG91Z2ggdGhlIG5vZGVzXG5cblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICAvL2NyZWF0ZSBjYWxsYmFjayBwYXNzaW5nIHRoZSBldmVudCwgYXJndW1lbnQgYW5kIHNvdXJjZSBub2RlXG4gICAgICAgIHZhciBfY2IgPSBjb250ZXh0ICE9PSBmYWxzZSA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgX2Z1bmMuY2FsbChjb250ZXh0LCBlLCBhcmcsIF9ub2Rlc1tpXSk7XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIF9mdW5jKGUsIGFyZywgX25vZGVzW2ldKTtcbiAgICAgICAgfTsgLy9hZGQgdGhlIGV2ZW50IHRvIHRoZSBub2RlIGV2ZW50IGNhY2hlXG5cblxuICAgICAgICBfdGhpcy5fZXZlbnRDYWNoZS5wdXNoKHtcbiAgICAgICAgICBub2RlOiBfbm9kZXNbaV0sXG4gICAgICAgICAgYWN0aW9uOiBldmVudE5hbWUsXG4gICAgICAgICAgZnVuYzogX2Z1bmMsXG4gICAgICAgICAgY2I6IF9jYixcbiAgICAgICAgICByb3V0ZXJMaW5rOiByTGlua1xuICAgICAgICB9KTsgLy9hZGQgdGhlIGV2ZW50IHRvIHRoZSBub2RlXG5cblxuICAgICAgICBfbm9kZXNbaV0uYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIF9jYik7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfbG9vcChpKTtcbiAgICAgIH1cbiAgICB9IC8vdGhpcyBmdW5jdGlvbiByZW1vdmVzIG5vbiByb3V0ZXIgZXZlbnRzIG1lZXRpbmcgdGhlIGNyaXRlcmlhXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKG5vZGUsIGV2ZW50TmFtZSwgZnVuYykge1xuICAgICAgLy9ub2RlbGlzdCBvciBzaW5nbGUgbm9kZT9cbiAgICAgIHZhciBfbm9kZXMgPSBpcy5ub2RlTGlzdChub2RlKSB8fCBpcy5hcnJheShub2RlKSA/IG5vZGUgOiBbbm9kZV07IC8vbG9vcCB0aG91Z2ggdGhlIG5vZGVzXG5cblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBfbm9kZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5fZXZlbnRDYWNoZS5sZW5ndGgpIHtcbiAgICAgICAgICAvL2NoZWNrIGlmIGl0IGlzIHRoZSBzYW1lIG5vZGUgYW5kIGlzIG5vdCBhIHJvdXRlciBsaW5rXG4gICAgICAgICAgaWYgKHRoaXMuX2V2ZW50Q2FjaGVbaV0ubm9kZSA9PT0gX25vZGVzW2tdICYmICF0aGlzLl9ldmVudENhY2hlW2ldLnJvdXRlckxpbmspIHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgJiYgZnVuYykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRDYWNoZVtpXS5hY3Rpb24gPT09IGV2ZW50TmFtZSAmJiB0aGlzLl9ldmVudENhY2hlW2ldLmZ1bmMgPT09IGZ1bmMpIHRoaXMuX3JlbW92ZUV2ZW50KGkpO2Vsc2UgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50Q2FjaGVbaV0uYWN0aW9uID09PSBldmVudE5hbWUpIHRoaXMuX3JlbW92ZUV2ZW50KGkpO2Vsc2UgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmdW5jKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudENhY2hlW2ldLmZ1bmMgPT09IGZ1bmMpIHRoaXMuX3JlbW92ZUV2ZW50KGkpO2Vsc2UgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vdGhpcyBmdW5jdGlvbiByZW1vdmVzIGFsbCBub24gcm91dGVyIGxpbmtzXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVBbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQWxsKCkge1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IHRoaXMuX2V2ZW50Q2FjaGUubGVuZ3RoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRDYWNoZVtpXS5yb3V0ZXJMaW5rKSB0aGlzLl9yZW1vdmVFdmVudChpKTtlbHNlIGkrKztcbiAgICAgIH1cbiAgICB9IC8vdGhpcyBmdW5jdGlvbiByZW1vdmVzIGV2ZXJ5dGhpbmcsIGl0IG11c3Qgb25seSBiZSB1c2VkIGJ5IGNvbXBvbmVudCBjbGFzc2VzIGFmdGVyIGVsZW1lbnRzIGFyZSByZW1vdmVkXG4gICAgLy9mcm9tIHRoZSBkb20gc28gdGhlcmUgYXJlIG5vdCBwcm9ibGVtcyB3aXRoIHVuYm91bmQgcm91dGVyIGxpbmtzIGNsaWNrZWQgYnkgdGhlIHVzZXIgcmVmcmVzaGluZyB0aGUgcGFnZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgd2hpbGUgKHRoaXMuX2V2ZW50Q2FjaGUubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudCgwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KCk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCIvKiFcbiAqIHN0cmluZ3M6IDMuMi42XG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOC0yMDIwLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIF90cmltRXhwID0gLyheXFxzK3xcXHMrJCkvZztcbmV4cG9ydCB2YXIgZW1vamlFeHAgPSAvKFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0oPzpbXFx1MjAwRFxcdUZFMEZdW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXSl7Mix9fFxcdUQ4M0RcXHVEQzY5KD86XFx1MjAwRCg/Oig/OlxcdUQ4M0RcXHVEQzY5XFx1MjAwRCk/XFx1RDgzRFxcdURDNjd8KD86XFx1RDgzRFxcdURDNjlcXHUyMDBEKT9cXHVEODNEXFx1REM2Nil8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXxcXHVEODNEXFx1REM2OVxcdTIwMEQoPzpcXHVEODNEXFx1REM2OVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY5XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzY5XFx1MjAwRCk/XFx1RDgzRFxcdURDNjdcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfFxcdUQ4M0NcXHVERkYzXFx1RkUwRlxcdTIwMERcXHVEODNDXFx1REYwOHwoPzpcXHVEODNDW1xcdURGQzNcXHVERkM0XFx1REZDQV18XFx1RDgzRFtcXHVEQzZFXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0LVxcdURFQjZdfFxcdUQ4M0VbXFx1REQyNlxcdUREMzctXFx1REQzOVxcdUREM0RcXHVERDNFXFx1RERENi1cXHVEREREXSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGfFxcdUQ4M0RcXHVEQzY5KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXSl8KD86XFx1RDgzQ1tcXHVERkMzXFx1REZDNFxcdURGQ0FdfFxcdUQ4M0RbXFx1REM2RVxcdURDNkZcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl18XFx1RDgzRVtcXHVERDI2XFx1REQzNy1cXHVERDM5XFx1REQzQy1cXHVERDNFXFx1RERENi1cXHVERERGXSlcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEZ8XFx1RDgzQ1xcdURERkRcXHVEODNDXFx1RERGMHxcXHVEODNDXFx1RERGNlxcdUQ4M0NcXHVEREU2fFxcdUQ4M0NcXHVEREY0XFx1RDgzQ1xcdURERjJ8XFx1RDgzQ1xcdURERTkoPzpcXHVEODNDW1xcdURERUFcXHVEREVDXFx1RERFRlxcdURERjBcXHVEREYyXFx1RERGNFxcdURERkZdKXxcXHVEODNDXFx1RERGNyg/OlxcdUQ4M0NbXFx1RERFQVxcdURERjRcXHVEREY4XFx1RERGQVxcdURERkNdKXxcXHVEODNDXFx1RERFOCg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREU5XFx1RERFQi1cXHVEREVFXFx1RERGMC1cXHVEREY1XFx1RERGN1xcdURERkEtXFx1RERGRl0pfCg/OlxcdTI2Rjl8XFx1RDgzQ1tcXHVERkNCXFx1REZDQ118XFx1RDgzRFxcdURENzUpKD86XFx1RkUwRlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdfCg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXSlcXHVGRTBGfCg/OlxcdUQ4M0RcXHVEQzQxXFx1RkUwRlxcdTIwMERcXHVEODNEXFx1RERFOHxcXHVEODNEXFx1REM2OSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzRFxcdURDNjlcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzRFxcdURDNjgoPzooPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XSkpXFx1RkUwRnxcXHVEODNDXFx1RERGMig/OlxcdUQ4M0NbXFx1RERFNlxcdURERTgtXFx1RERFRFxcdURERjAtXFx1RERGRl0pfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKXxcXHVEODNEW1xcdURDNjhcXHVEQzY5XSkpfFxcdUQ4M0NcXHVEREYxKD86XFx1RDgzQ1tcXHVEREU2LVxcdURERThcXHVEREVFXFx1RERGMFxcdURERjctXFx1RERGQlxcdURERkVdKXxcXHVEODNDXFx1RERFRig/OlxcdUQ4M0NbXFx1RERFQVxcdURERjJcXHVEREY0XFx1RERGNV0pfFxcdUQ4M0NcXHVEREVEKD86XFx1RDgzQ1tcXHVEREYwXFx1RERGMlxcdURERjNcXHVEREY3XFx1RERGOVxcdURERkFdKXxcXHVEODNDXFx1RERFQig/OlxcdUQ4M0NbXFx1RERFRS1cXHVEREYwXFx1RERGMlxcdURERjRcXHVEREY3XSl8WyNcXCowLTldXFx1RkUwRlxcdTIwRTN8XFx1RDgzQ1xcdURERTcoPzpcXHVEODNDW1xcdURERTZcXHVEREU3XFx1RERFOS1cXHVEREVGXFx1RERGMS1cXHVEREY0XFx1RERGNi1cXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZFXFx1RERGRl0pfFxcdUQ4M0NcXHVEREU2KD86XFx1RDgzQ1tcXHVEREU4LVxcdURERUNcXHVEREVFXFx1RERGMVxcdURERjJcXHVEREY0XFx1RERGNi1cXHVEREZBXFx1RERGQ1xcdURERkRcXHVEREZGXSl8XFx1RDgzQ1xcdURERkYoPzpcXHVEODNDW1xcdURERTZcXHVEREYyXFx1RERGQ10pfFxcdUQ4M0NcXHVEREY1KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFQS1cXHVEREVEXFx1RERGMC1cXHVEREYzXFx1RERGNy1cXHVEREY5XFx1RERGQ1xcdURERkVdKXxcXHVEODNDXFx1RERGQig/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBXFx1RERFQ1xcdURERUVcXHVEREYzXFx1RERGQV0pfFxcdUQ4M0NcXHVEREYzKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUEtXFx1RERFQ1xcdURERUVcXHVEREYxXFx1RERGNFxcdURERjVcXHVEREY3XFx1RERGQVxcdURERkZdKXxcXHVEODNDXFx1REZGNFxcdURCNDBcXHVEQzY3XFx1REI0MFxcdURDNjIoPzpcXHVEQjQwXFx1REM3N1xcdURCNDBcXHVEQzZDXFx1REI0MFxcdURDNzN8XFx1REI0MFxcdURDNzNcXHVEQjQwXFx1REM2M1xcdURCNDBcXHVEQzc0fFxcdURCNDBcXHVEQzY1XFx1REI0MFxcdURDNkVcXHVEQjQwXFx1REM2NylcXHVEQjQwXFx1REM3RnxcXHVEODNEXFx1REM2OCg/OlxcdTIwMEQoPzpcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY4fCg/Oig/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fCg/Oig/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXSl8KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXSkpfFxcdUQ4M0NcXHVEREY4KD86XFx1RDgzQ1tcXHVEREU2LVxcdURERUFcXHVEREVDLVxcdURERjRcXHVEREY3LVxcdURERjlcXHVEREZCXFx1RERGRC1cXHVEREZGXSl8XFx1RDgzQ1xcdURERjAoPzpcXHVEODNDW1xcdURERUFcXHVEREVDLVxcdURERUVcXHVEREYyXFx1RERGM1xcdURERjVcXHVEREY3XFx1RERGQ1xcdURERkVcXHVEREZGXSl8XFx1RDgzQ1xcdURERkUoPzpcXHVEODNDW1xcdURERUFcXHVEREY5XSl8XFx1RDgzQ1xcdURERUUoPzpcXHVEODNDW1xcdURERTgtXFx1RERFQVxcdURERjEtXFx1RERGNFxcdURERjYtXFx1RERGOV0pfFxcdUQ4M0NcXHVEREY5KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERTlcXHVEREVCLVxcdURERURcXHVEREVGLVxcdURERjRcXHVEREY3XFx1RERGOVxcdURERkJcXHVEREZDXFx1RERGRl0pfFxcdUQ4M0NcXHVEREVDKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFN1xcdURERTktXFx1RERFRVxcdURERjEtXFx1RERGM1xcdURERjUtXFx1RERGQVxcdURERkNcXHVEREZFXSl8XFx1RDgzQ1xcdURERkEoPzpcXHVEODNDW1xcdURERTZcXHVEREVDXFx1RERGMlxcdURERjNcXHVEREY4XFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERFQSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBXFx1RERFQ1xcdURERURcXHVEREY3LVxcdURERkFdKXxcXHVEODNDXFx1RERGQyg/OlxcdUQ4M0NbXFx1RERFQlxcdURERjhdKXwoPzpcXHUyNkY5fFxcdUQ4M0NbXFx1REZDQlxcdURGQ0NdfFxcdUQ4M0RcXHVERDc1KSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8KD86XFx1RDgzQ1tcXHVERkMzXFx1REZDNFxcdURGQ0FdfFxcdUQ4M0RbXFx1REM2RVxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM3LVxcdUREMzlcXHVERDNEXFx1REQzRVxcdURERDYtXFx1RERERF0pKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXwoPzpbXFx1MjYxRFxcdTI3MEEtXFx1MjcwRF18XFx1RDgzQ1tcXHVERjg1XFx1REZDMlxcdURGQzddfFxcdUQ4M0RbXFx1REM0MlxcdURDNDNcXHVEQzQ2LVxcdURDNTBcXHVEQzY2XFx1REM2N1xcdURDNzBcXHVEQzcyXFx1REM3NC1cXHVEQzc2XFx1REM3OFxcdURDN0NcXHVEQzgzXFx1REM4NVxcdURDQUFcXHVERDc0XFx1REQ3QVxcdUREOTBcXHVERDk1XFx1REQ5NlxcdURFNENcXHVERTRGXFx1REVDMFxcdURFQ0NdfFxcdUQ4M0VbXFx1REQxOC1cXHVERDFDXFx1REQxRVxcdUREMUZcXHVERDMwLVxcdUREMzZcXHVEREQxLVxcdURERDVdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8XFx1RDgzRFxcdURDNjgoPzpcXHUyMDBEKD86KD86KD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1MjAwRCk/XFx1RDgzRFxcdURDNjd8KD86KD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1MjAwRCk/XFx1RDgzRFxcdURDNjYpfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8KD86W1xcdTI2MURcXHUyNkY5XFx1MjcwQS1cXHUyNzBEXXxcXHVEODNDW1xcdURGODVcXHVERkMyLVxcdURGQzRcXHVERkM3XFx1REZDQS1cXHVERkNDXXxcXHVEODNEW1xcdURDNDJcXHVEQzQzXFx1REM0Ni1cXHVEQzUwXFx1REM2Ni1cXHVEQzY5XFx1REM2RVxcdURDNzAtXFx1REM3OFxcdURDN0NcXHVEQzgxLVxcdURDODNcXHVEQzg1LVxcdURDODdcXHVEQ0FBXFx1REQ3NFxcdURENzVcXHVERDdBXFx1REQ5MFxcdUREOTVcXHVERDk2XFx1REU0NS1cXHVERTQ3XFx1REU0Qi1cXHVERTRGXFx1REVBM1xcdURFQjQtXFx1REVCNlxcdURFQzBcXHVERUNDXXxcXHVEODNFW1xcdUREMTgtXFx1REQxQ1xcdUREMUVcXHVERDFGXFx1REQyNlxcdUREMzAtXFx1REQzOVxcdUREM0RcXHVERDNFXFx1REREMS1cXHVEREREXSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pP3woPzpbXFx1MjMxQVxcdTIzMUJcXHUyM0U5LVxcdTIzRUNcXHUyM0YwXFx1MjNGM1xcdTI1RkRcXHUyNUZFXFx1MjYxNFxcdTI2MTVcXHUyNjQ4LVxcdTI2NTNcXHUyNjdGXFx1MjY5M1xcdTI2QTFcXHUyNkFBXFx1MjZBQlxcdTI2QkRcXHUyNkJFXFx1MjZDNFxcdTI2QzVcXHUyNkNFXFx1MjZENFxcdTI2RUFcXHUyNkYyXFx1MjZGM1xcdTI2RjVcXHUyNkZBXFx1MjZGRFxcdTI3MDVcXHUyNzBBXFx1MjcwQlxcdTI3MjhcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzk1LVxcdTI3OTdcXHUyN0IwXFx1MjdCRlxcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVdfFxcdUQ4M0NbXFx1REMwNFxcdURDQ0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERFNi1cXHVEREZGXFx1REUwMVxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTM2XFx1REUzOC1cXHVERTNBXFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGMjBcXHVERjJELVxcdURGMzVcXHVERjM3LVxcdURGN0NcXHVERjdFLVxcdURGOTNcXHVERkEwLVxcdURGQ0FcXHVERkNGLVxcdURGRDNcXHVERkUwLVxcdURGRjBcXHVERkY0XFx1REZGOC1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1REMzRVxcdURDNDBcXHVEQzQyLVxcdURDRkNcXHVEQ0ZGLVxcdUREM0RcXHVERDRCLVxcdURENEVcXHVERDUwLVxcdURENjdcXHVERDdBXFx1REQ5NVxcdUREOTZcXHVEREE0XFx1RERGQi1cXHVERTRGXFx1REU4MC1cXHVERUM1XFx1REVDQ1xcdURFRDAtXFx1REVEMlxcdURFRUJcXHVERUVDXFx1REVGNC1cXHVERUY4XXxcXHVEODNFW1xcdUREMTAtXFx1REQzQVxcdUREM0MtXFx1REQzRVxcdURENDAtXFx1REQ0NVxcdURENDctXFx1REQ0Q1xcdURENTAtXFx1REQ2QlxcdUREODAtXFx1REQ5N1xcdUREQzBcXHVEREQwLVxcdURERTZdKXwoPzpbI1xcKjAtOVxceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyM0NGXFx1MjNFOS1cXHUyM0YzXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCLVxcdTI1RkVcXHUyNjAwLVxcdTI2MDRcXHUyNjBFXFx1MjYxMVxcdTI2MTRcXHUyNjE1XFx1MjYxOFxcdTI2MURcXHUyNjIwXFx1MjYyMlxcdTI2MjNcXHUyNjI2XFx1MjYyQVxcdTI2MkVcXHUyNjJGXFx1MjYzOC1cXHUyNjNBXFx1MjY0MFxcdTI2NDJcXHUyNjQ4LVxcdTI2NTNcXHUyNjYwXFx1MjY2M1xcdTI2NjVcXHUyNjY2XFx1MjY2OFxcdTI2N0JcXHUyNjdGXFx1MjY5Mi1cXHUyNjk3XFx1MjY5OVxcdTI2OUJcXHUyNjlDXFx1MjZBMFxcdTI2QTFcXHUyNkFBXFx1MjZBQlxcdTI2QjBcXHUyNkIxXFx1MjZCRFxcdTI2QkVcXHUyNkM0XFx1MjZDNVxcdTI2QzhcXHUyNkNFXFx1MjZDRlxcdTI2RDFcXHUyNkQzXFx1MjZENFxcdTI2RTlcXHUyNkVBXFx1MjZGMC1cXHUyNkY1XFx1MjZGNy1cXHUyNkZBXFx1MjZGRFxcdTI3MDJcXHUyNzA1XFx1MjcwOC1cXHUyNzBEXFx1MjcwRlxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjcyOFxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzYzXFx1Mjc2NFxcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwNFxcdURDQ0ZcXHVERDcwXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdURERTYtXFx1RERGRlxcdURFMDFcXHVERTAyXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTUwXFx1REU1MVxcdURGMDAtXFx1REYyMVxcdURGMjQtXFx1REY5M1xcdURGOTZcXHVERjk3XFx1REY5OS1cXHVERjlCXFx1REY5RS1cXHVERkYwXFx1REZGMy1cXHVERkY1XFx1REZGNy1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1RENGRFxcdURDRkYtXFx1REQzRFxcdURENDktXFx1REQ0RVxcdURENTAtXFx1REQ2N1xcdURENkZcXHVERDcwXFx1REQ3My1cXHVERDdBXFx1REQ4N1xcdUREOEEtXFx1REQ4RFxcdUREOTBcXHVERDk1XFx1REQ5NlxcdUREQTRcXHVEREE1XFx1RERBOFxcdUREQjFcXHVEREIyXFx1RERCQ1xcdUREQzItXFx1RERDNFxcdURERDEtXFx1REREM1xcdUREREMtXFx1RERERVxcdURERTFcXHVEREUzXFx1RERFOFxcdURERUZcXHVEREYzXFx1RERGQS1cXHVERTRGXFx1REU4MC1cXHVERUM1XFx1REVDQi1cXHVERUQyXFx1REVFMC1cXHVERUU1XFx1REVFOVxcdURFRUJcXHVERUVDXFx1REVGMFxcdURFRjMtXFx1REVGOF18XFx1RDgzRVtcXHVERDEwLVxcdUREM0FcXHVERDNDLVxcdUREM0VcXHVERDQwLVxcdURENDVcXHVERDQ3LVxcdURENENcXHVERDUwLVxcdURENkJcXHVERDgwLVxcdUREOTdcXHVEREMwXFx1REREMC1cXHVEREU2XSlcXHVGRTBGKS87XG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dChlKSB7XG4gIHZhciB0eXBlID0gZS5ub2RlVHlwZSxcbiAgICAgIHJlc3VsdCA9IFwiXCI7XG5cbiAgaWYgKHR5cGUgPT09IDEgfHwgdHlwZSA9PT0gOSB8fCB0eXBlID09PSAxMSkge1xuICAgIGlmICh0eXBlb2YgZS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGUudGV4dENvbnRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoZSA9IGUuZmlyc3RDaGlsZDsgZTsgZSA9IGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgcmVzdWx0ICs9IGdldFRleHQoZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IDMgfHwgdHlwZSA9PT0gNCkge1xuICAgIHJldHVybiBlLm5vZGVWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gc3BsaXRJbm5lckhUTUwoZWxlbWVudCwgZGVsaW1pdGVyLCB0cmltKSB7XG4gIHZhciBub2RlID0gZWxlbWVudC5maXJzdENoaWxkLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBlbW9qaVNhZmVTcGxpdCgobm9kZS5ub2RlVmFsdWUgKyBcIlwiKS5yZXBsYWNlKC9eXFxuKy9nLCBcIlwiKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKSwgZGVsaW1pdGVyLCB0cmltKSk7XG4gICAgfSBlbHNlIGlmICgobm9kZS5ub2RlTmFtZSArIFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwiYnJcIikge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSArPSBcIjxicj5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gobm9kZS5vdXRlckhUTUwpO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qXG4vL3NtYWxsZXIga2IgdmVyc2lvbiB0aGF0IG9ubHkgaGFuZGxlcyB0aGUgc2ltcGxlciBlbW9qaSdzLCB3aGljaCBpcyBvZnRlbiBwZXJmZWN0bHkgYWRlcXVhdGUuXG5cbmxldCBfZW1vamkgPSBcIltcXHVFMDAwLVxcdUY4RkZdfFxcdUQ4M0NbXFx1REMwMC1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1REZGRl18W1xcdTI2OTQtXFx1MjY5N118XFx1RDgzRVtcXHVERDEwLVxcdURENURdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl1cIixcblx0X2Vtb2ppRXhwID0gbmV3IFJlZ0V4cChfZW1vamkpLFxuXHRfZW1vamlBbmRDaGFyc0V4cCA9IG5ldyBSZWdFeHAoX2Vtb2ppICsgXCJ8LlwiLCBcImdcIiksXG5cdF9lbW9qaVNhZmVTcGxpdCA9ICh0ZXh0LCBkZWxpbWl0ZXIsIHRyaW0pID0+IHtcblx0XHRpZiAodHJpbSkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZShfdHJpbUV4cCwgXCJcIik7XG5cdFx0fVxuXHRcdHJldHVybiAoKGRlbGltaXRlciA9PT0gXCJcIiB8fCAhZGVsaW1pdGVyKSAmJiBfZW1vamlFeHAudGVzdCh0ZXh0KSkgPyB0ZXh0Lm1hdGNoKF9lbW9qaUFuZENoYXJzRXhwKSA6IHRleHQuc3BsaXQoZGVsaW1pdGVyIHx8IFwiXCIpO1xuXHR9O1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlbW9qaVNhZmVTcGxpdCh0ZXh0LCBkZWxpbWl0ZXIsIHRyaW0pIHtcbiAgdGV4dCArPSBcIlwiOyAvLyBtYWtlIHN1cmUgaXQncyBjYXN0IGFzIGEgc3RyaW5nLiBTb21lb25lIG1heSBwYXNzIGluIGEgbnVtYmVyLlxuXG4gIGlmICh0cmltKSB7XG4gICAgdGV4dCA9IHRleHQucmVwbGFjZShfdHJpbUV4cCwgXCJcIik7XG4gIH1cblxuICBpZiAoZGVsaW1pdGVyICYmIGRlbGltaXRlciAhPT0gXCJcIikge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnNwbGl0KGRlbGltaXRlcik7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICBsID0gdGV4dC5sZW5ndGgsXG4gICAgICBpID0gMCxcbiAgICAgIGosXG4gICAgICBjaGFyYWN0ZXI7XG5cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBjaGFyYWN0ZXIgPSB0ZXh0LmNoYXJBdChpKTtcblxuICAgIGlmIChjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSA+PSAweEQ4MDAgJiYgY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgPD0gMHhEQkZGIHx8IHRleHQuY2hhckNvZGVBdChpICsgMSkgPj0gMHhGRTAwICYmIHRleHQuY2hhckNvZGVBdChpICsgMSkgPD0gMHhGRTBGKSB7XG4gICAgICAvL3NwZWNpYWwgZW1vamkgY2hhcmFjdGVycyB1c2UgMiBvciA0IHVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IHdlIG11c3Qga2VlcCB0b2dldGhlci5cbiAgICAgIGogPSAoKHRleHQuc3Vic3RyKGksIDEyKS5zcGxpdChlbW9qaUV4cCkgfHwgW10pWzFdIHx8IFwiXCIpLmxlbmd0aCB8fCAyO1xuICAgICAgY2hhcmFjdGVyID0gdGV4dC5zdWJzdHIoaSwgaik7XG4gICAgICByZXN1bHQuZW1vamkgPSAxO1xuICAgICAgaSArPSBqIC0gMTtcbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChjaGFyYWN0ZXIgPT09IFwiPlwiID8gXCImZ3Q7XCIgOiBjaGFyYWN0ZXIgPT09IFwiPFwiID8gXCImbHQ7XCIgOiBjaGFyYWN0ZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0iLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIVxuICogU3BsaXRUZXh0OiAzLjIuNlxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyMCwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IGVtb2ppRXhwLCBnZXRUZXh0IH0gZnJvbSBcIi4uL3V0aWxzL3N0cmluZ3MuanNcIjtcblxudmFyIF9kb2MsXG4gICAgX3dpbixcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX3N0cmlwRXhwID0gLyg/OlxccnxcXG58XFx0XFx0KS9nLFxuICAgIC8vZmluZCBjYXJyaWFnZSByZXR1cm5zLCBuZXcgbGluZSBmZWVkcyBhbmQgZG91YmxlLXRhYnMuXG5fbXVsdGlwbGVTcGFjZXNFeHAgPSAvKD86XFxzXFxzKykvZyxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoKSB7XG4gIF9kb2MgPSBkb2N1bWVudDtcbiAgX3dpbiA9IHdpbmRvdztcbiAgX2NvcmVJbml0dGVkID0gMTtcbn0sXG4gICAgX2JvbnVzVmFsaWRhdGVkID0gMSxcbiAgICAvLzxuYW1lPlNwbGl0VGV4dDwvbmFtZT5cbl9nZXRDb21wdXRlZFN0eWxlID0gZnVuY3Rpb24gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gX3dpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufSxcbiAgICBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgX3NsaWNlID0gW10uc2xpY2UsXG4gICAgX3RvQXJyYXkgPSBmdW5jdGlvbiBfdG9BcnJheSh2YWx1ZSwgbGVhdmVTdHJpbmdzKSB7XG4gIC8vdGFrZXMgYW55IHZhbHVlIGFuZCByZXR1cm5zIGFuIGFycmF5LiBJZiBpdCdzIGEgc3RyaW5nIChhbmQgbGVhdmVTdHJpbmdzIGlzbid0IHRydWUpLCBpdCdsbCB1c2UgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgpIGFuZCBjb252ZXJ0IHRoYXQgdG8gYW4gYXJyYXkuIEl0J2xsIGFsc28gYWNjZXB0IGl0ZXJhYmxlcyBsaWtlIGpRdWVyeSBvYmplY3RzLlxuICB2YXIgdHlwZTtcbiAgcmV0dXJuIF9pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogKHR5cGUgPSBfdHlwZW9mKHZhbHVlKSkgPT09IFwic3RyaW5nXCIgJiYgIWxlYXZlU3RyaW5ncyAmJiB2YWx1ZSA/IF9zbGljZS5jYWxsKF9kb2MucXVlcnlTZWxlY3RvckFsbCh2YWx1ZSksIDApIDogdmFsdWUgJiYgdHlwZSA9PT0gXCJvYmplY3RcIiAmJiBcImxlbmd0aFwiIGluIHZhbHVlID8gX3NsaWNlLmNhbGwodmFsdWUsIDApIDogdmFsdWUgPyBbdmFsdWVdIDogW107XG59LFxuICAgIF9pc0Fic29sdXRlID0gZnVuY3Rpb24gX2lzQWJzb2x1dGUodmFycykge1xuICByZXR1cm4gdmFycy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHZhcnMuYWJzb2x1dGUgPT09IHRydWU7XG59LFxuICAgIC8vc29tZSBjaGFyYWN0ZXJzIGFyZSBjb21iaW5pbmcgbWFya3MgKHRoaW5rIGRpYWNyaXRpY3MvYWNjZW50cyBpbiBFdXJvcGVhbiBsYW5ndWFnZXMpIHdoaWNoIGludm9sdmUgMiBvciA0IGNoYXJhY3RlcnMgdGhhdCBjb21iaW5lIGluIHRoZSBicm93c2VyIHRvIGZvcm0gYSBzaW5nbGUgY2hhcmFjdGVyLiBQYXNzIGluIHRoZSByZW1haW5pbmcgdGV4dCBhbmQgYW4gYXJyYXkgb2YgdGhlIHNwZWNpYWwgY2hhcmFjdGVycyB0byBzZWFyY2ggZm9yIGFuZCBpZiB0aGUgdGV4dCBzdGFydHMgd2l0aCBvbmUgb2YgdGhvc2Ugc3BlY2lhbCBjaGFyYWN0ZXJzLCBpdCdsbCBzcGl0IGJhY2sgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHJldGFpbiAob2Z0ZW4gMiBvciA0KS4gVXNlZCBpbiB0aGUgc3BlY2lhbENoYXJzIGZlYXR1cmVzIHRoYXQgd2FzIGludHJvZHVjZWQgaW4gMC42LjAuXG5fZmluZFNwZWNpYWxDaGFycyA9IGZ1bmN0aW9uIF9maW5kU3BlY2lhbENoYXJzKHRleHQsIGNoYXJzKSB7XG4gIHZhciBpID0gY2hhcnMubGVuZ3RoLFxuICAgICAgcztcblxuICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICBzID0gY2hhcnNbaV07XG5cbiAgICBpZiAodGV4dC5zdWJzdHIoMCwgcy5sZW5ndGgpID09PSBzKSB7XG4gICAgICByZXR1cm4gcy5sZW5ndGg7XG4gICAgfVxuICB9XG59LFxuICAgIF9kaXZTdGFydCA9IFwiIHN0eWxlPSdwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmlubGluZS1ibG9jazsnXCIsXG4gICAgX2Nzc0NsYXNzRnVuYyA9IGZ1bmN0aW9uIF9jc3NDbGFzc0Z1bmMoY3NzQ2xhc3MsIHRhZykge1xuICBpZiAoY3NzQ2xhc3MgPT09IHZvaWQgMCkge1xuICAgIGNzc0NsYXNzID0gXCJcIjtcbiAgfVxuXG4gIHZhciBpdGVyYXRlID0gfmNzc0NsYXNzLmluZGV4T2YoXCIrK1wiKSxcbiAgICAgIG51bSA9IDE7XG5cbiAgaWYgKGl0ZXJhdGUpIHtcbiAgICBjc3NDbGFzcyA9IGNzc0NsYXNzLnNwbGl0KFwiKytcIikuam9pbihcIlwiKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiPFwiICsgdGFnICsgX2RpdlN0YXJ0ICsgKGNzc0NsYXNzID8gXCIgY2xhc3M9J1wiICsgY3NzQ2xhc3MgKyAoaXRlcmF0ZSA/IG51bSsrIDogXCJcIikgKyBcIic+XCIgOiBcIj5cIik7XG4gIH07XG59LFxuICAgIF9zd2FwVGV4dCA9IGZ1bmN0aW9uIF9zd2FwVGV4dChlbGVtZW50LCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gIHZhciB0eXBlID0gZWxlbWVudC5ub2RlVHlwZTtcblxuICBpZiAodHlwZSA9PT0gMSB8fCB0eXBlID09PSA5IHx8IHR5cGUgPT09IDExKSB7XG4gICAgZm9yIChlbGVtZW50ID0gZWxlbWVudC5maXJzdENoaWxkOyBlbGVtZW50OyBlbGVtZW50ID0gZWxlbWVudC5uZXh0U2libGluZykge1xuICAgICAgX3N3YXBUZXh0KGVsZW1lbnQsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAzIHx8IHR5cGUgPT09IDQpIHtcbiAgICBlbGVtZW50Lm5vZGVWYWx1ZSA9IGVsZW1lbnQubm9kZVZhbHVlLnNwbGl0KG9sZFRleHQpLmpvaW4obmV3VGV4dCk7XG4gIH1cbn0sXG4gICAgX3B1c2hSZXZlcnNlZCA9IGZ1bmN0aW9uIF9wdXNoUmV2ZXJzZWQoYSwgbWVyZ2UpIHtcbiAgdmFyIGkgPSBtZXJnZS5sZW5ndGg7XG5cbiAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgYS5wdXNoKG1lcmdlW2ldKTtcbiAgfVxufSxcbiAgICBfaXNCZWZvcmVXb3JkRGVsaW1pdGVyID0gZnVuY3Rpb24gX2lzQmVmb3JlV29yZERlbGltaXRlcihlLCByb290LCB3b3JkRGVsaW1pdGVyKSB7XG4gIHZhciBuZXh0O1xuXG4gIHdoaWxlIChlICYmIGUgIT09IHJvb3QpIHtcbiAgICBuZXh0ID0gZS5fbmV4dCB8fCBlLm5leHRTaWJsaW5nO1xuXG4gICAgaWYgKG5leHQpIHtcbiAgICAgIHJldHVybiBuZXh0LnRleHRDb250ZW50LmNoYXJBdCgwKSA9PT0gd29yZERlbGltaXRlcjtcbiAgICB9XG5cbiAgICBlID0gZS5wYXJlbnROb2RlIHx8IGUuX3BhcmVudDtcbiAgfVxufSxcbiAgICBfZGVXb3JkaWZ5ID0gZnVuY3Rpb24gX2RlV29yZGlmeShlKSB7XG4gIHZhciBjaGlsZHJlbiA9IF90b0FycmF5KGUuY2hpbGROb2RlcyksXG4gICAgICBsID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgaSxcbiAgICAgIGNoaWxkO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKGNoaWxkLl9pc1NwbGl0KSB7XG4gICAgICBfZGVXb3JkaWZ5KGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGkgJiYgY2hpbGQucHJldmlvdXNTaWJsaW5nLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgIGNoaWxkLnByZXZpb3VzU2libGluZy5ub2RlVmFsdWUgKz0gY2hpbGQubm9kZVR5cGUgPT09IDMgPyBjaGlsZC5ub2RlVmFsdWUgOiBjaGlsZC5maXJzdENoaWxkLm5vZGVWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgIT09IDMpIHtcbiAgICAgICAgZS5pbnNlcnRCZWZvcmUoY2hpbGQuZmlyc3RDaGlsZCwgY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX2dldFN0eWxlQXNOdW1iZXIgPSBmdW5jdGlvbiBfZ2V0U3R5bGVBc051bWJlcihuYW1lLCBjb21wdXRlZFN0eWxlKSB7XG4gIHJldHVybiBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbbmFtZV0pIHx8IDA7XG59LFxuICAgIF9zZXRQb3NpdGlvbnNBZnRlclNwbGl0ID0gZnVuY3Rpb24gX3NldFBvc2l0aW9uc0FmdGVyU3BsaXQoZWxlbWVudCwgdmFycywgYWxsQ2hhcnMsIGFsbFdvcmRzLCBhbGxMaW5lcywgb3JpZ1dpZHRoLCBvcmlnSGVpZ2h0KSB7XG4gIHZhciBjcyA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLFxuICAgICAgcGFkZGluZ0xlZnQgPSBfZ2V0U3R5bGVBc051bWJlcihcInBhZGRpbmdMZWZ0XCIsIGNzKSxcbiAgICAgIGxpbmVPZmZzZXRZID0gLTk5OSxcbiAgICAgIGJvcmRlclRvcEFuZEJvdHRvbSA9IF9nZXRTdHlsZUFzTnVtYmVyKFwiYm9yZGVyQm90dG9tV2lkdGhcIiwgY3MpICsgX2dldFN0eWxlQXNOdW1iZXIoXCJib3JkZXJUb3BXaWR0aFwiLCBjcyksXG4gICAgICBib3JkZXJMZWZ0QW5kUmlnaHQgPSBfZ2V0U3R5bGVBc051bWJlcihcImJvcmRlckxlZnRXaWR0aFwiLCBjcykgKyBfZ2V0U3R5bGVBc051bWJlcihcImJvcmRlclJpZ2h0V2lkdGhcIiwgY3MpLFxuICAgICAgcGFkVG9wQW5kQm90dG9tID0gX2dldFN0eWxlQXNOdW1iZXIoXCJwYWRkaW5nVG9wXCIsIGNzKSArIF9nZXRTdHlsZUFzTnVtYmVyKFwicGFkZGluZ0JvdHRvbVwiLCBjcyksXG4gICAgICBwYWRMZWZ0QW5kUmlnaHQgPSBfZ2V0U3R5bGVBc051bWJlcihcInBhZGRpbmdMZWZ0XCIsIGNzKSArIF9nZXRTdHlsZUFzTnVtYmVyKFwicGFkZGluZ1JpZ2h0XCIsIGNzKSxcbiAgICAgIGxpbmVUaHJlc2hvbGQgPSBfZ2V0U3R5bGVBc051bWJlcihcImZvbnRTaXplXCIsIGNzKSAqIDAuMixcbiAgICAgIHRleHRBbGlnbiA9IGNzLnRleHRBbGlnbixcbiAgICAgIGNoYXJBcnJheSA9IFtdLFxuICAgICAgd29yZEFycmF5ID0gW10sXG4gICAgICBsaW5lQXJyYXkgPSBbXSxcbiAgICAgIHdvcmREZWxpbWl0ZXIgPSB2YXJzLndvcmREZWxpbWl0ZXIgfHwgXCIgXCIsXG4gICAgICB0YWcgPSB2YXJzLnRhZyA/IHZhcnMudGFnIDogdmFycy5zcGFuID8gXCJzcGFuXCIgOiBcImRpdlwiLFxuICAgICAgdHlwZXMgPSB2YXJzLnR5cGUgfHwgdmFycy5zcGxpdCB8fCBcImNoYXJzLHdvcmRzLGxpbmVzXCIsXG4gICAgICBsaW5lcyA9IGFsbExpbmVzICYmIH50eXBlcy5pbmRleE9mKFwibGluZXNcIikgPyBbXSA6IG51bGwsXG4gICAgICB3b3JkcyA9IH50eXBlcy5pbmRleE9mKFwid29yZHNcIiksXG4gICAgICBjaGFycyA9IH50eXBlcy5pbmRleE9mKFwiY2hhcnNcIiksXG4gICAgICBhYnNvbHV0ZSA9IF9pc0Fic29sdXRlKHZhcnMpLFxuICAgICAgbGluZXNDbGFzcyA9IHZhcnMubGluZXNDbGFzcyxcbiAgICAgIGl0ZXJhdGVMaW5lID0gfihsaW5lc0NsYXNzIHx8IFwiXCIpLmluZGV4T2YoXCIrK1wiKSxcbiAgICAgIHNwYWNlTm9kZXNUb1JlbW92ZSA9IFtdLFxuICAgICAgaSxcbiAgICAgIGosXG4gICAgICBsLFxuICAgICAgbm9kZSxcbiAgICAgIG5vZGVzLFxuICAgICAgaXNDaGlsZCxcbiAgICAgIGN1ckxpbmUsXG4gICAgICBhZGRXb3JkU3BhY2VzLFxuICAgICAgc3R5bGUsXG4gICAgICBsaW5lTm9kZSxcbiAgICAgIGxpbmVXaWR0aCxcbiAgICAgIG9mZnNldDtcblxuICBpZiAoaXRlcmF0ZUxpbmUpIHtcbiAgICBsaW5lc0NsYXNzID0gbGluZXNDbGFzcy5zcGxpdChcIisrXCIpLmpvaW4oXCJcIik7XG4gIH0gLy9jb3B5IGFsbCB0aGUgZGVzY2VuZGFudCBub2RlcyBpbnRvIGFuIGFycmF5ICh3ZSBjYW4ndCB1c2UgYSByZWd1bGFyIG5vZGVMaXN0IGJlY2F1c2UgaXQncyBsaXZlIGFuZCB3ZSBtYXkgbmVlZCB0byByZW5lc3QgdGhpbmdzKVxuXG5cbiAgaiA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpO1xuICBsID0gai5sZW5ndGg7XG4gIG5vZGVzID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIG5vZGVzW2ldID0galtpXTtcbiAgfSAvL2ZvciBhYnNvbHV0ZSBwb3NpdGlvbmluZywgd2UgbmVlZCB0byByZWNvcmQgdGhlIHgveSBvZmZzZXRzIGFuZCB3aWR0aC9oZWlnaHQgZm9yIGV2ZXJ5IDxkaXY+LiBBbmQgZXZlbiBpZiB3ZSdyZSBub3QgcG9zaXRpb25pbmcgdGhpbmdzIGFic29sdXRlbHksIGluIG9yZGVyIHRvIGFjY29tbW9kYXRlIGxpbmVzLCB3ZSBtdXN0IGZpZ3VyZSBvdXQgd2hlcmUgdGhlIHkgb2Zmc2V0IGNoYW5nZXMgc28gdGhhdCB3ZSBjYW4gc2Vuc2Ugd2hlcmUgdGhlIGxpbmVzIGJyZWFrLCBhbmQgd2UgcG9wdWxhdGUgdGhlIGxpbmVzIGFycmF5LlxuXG5cbiAgaWYgKGxpbmVzIHx8IGFic29sdXRlKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgaXNDaGlsZCA9IG5vZGUucGFyZW50Tm9kZSA9PT0gZWxlbWVudDtcblxuICAgICAgaWYgKGlzQ2hpbGQgfHwgYWJzb2x1dGUgfHwgY2hhcnMgJiYgIXdvcmRzKSB7XG4gICAgICAgIG9mZnNldCA9IG5vZGUub2Zmc2V0VG9wO1xuXG4gICAgICAgIGlmIChsaW5lcyAmJiBpc0NoaWxkICYmIE1hdGguYWJzKG9mZnNldCAtIGxpbmVPZmZzZXRZKSA+IGxpbmVUaHJlc2hvbGQgJiYgKG5vZGUubm9kZU5hbWUgIT09IFwiQlJcIiB8fCBpID09PSAwKSkge1xuICAgICAgICAgIC8vd2UgZm91bmQgc29tZSByYXJlIG9jY2FzaW9ucyB3aGVyZSBhIGNlcnRhaW4gY2hhcmFjdGVyIGxpa2UgJiM4MjA5OyBjb3VsZCBjYXVzZSB0aGUgb2Zmc2V0VG9wIHRvIGJlIG9mZiBieSAxIHBpeGVsLCBzbyB3ZSBidWlsZCBpbiBhIHRocmVzaG9sZC5cbiAgICAgICAgICBjdXJMaW5lID0gW107XG4gICAgICAgICAgbGluZXMucHVzaChjdXJMaW5lKTtcbiAgICAgICAgICBsaW5lT2Zmc2V0WSA9IG9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYnNvbHV0ZSkge1xuICAgICAgICAgIC8vcmVjb3JkIG9mZnNldCB4IGFuZCB5LCBhcyB3ZWxsIGFzIHdpZHRoIGFuZCBoZWlnaHQgc28gdGhhdCB3ZSBjYW4gYWNjZXNzIHRoZW0gbGF0ZXIgZm9yIHBvc2l0aW9uaW5nLiBHcmFiYmluZyB0aGVtIGF0IG9uY2UgZW5zdXJlcyB3ZSBkb24ndCB0cmlnZ2VyIGEgYnJvd3NlciBwYWludCAmIHdlIG1heGltaXplIHBlcmZvcm1hbmNlLlxuICAgICAgICAgIG5vZGUuX3ggPSBub2RlLm9mZnNldExlZnQ7XG4gICAgICAgICAgbm9kZS5feSA9IG9mZnNldDtcbiAgICAgICAgICBub2RlLl93ID0gbm9kZS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICBub2RlLl9oID0gbm9kZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICBpZiAobm9kZS5faXNTcGxpdCAmJiBpc0NoaWxkIHx8ICFjaGFycyAmJiBpc0NoaWxkIHx8IHdvcmRzICYmIGlzQ2hpbGQgfHwgIXdvcmRzICYmIG5vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlID09PSBlbGVtZW50ICYmICFub2RlLnBhcmVudE5vZGUuX2lzU3BsaXQpIHtcbiAgICAgICAgICAgIGN1ckxpbmUucHVzaChub2RlKTtcbiAgICAgICAgICAgIG5vZGUuX3ggLT0gcGFkZGluZ0xlZnQ7XG5cbiAgICAgICAgICAgIGlmIChfaXNCZWZvcmVXb3JkRGVsaW1pdGVyKG5vZGUsIGVsZW1lbnQsIHdvcmREZWxpbWl0ZXIpKSB7XG4gICAgICAgICAgICAgIG5vZGUuX3dvcmRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSBcIkJSXCIgJiYgKG5vZGUubmV4dFNpYmxpbmcgJiYgbm9kZS5uZXh0U2libGluZy5ub2RlTmFtZSA9PT0gXCJCUlwiIHx8IGkgPT09IDApKSB7XG4gICAgICAgICAgICAvL3R3byBjb25zZWN1dGl2ZSA8YnI+IHRhZ3Mgc2lnbmlmeSBhIG5ldyBbZW1wdHldIGxpbmUuIEFsc28sIGlmIHRoZSBlbnRpcmUgYmxvY2sgb2YgY29udGVudCBTVEFSVFMgd2l0aCBhIDxicj4sIGFkZCBhIGxpbmUuXG4gICAgICAgICAgICBsaW5lcy5wdXNoKFtdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlzQ2hpbGQgPSBub2RlLnBhcmVudE5vZGUgPT09IGVsZW1lbnQ7XG5cbiAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gXCJCUlwiKSB7XG4gICAgICBpZiAobGluZXMgfHwgYWJzb2x1dGUpIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGVzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICBsLS07XG4gICAgICB9IGVsc2UgaWYgKCF3b3Jkcykge1xuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgIHN0eWxlID0gbm9kZS5zdHlsZTtcblxuICAgICAgaWYgKCF3b3JkcyAmJiAhaXNDaGlsZCkge1xuICAgICAgICBub2RlLl94ICs9IG5vZGUucGFyZW50Tm9kZS5feDtcbiAgICAgICAgbm9kZS5feSArPSBub2RlLnBhcmVudE5vZGUuX3k7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlLmxlZnQgPSBub2RlLl94ICsgXCJweFwiO1xuICAgICAgc3R5bGUudG9wID0gbm9kZS5feSArIFwicHhcIjtcbiAgICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjsgLy9pZiB3ZSBkb24ndCBzZXQgdGhlIHdpZHRoL2hlaWdodCwgdGhpbmdzIGNvbGxhcHNlIGluIG9sZGVyIHZlcnNpb25zIG9mIElFIGFuZCB0aGUgb3JpZ2luIGZvciB0cmFuc2Zvcm1zIGlzIHRocm93biBvZmYgaW4gYWxsIGJyb3dzZXJzLlxuXG4gICAgICBzdHlsZS53aWR0aCA9IG5vZGUuX3cgKyAxICsgXCJweFwiOyAvL0lFIGlzIDFweCBzaG9ydCBzb21ldGltZXMuIEF2b2lkIHdyYXBwaW5nXG5cbiAgICAgIHN0eWxlLmhlaWdodCA9IG5vZGUuX2ggKyBcInB4XCI7XG4gICAgfVxuXG4gICAgaWYgKCF3b3JkcyAmJiBjaGFycykge1xuICAgICAgLy93ZSBhbHdheXMgc3RhcnQgb3V0IHdyYXBwaW5nIHdvcmRzIGluIHRoZWlyIG93biA8ZGl2PiBzbyB0aGF0IGxpbmUgYnJlYWtzIGhhcHBlbiBjb3JyZWN0bHksIGJ1dCBoZXJlIHdlJ2xsIHJlbW92ZSB0aG9zZSA8ZGl2PiB0YWdzIGlmIG5lY2Vzc2FyeSBhbmQgcmVuZXN0IHRoZSBjaGFyYWN0ZXJzIGRpcmVjdGx5IGludG8gdGhlIGVsZW1lbnQgcmF0aGVyIHRoYW4gaW5zaWRlIHRoZSB3b3JkIDxkaXY+XG4gICAgICBpZiAobm9kZS5faXNTcGxpdCkge1xuICAgICAgICBub2RlLl9uZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKG5vZGUpOyAvL3B1dCBpdCBhdCB0aGUgZW5kIHRvIGtlZXAgdGhlIG9yZGVyIGNvcnJlY3QuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZS5faXNTcGxpdCkge1xuICAgICAgICBub2RlLl9wYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG5cbiAgICAgICAgaWYgKCFub2RlLnByZXZpb3VzU2libGluZyAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBub2RlLmZpcnN0Q2hpbGQuX2lzRmlyc3QgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUubmV4dFNpYmxpbmcgJiYgbm9kZS5uZXh0U2libGluZy50ZXh0Q29udGVudCA9PT0gXCIgXCIgJiYgIW5vZGUubmV4dFNpYmxpbmcubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAvL2lmIHRoZSBsYXN0IG5vZGUgaW5zaWRlIGEgbmVzdGVkIGVsZW1lbnQgaXMganVzdCBhIHNwYWNlIChsaWtlIFQ8c3Bhbj5uZXN0ZWQgPC9zcGFuPiksIHJlbW92ZSBpdCBvdGhlcndpc2UgaXQnbGwgZ2V0IHBsYWNlZCBpbiB0aGUgd3Jvbmcgb3JkZXIuIERvbid0IHJlbW92ZSBpdCByaWdodCBhd2F5LCB0aG91Z2gsIGJlY2F1c2Ugd2UgbmVlZCB0byBzZW5zZSB3aGVuIHdvcmRzL2NoYXJhY3RlcnMgYXJlIGJlZm9yZSBhIHNwYWNlIGxpa2UgX2lzQmVmb3JlV29yZERlbGltaXRlcigpLiBSZW1vdmluZyBpdCBub3cgd291bGQgbWFrZSB0aGF0IGEgZmFsc2UgbmVnYXRpdmUuXG4gICAgICAgICAgc3BhY2VOb2Rlc1RvUmVtb3ZlLnB1c2gobm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLl9uZXh0ID0gbm9kZS5uZXh0U2libGluZyAmJiBub2RlLm5leHRTaWJsaW5nLl9pc0ZpcnN0ID8gbnVsbCA6IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgbm9kZXMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIGwtLTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzQ2hpbGQpIHtcbiAgICAgICAgb2Zmc2V0ID0gIW5vZGUubmV4dFNpYmxpbmcgJiYgX2lzQmVmb3JlV29yZERlbGltaXRlcihub2RlLnBhcmVudE5vZGUsIGVsZW1lbnQsIHdvcmREZWxpbWl0ZXIpOyAvL2lmIHRoaXMgaXMgdGhlIGxhc3QgbGV0dGVyIGluIHRoZSB3b3JkIChhbmQgd2UncmUgbm90IGJyZWFraW5nIGJ5IGxpbmVzIGFuZCBub3QgcG9zaXRpb25pbmcgdGhpbmdzIGFic29sdXRlbHkpLCB3ZSBuZWVkIHRvIGFkZCBhIHNwYWNlIGFmdGVyd2FyZHMgc28gdGhhdCB0aGUgY2hhcmFjdGVycyBkb24ndCBqdXN0IG1hc2ggdG9nZXRoZXJcblxuICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlLl9wYXJlbnQpIHtcbiAgICAgICAgICBub2RlLnBhcmVudE5vZGUuX3BhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICBub2RlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoX2RvYy5jcmVhdGVUZXh0Tm9kZShcIiBcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhZyA9PT0gXCJzcGFuXCIpIHtcbiAgICAgICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZVwiOyAvL3NvIHRoYXQgd29yZCBicmVha3MgYXJlIGhvbm9yZWQgcHJvcGVybHkuXG4gICAgICAgIH1cblxuICAgICAgICBjaGFyQXJyYXkucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZS5faXNTcGxpdCAmJiAhbm9kZS5faXNTcGxpdCAmJiBub2RlLmlubmVySFRNTCAhPT0gXCJcIikge1xuICAgICAgd29yZEFycmF5LnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIGlmIChjaGFycyAmJiAhbm9kZS5faXNTcGxpdCkge1xuICAgICAgaWYgKHRhZyA9PT0gXCJzcGFuXCIpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmVcIjtcbiAgICAgIH1cblxuICAgICAgY2hhckFycmF5LnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgaSA9IHNwYWNlTm9kZXNUb1JlbW92ZS5sZW5ndGg7XG5cbiAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgc3BhY2VOb2Rlc1RvUmVtb3ZlW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3BhY2VOb2Rlc1RvUmVtb3ZlW2ldKTtcbiAgfVxuXG4gIGlmIChsaW5lcykge1xuICAgIC8vdGhlIG5leHQgNyBsaW5lcyBqdXN0IGdpdmUgdXMgdGhlIGxpbmUgd2lkdGggaW4gdGhlIG1vc3QgcmVsaWFibGUgd2F5IGFuZCBmaWd1cmUgb3V0IHRoZSBsZWZ0IG9mZnNldCAoaWYgcG9zaXRpb24gaXNuJ3QgcmVsYXRpdmUgb3IgYWJzb2x1dGUpLiBXZSBtdXN0IHNldCB0aGUgd2lkdGggYWxvbmcgd2l0aCB0ZXh0LWFsaWduIHRvIGVuc3VyZSBldmVyeXRoaW5nIHdvcmtzIHByb3Blcmx5IGZvciB2YXJpb3VzIGFsaWdubWVudHMuXG4gICAgaWYgKGFic29sdXRlKSB7XG4gICAgICBsaW5lTm9kZSA9IF9kb2MuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChsaW5lTm9kZSk7XG4gICAgICBsaW5lV2lkdGggPSBsaW5lTm9kZS5vZmZzZXRXaWR0aCArIFwicHhcIjtcbiAgICAgIG9mZnNldCA9IGxpbmVOb2RlLm9mZnNldFBhcmVudCA9PT0gZWxlbWVudCA/IDAgOiBlbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGxpbmVOb2RlKTtcbiAgICB9XG5cbiAgICBzdHlsZSA9IGVsZW1lbnQuc3R5bGUuY3NzVGV4dDtcbiAgICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcImRpc3BsYXk6bm9uZTtcIjsgLy90byBpbXByb3ZlIHBlcmZvcm1hbmNlLCBzZXQgZGlzcGxheTpub25lIG9uIHRoZSBlbGVtZW50IHNvIHRoYXQgdGhlIGJyb3dzZXIgZG9lc24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IHJlZmxvd2luZyBvciByZW5kZXJpbmcgd2hpbGUgd2UncmUgcmVuZXN0aW5nIHRoaW5ncy4gV2UnbGwgcmV2ZXJ0IHRoZSBjc3NUZXh0IGxhdGVyLlxuICAgIC8vd2UgY2FuJ3QgdXNlIGVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIiBiZWNhdXNlIHRoYXQgY2F1c2VzIElFIHRvIGxpdGVyYWxseSBkZWxldGUgYWxsIHRoZSBub2RlcyBhbmQgdGhlaXIgY29udGVudCBldmVuIHRob3VnaCB3ZSd2ZSBzdG9yZWQgdGhlbSBpbiBhbiBhcnJheSEgU28gd2UgbXVzdCBsb29wIHRocm91Z2ggdGhlIGNoaWxkcmVuIGFuZCByZW1vdmUgdGhlbS5cblxuICAgIHdoaWxlIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBhZGRXb3JkU3BhY2VzID0gd29yZERlbGltaXRlciA9PT0gXCIgXCIgJiYgKCFhYnNvbHV0ZSB8fCAhd29yZHMgJiYgIWNoYXJzKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY3VyTGluZSA9IGxpbmVzW2ldO1xuICAgICAgbGluZU5vZGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgIGxpbmVOb2RlLnN0eWxlLmNzc1RleHQgPSBcImRpc3BsYXk6YmxvY2s7dGV4dC1hbGlnbjpcIiArIHRleHRBbGlnbiArIFwiO3Bvc2l0aW9uOlwiICsgKGFic29sdXRlID8gXCJhYnNvbHV0ZTtcIiA6IFwicmVsYXRpdmU7XCIpO1xuXG4gICAgICBpZiAobGluZXNDbGFzcykge1xuICAgICAgICBsaW5lTm9kZS5jbGFzc05hbWUgPSBsaW5lc0NsYXNzICsgKGl0ZXJhdGVMaW5lID8gaSArIDEgOiBcIlwiKTtcbiAgICAgIH1cblxuICAgICAgbGluZUFycmF5LnB1c2gobGluZU5vZGUpO1xuICAgICAgbCA9IGN1ckxpbmUubGVuZ3RoO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIGlmIChjdXJMaW5lW2pdLm5vZGVOYW1lICE9PSBcIkJSXCIpIHtcbiAgICAgICAgICBub2RlID0gY3VyTGluZVtqXTtcbiAgICAgICAgICBsaW5lTm9kZS5hcHBlbmRDaGlsZChub2RlKTtcblxuICAgICAgICAgIGlmIChhZGRXb3JkU3BhY2VzICYmIG5vZGUuX3dvcmRFbmQpIHtcbiAgICAgICAgICAgIGxpbmVOb2RlLmFwcGVuZENoaWxkKF9kb2MuY3JlYXRlVGV4dE5vZGUoXCIgXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgICAgIGxpbmVOb2RlLnN0eWxlLnRvcCA9IG5vZGUuX3kgKyBcInB4XCI7XG4gICAgICAgICAgICAgIGxpbmVOb2RlLnN0eWxlLmxlZnQgPSBwYWRkaW5nTGVmdCArIG9mZnNldCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZS5zdHlsZS50b3AgPSBcIjBweFwiO1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgICAgICAgIG5vZGUuc3R5bGUubGVmdCA9IG5vZGUuX3ggLSBvZmZzZXQgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsID09PSAwKSB7XG4gICAgICAgIC8vaWYgdGhlcmUgYXJlIG5vIG5vZGVzIGluIHRoZSBsaW5lICh0eXBpY2FsbHkgbWVhbmluZyB0aGVyZSB3ZXJlIHR3byBjb25zZWN1dGl2ZSA8YnI+IHRhZ3MsIGp1c3QgYWRkIGEgbm9uLWJyZWFraW5nIHNwYWNlIHNvIHRoYXQgdGhpbmdzIGRpc3BsYXkgcHJvcGVybHkuXG4gICAgICAgIGxpbmVOb2RlLmlubmVySFRNTCA9IFwiJm5ic3A7XCI7XG4gICAgICB9IGVsc2UgaWYgKCF3b3JkcyAmJiAhY2hhcnMpIHtcbiAgICAgICAgX2RlV29yZGlmeShsaW5lTm9kZSk7XG5cbiAgICAgICAgX3N3YXBUZXh0KGxpbmVOb2RlLCBTdHJpbmcuZnJvbUNoYXJDb2RlKDE2MCksIFwiIFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFic29sdXRlKSB7XG4gICAgICAgIGxpbmVOb2RlLnN0eWxlLndpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBsaW5lTm9kZS5zdHlsZS5oZWlnaHQgPSBub2RlLl9oICsgXCJweFwiO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGxpbmVOb2RlKTtcbiAgICB9XG5cbiAgICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBzdHlsZTtcbiAgfSAvL2lmIGV2ZXJ5dGhpbmcgc2hpZnRzIHRvIGJlaW5nIHBvc2l0aW9uOmFic29sdXRlLCB0aGUgY29udGFpbmVyIGNhbiBjb2xsYXBzZSBpbiB0ZXJtcyBvZiBoZWlnaHQgb3Igd2lkdGgsIHNvIGZpeCB0aGF0IGhlcmUuXG5cblxuICBpZiAoYWJzb2x1dGUpIHtcbiAgICBpZiAob3JpZ0hlaWdodCA+IGVsZW1lbnQuY2xpZW50SGVpZ2h0KSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IG9yaWdIZWlnaHQgLSBwYWRUb3BBbmRCb3R0b20gKyBcInB4XCI7XG5cbiAgICAgIGlmIChlbGVtZW50LmNsaWVudEhlaWdodCA8IG9yaWdIZWlnaHQpIHtcbiAgICAgICAgLy9JRTggYW5kIGVhcmxpZXIgdXNlIGEgZGlmZmVyZW50IGJveCBtb2RlbCAtIHdlIG11c3QgaW5jbHVkZSBwYWRkaW5nIGFuZCBib3JkZXJzXG4gICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gb3JpZ0hlaWdodCArIGJvcmRlclRvcEFuZEJvdHRvbSArIFwicHhcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3JpZ1dpZHRoID4gZWxlbWVudC5jbGllbnRXaWR0aCkge1xuICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IG9yaWdXaWR0aCAtIHBhZExlZnRBbmRSaWdodCArIFwicHhcIjtcblxuICAgICAgaWYgKGVsZW1lbnQuY2xpZW50V2lkdGggPCBvcmlnV2lkdGgpIHtcbiAgICAgICAgLy9JRTggYW5kIGVhcmxpZXIgdXNlIGEgZGlmZmVyZW50IGJveCBtb2RlbCAtIHdlIG11c3QgaW5jbHVkZSBwYWRkaW5nIGFuZCBib3JkZXJzXG4gICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBvcmlnV2lkdGggKyBib3JkZXJMZWZ0QW5kUmlnaHQgKyBcInB4XCI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3B1c2hSZXZlcnNlZChhbGxDaGFycywgY2hhckFycmF5KTtcblxuICBpZiAod29yZHMpIHtcbiAgICBfcHVzaFJldmVyc2VkKGFsbFdvcmRzLCB3b3JkQXJyYXkpO1xuICB9XG5cbiAgX3B1c2hSZXZlcnNlZChhbGxMaW5lcywgbGluZUFycmF5KTtcbn0sXG4gICAgX3NwbGl0UmF3VGV4dCA9IGZ1bmN0aW9uIF9zcGxpdFJhd1RleHQoZWxlbWVudCwgdmFycywgd29yZFN0YXJ0LCBjaGFyU3RhcnQpIHtcbiAgdmFyIHRhZyA9IHZhcnMudGFnID8gdmFycy50YWcgOiB2YXJzLnNwYW4gPyBcInNwYW5cIiA6IFwiZGl2XCIsXG4gICAgICB0eXBlcyA9IHZhcnMudHlwZSB8fCB2YXJzLnNwbGl0IHx8IFwiY2hhcnMsd29yZHMsbGluZXNcIixcbiAgICAgIC8vd29yZHMgPSAodHlwZXMuaW5kZXhPZihcIndvcmRzXCIpICE9PSAtMSksXG4gIGNoYXJzID0gfnR5cGVzLmluZGV4T2YoXCJjaGFyc1wiKSxcbiAgICAgIGFic29sdXRlID0gX2lzQWJzb2x1dGUodmFycyksXG4gICAgICB3b3JkRGVsaW1pdGVyID0gdmFycy53b3JkRGVsaW1pdGVyIHx8IFwiIFwiLFxuICAgICAgc3BhY2UgPSB3b3JkRGVsaW1pdGVyICE9PSBcIiBcIiA/IFwiXCIgOiBhYnNvbHV0ZSA/IFwiJiMxNzM7IFwiIDogXCIgXCIsXG4gICAgICB3b3JkRW5kID0gXCI8L1wiICsgdGFnICsgXCI+XCIsXG4gICAgICB3b3JkSXNPcGVuID0gMSxcbiAgICAgIHNwZWNpYWxDaGFycyA9IHZhcnMuc3BlY2lhbENoYXJzID8gdHlwZW9mIHZhcnMuc3BlY2lhbENoYXJzID09PSBcImZ1bmN0aW9uXCIgPyB2YXJzLnNwZWNpYWxDaGFycyA6IF9maW5kU3BlY2lhbENoYXJzIDogbnVsbCxcbiAgICAgIC8vc3BlY2lhbENoYXJzIGNhbiBiZSBhbiBhcnJheSBvciBhIGZ1bmN0aW9uLiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgYWx3YXlzIHNldCB0aGlzIGxvY2FsIFwic3BlY2lhbENoYXJzXCIgdG8gYSBmdW5jdGlvbiB0byB3aGljaCB3ZSBwYXNzIHRoZSByZW1haW5pbmcgdGV4dCBhbmQgd2hhdGV2ZXIgdGhlIG9yaWdpbmFsIHZhcnMuc3BlY2lhbENoYXJzIHdhcyBzbyB0aGF0IGlmIGl0J3MgYW4gYXJyYXksIGl0IHdvcmtzIHdpdGggdGhlIF9maW5kU3BlY2lhbENoYXJzKCkgZnVuY3Rpb24uXG4gIHRleHQsXG4gICAgICBzcGxpdFRleHQsXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIGwsXG4gICAgICBjaGFyYWN0ZXIsXG4gICAgICBoYXNUYWdTdGFydCxcbiAgICAgIHRlc3RSZXN1bHQsXG4gICAgICBjb250YWluZXIgPSBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgcGFyZW50Lmluc2VydEJlZm9yZShjb250YWluZXIsIGVsZW1lbnQpO1xuICBjb250YWluZXIudGV4dENvbnRlbnQgPSBlbGVtZW50Lm5vZGVWYWx1ZTtcbiAgcGFyZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICBlbGVtZW50ID0gY29udGFpbmVyO1xuICB0ZXh0ID0gZ2V0VGV4dChlbGVtZW50KTtcbiAgaGFzVGFnU3RhcnQgPSB0ZXh0LmluZGV4T2YoXCI8XCIpICE9PSAtMTtcblxuICBpZiAodmFycy5yZWR1Y2VXaGl0ZVNwYWNlICE9PSBmYWxzZSkge1xuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoX211bHRpcGxlU3BhY2VzRXhwLCBcIiBcIikucmVwbGFjZShfc3RyaXBFeHAsIFwiXCIpO1xuICB9XG5cbiAgaWYgKGhhc1RhZ1N0YXJ0KSB7XG4gICAgdGV4dCA9IHRleHQuc3BsaXQoXCI8XCIpLmpvaW4oXCJ7e0xUfX1cIik7IC8vd2UgY2FuJ3QgbGVhdmUgXCI8XCIgaW4gdGhlIHN0cmluZywgb3Igd2hlbiB3ZSBzZXQgdGhlIGlubmVySFRNTCwgaXQgY2FuIGJlIGludGVycHJldGVkIGFzIGEgbm9kZVxuICB9XG5cbiAgbCA9IHRleHQubGVuZ3RoO1xuICBzcGxpdFRleHQgPSAodGV4dC5jaGFyQXQoMCkgPT09IFwiIFwiID8gc3BhY2UgOiBcIlwiKSArIHdvcmRTdGFydCgpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICBjaGFyYWN0ZXIgPSB0ZXh0LmNoYXJBdChpKTtcblxuICAgIGlmIChzcGVjaWFsQ2hhcnMgJiYgKHRlc3RSZXN1bHQgPSBzcGVjaWFsQ2hhcnModGV4dC5zdWJzdHIoaSksIHZhcnMuc3BlY2lhbENoYXJzKSkpIHtcbiAgICAgIC8vIGxvb2sgZm9yIGFueSBzcGVjaWFsQ2hhcnMgdGhhdCB3ZXJlIGRlY2xhcmVkLiBSZW1lbWJlciwgdGhleSBjYW4gYmUgcGFzc2VkIGluIGxpa2Uge3NwZWNpYWxDaGFyczpbXCLgpK7gpYBcIiwgXCLgpKrgpL5cIiwgXCLgpLngpYhcIl19IG9yIGEgZnVuY3Rpb24gY291bGQgYmUgZGVmaW5lZCBpbnN0ZWFkLiBFaXRoZXIgd2F5LCB0aGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgYmUgZ3JvdXBlZCB0b2dldGhlciBmb3IgdGhpcyBcImNoYXJhY3RlclwiLlxuICAgICAgY2hhcmFjdGVyID0gdGV4dC5zdWJzdHIoaSwgdGVzdFJlc3VsdCB8fCAxKTtcbiAgICAgIHNwbGl0VGV4dCArPSBjaGFycyAmJiBjaGFyYWN0ZXIgIT09IFwiIFwiID8gY2hhclN0YXJ0KCkgKyBjaGFyYWN0ZXIgKyBcIjwvXCIgKyB0YWcgKyBcIj5cIiA6IGNoYXJhY3RlcjtcbiAgICAgIGkgKz0gdGVzdFJlc3VsdCAtIDE7XG4gICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IHdvcmREZWxpbWl0ZXIgJiYgdGV4dC5jaGFyQXQoaSAtIDEpICE9PSB3b3JkRGVsaW1pdGVyICYmIGkpIHtcbiAgICAgIHNwbGl0VGV4dCArPSB3b3JkSXNPcGVuID8gd29yZEVuZCA6IFwiXCI7XG4gICAgICB3b3JkSXNPcGVuID0gMDtcblxuICAgICAgd2hpbGUgKHRleHQuY2hhckF0KGkgKyAxKSA9PT0gd29yZERlbGltaXRlcikge1xuICAgICAgICAvL3NraXAgb3ZlciBlbXB0eSBzcGFjZXMgKHRvIGF2b2lkIG1ha2luZyB0aGVtIHdvcmRzKVxuICAgICAgICBzcGxpdFRleHQgKz0gc3BhY2U7XG4gICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPT09IGwgLSAxKSB7XG4gICAgICAgIHNwbGl0VGV4dCArPSBzcGFjZTtcbiAgICAgIH0gZWxzZSBpZiAodGV4dC5jaGFyQXQoaSArIDEpICE9PSBcIilcIikge1xuICAgICAgICBzcGxpdFRleHQgKz0gc3BhY2UgKyB3b3JkU3RhcnQoKTtcbiAgICAgICAgd29yZElzT3BlbiA9IDE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IFwie1wiICYmIHRleHQuc3Vic3RyKGksIDYpID09PSBcInt7TFR9fVwiKSB7XG4gICAgICBzcGxpdFRleHQgKz0gY2hhcnMgPyBjaGFyU3RhcnQoKSArIFwie3tMVH19XCIgKyBcIjwvXCIgKyB0YWcgKyBcIj5cIiA6IFwie3tMVH19XCI7XG4gICAgICBpICs9IDU7XG4gICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSA+PSAweEQ4MDAgJiYgY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgPD0gMHhEQkZGIHx8IHRleHQuY2hhckNvZGVBdChpICsgMSkgPj0gMHhGRTAwICYmIHRleHQuY2hhckNvZGVBdChpICsgMSkgPD0gMHhGRTBGKSB7XG4gICAgICAvL3NwZWNpYWwgZW1vamkgY2hhcmFjdGVycyB1c2UgMiBvciA0IHVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IHdlIG11c3Qga2VlcCB0b2dldGhlci5cbiAgICAgIGogPSAoKHRleHQuc3Vic3RyKGksIDEyKS5zcGxpdChlbW9qaUV4cCkgfHwgW10pWzFdIHx8IFwiXCIpLmxlbmd0aCB8fCAyO1xuICAgICAgc3BsaXRUZXh0ICs9IGNoYXJzICYmIGNoYXJhY3RlciAhPT0gXCIgXCIgPyBjaGFyU3RhcnQoKSArIHRleHQuc3Vic3RyKGksIGopICsgXCI8L1wiICsgdGFnICsgXCI+XCIgOiB0ZXh0LnN1YnN0cihpLCBqKTtcbiAgICAgIGkgKz0gaiAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNwbGl0VGV4dCArPSBjaGFycyAmJiBjaGFyYWN0ZXIgIT09IFwiIFwiID8gY2hhclN0YXJ0KCkgKyBjaGFyYWN0ZXIgKyBcIjwvXCIgKyB0YWcgKyBcIj5cIiA6IGNoYXJhY3RlcjtcbiAgICB9XG4gIH1cblxuICBlbGVtZW50Lm91dGVySFRNTCA9IHNwbGl0VGV4dCArICh3b3JkSXNPcGVuID8gd29yZEVuZCA6IFwiXCIpO1xuXG4gIGlmIChoYXNUYWdTdGFydCkge1xuICAgIF9zd2FwVGV4dChwYXJlbnQsIFwie3tMVH19XCIsIFwiPFwiKTsgLy9ub3RlOiBkb24ndCBwZXJmb3JtIHRoaXMgb24gXCJlbGVtZW50XCIgYmVjYXVzZSB0aGF0IGdldHMgcmVwbGFjZWQgd2l0aCBhbGwgbmV3IGVsZW1lbnRzIHdoZW4gd2Ugc2V0IGVsZW1lbnQub3V0ZXJIVE1MLlxuXG4gIH1cbn0sXG4gICAgX3NwbGl0ID0gZnVuY3Rpb24gX3NwbGl0KGVsZW1lbnQsIHZhcnMsIHdvcmRTdGFydCwgY2hhclN0YXJ0KSB7XG4gIHZhciBjaGlsZHJlbiA9IF90b0FycmF5KGVsZW1lbnQuY2hpbGROb2RlcyksXG4gICAgICBsID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgYWJzb2x1dGUgPSBfaXNBYnNvbHV0ZSh2YXJzKSxcbiAgICAgIGksXG4gICAgICBjaGlsZDtcblxuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMyB8fCBsID4gMSkge1xuICAgIHZhcnMuYWJzb2x1dGUgPSBmYWxzZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSAhPT0gMyB8fCAvXFxTKy8udGVzdChjaGlsZC5ub2RlVmFsdWUpKSB7XG4gICAgICAgIGlmIChhYnNvbHV0ZSAmJiBjaGlsZC5ub2RlVHlwZSAhPT0gMyAmJiBfZ2V0Q29tcHV0ZWRTdHlsZShjaGlsZCkuZGlzcGxheSA9PT0gXCJpbmxpbmVcIikge1xuICAgICAgICAgIC8vaWYgdGhlcmUncyBhIGNoaWxkIG5vZGUgdGhhdCdzIGRpc3BsYXk6aW5saW5lLCBzd2l0Y2ggaXQgdG8gaW5saW5lLWJsb2NrIHNvIHRoYXQgYWJzb2x1dGUgcG9zaXRpb25pbmcgd29ya3MgcHJvcGVybHkgKG1vc3QgYnJvd3NlcnMgZG9uJ3QgcmVwb3J0IG9mZnNldFRvcC9vZmZzZXRMZWZ0IHByb3Blcmx5IGluc2lkZSBhIDxzcGFuPiBmb3IgZXhhbXBsZSlcbiAgICAgICAgICBjaGlsZC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgICBjaGlsZC5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkLl9pc1NwbGl0ID0gdHJ1ZTtcblxuICAgICAgICBfc3BsaXQoY2hpbGQsIHZhcnMsIHdvcmRTdGFydCwgY2hhclN0YXJ0KTsgLy9kb24ndCBzcGxpdCBsaW5lcyBvbiBjaGlsZCBlbGVtZW50c1xuXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFycy5hYnNvbHV0ZSA9IGFic29sdXRlO1xuICAgIGVsZW1lbnQuX2lzU3BsaXQgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIF9zcGxpdFJhd1RleHQoZWxlbWVudCwgdmFycywgd29yZFN0YXJ0LCBjaGFyU3RhcnQpO1xufTtcblxuZXhwb3J0IHZhciBTcGxpdFRleHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTcGxpdFRleHQoZWxlbWVudCwgdmFycykge1xuICAgIGlmICghX2NvcmVJbml0dGVkKSB7XG4gICAgICBfaW5pdENvcmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnRzID0gX3RvQXJyYXkoZWxlbWVudCk7XG4gICAgdGhpcy5jaGFycyA9IFtdO1xuICAgIHRoaXMud29yZHMgPSBbXTtcbiAgICB0aGlzLmxpbmVzID0gW107XG4gICAgdGhpcy5fb3JpZ2luYWxzID0gW107XG4gICAgdGhpcy52YXJzID0gdmFycyB8fCB7fTtcblxuICAgIGlmIChfYm9udXNWYWxpZGF0ZWQpIHtcbiAgICAgIHRoaXMuc3BsaXQodmFycyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90byA9IFNwbGl0VGV4dC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQodmFycykge1xuICAgIGlmICh0aGlzLmlzU3BsaXQpIHtcbiAgICAgIHRoaXMucmV2ZXJ0KCk7XG4gICAgfVxuXG4gICAgdGhpcy52YXJzID0gdmFycyA9IHZhcnMgfHwgdGhpcy52YXJzO1xuICAgIHRoaXMuX29yaWdpbmFscy5sZW5ndGggPSB0aGlzLmNoYXJzLmxlbmd0aCA9IHRoaXMud29yZHMubGVuZ3RoID0gdGhpcy5saW5lcy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCxcbiAgICAgICAgdGFnID0gdmFycy50YWcgPyB2YXJzLnRhZyA6IHZhcnMuc3BhbiA/IFwic3BhblwiIDogXCJkaXZcIixcbiAgICAgICAgd29yZFN0YXJ0ID0gX2Nzc0NsYXNzRnVuYyh2YXJzLndvcmRzQ2xhc3MsIHRhZyksXG4gICAgICAgIGNoYXJTdGFydCA9IF9jc3NDbGFzc0Z1bmModmFycy5jaGFyc0NsYXNzLCB0YWcpLFxuICAgICAgICBvcmlnSGVpZ2h0LFxuICAgICAgICBvcmlnV2lkdGgsXG4gICAgICAgIGU7IC8vd2Ugc3BsaXQgaW4gcmV2ZXJzZWQgb3JkZXIgc28gdGhhdCBpZi93aGVuIHdlIHBvc2l0aW9uOmFic29sdXRlIGVsZW1lbnRzLCB0aGV5IGRvbid0IGFmZmVjdCB0aGUgcG9zaXRpb24gb2YgdGhlIG9uZXMgYWZ0ZXIgdGhlbSBpbiB0aGUgZG9jdW1lbnQgZmxvdyAoc2hpZnRpbmcgdGhlbSB1cCBhcyB0aGV5J3JlIHRha2VuIG91dCBvZiB0aGUgZG9jdW1lbnQgZmxvdykuXG5cblxuICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgZSA9IHRoaXMuZWxlbWVudHNbaV07XG4gICAgICB0aGlzLl9vcmlnaW5hbHNbaV0gPSBlLmlubmVySFRNTDtcbiAgICAgIG9yaWdIZWlnaHQgPSBlLmNsaWVudEhlaWdodDtcbiAgICAgIG9yaWdXaWR0aCA9IGUuY2xpZW50V2lkdGg7XG5cbiAgICAgIF9zcGxpdChlLCB2YXJzLCB3b3JkU3RhcnQsIGNoYXJTdGFydCk7XG5cbiAgICAgIF9zZXRQb3NpdGlvbnNBZnRlclNwbGl0KGUsIHZhcnMsIHRoaXMuY2hhcnMsIHRoaXMud29yZHMsIHRoaXMubGluZXMsIG9yaWdXaWR0aCwgb3JpZ0hlaWdodCk7XG4gICAgfVxuXG4gICAgdGhpcy5jaGFycy5yZXZlcnNlKCk7XG4gICAgdGhpcy53b3Jkcy5yZXZlcnNlKCk7XG4gICAgdGhpcy5saW5lcy5yZXZlcnNlKCk7XG4gICAgdGhpcy5pc1NwbGl0ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ucmV2ZXJ0ID0gZnVuY3Rpb24gcmV2ZXJ0KCkge1xuICAgIHZhciBvcmlnaW5hbHMgPSB0aGlzLl9vcmlnaW5hbHM7XG5cbiAgICBpZiAoIW9yaWdpbmFscykge1xuICAgICAgdGhyb3cgXCJyZXZlcnQoKSBjYWxsIHdhc24ndCBzY29wZWQgcHJvcGVybHkuXCI7XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICByZXR1cm4gZS5pbm5lckhUTUwgPSBvcmlnaW5hbHNbaV07XG4gICAgfSk7XG4gICAgdGhpcy5jaGFycyA9IFtdO1xuICAgIHRoaXMud29yZHMgPSBbXTtcbiAgICB0aGlzLmxpbmVzID0gW107XG4gICAgdGhpcy5pc1NwbGl0ID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgU3BsaXRUZXh0LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShlbGVtZW50LCB2YXJzKSB7XG4gICAgcmV0dXJuIG5ldyBTcGxpdFRleHQoZWxlbWVudCwgdmFycyk7XG4gIH07XG5cbiAgcmV0dXJuIFNwbGl0VGV4dDtcbn0oKTtcblNwbGl0VGV4dC52ZXJzaW9uID0gXCIzLjIuNlwiO1xuZXhwb3J0IHsgU3BsaXRUZXh0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8vIEFwcFxuaW1wb3J0IGFwcFN0b3JlIGZyb20gJy4vYXBwU3RvcmUnO1xuaW1wb3J0IGFwcENvcmUgZnJvbSAnLi9hcHBDb3JlJzsgLy8gQ2xhc3Nlc1xuXG5pbXBvcnQgZG9tRXZlbnRzIGZyb20gJy4uL2NsYXNzZXMvZG9tRXZlbnRzJzsgLy8gR1NBUCBMaWJyYXJ5XG5cbmltcG9ydCBnc2FwIGZyb20gJ2dzYXAnO1xuaW1wb3J0IFNwbGl0VGV4dCBmcm9tICcuLi9jbGFzc2VzL3NwbGl0VGV4dCc7XG5pbXBvcnQgeyBQcmV2ZW50U2Nyb2xsaW5nLCBSZUVuYWJsZVNjcm9sbGluZyB9IGZyb20gJ3ByZXZlbnQtc2Nyb2xsaW5nJztcbnZhciBfc2luZ2xldG9uID0gbnVsbDtcblxudmFyIGFwcFVpID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gYXBwVWkoZGF0YSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBhcHBVaSk7XG5cbiAgICBpZiAoIV9zaW5nbGV0b24pIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICBfc2luZ2xldG9uID0gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9zaW5nbGV0b247XG4gICAgfSAvLyBTdG9yZVxuXG5cbiAgICB0aGlzLmFwcFN0b3JlID0gYXBwU3RvcmU7IC8vIEFwcCByZWZlcmVuY2VzXG5cbiAgICB0aGlzLmFwcENvcmUgPSBuZXcgYXBwQ29yZSgpOyAvLyBFdmVudHNcblxuICAgIHRoaXMuZG9tRXZlbnRzID0gbmV3IGRvbUV2ZW50cygpO1xuICAgIHRoaXMubWVudSA9IG51bGw7XG4gICAgdGhpcy5ndWlkZXMgPSBudWxsO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IG51bGw7XG4gICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgdGhpcy5hcHBTdG9yZS5maXJzdE5hdmlnYXRpb24gPSB0aGlzLmFwcFN0b3JlLmN1cnJlbnRTZWN0aW9uID09PSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKGFwcFVpLCBbe1xuICAgIGtleTogXCJzZWxlY3RvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0b3JzKCkge1xuICAgICAgLy8gRGVmYXVsdFxuICAgICAgdGhpcy4kYXBwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpO1xuICAgICAgdGhpcy4kbWFzayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYXNrJyk7XG4gICAgICB0aGlzLiRoZWFkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGVhZGVyJyk7XG4gICAgICB0aGlzLiR0cmlnZ2VyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RyaWdnZXInKTtcbiAgICAgIHRoaXMuJGxvZ28gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9nbycpO1xuICAgICAgdGhpcy4kcmVxdWVzdEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidXR0b24tLXJlcXVlc3QnKTtcbiAgICAgIHRoaXMuJGNpcmNsZUJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidXR0b24tLWNpcmNsZScpOyAvLyBNZW51XG5cbiAgICAgIHRoaXMuJG1lbnUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWVudScpO1xuXG4gICAgICBpZiAodGhpcy4kbWVudSkge1xuICAgICAgICB0aGlzLiRtZW51TWFzayA9IHRoaXMuJG1lbnUucXVlcnlTZWxlY3RvcignLm1lbnVfX21hc2snKTtcbiAgICAgICAgdGhpcy4kbWVudUNvbnRlbnQgPSB0aGlzLiRtZW51LnF1ZXJ5U2VsZWN0b3IoJy5tZW51X19jb250ZW50Jyk7XG4gICAgICAgIHRoaXMuJG1lbnVMaW5rcyA9IHRoaXMuJG1lbnUucXVlcnlTZWxlY3RvckFsbCgnbGknKTtcbiAgICAgIH0gLy8gR3VpZGVzXG5cblxuICAgICAgdGhpcy4kZ3VpZGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2d1aWRlcycpO1xuXG4gICAgICBpZiAodGhpcy4kZ3VpZGVzKSB7XG4gICAgICAgIHRoaXMuJGd1aWRlc1N3aXRjaGVyID0gdGhpcy4kZ3VpZGVzLnF1ZXJ5U2VsZWN0b3IoJy5ndWlkZXNfX3N3aXRjaGVyJyk7XG4gICAgICAgIHRoaXMuJGd1aWRlc1N3aXRjaGVyMiA9IHRoaXMuJGd1aWRlcy5xdWVyeVNlbGVjdG9yKCcuZ3VpZGVzX19zd2l0Y2hlcjInKTtcbiAgICAgICAgdGhpcy4kZ3VpZGVzSHIgPSB0aGlzLiRndWlkZXMucXVlcnlTZWxlY3RvcignLmd1aWRlc19faG9yaXpvbnRhbCcpO1xuICAgICAgICB0aGlzLiRndWlkZXNWciA9IHRoaXMuJGd1aWRlcy5xdWVyeVNlbGVjdG9yKCcuZ3VpZGVzX192ZXJ0aWNhbCcpO1xuICAgICAgICB0aGlzLiRndWlkZXNIcjIgPSB0aGlzLiRndWlkZXMucXVlcnlTZWxlY3RvcignLmd1aWRlc19faG9yaXpvbnRhbDInKTtcbiAgICAgICAgdGhpcy4kZ3VpZGVzVnIyID0gdGhpcy4kZ3VpZGVzLnF1ZXJ5U2VsZWN0b3IoJy5ndWlkZXNfX3ZlcnRpY2FsMicpO1xuICAgICAgfSAvLyBMb2FkZXJcbiAgICAgIC8vIHRoaXMuJGxvYWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2FkZXInKTtcbiAgICAgIC8vIGlmKHRoaXMuJGxvYWRlcilcbiAgICAgIC8vIHtcbiAgICAgIC8vICAgICB0aGlzLiRsb2FkZXJJbm5lciA9IHRoaXMuJGxvYWRlci5xdWVyeVNlbGVjdG9yKCcuaW5uZXInKTtcbiAgICAgIC8vICAgICB0aGlzLiRsb2FkZXJQcm9ncmVzcyA9IHRoaXMuJGxvYWRlci5xdWVyeVNlbGVjdG9yKCcuaW5uZXIgLnByb2dyZXNzJyk7XG4gICAgICAvLyB9XG4gICAgICAvLyBDb29raWVzXG5cblxuICAgICAgdGhpcy4kY29va2llcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb29raWUtbGF3LWluZm8tYmFyJyk7XG5cbiAgICAgIGlmICh0aGlzLiRjb29raWVzKSB7XG4gICAgICAgIHRoaXMuJGNvb2tpZXNCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdhLm1lZGl1bScpO1xuICAgICAgICB0aGlzLiRjb29raWVzTW9kYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2xpLW1vZGFsJyk7XG4gICAgICAgIHRoaXMuJGNvb2tpZXNTYXZlID0gdGhpcy4kY29va2llc01vZGFsLnF1ZXJ5U2VsZWN0b3IoJ2Ejd3QtY2xpLXByaXZhY3ktc2F2ZS1idG4nKTtcbiAgICAgICAgdGhpcy4kY29va2llc0NhdGVnb3J5ID0gdGhpcy4kY29va2llc01vZGFsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2EuY2xpLW5hdi1saW5rJyk7XG4gICAgICB9IC8vIE5vdGljZVxuXG5cbiAgICAgIHRoaXMuJG5vdGljZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdub3RpY2UnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLiRndWlkZXMpIHtcbiAgICAgICAgdGhpcy5kb21FdmVudHMuYWRkKHRoaXMuJGd1aWRlc1N3aXRjaGVyLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuZ3VpZGVzU3dpdGNoZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzLmFkZCh0aGlzLiRndWlkZXNTd2l0Y2hlcjIsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5ndWlkZXNTd2l0Y2hlcjIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIGlmICh0aGlzLiRtZW51TGlua3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRtZW51TGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3XG4gICAgICAgICAgbmV3IFNwbGl0VGV4dCh0aGlzLiRtZW51TGlua3NbaV0sIHtcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lcyB3b3JkcyBjaGFycycsXG4gICAgICAgICAgICBsaW5lc0NsYXNzOiAnbGluZSBsaW5lLS0rKycsXG4gICAgICAgICAgICB3b3Jkc0NsYXNzOiAnd29yZCB3b3JkLS0rKycsXG4gICAgICAgICAgICBjaGFyc0NsYXNzOiAnY2hhciBjaGFyLS0rKydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgY2hhcnMgPSB0aGlzLiRtZW51TGlua3NbaV0ucXVlcnlTZWxlY3RvckFsbCgnLmNoYXInKTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGdzYXAuc2V0KGNoYXJzW2pdLCB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgICAgICAgeTogJy0xMDAlJyxcbiAgICAgICAgICAgICAgcm90YXRpb246ICczZGVnJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLiRjb29raWVzKSB7XG4gICAgICAgIC8vIENvb2tpZXNcbiAgICAgICAgaWYgKHRoaXMuJGNvb2tpZXNCdXR0b24pIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2NyaXB0LXVybFxuICAgICAgICAgIHZhciBkaXNhYmxlZCA9ICdqYXZhc2NyaXB0OiB2b2lkKDApJztcblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLiRjb29raWVzQnV0dG9uLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdGhpcy4kY29va2llc0J1dHRvbltfaV0uc2V0QXR0cmlidXRlKCdocmVmJywgZGlzYWJsZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLiRjb29raWVzTW9kYWwpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2NyaXB0LXVybFxuICAgICAgICAgIHZhciBfZGlzYWJsZWQgPSAnamF2YXNjcmlwdDogdm9pZCgwKSc7XG4gICAgICAgICAgdGhpcy4kY29va2llc1NhdmUuc2V0QXR0cmlidXRlKCdocmVmJywgX2Rpc2FibGVkKTtcblxuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHRoaXMuJGNvb2tpZXNDYXRlZ29yeS5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICB0aGlzLiRjb29raWVzQ2F0ZWdvcnlbX2kyXS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBfZGlzYWJsZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoaWRlTG9hZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGVMb2FkZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gT3BhY2l0eVxuICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuY3VycmVudCAhPT0gJ2hvbWUnKSB7XG4gICAgICAgIGdzYXAudG8odGhpcy5hcHBTdG9yZS5jdXJyZW50U2VjdGlvbi53cmFwLCB7XG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICBkdXJhdGlvbjogMSxcbiAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCcsXG4gICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczIuJGNvb2tpZXMpIGdzYXAudG8oX3RoaXMyLiRjb29raWVzLCB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAxLFxuICAgICAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnc2FwLnRvKHRoaXMuYXBwU3RvcmUuY3VycmVudFNlY3Rpb24ud3JhcCwge1xuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgZHVyYXRpb246IDEsXG4gICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnLFxuICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzMi5hcHBTdG9yZS5pc0Rlc2t0b3ApIGdzYXAudG8oX3RoaXMyLiRjb29raWVzLCB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAxLFxuICAgICAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNob3dIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd0hlYWRlcigpIHtcbiAgICAgIGlmICh0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkgZ3NhcC50byh0aGlzLiRoZWFkZXIsIHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgZHVyYXRpb246IDEuMixcbiAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnXG4gICAgICB9KTtlbHNlIGdzYXAudG8odGhpcy4kaGVhZGVyLCB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGR1cmF0aW9uOiAwLjgsXG4gICAgICAgIGVhc2U6ICdwb3dlcjIub3V0J1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhpZGVIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZUhlYWRlcigpIHtcbiAgICAgIGdzYXAudG8odGhpcy4kaGVhZGVyLCB7XG4gICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgZHVyYXRpb246IDAuNCxcbiAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ29MaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnb0xpZ2h0KCkgey8vIGdzYXAudG8oZG9jdW1lbnQuYm9keSwgeyBiYWNrZ3JvdW5kQ29sb3I6ICcjRkZGRkZGJywgZHVyYXRpb246IDEuMiwgZWFzZTogJ3Bvd2VyMi5vdXQnIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnb0RhcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ29EYXJrKCkgey8vIGdzYXAudG8oZG9jdW1lbnQuYm9keSwgeyBiYWNrZ3JvdW5kQ29sb3I6ICcjMDAwQTMzJywgZHVyYXRpb246IDEuMiwgZWFzZTogJ3Bvd2VyMi5vdXQnIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbnRlclRyaWdnZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW50ZXJUcmlnZ2VyKCkge1xuICAgICAgaWYgKHRoaXMuaXNPcGVuKSByZXR1cm47XG4gICAgICBnc2FwLmtpbGxUd2VlbnNPZih0aGlzLiR0cmlnZ2VyLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLCB0aGlzLiR0cmlnZ2VyLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzFdKTtcbiAgICAgIGdzYXAudG8odGhpcy4kdHJpZ2dlci5jaGlsZHJlblswXS5jaGlsZHJlblswXSwge1xuICAgICAgICB5OiAnLTIwMCUnLFxuICAgICAgICBkdXJhdGlvbjogMC42LFxuICAgICAgICBlYXNlOiAnZXhwby5vdXQnXG4gICAgICB9KTtcbiAgICAgIGdzYXAudG8odGhpcy4kdHJpZ2dlci5jaGlsZHJlblswXS5jaGlsZHJlblsxXSwge1xuICAgICAgICB5OiAnMTEwJScsXG4gICAgICAgIGR1cmF0aW9uOiAwLjYsXG4gICAgICAgIGVhc2U6ICdleHBvLm91dCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZWF2ZVRyaWdnZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVhdmVUcmlnZ2VyKCkge1xuICAgICAgaWYgKHRoaXMuaXNPcGVuKSByZXR1cm47XG4gICAgICBnc2FwLmtpbGxUd2VlbnNPZih0aGlzLiR0cmlnZ2VyLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLCB0aGlzLiR0cmlnZ2VyLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzFdKTtcbiAgICAgIGdzYXAudG8odGhpcy4kdHJpZ2dlci5jaGlsZHJlblswXS5jaGlsZHJlblswXSwge1xuICAgICAgICB5OiAnLTM1MCUnLFxuICAgICAgICBkdXJhdGlvbjogMC42LFxuICAgICAgICBlYXNlOiAnZXhwby5vdXQnXG4gICAgICB9KTtcbiAgICAgIGdzYXAudG8odGhpcy4kdHJpZ2dlci5jaGlsZHJlblswXS5jaGlsZHJlblsxXSwge1xuICAgICAgICB5OiAnMjYwJScsXG4gICAgICAgIGR1cmF0aW9uOiAwLjYsXG4gICAgICAgIGVhc2U6ICdleHBvLm91dCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcGVuTWVudVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuTWVudSgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5pc0FuaW1hdGluZykgcmV0dXJuO1xuICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IHRydWU7XG4gICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHRoaXMuYXBwU3RvcmUuY3VycmVudFNlY3Rpb24uc3VwZXJTY3JvbGxlci5fc2Nyb2xsLmVuYWJsZSA9IGZhbHNlO2Vsc2UgdGhpcy5kaXNhYmxlU2Nyb2xsKCk7XG5cbiAgICAgIGlmICghdGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgZ3NhcC50byh0aGlzLiRsb2dvLCB7XG4gICAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLjIsXG4gICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnLFxuICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgICBnc2FwLnNldChfdGhpczMuJGxvZ28sIHtcbiAgICAgICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBnc2FwLnNldCh0aGlzLiRtZW51LCB7XG4gICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgIH0pO1xuICAgICAgZ3NhcC50byh0aGlzLiR0cmlnZ2VyLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLCB7XG4gICAgICAgIHk6ICctNTAlJyxcbiAgICAgICAgcm90YXRpb246IDQ1LFxuICAgICAgICBkdXJhdGlvbjogMS4yLFxuICAgICAgICBlYXNlOiAnZXhwby5vdXQnXG4gICAgICB9KTtcbiAgICAgIGdzYXAudG8odGhpcy4kdHJpZ2dlci5jaGlsZHJlblswXS5jaGlsZHJlblsxXSwge1xuICAgICAgICB5OiAnLTUwJScsXG4gICAgICAgIHJvdGF0aW9uOiAtNDUsXG4gICAgICAgIGR1cmF0aW9uOiAxLjIsXG4gICAgICAgIGVhc2U6ICdleHBvLm91dCdcbiAgICAgIH0pO1xuICAgICAgZ3NhcC50byh0aGlzLiRtZW51TWFzaywge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBkdXJhdGlvbjogMC40LFxuICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgIH0pO1xuICAgICAgZ3NhcC50byh0aGlzLiRtZW51Q29udGVudCwge1xuICAgICAgICBzY2FsZVk6IDEsXG4gICAgICAgIGR1cmF0aW9uOiAxLFxuICAgICAgICBlYXNlOiAnZXhwby5pbk91dCdcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkgZ3NhcC50byh0aGlzLiRyZXF1ZXN0QnV0dG9uLCB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGR1cmF0aW9uOiAwLjgsXG4gICAgICAgIGVhc2U6ICdwb3dlcjIub3V0JyxcbiAgICAgICAgZGVsYXk6IDFcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJG1lbnVMaW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhcnMgPSB0aGlzLiRtZW51TGlua3NbaV0ucXVlcnlTZWxlY3RvckFsbCgnLmNoYXInKTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoYXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZ3NhcC50byhjaGFyc1tqXSwge1xuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIHk6ICcwJScsXG4gICAgICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgICAgIGVhc2U6ICdleHBvLmluT3V0JyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAxLFxuICAgICAgICAgICAgZGVsYXk6IDAuMyArIGogKiAwLjAxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VNZW51XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlTWVudSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSBnc2FwLnNldCh0aGlzLiRsb2dvLCB7XG4gICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJG1lbnVMaW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhcnMgPSB0aGlzLiRtZW51TGlua3NbaV0ucXVlcnlTZWxlY3RvckFsbCgnLmNoYXInKTtcbiAgICAgICAgZ3NhcC50byhjaGFycywge1xuICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgICB5OiAnLTEwMCUnLFxuICAgICAgICAgIHJvdGF0aW9uOiAnM2RlZycsXG4gICAgICAgICAgc3RhZ2dlcjogMC4wMSxcbiAgICAgICAgICBlYXNlOiAnZXhwby5pbk91dCcsXG4gICAgICAgICAgZHVyYXRpb246IDAuNVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZ3NhcC50byh0aGlzLiRtZW51Q29udGVudCwge1xuICAgICAgICBzY2FsZVk6IDAsXG4gICAgICAgIGR1cmF0aW9uOiAwLjYsXG4gICAgICAgIGVhc2U6ICdleHBvLmluT3V0JyxcbiAgICAgICAgZGVsYXk6IDAuNlxuICAgICAgfSk7XG4gICAgICBnc2FwLnRvKHRoaXMuJHRyaWdnZXIuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0sIHtcbiAgICAgICAgeTogdGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3AgPyAnLTM1MCUnIDogJy01MDAlJyxcbiAgICAgICAgcm90YXRpb246IDAsXG4gICAgICAgIGR1cmF0aW9uOiAxLjIsXG4gICAgICAgIGVhc2U6ICdleHBvLm91dCdcbiAgICAgIH0pO1xuICAgICAgZ3NhcC50byh0aGlzLiR0cmlnZ2VyLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzFdLCB7XG4gICAgICAgIHk6IHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wID8gJzI2MCUnIDogJzQwMCUnLFxuICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgZHVyYXRpb246IDEuMixcbiAgICAgICAgZWFzZTogJ2V4cG8ub3V0J1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghdGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgZ3NhcC50byh0aGlzLiRyZXF1ZXN0QnV0dG9uLCB7XG4gICAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLjYsXG4gICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnLFxuICAgICAgICAgIGRlbGF5OiAwLjRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wID09PSAwKSBnc2FwLnRvKHRoaXMuJGxvZ28sIHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLjEsXG4gICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnLFxuICAgICAgICAgIGRlbGF5OiAxLjJcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGdzYXAudG8odGhpcy4kbWVudU1hc2ssIHtcbiAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICBkdXJhdGlvbjogMC42LFxuICAgICAgICBlYXNlOiAncG93ZXIyLm91dCcsXG4gICAgICAgIGRlbGF5OiAwLjYsXG4gICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgaWYgKF90aGlzNC5hcHBTdG9yZS5pc0Rlc2t0b3ApIF90aGlzNC5hcHBTdG9yZS5jdXJyZW50U2VjdGlvbi5zdXBlclNjcm9sbGVyLl9zY3JvbGwuZW5hYmxlID0gdHJ1ZTtlbHNlIF90aGlzNC5lbmFibGVTY3JvbGwoKTtcbiAgICAgICAgICBnc2FwLnNldChfdGhpczQuJG1lbnUsIHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICAgIH0pOyAvLyBnc2FwLnNldCh0aGlzLiR0cmlnZ2VyLCB7IHBvaW50ZXJFdmVudHM6ICdpbml0aWFsJyB9KTtcblxuICAgICAgICAgIF90aGlzNC5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICAgIF90aGlzNC5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlTWVudU9wYWNpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VNZW51T3BhY2l0eSgpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSBnc2FwLnNldCh0aGlzLiRsb2dvLCB7XG4gICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJG1lbnVMaW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhcnMgPSB0aGlzLiRtZW51TGlua3NbaV0ucXVlcnlTZWxlY3RvckFsbCgnLmNoYXInKTtcbiAgICAgICAgZ3NhcC50byhjaGFycywge1xuICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgICB5OiAnLTEwMCUnLFxuICAgICAgICAgIHJvdGF0aW9uOiAnM2RlZycsXG4gICAgICAgICAgc3RhZ2dlcjogMC4wMSxcbiAgICAgICAgICBlYXNlOiAnZXhwby5pbk91dCcsXG4gICAgICAgICAgZHVyYXRpb246IDAuNVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZ3NhcC50byh0aGlzLiRtZW51Q29udGVudCwge1xuICAgICAgICBzY2FsZVk6IDAsXG4gICAgICAgIGR1cmF0aW9uOiAwLjYsXG4gICAgICAgIGVhc2U6ICdleHBvLmluT3V0JyxcbiAgICAgICAgZGVsYXk6IDAuNlxuICAgICAgfSk7XG4gICAgICBnc2FwLnRvKHRoaXMuJHRyaWdnZXIuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0sIHtcbiAgICAgICAgeTogdGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3AgPyAnLTM1MCUnIDogJy01MDAlJyxcbiAgICAgICAgcm90YXRpb246IDAsXG4gICAgICAgIGR1cmF0aW9uOiAxLjIsXG4gICAgICAgIGVhc2U6ICdleHBvLm91dCdcbiAgICAgIH0pO1xuICAgICAgZ3NhcC50byh0aGlzLiR0cmlnZ2VyLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzFdLCB7XG4gICAgICAgIHk6IHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wID8gJzI2MCUnIDogJzQwMCUnLFxuICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgZHVyYXRpb246IDEuMixcbiAgICAgICAgZWFzZTogJ2V4cG8ub3V0J1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghdGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgZ3NhcC50byh0aGlzLiRyZXF1ZXN0QnV0dG9uLCB7XG4gICAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLjYsXG4gICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnLFxuICAgICAgICAgIGRlbGF5OiAwLjRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wID09PSAwKSBnc2FwLnRvKHRoaXMuJGxvZ28sIHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLjEsXG4gICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnLFxuICAgICAgICAgIGRlbGF5OiAxLjJcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGdzYXAudG8odGhpcy4kbWVudSwge1xuICAgICAgICBvcGFjaXR5OiAwLjAwMDEsXG4gICAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICAgIGVhc2U6ICdwb3dlcjIub3V0JyxcbiAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICBpZiAoX3RoaXM1LmFwcFN0b3JlLmlzRGVza3RvcCkgX3RoaXM1LmFwcFN0b3JlLmN1cnJlbnRTZWN0aW9uLnN1cGVyU2Nyb2xsZXIuX3Njcm9sbC5lbmFibGUgPSB0cnVlO1xuICAgICAgICAgIGdzYXAuc2V0KF90aGlzNS4kbWVudSwge1xuICAgICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3RoaXM1LmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXM1LmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlU2Nyb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZVNjcm9sbCgpIHtcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdub3Njcm9sbCcpO1xuICAgICAgUmVFbmFibGVTY3JvbGxpbmcoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZVNjcm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsKCkge1xuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ25vc2Nyb2xsJyk7XG4gICAgICBQcmV2ZW50U2Nyb2xsaW5nKEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW3ByZXZlbnQtc2Nyb2xsaW5nLWRpc2FibGVkXScpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImd1aWRlc1N3aXRjaGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGd1aWRlc1N3aXRjaGVyKCkge1xuICAgICAgaWYgKHRoaXMuJGd1aWRlc0hyLnN0eWxlLmRpc3BsYXkgPT09ICdibG9jaycpIHtcbiAgICAgICAgZ3NhcC5zZXQodGhpcy4kZ3VpZGVzSHIsIHtcbiAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgfSk7XG4gICAgICAgIGdzYXAuc2V0KHRoaXMuJGd1aWRlc1ZyLCB7XG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3NhcC5zZXQodGhpcy4kZ3VpZGVzSHIsIHtcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgIH0pO1xuICAgICAgICBnc2FwLnNldCh0aGlzLiRndWlkZXNWciwge1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImd1aWRlc1N3aXRjaGVyMlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBndWlkZXNTd2l0Y2hlcjIoKSB7XG4gICAgICBpZiAodGhpcy4kZ3VpZGVzSHIyLnN0eWxlLmRpc3BsYXkgPT09ICdibG9jaycpIHtcbiAgICAgICAgZ3NhcC5zZXQodGhpcy4kZ3VpZGVzSHIyLCB7XG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgIH0pO1xuICAgICAgICBnc2FwLnNldCh0aGlzLiRndWlkZXNWcjIsIHtcbiAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnc2FwLnNldCh0aGlzLiRndWlkZXNIcjIsIHtcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgIH0pO1xuICAgICAgICBnc2FwLnNldCh0aGlzLiRndWlkZXNWcjIsIHtcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKCdNb2JpbGUnKSAmJiB0aGlzLiRub3RpY2UpIHtcbiAgICAgICAgaWYgKHdpZHRoID4gaGVpZ2h0KSBnc2FwLnNldCh0aGlzLiRub3RpY2UsIHtcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgIH0pO2Vsc2UgZ3NhcC5zZXQodGhpcy4kbm90aWNlLCB7XG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBhcHBVaTtcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgYXBwVWk7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vLyB1dGlsaXRpZXNcbmltcG9ydCBWaXJ0dWFsU2Nyb2xsIGZyb20gJ3ZpcnR1YWwtc2Nyb2xsJztcbmltcG9ydCB7IGdzYXAgfSBmcm9tICdnc2FwJztcbmltcG9ydCBhcHBTdG9yZSBmcm9tICcuLi9hcHAvYXBwU3RvcmUnOyAvLyBlbXB0eSBmdW5jdGlvblxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5cbnZhciBfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIF9kZWZhdWx0KG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIC8vIHN0b3JlXG4gICAgdGhpcy5hcHBTdG9yZSA9IGFwcFN0b3JlOyAvLyBob29rIGZ1bmN0aW9uc1xuXG4gICAgdGhpcy5fb25SYWYgPSBvcHRpb25zLm9uUmFmIHx8IG5vb3A7XG4gICAgdGhpcy5fb25TY3JvbGwgPSBvcHRpb25zLm9uU2Nyb2xsIHx8IG5vb3A7XG4gICAgdGhpcy5fY3VycmVudFNlY3Rpb24gPSBvcHRpb25zLmN1cnJlbnRTZWN0aW9uID8gb3B0aW9ucy5jdXJyZW50U2VjdGlvbiA6IG51bGw7XG4gICAgdGhpcy5fZ2xvYmFsID0ge1xuICAgICAgcGVyY2VudDoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LFxuICAgICAgbGVycDogMC4xNSxcbiAgICAgIG1vZGU6IG9wdGlvbnMubW9kZSB8fCAndmVydGljYWwnXG4gICAgfTtcblxuICAgIHZhciBsZXJwID0gZnVuY3Rpb24gbGVycCh2YWx1ZTEsIHZhbHVlMiwgYW1vdW50KSB7XG4gICAgICBhbW91bnQgPSBhbW91bnQgPCAwID8gMCA6IGFtb3VudDtcbiAgICAgIGFtb3VudCA9IGFtb3VudCA+IDEgPyAxIDogYW1vdW50O1xuICAgICAgcmV0dXJuIHZhbHVlMSArICh2YWx1ZTIgLSB2YWx1ZTEpICogYW1vdW50O1xuICAgIH07IC8vIHNjcm9sbCBwcm9wZXJ0aWVzXG5cblxuICAgIGlmIChvcHRpb25zLnNjcm9sbCkge1xuICAgICAgLy8gZGVmYXVsdCB2aXJ0dWFsU2Nyb2xsIG9wdGlvbnNcbiAgICAgIHRoaXMuX3ZpcnR1YWxTY3JvbGwgPSBudWxsO1xuICAgICAgdGhpcy5fdmlydHVhbFNjcm9sbE9wdGlvbnMgPSB7XG4gICAgICAgIGVsOiB0eXBlb2Ygb3B0aW9ucy5lbCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmVsIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICBtb3VzZU11bHRpcGxpZXI6IHR5cGVvZiBvcHRpb25zLm1vdXNlTXVsdGlwbGllciAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1vdXNlTXVsdGlwbGllciA6IHRoaXMuYXBwU3RvcmUuY2xpZW50Lm9zID09PSAnd2luZG93cycgPyAxIDogMC40LFxuICAgICAgICB0b3VjaE11bHRpcGxpZXI6IHR5cGVvZiBvcHRpb25zLnRvdWNoTXVsdGlwbGllciAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnRvdWNoTXVsdGlwbGllciA6IDIsXG4gICAgICAgIGZpcmVmb3hNdWx0aXBsaWVyOiB0eXBlb2Ygb3B0aW9ucy5maXJlZm94TXVsdGlwbGllciAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmZpcmVmb3hNdWx0aXBsaWVyIDogNTAsXG4gICAgICAgIGxpbWl0SW5lcnRpYTogdHlwZW9mIG9wdGlvbnMubGltaXRJbmVydGlhICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubGltaXRJbmVydGlhIDogZmFsc2UsXG4gICAgICAgIHBhc3NpdmU6IHR5cGVvZiBvcHRpb25zLnBhc3NpdmUgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5wYXNpdmUgOiBmYWxzZSxcbiAgICAgICAgdXNlS2V5Ym9hcmQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgdGhpcy5fc2Nyb2xsID0ge1xuICAgICAgICBlbmFibGU6IHR5cGVvZiBvcHRpb25zLmVuYWJsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmVuYWJsZSA6IHRydWUsXG4gICAgICAgIHBhcmVudDogdHlwZW9mIG9wdGlvbnMuZWwgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5lbCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgdGFyZ2V0OiBvcHRpb25zLnNjcm9sbFRhcmdldCxcbiAgICAgICAgbG9ja0hlYWRlcjogZmFsc2UsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRpbWVvdXQ6IGZhbHNlLFxuICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIHJhdGlvOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGNsaWNrZWRQb2ludDoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogb3B0aW9ucy5zdGFydEF0ICE9PSBudWxsICYmIHR5cGVvZiBvcHRpb25zLnN0YXJ0QXQgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5zdGFydEF0IDogMFxuICAgICAgICB9LFxuICAgICAgICBsYXN0UG9zaXRpb246IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IG9wdGlvbnMuc3RhcnRBdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9ucy5zdGFydEF0ICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuc3RhcnRBdCA6IDBcbiAgICAgICAgfSxcbiAgICAgICAgbGl2ZVBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiBvcHRpb25zLnN0YXJ0QXQgIT09IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMuc3RhcnRBdCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnN0YXJ0QXQgOiAwXG4gICAgICAgIH0sXG4gICAgICAgIG1heFNjcm9sbDoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zY3JvbGxEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgLy8gc2V0IGZsYWdcbiAgICAgICAgX3RoaXMuX3Njcm9sbC5kcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgX3RoaXMuX3Njcm9sbC50YXJnZXQuY2xhc3NMaXN0LmFkZCgnZHJhZ2dpbmcnKTsgLy8gZ2V0IHRoZSBwb2ludCB0aGUgdXNlciBjbGlja2VkIG9uIHRoZSBiYXJcblxuXG4gICAgICAgIF90aGlzLl9zY3JvbGwuY2xpY2tlZFBvaW50LnggPSBlLmNsaWVudFggLSBfdGhpcy5fc2Nyb2xsLmxpdmVQb3NpdGlvbi54O1xuICAgICAgICBfdGhpcy5fc2Nyb2xsLmNsaWNrZWRQb2ludC55ID0gZS5jbGllbnRZIC0gX3RoaXMuX3Njcm9sbC5saXZlUG9zaXRpb24ueTsgLy8gdHJhY2sgdGhlIG1vdXNlIGV2ZW50c1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF90aGlzLl9zY3JvbGxEcmFnKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF90aGlzLl9zY3JvbGxVcCk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zY3JvbGxEcmFnID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKF90aGlzLl9nbG9iYWwubW9kZSA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBhbW91bnQgdGhlIHVzZXIgbW92ZWQgZnJvbSB0aGUgY2xpY2tlZCBwb2ludCBvbiB0aGUgc2Nyb2xsYmFyLCBjaGVja2luZyBsaW1pdHNcbiAgICAgICAgICBfdGhpcy5fc2Nyb2xsLnBvc2l0aW9uLnggPSBNYXRoLm1pbigwLCBNYXRoLm1heChfdGhpcy5fc2Nyb2xsLm1heFNjcm9sbC54LCBlLmNsaWVudFggLSBfdGhpcy5fc2Nyb2xsLmNsaWNrZWRQb2ludC54KSk7IC8vIHVwZGF0ZSBnbG9iYWwgcGVyY2VudGFnZVxuXG4gICAgICAgICAgX3RoaXMuX2dsb2JhbC5wZXJjZW50LnggPSBfdGhpcy5fc2Nyb2xsLnBvc2l0aW9uLnggLyBfdGhpcy5fc2Nyb2xsLm1heFNjcm9sbC54O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgYW1vdW50IHRoZSB1c2VyIG1vdmVkIGZyb20gdGhlIGNsaWNrZWQgcG9pbnQgb24gdGhlIHNjcm9sbGJhciwgY2hlY2tpbmcgbGltaXRzXG4gICAgICAgICAgX3RoaXMuX3Njcm9sbC5wb3NpdGlvbi55ID0gTWF0aC5taW4oMCwgTWF0aC5tYXgoX3RoaXMuX3Njcm9sbC5tYXhTY3JvbGwueSwgZS5jbGllbnRZIC0gX3RoaXMuX3Njcm9sbC5jbGlja2VkUG9pbnQueSkpOyAvLyB1cGRhdGUgZ2xvYmFsIHBlcmNlbnRhZ2VcblxuICAgICAgICAgIF90aGlzLl9nbG9iYWwucGVyY2VudC55ID0gX3RoaXMuX3Njcm9sbC5wb3NpdGlvbi55IC8gX3RoaXMuX3Njcm9sbC5tYXhTY3JvbGwueTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5fc2Nyb2xsVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHN0b3AgdHJhY2tpbmcgdGhlIHR3byBtb3VzZSBldmVudHNcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX3RoaXMuX3Njcm9sbERyYWcpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX3RoaXMuX3Njcm9sbFVwKTsgLy8gc2V0IGZsYWdcblxuICAgICAgICBfdGhpcy5fc2Nyb2xsLmRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgX3RoaXMuX3Njcm9sbC50YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnZHJhZ2dpbmcnKTtcbiAgICAgIH07IC8vIGJpbmQgbW91c2Vkb3duIGV2ZW50XG5cblxuICAgICAgaWYgKHRoaXMuX2dsb2JhbC5tb2RlID09PSAnaG9yaXpvbnRhbCcpIHRoaXMuX3Njcm9sbC50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fc2Nyb2xsRG93bik7XG5cbiAgICAgIHRoaXMuX3Njcm9sbE1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBfdGhpcy5fb25TY3JvbGwoKTsgLy8gUHJldmVudCBwb2ludGVyZXZlbnRzIG9uIHNjcm9sbFxuICAgICAgICAvLyB0aGlzLl9zY3JvbGwudGFyZ2V0LnBhcmVudE5vZGUuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcblxuXG4gICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5fc2Nyb2xsLnRpbWVvdXQpOyAvLyB0aGlzLl9zY3JvbGwudGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyAgICAgdGhpcy5fc2Nyb2xsLnRhcmdldC5wYXJlbnROb2RlLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYWxsJztcbiAgICAgICAgLy8gfSwgMjAwKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgc2Nyb2xsIGlzIGFsbG93ZWRcblxuICAgICAgICBpZiAoIV90aGlzLl9zY3JvbGwuZW5hYmxlKSByZXR1cm47IC8vIHVwZGF0ZSBzY3JvbGxcblxuICAgICAgICBpZiAoX3RoaXMuX2dsb2JhbC5tb2RlID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAvLyBnZXQgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgIF90aGlzLl9zY3JvbGwucG9zaXRpb24ueCA9IE1hdGgubWluKDAsIE1hdGgubWF4KF90aGlzLl9zY3JvbGwubWF4U2Nyb2xsLngsIF90aGlzLl9zY3JvbGwucG9zaXRpb24ueCArPSBlLmRlbHRhWSkpO1xuICAgICAgICAgIF90aGlzLl9zY3JvbGwucG9zaXRpb24ueCA9IE1hdGgubWluKDAsIE1hdGgubWF4KF90aGlzLl9zY3JvbGwubWF4U2Nyb2xsLngsIF90aGlzLl9zY3JvbGwucG9zaXRpb24ueCArPSBlLmRlbHRhWCkpO1xuICAgICAgICAgIF90aGlzLl9nbG9iYWwucGVyY2VudC54ID0gX3RoaXMuX3Njcm9sbC5wb3NpdGlvbi54IC8gX3RoaXMuX3Njcm9sbC5tYXhTY3JvbGwueDtcbiAgICAgICAgICBfdGhpcy5fZ2xvYmFsLnBlcmNlbnQueCA9IE51bWJlci5pc05hTihfdGhpcy5fZ2xvYmFsLnBlcmNlbnQueCkgPyAwIDogX3RoaXMuX2dsb2JhbC5wZXJjZW50Lng7XG4gICAgICAgICAgX3RoaXMuX3Njcm9sbC5sYXN0UG9zaXRpb24ueCA9IF90aGlzLl9zY3JvbGwucG9zaXRpb24ueDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBnZXQgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgIF90aGlzLl9zY3JvbGwucG9zaXRpb24ueSA9IE1hdGgubWluKDAsIE1hdGgubWF4KF90aGlzLl9zY3JvbGwubWF4U2Nyb2xsLnksIF90aGlzLl9zY3JvbGwucG9zaXRpb24ueSArPSBlLmRlbHRhWSkpO1xuICAgICAgICAgIF90aGlzLl9nbG9iYWwucGVyY2VudC55ID0gX3RoaXMuX3Njcm9sbC5wb3NpdGlvbi55IC8gX3RoaXMuX3Njcm9sbC5tYXhTY3JvbGwueTtcbiAgICAgICAgICBfdGhpcy5fZ2xvYmFsLnBlcmNlbnQueSA9IE51bWJlci5pc05hTihfdGhpcy5fZ2xvYmFsLnBlcmNlbnQueSkgPyAwIDogX3RoaXMuX2dsb2JhbC5wZXJjZW50Lnk7XG4gICAgICAgICAgX3RoaXMuX3Njcm9sbC5sYXN0UG9zaXRpb24ueSA9IF90aGlzLl9zY3JvbGwucG9zaXRpb24ueTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fc2Nyb2xsUmFmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMuX2dsb2JhbC5tb2RlID09PSAnaG9yaXpvbnRhbCcpIF90aGlzLl9zY3JvbGwubGl2ZVBvc2l0aW9uLnggPSBsZXJwKF90aGlzLl9zY3JvbGwubGl2ZVBvc2l0aW9uLngsIF90aGlzLl9zY3JvbGwubWF4U2Nyb2xsLnggKiBfdGhpcy5fZ2xvYmFsLnBlcmNlbnQueCwgX3RoaXMuX2dsb2JhbC5sZXJwKTtlbHNlIF90aGlzLl9zY3JvbGwubGl2ZVBvc2l0aW9uLnkgPSBsZXJwKF90aGlzLl9zY3JvbGwubGl2ZVBvc2l0aW9uLnksIF90aGlzLl9zY3JvbGwubWF4U2Nyb2xsLnkgKiBfdGhpcy5fZ2xvYmFsLnBlcmNlbnQueSwgX3RoaXMuX2dsb2JhbC5sZXJwKTtcbiAgICAgICAgX3RoaXMuX3Njcm9sbC50YXJnZXQuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKCcgKyBfdGhpcy5fc2Nyb2xsLmxpdmVQb3NpdGlvbi54ICsgJ3B4LCcgKyBfdGhpcy5fc2Nyb2xsLmxpdmVQb3NpdGlvbi55ICsgJ3B4LCAwcHgpJztcbiAgICAgIH07XG4gICAgfSAvLyBiYXIgcHJvcGVydGllc1xuXG5cbiAgICBpZiAob3B0aW9ucy5iYXIpIHtcbiAgICAgIHRoaXMuX2JhciA9IHtcbiAgICAgICAgZW5hYmxlOiB0cnVlLFxuICAgICAgICB0YXJnZXQ6IG9wdGlvbnMuYmFyVGFyZ2V0LFxuICAgICAgICBwYXJlbnQ6IG9wdGlvbnMuYmFyVGFyZ2V0LnBhcmVudE5vZGUsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgcmF0aW86IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSxcbiAgICAgICAgbGl2ZVBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sXG4gICAgICAgIG1heFNjcm9sbDoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LFxuICAgICAgICBjbGlja2VkUG9pbnQ6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5fYmFyRG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vIHNldCBmbGFnXG4gICAgICAgIF90aGlzLl9iYXIuZHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgIF90aGlzLl9iYXIudGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ2RyYWdnaW5nJyk7IC8vIGdldCB0aGUgcG9pbnQgdGhlIHVzZXIgY2xpY2tlZCBvbiB0aGUgYmFyXG5cblxuICAgICAgICBfdGhpcy5fYmFyLmNsaWNrZWRQb2ludC54ID0gZS5jbGllbnRYIC0gX3RoaXMuX2Jhci5saXZlUG9zaXRpb24ueDtcbiAgICAgICAgX3RoaXMuX2Jhci5jbGlja2VkUG9pbnQueSA9IGUuY2xpZW50WSAtIF90aGlzLl9iYXIubGl2ZVBvc2l0aW9uLnk7IC8vIHRyYWNrIHRoZSBtb3VzZSBldmVudHNcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfdGhpcy5fYmFyTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfdGhpcy5fYmFyVXApO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fYmFyTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChfdGhpcy5fZ2xvYmFsLm1vZGUgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgYW1vdW50IHRoZSB1c2VyIG1vdmVkIGZyb20gdGhlIGNsaWNrZWQgcG9pbnQgb24gdGhlIHNjcm9sbGJhciwgY2hlY2tpbmcgbGltaXRzXG4gICAgICAgICAgX3RoaXMuX2Jhci5wb3NpdGlvbi54ID0gTWF0aC5taW4oTWF0aC5tYXgoZS5jbGllbnRYIC0gX3RoaXMuX2Jhci5jbGlja2VkUG9pbnQueCwgMCksIF90aGlzLl9iYXIubWF4U2Nyb2xsLngpOyAvLyB1cGRhdGUgZ2xvYmFsIHBlcmNlbnRhZ2VcblxuICAgICAgICAgIF90aGlzLl9nbG9iYWwucGVyY2VudC54ID0gX3RoaXMuX2Jhci5wb3NpdGlvbi54IC8gX3RoaXMuX2Jhci5tYXhTY3JvbGwueDtcbiAgICAgICAgICBfdGhpcy5fc2Nyb2xsLnBvc2l0aW9uLnggPSBfdGhpcy5fZ2xvYmFsLnBlcmNlbnQueCAqIF90aGlzLl9zY3JvbGwubWF4U2Nyb2xsLng7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBhbW91bnQgdGhlIHVzZXIgbW92ZWQgZnJvbSB0aGUgY2xpY2tlZCBwb2ludCBvbiB0aGUgc2Nyb2xsYmFyLCBjaGVja2luZyBsaW1pdHNcbiAgICAgICAgICBfdGhpcy5fYmFyLnBvc2l0aW9uLnkgPSBNYXRoLm1pbihNYXRoLm1heChlLmNsaWVudFkgLSBfdGhpcy5fYmFyLmNsaWNrZWRQb2ludC55LCAwKSwgX3RoaXMuX2Jhci5tYXhTY3JvbGwueSk7IC8vIHVwZGF0ZSBnbG9iYWwgcGVyY2VudGFnZVxuXG4gICAgICAgICAgX3RoaXMuX2dsb2JhbC5wZXJjZW50LnkgPSBfdGhpcy5fYmFyLnBvc2l0aW9uLnkgLyBfdGhpcy5fYmFyLm1heFNjcm9sbC55O1xuICAgICAgICAgIF90aGlzLl9zY3JvbGwucG9zaXRpb24ueSA9IF90aGlzLl9nbG9iYWwucGVyY2VudC55ICogX3RoaXMuX3Njcm9sbC5tYXhTY3JvbGwueTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5fYmFyVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHN0b3AgdHJhY2tpbmcgdGhlIHR3byBtb3VzZSBldmVudHNcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX3RoaXMuX2Jhck1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX3RoaXMuX2JhclVwKTsgLy8gc2V0IGZsYWdcblxuICAgICAgICBfdGhpcy5fYmFyLmRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgX3RoaXMuX2Jhci50YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnZHJhZ2dpbmcnKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2JhclJhZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzLl9nbG9iYWwubW9kZSA9PT0gJ2hvcml6b250YWwnKSBfdGhpcy5fYmFyLmxpdmVQb3NpdGlvbi54ID0gbGVycChfdGhpcy5fYmFyLmxpdmVQb3NpdGlvbi54LCBfdGhpcy5fYmFyLm1heFNjcm9sbC54ICogX3RoaXMuX2dsb2JhbC5wZXJjZW50LngsIDAuMSk7ZWxzZSBfdGhpcy5fYmFyLmxpdmVQb3NpdGlvbi55ID0gbGVycChfdGhpcy5fYmFyLmxpdmVQb3NpdGlvbi55LCBfdGhpcy5fYmFyLm1heFNjcm9sbC55ICogX3RoaXMuX2dsb2JhbC5wZXJjZW50LnksIDAuMSk7XG4gICAgICAgIF90aGlzLl9iYXIudGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgnICsgX3RoaXMuX2Jhci5saXZlUG9zaXRpb24ueCArICdweCwnICsgX3RoaXMuX2Jhci5saXZlUG9zaXRpb24ueSArICdweCwgMHB4KSc7XG4gICAgICB9OyAvLyBiaW5kIG1vdXNlZG93biBldmVudFxuXG5cbiAgICAgIHRoaXMuX2Jhci50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fYmFyRG93bik7XG4gICAgfVxuXG4gICAgdGhpcy5fcmFmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFfdGhpcy5fc2Nyb2xsLmVuYWJsZSkgcmV0dXJuO1xuICAgICAgaWYgKF90aGlzLl9zY3JvbGwpIF90aGlzLl9zY3JvbGxSYWYoKTtcbiAgICAgIGlmIChfdGhpcy5fYmFyKSBfdGhpcy5fYmFyUmFmKCk7XG5cbiAgICAgIF90aGlzLl9vblJhZihfdGhpcy5fc2Nyb2xsLmxpdmVQb3NpdGlvbiwgX3RoaXMuX2dsb2JhbC5wZXJjZW50KTtcbiAgICB9OyAvLyBiaW5kIHRvIGdzYXAgdGlja2VyXG5cblxuICAgIGdzYXAudGlja2VyLmFkZCh0aGlzLl9yYWYpOyAvLyBiaW5kXG5cbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIHZpcnR1YWxzY3JvbGwgcHJvcGVydGllc1xuICAgICAgaWYgKHRoaXMuX3ZpcnR1YWxTY3JvbGwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuX3ZpcnR1YWxTY3JvbGwgPSBuZXcgVmlydHVhbFNjcm9sbCh0aGlzLl92aXJ0dWFsU2Nyb2xsT3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fdmlydHVhbFNjcm9sbC5vbihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIF90aGlzMi5fc2Nyb2xsTW92ZShlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNjcm9sbEFuaW1hdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Nyb2xsQW5pbWF0ZShfcG9zaXRpb24pIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgX2R1cmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAyO1xuXG4gICAgICB2YXIgX2Vhc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdwb3dlcjQuaW5PdXQnO1xuXG4gICAgICB2YXIgX2ZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICAgICAgdGhpcy5fc2Nyb2xsLmxvY2tIZWFkZXIgPSB0cnVlO1xuICAgICAgX2R1cmF0aW9uID0gdGhpcy5hcHBTdG9yZS5jbGllbnQuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnID8gX2R1cmF0aW9uIC8gMiA6IF9kdXJhdGlvbjtcbiAgICAgIGlmICghX2ZvcmNlICYmICF0aGlzLl9zY3JvbGwuZW5hYmxlKSByZXR1cm47XG4gICAgICB0aGlzLl9zY3JvbGwucG9zaXRpb24ueSA9IE1hdGgubWF4KC1fcG9zaXRpb24sIHRoaXMuX3Njcm9sbC5tYXhTY3JvbGwueSk7XG4gICAgICBnc2FwLnRvKHRoaXMuX2dsb2JhbC5wZXJjZW50LCB7XG4gICAgICAgIHk6IHRoaXMuX3Njcm9sbC5wb3NpdGlvbi55IC8gdGhpcy5fc2Nyb2xsLm1heFNjcm9sbC55LFxuICAgICAgICBlYXNlOiBfZWFzZSxcbiAgICAgICAgZHVyYXRpb246IF9kdXJhdGlvblxuICAgICAgfSk7XG4gICAgICBnc2FwLmRlbGF5ZWRDYWxsKF9kdXJhdGlvbiAqIDUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLl9zY3JvbGwubG9ja0hlYWRlciA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNjcm9sbFNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxTZXQoX3Bvc2l0aW9uKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdGhpcy5fc2Nyb2xsLmxvY2tIZWFkZXIgPSB0cnVlO1xuICAgICAgdGhpcy5fZ2xvYmFsLmxlcnAgPSAxO1xuICAgICAgdGhpcy5fc2Nyb2xsLnBvc2l0aW9uLnkgPSBNYXRoLm1heCgtX3Bvc2l0aW9uLCB0aGlzLl9zY3JvbGwubWF4U2Nyb2xsLnkpO1xuICAgICAgdGhpcy5fZ2xvYmFsLnBlcmNlbnQueSA9IHRoaXMuX3Njcm9sbC5wb3NpdGlvbi55IC8gdGhpcy5fc2Nyb2xsLm1heFNjcm9sbC55O1xuICAgICAgZ3NhcC5kZWxheWVkQ2FsbCgxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNC5fZ2xvYmFsLmxlcnAgPSAwLjA1O1xuICAgICAgfSk7XG4gICAgICBnc2FwLmRlbGF5ZWRDYWxsKDUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM0Ll9zY3JvbGwubG9ja0hlYWRlciA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNjcm9sbFJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxSZXNpemUoKSB7XG4gICAgICAvL1xuICAgICAgdGhpcy5fc2Nyb2xsLndpZHRoID0gdGhpcy5fc2Nyb2xsLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgIHRoaXMuX3Njcm9sbC5oZWlnaHQgPSB0aGlzLl9zY3JvbGwudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgIHRoaXMuX3Njcm9sbC5wYXJlbnRXaWR0aCA9IHRoaXMuX3Njcm9sbC5wYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgdGhpcy5fc2Nyb2xsLnBhcmVudEhlaWdodCA9IHRoaXMuX3Njcm9sbC5wYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgdGhpcy5fc2Nyb2xsLm1heFNjcm9sbC54ID0gLSh0aGlzLl9zY3JvbGwud2lkdGggLSB0aGlzLl9zY3JvbGwucGFyZW50V2lkdGgpO1xuICAgICAgdGhpcy5fc2Nyb2xsLm1heFNjcm9sbC55ID0gLSh0aGlzLl9zY3JvbGwuaGVpZ2h0IC0gdGhpcy5fc2Nyb2xsLnBhcmVudEhlaWdodCk7XG4gICAgICB0aGlzLl9nbG9iYWwucGVyY2VudC54ID0gdGhpcy5fc2Nyb2xsLnBvc2l0aW9uLnggLyB0aGlzLl9zY3JvbGwubWF4U2Nyb2xsLng7XG4gICAgICB0aGlzLl9nbG9iYWwucGVyY2VudC54ID0gTnVtYmVyLmlzTmFOKHRoaXMuX2dsb2JhbC5wZXJjZW50LngpID8gMCA6IHRoaXMuX2dsb2JhbC5wZXJjZW50Lng7XG4gICAgICB0aGlzLl9nbG9iYWwucGVyY2VudC55ID0gdGhpcy5fc2Nyb2xsLnBvc2l0aW9uLnkgLyB0aGlzLl9zY3JvbGwubWF4U2Nyb2xsLnk7XG4gICAgICB0aGlzLl9nbG9iYWwucGVyY2VudC55ID0gTnVtYmVyLmlzTmFOKHRoaXMuX2dsb2JhbC5wZXJjZW50LnkpID8gMCA6IHRoaXMuX2dsb2JhbC5wZXJjZW50Lnk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJhclJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiYXJSZXNpemUoKSB7XG4gICAgICAvLyBnZXQgY29udGFpbmVyIGVsIHNpemVzXG4gICAgICB0aGlzLl9iYXIucGFyZW50V2lkdGggPSB0aGlzLl9iYXIucGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgdGhpcy5fYmFyLnBhcmVudEhlaWdodCA9IHRoaXMuX2Jhci5wYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0OyAvLyBnZXQgYmFyIHNpemVcblxuICAgICAgaWYgKHRoaXMuX2dsb2JhbC5tb2RlID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgdGhpcy5fYmFyLndpZHRoID0gdGhpcy5fYmFyLnBhcmVudFdpZHRoICogKHRoaXMuX3Njcm9sbC5wYXJlbnRXaWR0aCAvIHRoaXMuX3Njcm9sbC53aWR0aCk7XG4gICAgICAgIHRoaXMuX2Jhci5oZWlnaHQgPSB0aGlzLl9iYXIudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgdGhpcy5fYmFyLnRhcmdldC5zdHlsZS53aWR0aCA9IHRoaXMuX2Jhci53aWR0aCArICdweCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9iYXIud2lkdGggPSB0aGlzLl9iYXIudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICB0aGlzLl9iYXIuaGVpZ2h0ID0gdGhpcy5fYmFyLnBhcmVudEhlaWdodCAqICh0aGlzLl9zY3JvbGwucGFyZW50SGVpZ2h0IC8gdGhpcy5fc2Nyb2xsLmhlaWdodCk7XG4gICAgICAgIHRoaXMuX2Jhci50YXJnZXQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fYmFyLmhlaWdodCArICdweCc7XG4gICAgICB9IC8vIGNhbGN1bGF0ZSBtYXhpbXVtIHNjcm9sbFxuXG5cbiAgICAgIHRoaXMuX2Jhci5tYXhTY3JvbGwueCA9IHRoaXMuX2Jhci5wYXJlbnRXaWR0aCAtIHRoaXMuX2Jhci53aWR0aDtcbiAgICAgIHRoaXMuX2Jhci5tYXhTY3JvbGwueSA9IHRoaXMuX2Jhci5wYXJlbnRIZWlnaHQgLSB0aGlzLl9iYXIuaGVpZ2h0O1xuICAgICAgdGhpcy5fYmFyLnJhdGlvLnggPSB0aGlzLl9iYXIud2lkdGggLyB0aGlzLl9iYXIucGFyZW50V2lkdGg7XG4gICAgICB0aGlzLl9iYXIucmF0aW8ueSA9IHRoaXMuX2Jhci5oZWlnaHQgLyB0aGlzLl9iYXIucGFyZW50SGVpZ2h0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgaWYgKHRoaXMuX3Njcm9sbCkgdGhpcy5zY3JvbGxSZXNpemUoKTtcbiAgICAgIGlmICh0aGlzLl9iYXIpIHRoaXMuYmFyUmVzaXplKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGdzYXAudGlja2VyLnJlbW92ZSh0aGlzLl9yYWYpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oKTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8vIEFwcFxuaW1wb3J0IGFwcENvcmUgZnJvbSAnLi4vYXBwL2FwcENvcmUnO1xuaW1wb3J0IGFwcFN0b3JlIGZyb20gJy4uL2FwcC9hcHBTdG9yZSc7XG5pbXBvcnQgYXBwVWkgZnJvbSAnLi4vYXBwL2FwcFVpJzsgLy8gQ2xhc3Nlc1xuXG5pbXBvcnQgZG9tRXZlbnRzIGZyb20gJy4uL2NsYXNzZXMvZG9tRXZlbnRzJzsgLy8gSGlnaHdheVxuXG5pbXBvcnQgSGlnaHdheSBmcm9tICdAZG9nc3R1ZGlvL2hpZ2h3YXknOyAvLyBQcmVsb2FkXG5cbmltcG9ydCBQcmVsb2FkIGZyb20gJ3ByZWxvYWQtaXQnO1xuaW1wb3J0IExhenlMb2FkIGZyb20gJ2xhenlsb2FkJzsgLy8gVXRpbGl0aWVzXG5cbmltcG9ydCBTdXBlclNjcm9sbGVyIGZyb20gJy4uL2NsYXNzZXMvc3VwZXJTY3JvbGxlcic7IC8vIEdTQVAgTGlicmFyeVxuXG5pbXBvcnQgZ3NhcCBmcm9tICdnc2FwJztcbmltcG9ydCBTcGxpdFRleHQgZnJvbSAnLi4vY2xhc3Nlcy9zcGxpdFRleHQnO1xuaW1wb3J0IFNjcm9sbFRyaWdnZXIgZnJvbSAnZ3NhcC9TY3JvbGxUcmlnZ2VyJztcbmdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVHJpZ2dlcik7XG5cbnZhciBSZW5kZXJlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0hpZ2h3YXkkUmVuZGVyZXIpIHtcbiAgX2luaGVyaXRzKFJlbmRlcmVyLCBfSGlnaHdheSRSZW5kZXJlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihSZW5kZXJlcik7XG5cbiAgZnVuY3Rpb24gUmVuZGVyZXIocHJvcGVydGllcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZW5kZXJlcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BlcnRpZXMpOyAvLyBTdG9yZVxuXG4gICAgX3RoaXMuYXBwU3RvcmUgPSBhcHBTdG9yZTsgLy8gQXBwIHJlZmVyZW5jZXNcblxuICAgIF90aGlzLmFwcENvcmUgPSBuZXcgYXBwQ29yZSgpO1xuICAgIF90aGlzLmFwcFVpID0gbmV3IGFwcFVpKCk7IC8vIEV2ZW50c1xuXG4gICAgX3RoaXMuZG9tRXZlbnRzID0gbmV3IGRvbUV2ZW50cygpO1xuICAgIF90aGlzLmhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaCAhPT0gJycgPyB3aW5kb3cubG9jYXRpb24uaGFzaCA6IG51bGw7XG4gICAgX3RoaXMucGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICBfdGhpcy5hcHBTdG9yZS5maXJzdE5hdmlnYXRpb24gPSBfdGhpcy5hcHBTdG9yZS5jdXJyZW50U2VjdGlvbiA9PT0gbnVsbDsgLy8gUHJlbG9hZGVyXG5cbiAgICBfdGhpcy5wcmVsb2FkTWFpbiA9IG51bGw7XG4gICAgX3RoaXMucHJlbG9hZFNlY29uZGFyeSA9IG51bGw7XG4gICAgX3RoaXMucHJlbG9hZERlbGF5ID0gMTtcbiAgICBfdGhpcy5wcmVsb2FkSXRlbXMgPSB7XG4gICAgICAvLyBtYWluOiBbJ2h0dHBzOi8vY29tbW9uZGF0YXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vZ3R2LXZpZGVvcy1idWNrZXQvc2FtcGxlL0ZvckJpZ2dlckVzY2FwZXMubXA0JywgJ2h0dHBzOi8vY29tbW9uZGF0YXN0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vZ3R2LXZpZGVvcy1idWNrZXQvc2FtcGxlL0JpZ0J1Y2tCdW5ueS5tcDQnLCAnaHR0cHM6Ly9pbWFnZXMucGV4ZWxzLmNvbS9waG90b3MvMjQ4Nzk3L3BleGVscy1waG90by0yNDg3OTcuanBlZyddLCAvLyBUZXN0XG4gICAgICBtYWluOiBbXSxcbiAgICAgIC8vIE1hbmRhdG9yeSBpdGVtc1xuICAgICAgc2Vjb25kYXJ5OiBbXSAvLyBTZWNvbmRhcnkgaXRlbXNcblxuICAgIH07IC8vIFNjcm9sbFxuXG4gICAgX3RoaXMuc3VwZXJTY3JvbGxlciA9IG51bGw7XG4gICAgX3RoaXMuc3VwZXJUcmlnZ2VyID0gbnVsbDtcbiAgICBfdGhpcy5hcHBTdG9yZS5jdXJyZW50U2VjdGlvbiA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpO1xuICAgIF90aGlzLmFwcFN0b3JlLmN1cnJlbnQgPSBfdGhpcy5wcm9wZXJ0aWVzLnNsdWc7XG4gICAgX3RoaXMuX3Njcm9sbCA9IDA7XG4gICAgX3RoaXMuX3Njcm9sbFBvc2l0aW9uID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICBfdGhpcy5mb3JtID0ge1xuICAgICAgaXNBbmltYXRpbmc6IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVuZGVyZXIsIFt7XG4gICAga2V5OiBcIm9uRW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25FbnRlcigpIHtcbiAgICAgIHRoaXMucHJlc2VsZWN0b3JzKCk7XG4gICAgICB0aGlzLnNlbGVjdG9ycygpO1xuICAgICAgdGhpcy5ldmVudHMoKTtcbiAgICAgIHRoaXMucHJlbG9hZCgpO1xuXG4gICAgICBpZiAoIXRoaXMucGFyYW1zLmhhcygndHJwLWVkaXQtdHJhbnNsYXRpb24nKSkge1xuICAgICAgICAvLyBTZXQgYW5pbWF0aW9uc1xuICAgICAgICB0aGlzLnNldEZvcm1zKCk7XG4gICAgICAgIHRoaXMuc2V0TGFiZWxzKCk7XG4gICAgICAgIHRoaXMuc2V0VGl0bGVzKCk7XG4gICAgICAgIHRoaXMuc2V0VGl0bGVzTGFyZ2UoKTtcbiAgICAgICAgdGhpcy5zZXRUZXh0cygpO1xuICAgICAgICB0aGlzLnNldEltYWdlcygpO1xuICAgICAgICB0aGlzLnNldExpbmVzKCk7XG4gICAgICAgIHRoaXMuc2V0TGlua3MoKTtcbiAgICAgICAgdGhpcy5zZXRXb3JkcygpO1xuICAgICAgICB0aGlzLnNldERyYWdnYWJsZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB0aGlzLnNldEZvb3RlcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJlZm9yZUVudGVyKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByZXNlbGVjdG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVzZWxlY3RvcnMoKSB7XG4gICAgICAvLyBTZXQgcmVmZXJlbmNlIHRvIGN1cnJlbnQgc2VjdGlvblxuICAgICAgdGhpcy4kYXBwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpO1xuICAgICAgdGhpcy4kZWwgPSB0aGlzLndyYXAubGFzdEVsZW1lbnRDaGlsZDtcbiAgICAgIHRoaXMuJGlubmVyID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignW2RhdGEtc2Nyb2xsLXdyYXBwZXJdIC5pbm5lcicpO1xuICAgICAgdGhpcy4kc2Nyb2xsYmFyID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignW2RhdGEtc2Nyb2xsLXdyYXBwZXJdIC5zY3JvbGxiYXInKTsgLy8gRm9ybXNcblxuICAgICAgdGhpcy4kaHVic3BvdCA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5odWJzcG90Jyk7XG5cbiAgICAgIGlmICh0aGlzLiRodWJzcG90KSB7XG4gICAgICAgIHRoaXMuJGh1YnNwb3RNYXNrID0gdGhpcy4kaHVic3BvdC5xdWVyeVNlbGVjdG9yKCcuaHVic3BvdF9fbWFzaycpO1xuICAgICAgICB0aGlzLiRodWJzcG90Q29udGVudCA9IHRoaXMuJGh1YnNwb3QucXVlcnlTZWxlY3RvcignLmh1YnNwb3RfX2NvbnRlbnQnKTtcbiAgICAgICAgdGhpcy4kaHVic3BvdENsb3NlciA9IHRoaXMuJGh1YnNwb3QucXVlcnlTZWxlY3RvcignLmh1YnNwb3RfX2Nsb3NlcicpO1xuICAgICAgICB0aGlzLiRodWJzcG90Rm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdodWJzcG90Zm9ybScpO1xuICAgICAgfSAvLyBTY3JvbGxcblxuXG4gICAgICB0aGlzLiRzY3JvbGwgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcjc2Nyb2xsJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RvcnMoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgfSwge1xuICAgIGtleTogXCJldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZlbnRzKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJlbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVsb2FkKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0VsZW1lbnRzKCkge1xuICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnRzTW9iaWxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbW9iaWxlXScpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kZWxlbWVudHNNb2JpbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50c01vYmlsZVtpXS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudHNEZXNrdG9wID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZGVza3RvcF0nKTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy4kZWxlbWVudHNEZXNrdG9wLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnRzRGVza3RvcFtfaV0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmVmb3JlRW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlRW50ZXIoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgfSwge1xuICAgIGtleTogXCJvbkVudGVyQ29tcGxldGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRW50ZXJDb21wbGV0ZWQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gUmVzZXQgU2Nyb2xsXG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wID0gMDsgLy8gTGF6eSBsb2FkXG5cbiAgICAgIHRoaXMubGF6eUxvYWQgPSBuZXcgTGF6eUxvYWQodGhpcy5sYXp5TG9hZCwge1xuICAgICAgICByb290OiBudWxsLFxuICAgICAgICByb290TWFyZ2luOiB3aW5kb3cuaW5uZXJIZWlnaHQgKiAwLjI1ICsgJ3B4JyxcbiAgICAgICAgdGhyZXNob2xkOiAwXG4gICAgICB9KTsgLy8gSWYgZmlyc3QgbmF2aWdhdGlvbiBhbmQgbmVlZCBwcmVsb2FkXG5cbiAgICAgIGlmICh0aGlzLnByZWxvYWRJdGVtcy5tYWluLmxlbmd0aCA+IDAgJiYgdGhpcy5hcHBTdG9yZS5maXJzdE5hdmlnYXRpb24pIHtcbiAgICAgICAgdmFyIF9wcmVsb2FkT24gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICB0aGlzLnByZWxvYWRNYWluID0gUHJlbG9hZCgpO1xuICAgICAgICB0aGlzLnByZWxvYWRNYWluLmZldGNoKHRoaXMucHJlbG9hZEl0ZW1zLm1haW4pO1xuXG4gICAgICAgIHRoaXMucHJlbG9hZE1haW4ub25wcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIC8qIHRoaXMuYXBwVWkuJGxvYWRlclByb2dyZXNzLmlubmVySFRNTCA9IGV2ZW50LnByb2dyZXNzICsgJyUnOyAqL1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucHJlbG9hZE1haW4ub25jb21wbGV0ZSA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgICAgIHZhciBfcHJlbG9hZE9mZiA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgdmFyIF9wcmVsb2FkRGlmZmVyZW5jZSA9IChfcHJlbG9hZE9mZiAtIF9wcmVsb2FkT24pIC8gMTAwMDtcblxuICAgICAgICAgIHZhciBfcHJlbG9hZERlbGF5ID0gTWF0aC5tYXgoMCwgX3RoaXMyLnByZWxvYWREZWxheSAtIF9wcmVsb2FkRGlmZmVyZW5jZSk7XG5cbiAgICAgICAgICBnc2FwLmRlbGF5ZWRDYWxsKF9wcmVsb2FkRGVsYXksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5zdGFydCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSAvLyBJZiBmaXJzdCBuYXZpZ2F0aW9uIGJ1dCBkb250IG5lZWQgcHJlbG9hZHNcbiAgICAgIGVsc2UgaWYgKHRoaXMucHJlbG9hZEl0ZW1zLm1haW4ubGVuZ3RoID09PSAwICYmIHRoaXMuYXBwU3RvcmUuZmlyc3ROYXZpZ2F0aW9uKSB7XG4gICAgICAgIGdzYXAuZGVsYXllZENhbGwodGhpcy5wcmVsb2FkRGVsYXksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIuc3RhcnQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIElmIG5vdCBmaXJzdCBuYXZpZ2F0aW9uXG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIC8vIFJlc2V0IFNjcm9sbFxuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS5maXJzdE5hdmlnYXRpb24pIHRoaXMuYXBwVWkuaGlkZUxvYWRlcigpOyAvLyBNZW51XG5cbiAgICAgIHRoaXMuZXZlbnRzQWx0ZXJuYXRpdmUoKTtcbiAgICAgIHRoaXMuc2Nyb2xsKCk7XG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS5maXJzdE5hdmlnYXRpb24pIHRoaXMuYXBwQ29yZS5uYXZpZ2F0ZVN0YXJ0KCk7XG5cbiAgICAgIGlmICghdGhpcy5wYXJhbXMuaGFzKCd0cnAtZWRpdC10cmFuc2xhdGlvbicpKSB7XG4gICAgICAgIC8vIEluaXQgYW5pbWF0aW9uc1xuICAgICAgICB0aGlzLmluaXRMYWJlbHMoKTtcbiAgICAgICAgdGhpcy5pbml0VGl0bGVzKCk7XG4gICAgICAgIHRoaXMuaW5pdFRpdGxlc0xhcmdlKCk7XG4gICAgICAgIHRoaXMuaW5pdFRleHRzKCk7XG4gICAgICAgIHRoaXMuaW5pdEltYWdlcygpO1xuICAgICAgICB0aGlzLmluaXRMaW5lcygpO1xuICAgICAgICB0aGlzLmluaXRMaW5rcygpO1xuICAgICAgICB0aGlzLmluaXRXb3JkcygpO1xuICAgICAgICB0aGlzLmluaXRBbmNob3JzKCk7XG4gICAgICAgIHRoaXMuaW5pdERyYWdnYWJsZXMoKTtcbiAgICAgICAgdGhpcy5pbml0Q2Fyb3VzZWwoKTtcbiAgICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB0aGlzLmluaXRGb290ZXIoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbnRlcigpO1xuICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuZmlyc3ROYXZpZ2F0aW9uICYmIHRoaXMuYXBwU3RvcmUuY3VycmVudCAhPT0gJ2hvbWUnKSB0aGlzLmFwcFVpLnNob3dIZWFkZXIoKTtcbiAgICAgIHRoaXMuYmVmb3JlUmVzaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgaWYgKHRoaXMuaGFzaCkgdGhpcy5zY3JvbGxUbyh0aGlzLmhhc2gpO1xuICAgICAgdGhpcy5oaWRlTG9nbygpO1xuXG4gICAgICBpZiAodGhpcy5wcmVsb2FkSXRlbXMuc2Vjb25kYXJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5wcmVsb2FkU2Vjb25kYXJ5ID0gUHJlbG9hZCgpO1xuICAgICAgICB0aGlzLnByZWxvYWRTZWNvbmRhcnkuZmV0Y2godGhpcy5wcmVsb2FkSXRlbXMuc2Vjb25kYXJ5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wICYmIHRoaXMuJHNjcm9sbCkgdGhpcy5zY3JvbGxSb3RhdGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2Nyb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjcm9sbCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzLFxuICAgICAgICAgIF9hcmd1bWVudHMgPSBhcmd1bWVudHM7XG5cbiAgICAgIGlmICh0aGlzLiRpbm5lcikge1xuICAgICAgICBpZiAodGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgICAvLyBTdXBlcnNjcm9sbGVyXG4gICAgICAgICAgdGhpcy5zdXBlclNjcm9sbGVyID0gbmV3IFN1cGVyU2Nyb2xsZXIoe1xuICAgICAgICAgICAgc2Nyb2xsOiB0cnVlLFxuICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0OiB0aGlzLiRpbm5lcixcbiAgICAgICAgICAgIGJhcjogdHJ1ZSxcbiAgICAgICAgICAgIGJhclRhcmdldDogdGhpcy4kc2Nyb2xsYmFyLmNoaWxkcmVuWzBdLFxuICAgICAgICAgICAgb25SYWY6IGZ1bmN0aW9uIG9uUmFmKHNjcm9sbCwgcGVyY2VudCkge1xuICAgICAgICAgICAgICBfdGhpczMucmFmKCk7XG5cbiAgICAgICAgICAgICAgaWYgKF90aGlzMy5zdXBlclRyaWdnZXIpIF90aGlzMy5zdXBlclRyaWdnZXIudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7IC8vIFNjcm9sbCBUcmlnZ2VyXG5cbiAgICAgICAgICB0aGlzLnN1cGVyVHJpZ2dlciA9IFNjcm9sbFRyaWdnZXI7XG4gICAgICAgICAgdGhpcy5zdXBlclRyaWdnZXIuZGVmYXVsdHMoe1xuICAgICAgICAgICAgc2Nyb2xsZXI6IHRoaXMuJGlubmVyXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5zdXBlclRyaWdnZXIuc2Nyb2xsZXJQcm94eSh0aGlzLiRpbm5lciwge1xuICAgICAgICAgICAgc2Nyb2xsVG9wOiBmdW5jdGlvbiBzY3JvbGxUb3AodmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKF9hcmd1bWVudHMubGVuZ3RoKSBfdGhpczMuc3VwZXJTY3JvbGxlci5fc2Nyb2xsLmxpdmVQb3NpdGlvbi55ID0gLXZhbHVlO1xuICAgICAgICAgICAgICByZXR1cm4gLV90aGlzMy5zdXBlclNjcm9sbGVyLl9zY3JvbGwubGl2ZVBvc2l0aW9uLnk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5zdXBlclRyaWdnZXIucmVmcmVzaCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3VwZXJUcmlnZ2VyID0gU2Nyb2xsVHJpZ2dlcjtcbiAgICAgICAgICB0aGlzLnN1cGVyVHJpZ2dlci5jb25maWcoe1xuICAgICAgICAgICAgYXV0b1JlZnJlc2hFdmVudHM6ICdET01Db250ZW50TG9hZGVkLGxvYWQnLFxuICAgICAgICAgICAgc3luY0ludGVydmFsOiA5OTk5OTk5OTlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnN1cGVyVHJpZ2dlci5yZWZyZXNoKCk7XG4gICAgICAgICAgdGhpcy5zdXBlclRyaWdnZXIgPSBnc2FwLnRpbWVsaW5lKHtcbiAgICAgICAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgICAgIGVhc2U6ICdub25lJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjcm9sbFRyaWdnZXI6IHtcbiAgICAgICAgICAgICAgdHJpZ2dlcjogdGhpcy4kYXBwLFxuICAgICAgICAgICAgICBzY3J1YjogdHJ1ZSxcbiAgICAgICAgICAgICAgc3RhcnQ6ICd0b3AgdG9wJyxcbiAgICAgICAgICAgICAgZW5kOiAnYm90dG9tIGJvdHRvbScsXG4gICAgICAgICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShzZWxmKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLnJhZigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2Nyb2xsVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Nyb2xsVG8oaGFzaCkge1xuICAgICAgdmFyICR0YXJnZXQgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKGhhc2gpO1xuXG4gICAgICBpZiAoJHRhcmdldCkge1xuICAgICAgICBpZiAodGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gJHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS55ICsgLXRoaXMuc3VwZXJTY3JvbGxlci5fc2Nyb2xsLmxpdmVQb3NpdGlvbi55O1xuICAgICAgICAgIHRoaXMuc3VwZXJTY3JvbGxlci5zY3JvbGxBbmltYXRlKG9mZnNldCwgMiwgJ3Bvd2VyNC5pbk91dCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfb2Zmc2V0ID0gJHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS55ICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcblxuICAgICAgICAgIGdzYXAudG8oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7XG4gICAgICAgICAgICBzY3JvbGxUb3A6IF9vZmZzZXQsXG4gICAgICAgICAgICBkdXJhdGlvbjogMixcbiAgICAgICAgICAgIGVhc2U6ICdwb3dlcjQuaW5PdXQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2Nyb2xsUm90YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjcm9sbFJvdGF0ZSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBnc2FwLnRvKHRoaXMuJHNjcm9sbC5xdWVyeVNlbGVjdG9yKCdzdmcnKSwge1xuICAgICAgICByb3RhdGlvbjogJzM2MCcsXG4gICAgICAgIGR1cmF0aW9uOiAxNSxcbiAgICAgICAgZWFzZTogJ25vbmUnLFxuICAgICAgICByZXBlYXQ6IC0xXG4gICAgICB9KTtcbiAgICAgIFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgdHJpZ2dlcjogdGhpcy4kaW5uZXIsXG4gICAgICAgIHN0YXJ0OiB3aW5kb3cuaW5uZXJXaWR0aCAqIDAuMDIgKyAnIHRvcCcsXG4gICAgICAgIG1hcmtlcnM6IGZhbHNlLFxuICAgICAgICBvbkVudGVyOiBmdW5jdGlvbiBvbkVudGVyKCkge1xuICAgICAgICAgIGdzYXAudG8oX3RoaXM0LiRzY3JvbGwsIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLjUsXG4gICAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCcsXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgICAgICBnc2FwLnNldChfdGhpczQuJHNjcm9sbCwge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBnc2FwLnRvKF90aGlzNC4kc2Nyb2xsLnF1ZXJ5U2VsZWN0b3IoJ3N2ZycpLCB7XG4gICAgICAgICAgICByb3RhdGlvbjogJys9MTgwJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLjMsXG4gICAgICAgICAgICBlYXNlOiAncG93ZXIyLmluT3V0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXZlbnRzQWx0ZXJuYXRpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZlbnRzQWx0ZXJuYXRpdmUoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgLy8gT3BlbiBtZW51XG4gICAgICB0aGlzLmRvbUV2ZW50cy5hZGQodGhpcy5hcHBVaS4kdHJpZ2dlciwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXM1LmFwcFVpLmlzQW5pbWF0aW5nKSBfdGhpczUuYXBwVWkuY2xvc2VNZW51KCk7ZWxzZSBfdGhpczUuYXBwVWkub3Blbk1lbnUoKTtcbiAgICAgIH0pOyAvLyBDbG9zZSBtZW51XG5cbiAgICAgIHRoaXMuZG9tRXZlbnRzLmFkZCh0aGlzLmFwcFVpLiRtZW51TWFzaywgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczUuYXBwVWkuY2xvc2VNZW51KCk7XG4gICAgICB9KTsgLy8gTW91c2UgZW50ZXIvbGVhdmUgb24gdHJpZ2dlclxuXG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgdGhpcy5kb21FdmVudHMuYWRkKHRoaXMuYXBwVWkuJHRyaWdnZXIsICdtb3VzZWVudGVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNS5hcHBVaS5lbnRlclRyaWdnZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzLmFkZCh0aGlzLmFwcFVpLiR0cmlnZ2VyLCAnbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczUuYXBwVWkubGVhdmVUcmlnZ2VyKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBPcGVuIGZvcm1zIG1vZGFsXG5cblxuICAgICAgaWYgKHRoaXMuYXBwVWkuJHJlcXVlc3RCdXR0b24pIHRoaXMuZG9tRXZlbnRzLmFkZCh0aGlzLmFwcFVpLiRyZXF1ZXN0QnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNS5vcGVuRm9ybSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhpZGVMb2dvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGVMb2dvKCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgdHJpZ2dlcjogdGhpcy4kaW5uZXIsXG4gICAgICAgIHN0YXJ0OiB3aW5kb3cuaW5uZXJIZWlnaHQgKiAwLjEgKyAnIHRvcCcsXG4gICAgICAgIG9uRW50ZXI6IGZ1bmN0aW9uIG9uRW50ZXIoKSB7XG4gICAgICAgICAgaWYgKF90aGlzNi5hcHBVaS4kbG9nbykgZ3NhcC50byhfdGhpczYuYXBwVWkuJGxvZ28sIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLjMsXG4gICAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25MZWF2ZUJhY2s6IGZ1bmN0aW9uIG9uTGVhdmVCYWNrKCkge1xuICAgICAgICAgIGlmIChfdGhpczYuYXBwVWkuJGxvZ28pIHtcbiAgICAgICAgICAgIC8vIGdzYXAuc2V0KHRoaXMuYXBwVWkuJGxvZ28sIHsgZGlzcGxheTogJ2Jsb2NrJyB9KTtcbiAgICAgICAgICAgIGdzYXAudG8oX3RoaXM2LmFwcFVpLiRsb2dvLCB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjMsXG4gICAgICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Rm9ybXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Rm9ybXMoKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdGhpcy4kZm9ybXMgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKCcuaHVic3BvdGZvcm0nKTtcblxuICAgICAgaWYgKHRoaXMuJGZvcm1zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX3RhcmdldCA9ICcjJyArIHRoaXMuJGZvcm1zW2ldLmlkO1xuXG4gICAgICAgICAgdmFyIF9pZCA9IHRoaXMuJGZvcm1zW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS1pZCcpO1xuXG4gICAgICAgICAgaWYgKF9pZCkge1xuICAgICAgICAgICAgaGJzcHQuZm9ybXMuY3JlYXRlKHtcbiAgICAgICAgICAgICAgcmVnaW9uOiAnbmExJyxcbiAgICAgICAgICAgICAgcG9ydGFsSWQ6ICc2NTgwMzgzJyxcbiAgICAgICAgICAgICAgdGFyZ2V0OiBfdGFyZ2V0LFxuICAgICAgICAgICAgICBmb3JtSWQ6IF9pZCxcbiAgICAgICAgICAgICAgb25Gb3JtUmVhZHk6IGZ1bmN0aW9uIG9uRm9ybVJlYWR5KCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpczcuYXBwU3RvcmUuaXNEZXNrdG9wKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXM3LmludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoX3RoaXM3LmludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXM3LmludGVydmFsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgX3RoaXM3LmludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXM3LnN1cGVyU2Nyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpczcuc3VwZXJTY3JvbGxlci5yZXNpemUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoX3RoaXM3LmludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TGFiZWxzKCkge1xuICAgICAgdGhpcy4kbGFiZWxzID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvckFsbCgnLmxhYmVsLS1pbml0Jyk7XG5cbiAgICAgIGlmICh0aGlzLiRsYWJlbHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3XG4gICAgICAgICAgbmV3IFNwbGl0VGV4dCh0aGlzLiRsYWJlbHNbaV0sIHtcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lcywgd29yZHMnLFxuICAgICAgICAgICAgbGluZXNDbGFzczogJ2xpbmUgbGluZS0tKysnLFxuICAgICAgICAgICAgd29yZHNDbGFzczogJ3dvcmQgd29yZC0tKysnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuJGxhYmVsc1tpXS5xdWVyeVNlbGVjdG9yQWxsKCcud29yZCcpLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBnc2FwLnNldCh0aGlzLiRsYWJlbHNbaV0ucXVlcnlTZWxlY3RvckFsbCgnLndvcmQnKVtqXSwge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAwLjAwMDEsXG4gICAgICAgICAgICAgIHk6ICcxMDAlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFRpdGxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUaXRsZXMoKSB7XG4gICAgICB0aGlzLiR0aXRsZXMgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKCcudGl0bGUtLWluaXQnKTtcblxuICAgICAgaWYgKHRoaXMuJHRpdGxlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJHRpdGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcbiAgICAgICAgICBuZXcgU3BsaXRUZXh0KHRoaXMuJHRpdGxlc1tpXSwge1xuICAgICAgICAgICAgdHlwZTogJ2xpbmVzIHdvcmRzJyxcbiAgICAgICAgICAgIGxpbmVzQ2xhc3M6ICdsaW5lIGxpbmUtLSsrJyxcbiAgICAgICAgICAgIHdvcmRzQ2xhc3M6ICd3b3JkIHdvcmQtLSsrJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciB3b3JkcyA9IHRoaXMuJHRpdGxlc1tpXS5xdWVyeVNlbGVjdG9yQWxsKCcud29yZCcpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3b3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZ3NhcC5zZXQod29yZHNbal0sIHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICAgICAgICB5OiAnMTAwJScsXG4gICAgICAgICAgICAgIHJvdGF0aW9uWDogJzNkZWcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VGl0bGVzTGFyZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGl0bGVzTGFyZ2UoKSB7XG4gICAgICB0aGlzLiR0aXRsZXNMYXJnZSA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy50aXRsZWxhcmdlLS1pbml0Jyk7XG5cbiAgICAgIGlmICh0aGlzLiR0aXRsZXNMYXJnZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJHRpdGxlc0xhcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ld1xuICAgICAgICAgIG5ldyBTcGxpdFRleHQodGhpcy4kdGl0bGVzTGFyZ2VbaV0sIHtcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lcyB3b3JkcyBjaGFycycsXG4gICAgICAgICAgICBsaW5lc0NsYXNzOiAnbGluZSBsaW5lLS0rKycsXG4gICAgICAgICAgICB3b3Jkc0NsYXNzOiAnd29yZCB3b3JkLS0rKycsXG4gICAgICAgICAgICBjaGFyc0NsYXNzOiAnY2hhciBjaGFyLS0rKydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgY2hhcnMgPSB0aGlzLiR0aXRsZXNMYXJnZVtpXS5xdWVyeVNlbGVjdG9yQWxsKCcuY2hhcicpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZ3NhcC5zZXQoY2hhcnNbal0sIHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICAgICAgICB5OiAnMTAwJScsXG4gICAgICAgICAgICAgIHJvdGF0aW9uWDogJzNkZWcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VGV4dHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGV4dHMoKSB7XG4gICAgICB0aGlzLiR0ZXh0cyA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy50ZXh0LS1pbml0Jyk7XG5cbiAgICAgIGlmICh0aGlzLiR0ZXh0cykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJHRleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZ3NhcC5zZXQodGhpcy4kdGV4dHNbaV0sIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgICAgIHk6ICc1MCUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0SW1hZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEltYWdlcygpIHtcbiAgICAgIHRoaXMuJG9wYWNpdHkgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKCcuaW1hZ2UtLWluaXQnKTtcblxuICAgICAgaWYgKHRoaXMuJG9wYWNpdHkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRvcGFjaXR5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZ3NhcC5zZXQodGhpcy4kb3BhY2l0eVtpXSwge1xuICAgICAgICAgICAgb3BhY2l0eTogMC4wMDAxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TGluZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TGluZXMoKSB7XG4gICAgICB0aGlzLiRsaW5lcyA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5oci0taW5pdCcpO1xuXG4gICAgICBpZiAodGhpcy4kbGluZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGdzYXAuc2V0KHRoaXMuJGxpbmVzW2ldLCB7XG4gICAgICAgICAgICBzY2FsZVg6IDAsXG4gICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46ICcwIDUwJSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRMaW5rc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMaW5rcygpIHtcbiAgICAgIHRoaXMuJGxpbmtzID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvckFsbCgnLmxpbmstLWluaXQnKTtcblxuICAgICAgaWYgKHRoaXMuJGxpbmtzICYmIHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kbGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBnc2FwLnNldCh0aGlzLiRsaW5rc1tpXS5xdWVyeVNlbGVjdG9yKCcudW5kZXJsaW5lJyksIHtcbiAgICAgICAgICAgIHNjYWxlWDogMCxcbiAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogJzAgNTAlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFdvcmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFdvcmRzKCkge1xuICAgICAgdGhpcy4kd29yZHNUaXRsZXMgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKCcud29yZHMtLWluaXQnKTtcblxuICAgICAgaWYgKHRoaXMuJHdvcmRzVGl0bGVzICYmICF0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJHdvcmRzVGl0bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ld1xuICAgICAgICAgIG5ldyBTcGxpdFRleHQodGhpcy4kd29yZHNUaXRsZXNbaV0sIHtcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lcyB3b3JkcycsXG4gICAgICAgICAgICBsaW5lc0NsYXNzOiAnbGluZSBsaW5lLS0rKycsXG4gICAgICAgICAgICB3b3Jkc0NsYXNzOiAnd29yZCB3b3JkLS0rKydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgd29yZHMgPSB0aGlzLiR3b3Jkc1RpdGxlc1tpXS5xdWVyeVNlbGVjdG9yQWxsKCcud29yZCcpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3b3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZ3NhcC5zZXQod29yZHNbal0sIHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICAgICAgICB5OiAnMTAwJScsXG4gICAgICAgICAgICAgIHJvdGF0aW9uOiAnM2RlZydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXREcmFnZ2FibGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERyYWdnYWJsZXMoKSB7XG4gICAgICB0aGlzLiRkcmFnZ2FibGVzID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvckFsbCgnLmRyYWdnYWJsZS0taW5pdCcpO1xuXG4gICAgICBpZiAodGhpcy4kZHJhZ2dhYmxlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJGRyYWdnYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLiRkcmFnZ2FibGVJbm5lciA9IHRoaXMuJGRyYWdnYWJsZXNbaV0ucXVlcnlTZWxlY3RvcignLnNsaWRlcl9faW5uZXInKTtcbiAgICAgICAgICB0aGlzLiRkcmFnZ2FibGVJdGVtcyA9IHRoaXMuJGRyYWdnYWJsZXNbaV0ucXVlcnlTZWxlY3RvckFsbCgnLnNsaWRlcl9faXRlbScpOyAvLyB0aGlzLiRkcmFnZ2FibGVQcm9ncmVzcyA9IHRoaXMuJGRyYWdnYWJsZXNbaV0ucXVlcnlTZWxlY3RvcignLnNsaWRlcl9fcHJvZ3Jlc3MnKTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy4kZHJhZ2dhYmxlSXRlbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGdzYXAuc2V0KHRoaXMuJGRyYWdnYWJsZUl0ZW1zW2pdLCB7XG4gICAgICAgICAgICAgIHg6IDYwICogaiArICclJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ3NhcC5zZXQodGhpcy4kZHJhZ2dhYmxlSW5uZXIsIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgICAgIHg6ICcxMDAlJ1xuICAgICAgICAgIH0pOyAvLyBpZih0aGlzLiRkcmFnZ2FibGVQcm9ncmVzcyAmJiAhdGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApXG4gICAgICAgICAgLy8gICAgIGdzYXAuc2V0KHRoaXMuJGRyYWdnYWJsZVByb2dyZXNzLCB7IG9wYWNpdHk6IDAuMDAwMSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGb290ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Rm9vdGVyKCkge1xuICAgICAgLy8gU2VsZWN0b3JzXG4gICAgICB0aGlzLiRmb290ZXIgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCdbY2xhc3MqPVwiX19mb290ZXJcIl0nKTtcbiAgICAgIHRoaXMuJGZvb3RlckNvbnRhaW5lciA9IHRoaXMuJGZvb3Rlci5xdWVyeVNlbGVjdG9yKCcuY29udGFpbmVyJyk7XG4gICAgICB0aGlzLiRmb290ZXJUaXRsZSA9IHRoaXMuJGZvb3Rlci5xdWVyeVNlbGVjdG9yKCcuc3VwZXJ0aXRsZScpO1xuICAgICAgdGhpcy4kZm9vdGVyVGV4dCA9IHRoaXMuJGZvb3Rlci5xdWVyeVNlbGVjdG9yKCcud3lzaXd5ZycpO1xuXG4gICAgICBpZiAodGhpcy4kZm9vdGVyKSB7XG4gICAgICAgIC8vIFNldCBhbmltYXRpb25cbiAgICAgICAgZ3NhcC5zZXQodGhpcy4kZm9vdGVyQ29udGFpbmVyLCB7XG4gICAgICAgICAgeTogJy0xMDB2aCdcbiAgICAgICAgfSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcblxuICAgICAgICBuZXcgU3BsaXRUZXh0KHRoaXMuJGZvb3RlclRpdGxlLCB7XG4gICAgICAgICAgdHlwZTogJ2xpbmVzIHdvcmRzIGNoYXJzJyxcbiAgICAgICAgICBsaW5lc0NsYXNzOiAnbGluZSBsaW5lLS0rKycsXG4gICAgICAgICAgd29yZHNDbGFzczogJ3dvcmQgd29yZC0tKysnLFxuICAgICAgICAgIGNoYXJzQ2xhc3M6ICdjaGFyIGNoYXItLSsrJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNoYXJzID0gdGhpcy4kZm9vdGVyVGl0bGUucXVlcnlTZWxlY3RvckFsbCgnLmNoYXInKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZ3NhcC5zZXQoY2hhcnNbaV0sIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcblxuXG4gICAgICAgIG5ldyBTcGxpdFRleHQodGhpcy4kZm9vdGVyVGV4dCwge1xuICAgICAgICAgIHR5cGU6ICdsaW5lcyB3b3JkcycsXG4gICAgICAgICAgbGluZXNDbGFzczogJ2xpbmUgbGluZS0tKysnLFxuICAgICAgICAgIHdvcmRzQ2xhc3M6ICd3b3JkIHdvcmQtLSsrJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHdvcmRzID0gdGhpcy4kZm9vdGVyVGV4dC5xdWVyeVNlbGVjdG9yQWxsKCcud29yZCcpO1xuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHdvcmRzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICBnc2FwLnNldCh3b3Jkc1tfaTJdLCB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLjAwMDEsXG4gICAgICAgICAgICB5OiAnMTAwJScsXG4gICAgICAgICAgICByb3RhdGlvbjogJzNkZWcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBnc2FwLnNldChbdGhpcy4kZm9vdGVyLnF1ZXJ5U2VsZWN0b3IoJy5zb2NpYWwnKSwgdGhpcy4kZm9vdGVyLnF1ZXJ5U2VsZWN0b3IoJy5sZWdhbCcpXSwge1xuICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdExhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0TGFiZWxzKCkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLiRsYWJlbHMpIHtcbiAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICAgIFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgICAgIHN0YXJ0OiAndG9wIDkwJScsXG4gICAgICAgICAgICB0cmlnZ2VyOiBfdGhpczguJGxhYmVsc1tpXSxcbiAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICBvbkVudGVyOiBmdW5jdGlvbiBvbkVudGVyKCkge1xuICAgICAgICAgICAgICB2YXIgJHdvcmRzID0gX3RoaXM4LiRsYWJlbHNbaV0ucXVlcnlTZWxlY3RvckFsbCgnLndvcmQnKTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8ICR3b3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGdzYXAudG8oJHdvcmRzW2pdLCB7XG4gICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgICAgeTogJzAlJyxcbiAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiAnMGRlZycsXG4gICAgICAgICAgICAgICAgICBlYXNlOiAnZXhwby5pbk91dCcsXG4gICAgICAgICAgICAgICAgICBkdXJhdGlvbjogMC44LFxuICAgICAgICAgICAgICAgICAgZGVsYXk6IDAuMiArIGogKiAwLjAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJGxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIF9sb29wKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRUaXRsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFRpdGxlcygpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy4kdGl0bGVzKSB7XG4gICAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoaSkge1xuICAgICAgICAgIFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgICAgIHN0YXJ0OiAndG9wIDkwJScsXG4gICAgICAgICAgICB0cmlnZ2VyOiBfdGhpczkuJHRpdGxlc1tpXSxcbiAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICBvbkVudGVyOiBmdW5jdGlvbiBvbkVudGVyKCkge1xuICAgICAgICAgICAgICB2YXIgd29yZHMgPSBfdGhpczkuJHRpdGxlc1tpXS5xdWVyeVNlbGVjdG9yQWxsKCcud29yZCcpO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd29yZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBnc2FwLnRvKHdvcmRzW2pdLCB7XG4gICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgICAgeTogJzAlJyxcbiAgICAgICAgICAgICAgICAgIHJvdGF0aW9uWDogJzBkZWcnLFxuICAgICAgICAgICAgICAgICAgZWFzZTogJ2V4cG8ub3V0JyxcbiAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjgsXG4gICAgICAgICAgICAgICAgICBkZWxheTogMC4yICsgaiAqIDAuMDFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kdGl0bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgX2xvb3AyKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRUaXRsZXNMYXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0VGl0bGVzTGFyZ2UoKSB7XG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLiR0aXRsZXNMYXJnZSkge1xuICAgICAgICB2YXIgX2xvb3AzID0gZnVuY3Rpb24gX2xvb3AzKGkpIHtcbiAgICAgICAgICBTY3JvbGxUcmlnZ2VyLmNyZWF0ZSh7XG4gICAgICAgICAgICB0cmlnZ2VyOiBfdGhpczEwLmFwcFN0b3JlLmlzRGVza3RvcCA/IF90aGlzMTAuJHRpdGxlc0xhcmdlW2ldIDogX3RoaXMxMC4kdGl0bGVzTGFyZ2VbaV0ucGFyZW50Tm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgc3RhcnQ6IF90aGlzMTAuYXBwU3RvcmUuaXNEZXNrdG9wID8gJ3RvcCA5MCUnIDogJ3RvcCAzNSUnLFxuICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIG9uRW50ZXI6IGZ1bmN0aW9uIG9uRW50ZXIoKSB7XG4gICAgICAgICAgICAgIHZhciBjaGFycyA9IF90aGlzMTAuJHRpdGxlc0xhcmdlW2ldLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jaGFyJyk7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGdzYXAudG8oY2hhcnNbal0sIHtcbiAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgICB5OiAnMCUnLFxuICAgICAgICAgICAgICAgICAgcm90YXRpb25YOiAnMGRlZycsXG4gICAgICAgICAgICAgICAgICBlYXNlOiAnZXhwby5vdXQnLFxuICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDEuNCxcbiAgICAgICAgICAgICAgICAgIGRlbGF5OiAwLjcgKyBqICogMC4wMlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiR0aXRsZXNMYXJnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIF9sb29wMyhpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0VGV4dHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFRleHRzKCkge1xuICAgICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy4kdGV4dHMpIHtcbiAgICAgICAgdmFyIF9sb29wNCA9IGZ1bmN0aW9uIF9sb29wNChpKSB7XG4gICAgICAgICAgU2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xuICAgICAgICAgICAgdHJpZ2dlcjogX3RoaXMxMS5hcHBTdG9yZS5pc0Rlc2t0b3AgPyBfdGhpczExLiR0ZXh0c1tpXSA6IF90aGlzMTEuJHRleHRzW2ldLnBhcmVudE5vZGUsXG4gICAgICAgICAgICBzdGFydDogJ3RvcCA5MCUnLFxuICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIG9uRW50ZXI6IGZ1bmN0aW9uIG9uRW50ZXIoKSB7XG4gICAgICAgICAgICAgIGdzYXAudG8oX3RoaXMxMS4kdGV4dHNbaV0sIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHk6ICcwJScsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IF90aGlzMTEuYXBwU3RvcmUuaXNEZXNrdG9wID8gMS41IDogMixcbiAgICAgICAgICAgICAgICBlYXNlOiAnZXhwby5vdXQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kdGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBfbG9vcDQoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdEltYWdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0SW1hZ2VzKCkge1xuICAgICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy4kaW1hZ2VzKSB7XG4gICAgICAgIHZhciBfbG9vcDUgPSBmdW5jdGlvbiBfbG9vcDUoaSkge1xuICAgICAgICAgIFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgICAgIHRyaWdnZXI6IF90aGlzMTIuJGltYWdlc1tpXSxcbiAgICAgICAgICAgIHN0YXJ0OiBfdGhpczEyLmFwcFN0b3JlLmlzRGVza3RvcCA/ICd0b3AgOTAlJyA6ICd0b3AgODAlJyxcbiAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICBvbkVudGVyOiBmdW5jdGlvbiBvbkVudGVyKCkge1xuICAgICAgICAgICAgICBnc2FwLnRvKF90aGlzMTIuJGltYWdlc1tpXSwge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDUsXG4gICAgICAgICAgICAgICAgZWFzZTogJ2V4cG8ub3V0J1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJGltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIF9sb29wNShpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0TGluZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdExpbmVzKCkge1xuICAgICAgdmFyIF90aGlzMTMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy4kbGluZXMpIHtcbiAgICAgICAgdmFyIF9sb29wNiA9IGZ1bmN0aW9uIF9sb29wNihpKSB7XG4gICAgICAgICAgU2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xuICAgICAgICAgICAgdHJpZ2dlcjogX3RoaXMxMy4kbGluZXNbaV0sXG4gICAgICAgICAgICBzdGFydDogX3RoaXMxMy5hcHBTdG9yZS5pc0Rlc2t0b3AgPyAndG9wIDkwJScgOiAndG9wIDgwJScsXG4gICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgb25FbnRlcjogZnVuY3Rpb24gb25FbnRlcigpIHtcbiAgICAgICAgICAgICAgZ3NhcC50byhfdGhpczEzLiRsaW5lc1tpXSwge1xuICAgICAgICAgICAgICAgIHNjYWxlWDogMSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMS41LFxuICAgICAgICAgICAgICAgIGVhc2U6ICdleHBvLmluT3V0J1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgX2xvb3A2KGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRMaW5rc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0TGlua3MoKSB7XG4gICAgICB2YXIgX3RoaXMxNCA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLiRsaW5rcykge1xuICAgICAgICB2YXIgX2xvb3A3ID0gZnVuY3Rpb24gX2xvb3A3KGkpIHtcbiAgICAgICAgICBTY3JvbGxUcmlnZ2VyLmNyZWF0ZSh7XG4gICAgICAgICAgICB0cmlnZ2VyOiBfdGhpczE0LiRsaW5rc1tpXSxcbiAgICAgICAgICAgIHN0YXJ0OiBfdGhpczE0LmFwcFN0b3JlLmlzRGVza3RvcCA/ICd0b3AgOTAlJyA6ICd0b3AgODAlJyxcbiAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICBvbkVudGVyOiBmdW5jdGlvbiBvbkVudGVyKCkge1xuICAgICAgICAgICAgICBnc2FwLnRvKF90aGlzMTQuJGxpbmtzW2ldLnF1ZXJ5U2VsZWN0b3IoJy51bmRlcmxpbmUnKSwge1xuICAgICAgICAgICAgICAgIHNjYWxlWDogMSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMSxcbiAgICAgICAgICAgICAgICBlYXNlOiAnZXhwby5pbk91dCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoX3RoaXMxNC5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgICAgIF90aGlzMTQuZG9tRXZlbnRzLmFkZChfdGhpczE0LiRsaW5rc1tpXSwgJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoYSwgZSwgZWwpIHtcbiAgICAgICAgICAgICAgZ3NhcC50byhlbC5xdWVyeVNlbGVjdG9yKCcudW5kZXJsaW5lJyksIHtcbiAgICAgICAgICAgICAgICBzY2FsZVg6IDAsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDAuNixcbiAgICAgICAgICAgICAgICBlYXNlOiAnZXhwby5pbk91dCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgX3RoaXMxNC5kb21FdmVudHMuYWRkKF90aGlzMTQuJGxpbmtzW2ldLCAnbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChhLCBlLCBlbCkge1xuICAgICAgICAgICAgICBnc2FwLnRvKGVsLnF1ZXJ5U2VsZWN0b3IoJy51bmRlcmxpbmUnKSwge1xuICAgICAgICAgICAgICAgIHNjYWxlWDogMSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMC42LFxuICAgICAgICAgICAgICAgIGVhc2U6ICdleHBvLmluT3V0J1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJGxpbmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgX2xvb3A3KGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRXb3Jkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0V29yZHMoKSB7XG4gICAgICB2YXIgX3RoaXMxNSA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLiR3b3Jkc1RpdGxlcyAmJiAhdGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgdmFyIF9sb29wOCA9IGZ1bmN0aW9uIF9sb29wOChpKSB7XG4gICAgICAgICAgU2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xuICAgICAgICAgICAgdHJpZ2dlcjogX3RoaXMxNS4kd29yZHNUaXRsZXNbaV0sXG4gICAgICAgICAgICBzdGFydDogX3RoaXMxNS5hcHBTdG9yZS5pc0Rlc2t0b3AgPyAndG9wIDkwJScgOiAndG9wIDgwJScsXG4gICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgb25FbnRlcjogZnVuY3Rpb24gb25FbnRlcigpIHtcbiAgICAgICAgICAgICAgdmFyIHdvcmRzID0gX3RoaXMxNS4kd29yZHNUaXRsZXNbaV0ucXVlcnlTZWxlY3RvckFsbCgnLndvcmQnKTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHdvcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZ3NhcC50byh3b3Jkc1tqXSwge1xuICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICAgIHk6ICcwJScsXG4gICAgICAgICAgICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgICAgICAgICAgIGVhc2U6ICdleHBvLmluT3V0JyxcbiAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjgsXG4gICAgICAgICAgICAgICAgICBkZWxheTogMCArIGogKiAwLjAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJHdvcmRzVGl0bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgX2xvb3A4KGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRBbmNob3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRBbmNob3JzKCkge1xuICAgICAgdmFyIF90aGlzMTYgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRhbmNob3JzID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvckFsbCgnYVtocmVmKj1cIiNcIl0nKTtcblxuICAgICAgaWYgKHRoaXMuJGFuY2hvcnMpIHtcbiAgICAgICAgdmFyIF9sb29wOSA9IGZ1bmN0aW9uIF9sb29wOShpKSB7XG4gICAgICAgICAgX3RoaXMxNi5kb21FdmVudHMuYWRkKF90aGlzMTYuJGFuY2hvcnNbaV0sICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpczE2LnNjcm9sbFRvKCcjJyArIF90aGlzMTYuJGFuY2hvcnNbaV0uaHJlZi5zcGxpdCgnIycpWzFdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJGFuY2hvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBfbG9vcDkoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdERyYWdnYWJsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdERyYWdnYWJsZXMoKSB7XG4gICAgICB2YXIgX3RoaXMxNyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLiRkcmFnZ2FibGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kZHJhZ2dhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgICAgIHRyaWdnZXI6IHRoaXMuJGRyYWdnYWJsZXNbaV0sXG4gICAgICAgICAgICBzdGFydDogJ3RvcCA5MCUnLFxuICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIG9uRW50ZXI6IGZ1bmN0aW9uIG9uRW50ZXIoKSB7XG4gICAgICAgICAgICAgIGdzYXAudG8oX3RoaXMxNy4kZHJhZ2dhYmxlSW5uZXIsIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHg6ICcwJScsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDIsXG4gICAgICAgICAgICAgICAgZWFzZTogJ2V4cG8ub3V0J1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IF90aGlzMTcuJGRyYWdnYWJsZUl0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZ3NhcC50byhfdGhpczE3LiRkcmFnZ2FibGVJdGVtc1tqXSwge1xuICAgICAgICAgICAgICAgICAgeDogJzAlJyxcbiAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxLjUsXG4gICAgICAgICAgICAgICAgICBlYXNlOiAnZXhwby5vdXQnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0Q2Fyb3VzZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdENhcm91c2VsKCkge1xuICAgICAgdmFyIF90aGlzMTggPSB0aGlzO1xuXG4gICAgICB0aGlzLmNhcm91c2VsID0gW107XG4gICAgICB0aGlzLiRjYXJvdXNlbHMgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKCcuY2Fyb3VzZWxfX2lubmVyJyk7XG5cbiAgICAgIHZhciBfbG9vcDEwID0gZnVuY3Rpb24gX2xvb3AxMChpKSB7XG4gICAgICAgIC8vIGNvbnN0IF9kaXJlY3Rpb24gPSB0aGlzLiRjYXJvdXNlbHNbaV0uZGF0YXNldC5kaXJlY3Rpb247XG4gICAgICAgIHZhciBfY2Fyb3VzZWwgPSB7fTtcbiAgICAgICAgX2Nhcm91c2VsLiRjYXJvdXNlbEl0ZW1zID0gX3RoaXMxOC4kY2Fyb3VzZWxzW2ldLmNoaWxkcmVuO1xuXG4gICAgICAgIHZhciBfd2lkdGggPSBfY2Fyb3VzZWwuJGNhcm91c2VsSXRlbXNbMF0ub2Zmc2V0V2lkdGggKyAncHgnO1xuXG4gICAgICAgIF90aGlzMTguJGNhcm91c2Vsc1tpXS5zdHlsZS53aWR0aCA9IF93aWR0aDtcbiAgICAgICAgX2Nhcm91c2VsLmNhcm91c2VsTGVmdCA9IGdzYXAudGltZWxpbmUoe1xuICAgICAgICAgIHBhdXNlZDogZmFsc2UsXG4gICAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgIGVhc2U6ICdub25lJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBfdGhpczE4LmFwcFN0b3JlLmlzRGVza3RvcCA/IF9jYXJvdXNlbC4kY2Fyb3VzZWxJdGVtc1swXS5vZmZzZXRXaWR0aCAvIDIwMCA6IF9jYXJvdXNlbC4kY2Fyb3VzZWxJdGVtc1swXS5vZmZzZXRXaWR0aCAvIDc1LFxuICAgICAgICAgICAgcmVwZWF0OiAnLTEnLFxuICAgICAgICAgICAgb25SZXZlcnNlQ29tcGxldGU6IGZ1bmN0aW9uIG9uUmV2ZXJzZUNvbXBsZXRlKCkge1xuICAgICAgICAgICAgICBfY2Fyb3VzZWwuY2Fyb3VzZWxMZWZ0LnBhdXNlKCk7XG5cbiAgICAgICAgICAgICAgX2Nhcm91c2VsLmNhcm91c2VsUmlnaHQucGxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfY2Fyb3VzZWwuJGNhcm91c2VsSXRlbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBfY2Fyb3VzZWwuY2Fyb3VzZWxMZWZ0LnRvKF9jYXJvdXNlbC4kY2Fyb3VzZWxJdGVtc1tqXSwge1xuICAgICAgICAgICAgeDogLTEwMCArICclJ1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgX2Nhcm91c2VsLmNhcm91c2VsUmlnaHQgPSBnc2FwLnRpbWVsaW5lKHtcbiAgICAgICAgICBwYXVzZWQ6IHRydWUsXG4gICAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgIGVhc2U6ICdub25lJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBfdGhpczE4LmFwcFN0b3JlLmlzRGVza3RvcCA/IF9jYXJvdXNlbC4kY2Fyb3VzZWxJdGVtc1swXS5vZmZzZXRXaWR0aCAvIDIwMCA6IF9jYXJvdXNlbC4kY2Fyb3VzZWxJdGVtc1swXS5vZmZzZXRXaWR0aCAvIDc1LFxuICAgICAgICAgICAgcmVwZWF0OiAnLTEnLFxuICAgICAgICAgICAgb25SZXZlcnNlQ29tcGxldGU6IGZ1bmN0aW9uIG9uUmV2ZXJzZUNvbXBsZXRlKCkge1xuICAgICAgICAgICAgICBfY2Fyb3VzZWwuY2Fyb3VzZWxSaWdodC5wYXVzZSgpO1xuXG4gICAgICAgICAgICAgIF9jYXJvdXNlbC5jYXJvdXNlbExlZnQucGxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IF9jYXJvdXNlbC4kY2Fyb3VzZWxJdGVtcy5sZW5ndGg7IF9qKyspIHtcbiAgICAgICAgICBfY2Fyb3VzZWwuY2Fyb3VzZWxSaWdodC50byhfY2Fyb3VzZWwuJGNhcm91c2VsSXRlbXNbX2pdLCB7XG4gICAgICAgICAgICB4OiAxMDAgKyAnJSdcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpczE4LmFwcFN0b3JlLmlzRGVza3RvcCkge1xuICAgICAgICAgIF9jYXJvdXNlbC5jYXJvdXNlbE1vdmUgPSBnc2FwLnRpbWVsaW5lKHtcbiAgICAgICAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgICAgIGVhc2U6ICdub25lJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjcm9sbFRyaWdnZXI6IHtcbiAgICAgICAgICAgICAgdHJpZ2dlcjogX3RoaXMxOC4kY2Fyb3VzZWxzW2ldLFxuICAgICAgICAgICAgICBzY3J1YjogdHJ1ZSxcbiAgICAgICAgICAgICAgc3RhcnQ6ICd0b3AgYm90dG9tJyxcbiAgICAgICAgICAgICAgZW5kOiAnYm90dG9tIHRvcCcsXG4gICAgICAgICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShzZWxmKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfY2Fyb3VzZWwuY2Fyb3VzZWxMZWZ0LnBhdXNlZCgpKSBfY2Fyb3VzZWwuY2Fyb3VzZWxMZWZ0LnJldmVyc2VkKHNlbGYuZGlyZWN0aW9uICE9PSAxKTtcbiAgICAgICAgICAgICAgICBpZiAoIV9jYXJvdXNlbC5jYXJvdXNlbFJpZ2h0LnBhdXNlZCgpKSBfY2Fyb3VzZWwuY2Fyb3VzZWxSaWdodC5yZXZlcnNlZChzZWxmLmRpcmVjdGlvbiA9PT0gMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTsgLy8gX2Nhcm91c2VsLmNhcm91c2VsTW92ZS5mcm9tVG8odGhpcy4kY2Fyb3VzZWxzW2ldLCB7IHg6IHdpbmRvdy5pbm5lcldpZHRoICogMC4yICogX2RpcmVjdGlvbiB9LCB7IHg6IC13aW5kb3cuaW5uZXJXaWR0aCAqIDAuMiAqIF9kaXJlY3Rpb24gfSwgMCk7XG5cbiAgICAgICAgICBfY2Fyb3VzZWwuY2Fyb3VzZWxNb3ZlLmZyb21UbyhfdGhpczE4LiRjYXJvdXNlbHNbaV0sIHtcbiAgICAgICAgICAgIHg6IHdpbmRvdy5pbm5lcldpZHRoICogMC4yXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogLXdpbmRvdy5pbm5lcldpZHRoICogMC4yXG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczE4LmNhcm91c2VsLnB1c2goX2Nhcm91c2VsKTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kY2Fyb3VzZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9sb29wMTAoaSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRGb290ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdEZvb3RlcigpIHtcbiAgICAgIGlmICh0aGlzLiRmb290ZXIpIHtcbiAgICAgICAgLy8gU3RhcnQgZm9vdGVyIHRpbWVsaW5lXG4gICAgICAgIHRoaXMuX2Zvb3RlclRpbWVsaW5lID0gZ3NhcC50aW1lbGluZSh7XG4gICAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgIGVhc2U6ICdub25lJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzY3JvbGxUcmlnZ2VyOiB7XG4gICAgICAgICAgICB0cmlnZ2VyOiB0aGlzLiRmb290ZXIsXG4gICAgICAgICAgICBzdGFydDogJ3RvcCBib3R0b20nLFxuICAgICAgICAgICAgZW5kOiAnYm90dG9tIDEwMCUnLFxuICAgICAgICAgICAgc2NydWI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBBbmltYXRlIGluL291dFxuXG4gICAgICAgIHRoaXMuX2Zvb3RlclRpbWVsaW5lLnRvKHRoaXMuJGZvb3RlckNvbnRhaW5lciwge1xuICAgICAgICAgIHk6ICcxMDB2aCcsXG4gICAgICAgICAgZHVyYXRpb246IDFcbiAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgdmFyIGNoYXJzID0gdGhpcy4kZm9vdGVyVGl0bGUucXVlcnlTZWxlY3RvckFsbCgnLmNoYXInKTtcblxuICAgICAgICB0aGlzLl9mb290ZXJUaW1lbGluZS50byhjaGFycywge1xuICAgICAgICAgIG9wYWNpdHk6IDAuMSxcbiAgICAgICAgICBkdXJhdGlvbjogMC4xXG4gICAgICAgIH0sIDAuMyk7XG5cbiAgICAgICAgdGhpcy5fZm9vdGVyVGltZWxpbmUudG8oY2hhcnMsIHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIHN0YWdnZXI6IDAuNSAvIGNoYXJzLmxlbmd0aCxcbiAgICAgICAgICBkdXJhdGlvbjogMC41IC8gY2hhcnMubGVuZ3RoXG4gICAgICAgIH0sIDAuNSk7XG5cbiAgICAgICAgdmFyIHdvcmRzID0gdGhpcy4kZm9vdGVyVGV4dC5xdWVyeVNlbGVjdG9yQWxsKCcud29yZCcpO1xuXG4gICAgICAgIHRoaXMuX2Zvb3RlclRpbWVsaW5lLnRvKHdvcmRzLCB7XG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICB5OiAnMCUnLFxuICAgICAgICAgIHJvdGF0aW9uOiAnMGRlZycsXG4gICAgICAgICAgZHVyYXRpb246IDAuMSAvIHdvcmRzLmxlbmd0aCxcbiAgICAgICAgICBzdGFnZ2VyOiB7XG4gICAgICAgICAgICBlYWNoOiAwLjEgLyB3b3Jkcy5sZW5ndGgsXG4gICAgICAgICAgICBmcm9tOiAnc3RhcnQnXG4gICAgICAgICAgfVxuICAgICAgICB9LCAwLjkpO1xuXG4gICAgICAgIHRoaXMuX2Zvb3RlclRpbWVsaW5lLnRvKHRoaXMuJGZvb3Rlci5xdWVyeVNlbGVjdG9yKCcuc29jaWFsJyksIHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLjFcbiAgICAgICAgfSwgMC45KTtcblxuICAgICAgICB0aGlzLl9mb290ZXJUaW1lbGluZS50byh0aGlzLiRmb290ZXIucXVlcnlTZWxlY3RvcignLmxlZ2FsJyksIHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLjFcbiAgICAgICAgfSwgMC45KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW50ZXJDYXJkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbnRlckNhcmRzKGEsIGUsIGVsKSB7XG4gICAgICBpZiAoZWwucXVlcnlTZWxlY3RvcignLmxpbmsnKSkge1xuICAgICAgICBnc2FwLmtpbGxUd2VlbnNPZihlbC5xdWVyeVNlbGVjdG9yKCcubGluaycpLCBlbC5xdWVyeVNlbGVjdG9yKCcuYmFja2dyb3VuZF9fYmcnKSk7XG4gICAgICAgIGdzYXAudG8oZWwucXVlcnlTZWxlY3RvcignLmxpbmsnKSwge1xuICAgICAgICAgIHNjYWxlOiAwLjksXG4gICAgICAgICAgZHVyYXRpb246IDIuNSxcbiAgICAgICAgICBlYXNlOiAnZXhwby5vdXQnXG4gICAgICAgIH0pO1xuICAgICAgICBnc2FwLnRvKGVsLnF1ZXJ5U2VsZWN0b3IoJy5iYWNrZ3JvdW5kX19iZycpLCB7XG4gICAgICAgICAgc2NhbGU6IDEsXG4gICAgICAgICAgZHVyYXRpb246IDIuNSxcbiAgICAgICAgICBlYXNlOiAnZXhwby5vdXQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZWF2ZUNhcmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlYXZlQ2FyZHMoYSwgZSwgZWwpIHtcbiAgICAgIGlmIChlbC5xdWVyeVNlbGVjdG9yKCcubGluaycpKSB7XG4gICAgICAgIGdzYXAua2lsbFR3ZWVuc09mKGVsLnF1ZXJ5U2VsZWN0b3IoJy5saW5rJyksIGVsLnF1ZXJ5U2VsZWN0b3IoJy5iYWNrZ3JvdW5kX19iZycpKTtcbiAgICAgICAgZ3NhcC50byhlbC5xdWVyeVNlbGVjdG9yKCcubGluaycpLCB7XG4gICAgICAgICAgc2NhbGU6IDEsXG4gICAgICAgICAgZHVyYXRpb246IDIuNSxcbiAgICAgICAgICBlYXNlOiAnZXhwby5vdXQnXG4gICAgICAgIH0pO1xuICAgICAgICBnc2FwLnRvKGVsLnF1ZXJ5U2VsZWN0b3IoJy5iYWNrZ3JvdW5kX19iZycpLCB7XG4gICAgICAgICAgc2NhbGU6IDEuMSxcbiAgICAgICAgICBkdXJhdGlvbjogMi41LFxuICAgICAgICAgIGVhc2U6ICdleHBvLm91dCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5Gb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5Gb3JtKCkge1xuICAgICAgdmFyIF90aGlzMTkgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5mb3JtLmlzQW5pbWF0aW5nKSByZXR1cm47XG4gICAgICB0aGlzLmZvcm0uaXNBbmltYXRpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5hcHBVaS5jbG9zZU1lbnVPcGFjaXR5KCk7IC8vIEFuaW1hdGUgaW5cblxuICAgICAgZ3NhcC5zZXQodGhpcy5hcHBVaS4kaGVhZGVyLCB7XG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIGdzYXAuc2V0KFt0aGlzLmFwcFVpLiR0cmlnZ2VyLCB0aGlzLmFwcFVpLiRyZXF1ZXN0QnV0dG9uXSwge1xuICAgICAgICBvcGFjaXR5OiAwLjAwMDFcbiAgICAgIH0pO2Vsc2UgZ3NhcC5zZXQodGhpcy5hcHBVaS4kdHJpZ2dlciwge1xuICAgICAgICBvcGFjaXR5OiAwLjAwMDFcbiAgICAgIH0pO1xuICAgICAgZ3NhcC5zZXQodGhpcy4kaHVic3BvdCwge1xuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICB6SW5kZXg6IDk5OVxuICAgICAgfSk7XG4gICAgICBnc2FwLnRvKHRoaXMuJGh1YnNwb3RNYXNrLCB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGR1cmF0aW9uOiAwLjgsXG4gICAgICAgIGVhc2U6ICdwb3dlcjIub3V0J1xuICAgICAgfSk7XG4gICAgICBnc2FwLnRvKHRoaXMuJGh1YnNwb3RDb250ZW50LCB7XG4gICAgICAgIHNjYWxlWTogMSxcbiAgICAgICAgZHVyYXRpb246IDEsXG4gICAgICAgIGVhc2U6ICdleHBvLmluT3V0J1xuICAgICAgfSk7XG4gICAgICBnc2FwLnRvKHRoaXMuJGh1YnNwb3RDbG9zZXIsIHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgZHVyYXRpb246IDAuOCxcbiAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnLFxuICAgICAgICBkZWxheTogMVxuICAgICAgfSk7XG4gICAgICBnc2FwLnRvKHRoaXMuJGZvcm1zLCB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGR1cmF0aW9uOiAxLFxuICAgICAgICBlYXNlOiAncG93ZXIyLm91dCcsXG4gICAgICAgIGRlbGF5OiAxXG4gICAgICB9KTsgLy8gQmxvY2sgc2Nyb2xsXG5cbiAgICAgIGlmICh0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkgdGhpcy5hcHBTdG9yZS5jdXJyZW50U2VjdGlvbi5zdXBlclNjcm9sbGVyLl9zY3JvbGwuZW5hYmxlID0gZmFsc2U7ZWxzZSB0aGlzLmFwcFVpLmRpc2FibGVTY3JvbGwoKTtcbiAgICAgIHRoaXMuZG9tRXZlbnRzLmFkZCh0aGlzLiRodWJzcG90Q2xvc2VyLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMTkuY2xvc2VGb3JtKCk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkgdGhpcy5kb21FdmVudHMuYWRkKHRoaXMuJGh1YnNwb3RNYXNrLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMTkuY2xvc2VGb3JtKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VGb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlRm9ybSgpIHtcbiAgICAgIHZhciBfdGhpczIwID0gdGhpcztcblxuICAgICAgLy8gQW5pbWF0ZSBvdXRcbiAgICAgIGdzYXAudG8odGhpcy4kaHVic3BvdE1hc2ssIHtcbiAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICBkdXJhdGlvbjogMC40LFxuICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgIH0pO1xuICAgICAgZ3NhcC50byh0aGlzLiRodWJzcG90Q2xvc2VyLCB7XG4gICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgZHVyYXRpb246IDAuNixcbiAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnXG4gICAgICB9KTtcbiAgICAgIGdzYXAudG8odGhpcy4kZm9ybXMsIHtcbiAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICBkdXJhdGlvbjogMC42LFxuICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSBnc2FwLnNldChbdGhpcy5hcHBVaS4kdHJpZ2dlciwgdGhpcy5hcHBVaS4kcmVxdWVzdEJ1dHRvbl0sIHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgZGVsYXk6IDAuNlxuICAgICAgfSk7ZWxzZSBnc2FwLnNldCh0aGlzLmFwcFVpLiR0cmlnZ2VyLCB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGRlbGF5OiAwLjZcbiAgICAgIH0pO1xuICAgICAgZ3NhcC50byh0aGlzLiRodWJzcG90Q29udGVudCwge1xuICAgICAgICBzY2FsZVk6IDAsXG4gICAgICAgIGR1cmF0aW9uOiAwLjYsXG4gICAgICAgIGVhc2U6ICdleHBvLmluT3V0JyxcbiAgICAgICAgZGVsYXk6IDAuMSxcbiAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyMC5hcHBTdG9yZS5pc0Rlc2t0b3ApIF90aGlzMjAuYXBwU3RvcmUuY3VycmVudFNlY3Rpb24uc3VwZXJTY3JvbGxlci5fc2Nyb2xsLmVuYWJsZSA9IHRydWU7ZWxzZSBfdGhpczIwLmFwcFVpLmVuYWJsZVNjcm9sbCgpO1xuICAgICAgICAgIGdzYXAuc2V0KF90aGlzMjAuYXBwVWkuJGhlYWRlciwge1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ2luaXRpYWwnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZ3NhcC5zZXQoX3RoaXMyMC5hcHBVaS4kbWVudSwge1xuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGdzYXAuc2V0KF90aGlzMjAuJGh1YnNwb3QsIHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgICAgICAgIHpJbmRleDogMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczIwLiRodWJzcG90Rm9ybS5kYXRhc2V0LmlkO1xuICAgICAgICAgIF90aGlzMjAuZm9ybS5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhZigpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICB9LCB7XG4gICAga2V5OiBcImJlZm9yZVJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmVSZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgaWYgKHRoaXMuc3VwZXJTY3JvbGxlcikgdGhpcy5zdXBlclNjcm9sbGVyLnJlc2l6ZSgpO1xuICAgICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUod2lkdGgsIGhlaWdodCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW50ZXIoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgfSwge1xuICAgIGtleTogXCJvbkxlYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTGVhdmUoKSB7XG4gICAgICB0aGlzLmxlYXZlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlYXZlKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwib25MZWF2ZUNvbXBsZXRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkxlYXZlQ29tcGxldGVkKCkge1xuICAgICAgdGhpcy5hZnRlckxlYXZlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFmdGVyTGVhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWZ0ZXJMZWF2ZSgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy4kZm9ybXNbaV0ucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRvbUV2ZW50cykgdGhpcy5kb21FdmVudHMuZGVzdHJveSgpO1xuICAgICAgaWYgKHRoaXMuc3VwZXJTY3JvbGxlcikgdGhpcy5zdXBlclNjcm9sbGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVuZGVyZXI7XG59KEhpZ2h3YXkuUmVuZGVyZXIpOyAvLyBEb24ndCBmb3JnZXQgdG8gZXhwb3J0IHlvdXIgcmVuZGVyZXJcblxuXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJlcjsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vLyBHU0FQIExpYnJhcnlcbmltcG9ydCBnc2FwIGZyb20gJ2dzYXAnO1xuaW1wb3J0IFNjcm9sbFRyaWdnZXIgZnJvbSAnZ3NhcC9TY3JvbGxUcmlnZ2VyJztcbmdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVHJpZ2dlcik7IC8vIEltcG9ydCBSZW5kZXJlclxuXG5pbXBvcnQgUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlci5qcyc7IC8vIFV0aWxpdGllc1xuXG5pbXBvcnQgRG9tRXZlbnRzIGZyb20gJy4uL2NsYXNzZXMvZG9tRXZlbnRzJztcbmltcG9ydCBTdXBlclNjcm9sbGVyIGZyb20gJy4uL2NsYXNzZXMvc3VwZXJTY3JvbGxlcic7XG5cbnZhciBSZW5kZXJlckRlZmF1bHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZW5kZXJlcikge1xuICBfaW5oZXJpdHMoUmVuZGVyZXJEZWZhdWx0LCBfUmVuZGVyZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUmVuZGVyZXJEZWZhdWx0KTtcblxuICBmdW5jdGlvbiBSZW5kZXJlckRlZmF1bHQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbmRlcmVyRGVmYXVsdCk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVuZGVyZXJEZWZhdWx0LCBbe1xuICAgIGtleTogXCJzZWxlY3RvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0b3JzKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2ZW50cygpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICB9LCB7XG4gICAga2V5OiBcInByZWxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICAgIC8vIHRoaXMucHJlbG9hZERlbGF5ID0gMTtcbiAgICAgIHRoaXMucHJlbG9hZEl0ZW1zID0ge1xuICAgICAgICBtYWluOiBbXSxcbiAgICAgICAgc2Vjb25kYXJ5OiBbXVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmVmb3JlRW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlRW50ZXIoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgfSwge1xuICAgIGtleTogXCJlbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbnRlcigpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICB9LCB7XG4gICAga2V5OiBcInJhZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYWYoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKHdpZHRoLCBoZWlnaHQpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICB9XSk7XG5cbiAgcmV0dXJuIFJlbmRlcmVyRGVmYXVsdDtcbn0oUmVuZGVyZXIpOyAvLyBEb24ndCBmb3JnZXQgdG8gZXhwb3J0IHlvdXIgcmVuZGVyZXJcblxuXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJlckRlZmF1bHQ7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vL2ltcG9ydCAqIGFzIFRIUkVFIGZyb20gXCJ0aHJlZVwiXG4vL2ltcG9ydCBnc2FwIGZyb20gXCJnc2FwXCJcbi8vaW1wb3J0IHtHTFRGTG9hZGVyLCBHTFRMb2FkZXJ9IGZyb20gXCJ0aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9HTFRGTG9hZGVyXCJcbnZhciBXZWJHTFV0aWxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV2ViR0xVdGlscygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViR0xVdGlscyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV2ViR0xVdGlscywgbnVsbCwgW3tcbiAgICBrZXk6IFwiY2xhbXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xhbXAobnVtLCBtaW4sIG1heCkge1xuICAgICAgLy8gR2l2ZW4gYSBudW0geSByZXR1cm4gdGhlIG51bSBidXQgbWFraW5nIHN1cmUgaXRzIGJldHdlZW4gbWluIGFuZCBtYXguXG4gICAgICAvLyBJZiBpdHMgYmVsb3cgbWluIGl0IHdpbGwgZXF1YWwgdG8gbWluXG4gICAgICAvLyBJZiBpdHMgYWJvdmUgbWF4IGl0IHdpbGwgZXF1YWwgbWF4XG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobnVtLCBtaW4pLCBtYXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZXJwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlcnAoeCwgeSwgYSkge1xuICAgICAgLy9BIGxlcnAgcmV0dXJucyB0aGUgdmFsdWUgYmV0d2VlbiB0d28gbnVtYmVycyBhdCBhIHNwZWNpZmllZCwgZGVjaW1hbCBtaWRwb2ludDpcbiAgICAgIC8vIEZ1bmNpb25hIGNvbW8gbWl4IGRlIGdsc2xcbiAgICAgIC8vIGxlcnAoMjAsIDgwLCAwKSAgIC8vIDIwXG4gICAgICAvLyBsZXJwKDIwLCA4MCwgMSkgICAvLyA4MFxuICAgICAgLy8gbGVycCgyMCwgODAsIDAuNSkgLy8gNDBcbiAgICAgIHJldHVybiB4ICogKDEgLSBhKSArIHkgKiBhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZsZXJwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmxlcnAoeCwgeSwgYSkge1xuICAgICAgLy8gV29ya3MgaW4gdGhlIG9wcG9zaXRlIHdheSB0byB0aGUgbGVycC4gSW5zdGVhZCBvZiBwYXNzaW5nIGEgZGVjaW1hbCBtaWRwb2ludCwgeW91IHBhc3MgYW55IHZhbHVlLFxuICAgICAgLy8gYW5kIGl04oCZbGwgcmV0dXJuIHRoYXQgZGVjaW1hbCwgd2hlcmV2ZXIgaXQgZmFsbHMgb24gdGhhdCBzcGVjdHJ1bS4gSW50ZXJuYWxseSBpdCBhbHNvIHVzZXMgYSBjbGFtcCxcbiAgICAgIC8vIHNvIHlvdSBuZXZlciBnZXQgdW53aWVsZHkgdmFsdWVzIGJhY2suXG4gICAgICAvLyBpbnZsZXJwKDUwLCAxMDAsIDc1KSAgLy8gMC41XG4gICAgICAvLyBpbnZsZXJwKDUwLCAxMDAsIDI1KSAgLy8gMFxuICAgICAgLy8gaW52bGVycCg1MCwgMTAwLCAxMjUpIC8vIDFcbiAgICAgIHJldHVybiB0aGlzLmNsYW1wKChhIC0geCkgLyAoeSAtIHgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmFuZ2UoeDEsIHkxLCB4MiwgeTIsIGEpIHtcbiAgICAgIC8vIFRoaXMgZmluYWwgbWV0aG9kIGlzIGFjZS4gSXTigJlzIGEgb25lLWxpbmVyIHRoYXQgY29udmVydHMgYSB2YWx1ZSBmcm9tIG9uZSBkYXRhIHJhbmdlIHRvIGFub3RoZXIuXG4gICAgICAvLyBUaGF0IG1pZ2h0IHNvdW5kIGEgYml0IGFyYml0cmFyeSwgYnV0IGl04oCZcyBzdXJwcmlzaW5nbHkgdXNlZnVsLlxuICAgICAgLy8gV2UgcGFzcyBpbiB0d28gZGF0YSByYW5nZXMgYW5kIGEgdmFsdWUgdGhhdCBzaXRzIHdpdGhpbiBkYXRhIHJhbmdlIG9uZSAoaXQgd2lsbCBzdGlsbCBiZSBjbGFtcGVkKS5cbiAgICAgIC8vICAgIFJhbmdlIDEgICAgUmFuZ2UgMiAgICBWYWx1ZVxuICAgICAgLy9yYW5nZSgxMCwgMTAwLCAyMDAwLCAyMDAwMCwgNTApIC8vIDEwMDAwXG4gICAgICByZXR1cm4gdGhpcy5sZXJwKHgyLCB5MiwgdGhpcy5pbnZsZXJwKHgxLCB5MSwgYSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXZWJHTFV0aWxzO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBXZWJHTFV0aWxzOyIsImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhX3JhbmRvbW5lc3M7XFxuYXR0cmlidXRlIHZlYzMgYV9nZW8xX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfZ2VvMV9jb2xvcjtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9nZW8xX2FuZ3Vsb1JhZDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9nZW8xX29yYml0YWw7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9wb3Nfb3JiaXRhO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfaW5jcl9hbmd1bG9SYWQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9pbmNyO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfZGlyO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfcmFkaW87XFxuXFxudW5pZm9ybSBmbG9hdCB1Q2FtYXJhRGlzdGFuY2U7XFxudW5pZm9ybSBmbG9hdCB1VGltZTtcXG51bmlmb3JtIGZsb2F0IHVPcGVuUHJvZ3Jlc3M7XFxudW5pZm9ybSBmbG9hdCB1UmVzcG9uc2l2ZVNjYWxlO1xcblxcbnVuaWZvcm0gZmxvYXQgdVNjcm9sbERlbHRhO1xcbnVuaWZvcm0gZmxvYXQgdVJvdGF0aW9uMTtcXG51bmlmb3JtIGZsb2F0IHVSb3RhdGlvbjI7XFxudW5pZm9ybSBmbG9hdCB1Um90YXRpb24zO1xcblxcbnVuaWZvcm0gZmxvYXQgdUludHJvUHJvZ3Jlc3MxO1xcbnVuaWZvcm0gZmxvYXQgdUludHJvUHJvZ3Jlc3MyO1xcbnVuaWZvcm0gZmxvYXQgdUludHJvUHJvZ3Jlc3MzO1xcblxcbnVuaWZvcm0gZmxvYXQgdVpvb21PdXRQcm9ncmVzczE7XFxudW5pZm9ybSBmbG9hdCB1Wm9vbU91dFByb2dyZXNzMjtcXG51bmlmb3JtIGZsb2F0IHVab29tT3V0UHJvZ3Jlc3MzO1xcblxcbnVuaWZvcm0gZmxvYXQgdVZpZGVvWU9mZnNldDtcXG5cXG51bmlmb3JtIGZsb2F0IHVab29taW5nUHJvZ3Jlc3M7XFxuXFxudW5pZm9ybSBmbG9hdCB1SGVpZ2h0O1xcbi8vdW5pZm9ybSBmbG9hdCB1U2NhbGU7XFxuXFxudmFyeWluZyB2ZWMzIHZfY29sb3I7XFxudmFyeWluZyBmbG9hdCB2X3B1bHNlU3RyZW5ndGhOb3JtMTtcXG52YXJ5aW5nIGZsb2F0IHZfcHVsc2VTdHJlbmd0aE5vcm0yO1xcblxcbi8vXFx0Q2xhc3NpYyBQZXJsaW4gM0QgTm9pc2UgXFxuLy9cXHRieSBTdGVmYW4gR3VzdGF2c29uXFxuLy9cXG5cXG4jZGVmaW5lIFBJIDMuMTQxNTkyNjUzOFxcbi8vI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTVcXG5cXG52ZWMzIGdldF9wb3MxKGZsb2F0IGFuZ3Vsb1JhZCl7XFxuICAgIC8vZmxvYXQgYW5ndWxvUmFkID0gYV9nZW8xX3Bvc19vcmJpdGEqYV9nZW8xX2luY3JfYW5ndWxvUmFkKygoYV9nZW8xX2luY3JfYW5ndWxvUmFkLzIuKSphX2dlbzFfaW5jcikrKDEuKmFfZ2VvMV9kaXIqMC4yKTtcXG4gICAgZmxvYXQgeCA9IGNvcyhhbmd1bG9SYWQpKmFfZ2VvMV9yYWRpbztcXG4gICAgZmxvYXQgeSA9IHNpbihhbmd1bG9SYWQpKmFfZ2VvMV9yYWRpbztcXG4gICAgZmxvYXQgeiA9IDAuMDtcXG4gICAgdmVjMyBuZXdQb3MgPSB2ZWMzKHgsIHksIHopO1xcbiAgICByZXR1cm4gbmV3UG9zO1xcbn1cXG5cXG5mbG9hdCBnZXRfb3BlblNjYWxlKCl7XFxuICAgIHJldHVybiBtaXgoMS4sIDguLCB1T3BlblByb2dyZXNzKTtcXG59XFxuXFxudmVjMyBnZXRfb3BlbkZ4KCB2ZWMzIHBvcyl7XFxuICAgIC8vZmxvYXQgb3BlblNjYWxlID0gbWl4KDEuLCA4LiwgdU9wZW5Qcm9ncmVzcyk7XFxuICAgIHZlYzMgcG9zRnggPSBwb3MqZ2V0X29wZW5TY2FsZSgpO1xcbiAgICByZXR1cm4gcG9zRng7XFxufVxcblxcbmZsb2F0IGdldF9jb3NUaW1lKGZsb2F0IHRpbWUsIGZsb2F0IHJhZGl1cyl7XFxuICAgIC8vXFxuICAgIC8vZmxvYXQgdmFsdWUgPSBzaW4odVRpbWUpKjIuKlBJO1xcbiAgICBmbG9hdCB2YWx1ZSA9IHNpbih0aW1lKSpyYWRpdXM7XFxuICAgIHJldHVybiB2YWx1ZTtcXG59XFxuXFxuZmxvYXQgZ2V0X3goZmxvYXQgYW5nbGVSYWQsIGZsb2F0IHJhZGl1cyl7XFxuICAgIHJldHVybiBjb3MoYW5nbGVSYWQpKmFfZ2VvMV9yYWRpbztcXG59XFxuXFxuZmxvYXQgZ2V0X3B1bHNlU3RyZW5ndGhOb3JtKCBmbG9hdCBkaXJlY3Rpb24pe1xcbiAgICBmbG9hdCBkb3RBZ3VsZU5vcm0gPSBhX2dlbzFfYW5ndWxvUmFkLygyLipQSSk7IC8vIFBhc2Ftb3MgZWwgYW5ndWxvIGRlbCBwdW50byBxdWUgZXN0w6EgZW4gcmFkaWFuZXMgYSB1biB2YWxvciBkZSAwIGEgMS5cXG5cXG4gICAgZmxvYXQgbW9kU3BlZWQgPSBtaXgoMS4sIDIuNSwgMTMuL2FfZ2VvMV9vcmJpdGFsKSpkaXJlY3Rpb247XFxuICAgIGZsb2F0IHJhZGlhbFNwZWVkID0gdVRpbWUqMC4wMiptb2RTcGVlZDsgLy8gTW9kaWZpY2Ftb3MgdVRpbWUgcGFyYSBkZXRlcm1pbmFyIGxhIHZlbG9jaWRhZCByYWRpYWwuXFxuXFxuICAgIGZsb2F0IHB1bHNlQW5nbGVSYWQgPSByYWRpYWxTcGVlZCooNC4qUEkpO1xcblxcbiAgICAvLyBFbCB2YWxvciBkZSBwdWxzZUFuZ2xlUmFkIGRlYmUgZXN0YXIgZW50cmUgMCB5IDJQSSAoaW5pY2lvIHkgZmluIGRlIHVuYSBjaXJjdW5mZXJlbmNpYSkuXFxuICAgIC8vIENvbW8gZGVwZW5kZSBkZSB1VGltZSBlbCB2YWxvciBzYWxkcsOhIGRlIGVzZSByYW5nbyBwcm9udG8gcG9yIGxvIHF1ZSB0b21hcmVtb3MgZWwgcmVzdG8gKG1vZHVsbyksXFxuICAgIC8vIGRlIGRpdmlkaXIgcHVsc2VBbmdsZVJhZCBwb3IgMlBJLlxcbiAgICBpZihwdWxzZUFuZ2xlUmFkID4gMi4qUEkpe1xcbiAgICAgICAgcHVsc2VBbmdsZVJhZCA9IG1vZChwdWxzZUFuZ2xlUmFkLCAoMi4qUEkpKTtcXG4gICAgfVxcbiAgICBpZihwdWxzZUFuZ2xlUmFkIDwgMC4pe1xcbiAgICAgICAgcHVsc2VBbmdsZVJhZCA9IG1vZChwdWxzZUFuZ2xlUmFkLCAoMi4qUEkpKTtcXG4gICAgfVxcblxcbiAgICBmbG9hdCBwdWxzZUFuZ2xlTm9ybSA9IHB1bHNlQW5nbGVSYWQvKDIuKlBJKTsgLy8gTm9ybWFsaXphbW9zIGVsIHZhbG9yIChkZSAwIGEgMSlcXG5cXG4gICAgZmxvYXQgZGlzdEFuZ2xlTm9ybSA9IGFicyhwdWxzZUFuZ2xlTm9ybS1kb3RBZ3VsZU5vcm0pOyAvLyBDYWxjdWxhbW9zIGxhIGRpc3RhbmNpYSByYWRpYWwgZGVsIHB1bHNvIGFsIHB1bnRvXFxuXFxuICAgIC8vIEFwYcOxYW1vcyBsYSBkaXN0YW5jaWEgZGUgdGFsIGZvcm1hIHF1ZSBubyBsZSBhZmVjdGUgZWwgcHVudG8gZGUgZGlzY29udGludWlkYWQgT1BJID0gMlBJXFxuICAgIGlmKGRpc3RBbmdsZU5vcm0gPiAwLjUpeyBcXG4gICAgICAgIGRpc3RBbmdsZU5vcm0gPSAwLjUtKGRpc3RBbmdsZU5vcm0tMC41KTtcXG4gICAgfVxcblxcbiAgICAvLyBMYSBtYXhpbWEgZGlzdGFuY2lhIGVzIGRlIG1lZGlvIGNpcmN1bG8geSBlbiB0ZXJtaW5vcyBub3JtYWxpemFkb3MgZXMgMC41XFxuICAgIC8vIENyZWFtb3MgdW5hIHZhcmlhYmxlIHF1ZSBub3JtYWxpY2UgZXNlIHZhbG9yIGVudHJlIDAgeSAxLlxcbiAgICBmbG9hdCBwdWxzZVN0cmVuZ3RoTm9ybSAgPSBkaXN0QW5nbGVOb3JtKjIuOyBcXG5cXG4gICAgZmxvYXQgcGljbyA9IDAuOTI7XFxuICAgIHBpY28gPSBtaXgocGljbyowLjk5LCBwaWNvKjEuMDEsIGFfZ2VvMV9vcmJpdGFsLzEzLik7XFxuXFxuICAgIC8vIE5vcyBpbnRlcmVzYSBzb2xvIGVsIHBpY28sIGxhIHpvbmEgcXVlIHZhIGVudHJlIDAuOTUgeSAxLlxcbiAgICAvLyBUb29kbyBsbyBxdWUgaGF5YSBwb3IgZGViYWpvIGRlIDAuOTUgbG8gcGFzYW1vcyBhIDAuOTVcXG4gICAgLy8geSBsZSByZXN0YW1vcyBlc2UgbWlzbW8gMC45NSBwYXJhIHF1ZWRhcm5vcyBjb24gZWwgcGljbyBkZSAwLjA1IGVvbCBjdWFsIGFtcGxpZmljYW1vcyB4MjAgcGFyYSBub3JtYWxpemFybG8gKGRlIDAgYSAxKS5cXG4gICAgcHVsc2VTdHJlbmd0aE5vcm0gPSAoY2xhbXAocHVsc2VTdHJlbmd0aE5vcm0sIHBpY28sIDEuKS1waWNvKSoxMC47XFxuICAgIC8vLS1cXG4gICAgcmV0dXJuIHB1bHNlU3RyZW5ndGhOb3JtO1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIC8vIFNPUlRJTkc6XFxuICAgIGZsb2F0IGFuZ3Vsb1JhZF90aW1lID0gYV9nZW8xX2FuZ3Vsb1JhZDtcXG4gICAgZmxvYXQgaW50cm9Qcm9ncmVzcztcXG4gICAgZmxvYXQgem9vbU91dFByb2dyZXNzO1xcblxcbiAgICBpZihhYnMoYV9nZW8xX29yYml0YWwtOS4pIDwgMC41KXsgLy8gRGV0ZWN0YSBlbCBvcmJpdGFsIDlcXG4gICAgICAgIGFuZ3Vsb1JhZF90aW1lID0gYV9nZW8xX2FuZ3Vsb1JhZCt1Um90YXRpb24xO1xcbiAgICAgICAgaW50cm9Qcm9ncmVzcyA9IG1peCgyLiwgMC4zLCB1SW50cm9Qcm9ncmVzczEpOyBcXG4gICAgICAgIHpvb21PdXRQcm9ncmVzcyA9IHVab29tT3V0UHJvZ3Jlc3MxO1xcblxcbiAgICB9ZWxzZSBpZihhYnMoYV9nZW8xX29yYml0YWwtMTMuKSA8IDAuNSl7IC8vIERldGVjdGEgZWwgb3JiaXRhbCAxM1xcbiAgICAgICAgYW5ndWxvUmFkX3RpbWUgPSBhX2dlbzFfYW5ndWxvUmFkK3VSb3RhdGlvbjI7XFxuICAgICAgICBpbnRyb1Byb2dyZXNzID0gbWl4KDIuLCAwLjUsIHVJbnRyb1Byb2dyZXNzMik7IFxcbiAgICAgICAgem9vbU91dFByb2dyZXNzID0gdVpvb21PdXRQcm9ncmVzczI7XFxuXFxuICAgIH1lbHNlIGlmKGFicyhhX2dlbzFfb3JiaXRhbC0xNy4pIDwgMC41KXsgLy8gRGV0ZWN0YSBlbCBvcmJpdGFsIDE3XFxuICAgICAgICBhbmd1bG9SYWRfdGltZSA9IGFfZ2VvMV9hbmd1bG9SYWQrdVJvdGF0aW9uMztcXG4gICAgICAgIGludHJvUHJvZ3Jlc3M9IG1peCgyLiwgMC44LCB1SW50cm9Qcm9ncmVzczMpOyBcXG4gICAgICAgIHpvb21PdXRQcm9ncmVzcyA9IHVab29tT3V0UHJvZ3Jlc3MzO1xcbiAgICB9XFxuXFxuICAgIGZsb2F0IHB1bHNlU3RyZW5ndGhOb3JtMSA9IGdldF9wdWxzZVN0cmVuZ3RoTm9ybSgxLjUpO1xcbiAgICBmbG9hdCBwdWxzZVN0cmVuZ3RoTm9ybTIgPSBnZXRfcHVsc2VTdHJlbmd0aE5vcm0oLTEuKTtcXG4gICAgXFxuXFxuICAgIC8vIERldGVybWluYW1vcyBlbCB0YW1hw7FvIGRlbCBwdW50byB0ZW5pZW5kbyB1biBtaW5pbW8gZGUgNSB5IGFtcGxpZmljYW5kbyBlbCBtYXhpbW8gcGFyYSBxdWUgdmlzdWFsbWVudGUgc2VhIGJvbml0b1xcbiAgICAvL2Zsb2F0IHNpemUgPSA1LisocHVsc2VTdHJlbmd0aE5vcm0qMTUuKmxvbmdQZXJpb2QpO1xcbiAgICBmbG9hdCBzaXplID0gMy47XFxuICAgIC8vc2l6ZSAqPSBjbGFtcChpbnRyb1Byb2dyZXNzLCA1LiwgMS41KTtcXG4gICAgc2l6ZSArPSAocHVsc2VTdHJlbmd0aE5vcm0xKjUuKTtcXG4gICAgc2l6ZSArPSAocHVsc2VTdHJlbmd0aE5vcm0yKjUuKTtcXG4gICAgc2l6ZSAqPSBtaXgoMS4sIDguLCB1T3BlblByb2dyZXNzKTtcXG5cXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyBQT1NJVElPTjpcXG4gICAgdmVjMyBwb3Nfb3JpZ2luYWwgPSBnZXRfcG9zMShhbmd1bG9SYWRfdGltZSk7XFxuICAgIHBvc19vcmlnaW5hbCAqPSB1UmVzcG9uc2l2ZVNjYWxlO1xcblxcbiAgICB2ZWMzIHBvc19maW5hbCA9IHBvc19vcmlnaW5hbDtcXG4gICAgcG9zX2ZpbmFsICo9IGludHJvUHJvZ3Jlc3M7XFxuICAgIHBvc19maW5hbCA9IG1peChwb3NfZmluYWwsIHBvc19vcmlnaW5hbCwgem9vbU91dFByb2dyZXNzKTtcXG5cXG4gICAgcG9zX2ZpbmFsICo9IG1peCgxLiwgOC4sIHVPcGVuUHJvZ3Jlc3MpO1xcblxcbiAgICBmbG9hdCB2aWRlb1lPZmZzZXQgPSB1VmlkZW9ZT2Zmc2V0O1xcbiAgICB2aWRlb1lPZmZzZXQgPSBjbGFtcCAodmlkZW9ZT2Zmc2V0LCAwLiwgYWJzKHZpZGVvWU9mZnNldCkpO1xcbiAgICBwb3NfZmluYWwueSAtPSB2aWRlb1lPZmZzZXQ7XFxuICAgIFxcblxcbiAgICB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NfZmluYWwsIDEuMCApOyAvLzwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uOyAvLzwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICBnbF9Qb2ludFNpemUgPSBzaXplKih1Q2FtYXJhRGlzdGFuY2UvLW12UG9zaXRpb24ueik7IC8vPC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIC8vIFZBUllJTkdTOlxcbiAgICB2X2NvbG9yID0gYV9nZW8xX2NvbG9yOyBcXG4gICAgdl9wdWxzZVN0cmVuZ3RoTm9ybTEgPSBwdWxzZVN0cmVuZ3RoTm9ybTE7IFxcbiAgICB2X3B1bHNlU3RyZW5ndGhOb3JtMiA9IHB1bHNlU3RyZW5ndGhOb3JtMjsgXFxuXFxufVxcblxcblwiOyIsImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzMgdl9jb2xvcjtcXG52YXJ5aW5nIGZsb2F0IHZfcHVsc2VTdHJlbmd0aE5vcm0xO1xcbnZhcnlpbmcgZmxvYXQgdl9wdWxzZVN0cmVuZ3RoTm9ybTI7XFxuXFxuZmxvYXQgY2lyY3VsaXphcihmbG9hdCByYWRpbyl7XFxuICAgIC8vIHJhZGlvIGVzIHVuIHZhbG9yIGVudHJlIDAgeSAxLiAwIGVzIDAgZGUgcmFkaW8geSAxIGVzIGVsIG1heGltbyBkZWwgcmFkaW8gZGVudHJvIGRlXFxuICAgIHJhZGlvID0gMS4wLSgwLjUqcmFkaW8pO1xcbiAgICBmbG9hdCByZXN1bHQgPSBkaXN0YW5jZShnbF9Qb2ludENvb3JkLCB2ZWMyKDAuNSwgMC41KSk7XFxuICAgIHJlc3VsdCA9IDEuIC1yZXN1bHQ7XFxuICAgIHJlc3VsdCA9IHBvdyhyZXN1bHQsIDEuKTtcXG4gICAgcmVzdWx0ID0gc3RlcChyYWRpbywgcmVzdWx0KTtcXG4gICAgcmV0dXJuIHJlc3VsdDtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWMzIHdoaXRlID0gdmVjMygxLiwgMS4sIDEuKTtcXG4gICAgZmxvYXQgcHVsc2UgPSB2X3B1bHNlU3RyZW5ndGhOb3JtMSt2X3B1bHNlU3RyZW5ndGhOb3JtMjtcXG4gICAgcHVsc2UgPSBjbGFtcChwdWxzZSwgMC4sIDEuKTtcXG4gICAgdmVjMyBmaW5hbENvbG9yID0gdl9jb2xvcjtcXG4gICAgLy9maW5hbENvbG9yID0gbWl4KGZpbmFsQ29sb3IsIHdoaXRlLCBwdWxzZSo1Lik7XFxuICAgIC8vZmluYWxDb2xvciA9IG1peChmaW5hbENvbG9yLCB3aGl0ZSwgMC4pO1xcbiAgICBmbG9hdCBhbHBoYSA9IGNpcmN1bGl6YXIoMS4wKTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChmaW5hbENvbG9yLCBhbHBoYSowLjgpO1xcbn1cIjsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8vaW1wb3J0ICogYXMgVEhSRUUgZnJvbSBcInRocmVlXCJcbmltcG9ydCBnc2FwIGZyb20gXCJnc2FwXCI7XG5pbXBvcnQgRWFzaW5nIGZyb20gJ2Vhc2luZy1mdW5jdGlvbnMnO1xuXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbnZhciBFdmVudFByb2dyZXNzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRQcm9ncmVzcyhpZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudFByb2dyZXNzKTtcblxuICAgIC8vY29uc29sZS5sb2coXCIoRXZlbnRQcm9ncmVzcy5DT05TVFJVQ1RPUkEpISBcIilcbiAgICB0aGlzLmR1cmF0aW9uU2VjO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmVhc2luZ0Z1bmMgPSBudWxsO1xuICAgIHRoaXMucHJvY2Vzc1RpbWVTZWMgPSBudWxsO1xuICAgIHRoaXMucmVmVGltZVNlYyA9IG51bGw7IC8vIFNlY3MgZGUgcmVmZXJlbmNpYSBkZWwgcmVqb2YgZGUgZ3NhcCBjdWFuZG8gZW1waWV6YSBlbCBzdGFydFxuICAgIC8vLS1cblxuICAgIHRoaXMuc3RhcnRpbmdfdCA9IDA7IC8vIHQgZGUgcmVmZXJlbmNpYSBkZSBpbmljaW8uXG5cbiAgICB0aGlzLnQgPSAwOyAvLyBFbiB1biB2YWxvciBxdWUgcHJvZ3Jlc2EgbGluZWFsbWVudGUgZGUgMCBhIDEuXG5cbiAgICB0aGlzLnJhbmdlX3QgPSAwOyAvLyBFZSBlbCByYW5nbyBzb2JyZSBlbCBxdWUgcHJvZ3Jlc2Fyw6EgdCBxdWl0YW5kbyBzdSBzdGFydGluZyBwb2ludC5cbiAgICAvLy0tXG4gICAgLy90aGlzLnByb2Nlc3MgPSAwIC8vIEVzIHVuIHZhbG9yIHF1ZSB0cmFkdWNlIGxhIHByb2dyZXNpw7NuIGxpbmVhbCBkZSB0IGEgdW4gcHJvZ3Jlc2nDs24gZWFzb25nIGVuIGZ1bmNpw7NuIGRlIHRoaXMuZWFzaW5nRnVuYyBcbiAgICAvLy0tXG5cbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTsgLy8tLVxuXG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IGV2ZW50cy5FdmVudEVtaXR0ZXIoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFdmVudFByb2dyZXNzLCBbe1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydChkdXJhdGlvblNlYywgc3RhcnRpbmdfdCwgZWFzaW5nRnVuYywgcGF1c2VTZWMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vY29uc29sZS5sb2coXCIoRXZlbnRQcm9ncmVzcy5zdGFydCkoXCIrdGhpcy5pZCtcIikgZHVyYXRpb25TZWM6IFwiK2R1cmF0aW9uU2VjK1wiIHN0YXJ0aW5nX3Q6IFwiK3N0YXJ0aW5nX3QpXG4gICAgICBpZiAocGF1c2VTZWMgPT0gMCkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmR1cmF0aW9uU2VjID0gZHVyYXRpb25TZWM7XG4gICAgICAgIHRoaXMuZWFzaW5nRnVuYyA9IGVhc2luZ0Z1bmM7XG4gICAgICAgIHRoaXMuc3RhcnRpbmdfdCA9IHN0YXJ0aW5nX3Q7XG4gICAgICAgIHRoaXMudCA9IHN0YXJ0aW5nX3Q7XG4gICAgICAgIHRoaXMucmFuZ2VfdCA9IDEgLSB0aGlzLnN0YXJ0aW5nX3Q7XG4gICAgICAgIHRoaXMucmVmVGltZVNlYyA9IHRoaXMuX2dldF90aWNrZXJUaW1lKCk7IC8vLS1cblxuICAgICAgICBnc2FwLnRpY2tlci5yZW1vdmUodGhpcy5vblRpY2spO1xuICAgICAgICB0aGlzLm9uVGljayA9IHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICBnc2FwLnRpY2tlci5hZGQodGhpcy5vblRpY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3NhcC5kZWxheWVkQ2FsbChwYXVzZVNlYywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5zdGFydChkdXJhdGlvblNlYywgc3RhcnRpbmdfdCwgZWFzaW5nRnVuYywgMCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgZ3NhcC50aWNrZXIucmVtb3ZlKHRoaXMub25UaWNrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0X3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0X3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRfcHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0X3Byb2dyZXNzKCkge1xuICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFzaW5nRnVuYyh0aGlzLnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0X3RpY2tlclRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF90aWNrZXJUaW1lKCkge1xuICAgICAgcmV0dXJuIGdzYXAudGlja2VyLnRpbWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZSgpIHtcbiAgICAgIHZhciB0aWNrZXJUaW1lID0gdGhpcy5fZ2V0X3RpY2tlclRpbWUoKTtcblxuICAgICAgdGhpcy5wcm9jZXNzVGltZVNlYyA9IHRpY2tlclRpbWUgLSB0aGlzLnJlZlRpbWVTZWM7XG5cbiAgICAgIGlmICh0aGlzLnByb2Nlc3NUaW1lU2VjID49IHRoaXMuZHVyYXRpb25TZWMpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzVGltZVNlYyA9IHRoaXMuZHVyYXRpb25TZWM7XG4gICAgICAgIGdzYXAudGlja2VyLnJlbW92ZSh0aGlzLm9uVGljayk7IC8vLS1cbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIm9uUHJvZ3Jlc3NGaW5pc2hlZFwiKVxuXG4gICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KFwib25Qcm9ncmVzc0ZpbmlzaGVkXCIpO1xuICAgICAgfSAvL2NvbnNvbGUubG9nKFwic3RhcnRpbmdfdDogXCIrdGhpcy5zdGFydGluZ190KVxuICAgICAgLy8gY29uc29sZS5sb2coXCJ0aGlzLnByb2Nlc3NUaW1lU2VjL3RoaXMuZHVyYXRpb25TZWM6IFwiK3RoaXMucHJvY2Vzc1RpbWVTZWMvdGhpcy5kdXJhdGlvblNlYylcbiAgICAgIC8vY29uc29sZS5sb2coXCJ0aGlzLnJhbmdlX3Q6IFwiK3RoaXMucmFuZ2VfdClcblxuXG4gICAgICB0aGlzLnQgPSB0aGlzLnN0YXJ0aW5nX3QgKyB0aGlzLnByb2Nlc3NUaW1lU2VjIC8gdGhpcy5kdXJhdGlvblNlYyAqIHRoaXMucmFuZ2VfdDsgLy9jb25zb2xlLmxvZyhcInQ6IFwiK3RoaXMudClcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRXZlbnRQcm9ncmVzcztcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRQcm9ncmVzczsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBFYXNlZE91dFZhbHVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRWFzZWRPdXRWYWx1ZShfdmFsdWUsIF9mYWN0b3IpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWFzZWRPdXRWYWx1ZSk7XG5cbiAgICAvL2NvbnNvbGUubG9nKFwiKEVhc2VkT3V0VmFsdWUuQ09OU1RSVUNUT1JBKTogXCIrX3ZhbHVlKVxuICAgIHRoaXMudmFsdWUgPSBfdmFsdWU7XG4gICAgdGhpcy5mYWN0b3IgPSBfZmFjdG9yO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVhc2VkT3V0VmFsdWUsIFt7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQobmV3VmFsdWUpIHtcbiAgICAgIHZhciBmaWx0ZXJlZFZhbHVlID0gdGhpcy52YWx1ZSArIChuZXdWYWx1ZSAtIHRoaXMudmFsdWUpICogdGhpcy5mYWN0b3I7XG4gICAgICB0aGlzLnZhbHVlID0gZmlsdGVyZWRWYWx1ZTsgLy9jb25zb2xlLmxvZyhmaWx0ZXJlZFZhbHVlKVxuXG4gICAgICByZXR1cm4gZmlsdGVyZWRWYWx1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRWFzZWRPdXRWYWx1ZTtcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgRWFzZWRPdXRWYWx1ZTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vL2ltcG9ydCAqIGFzIFRIUkVFIGZyb20gXCJ0aHJlZVwiXG4vL2ltcG9ydCBnc2FwIGZyb20gXCJnc2FwXCJcbi8vaW1wb3J0IHtHTFRGTG9hZGVyLCBHTFRMb2FkZXJ9IGZyb20gXCJ0aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9HTFRGTG9hZGVyXCJcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcblxudmFyIEhvbWUxR2VvbWV0cnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKEhvbWUxR2VvbWV0cnksIF9FdmVudEVtaXR0ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoSG9tZTFHZW9tZXRyeSk7XG5cbiAgZnVuY3Rpb24gSG9tZTFHZW9tZXRyeShvYmopIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSG9tZTFHZW9tZXRyeSk7XG5cbiAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWUxR2VvbWV0cnkuQ09OU1RSVUNUT1JBKSFcIilcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpOyAvLy0tXG5cbiAgICBfdGhpcy5mYWN0b3IgPSBvYmouZmFjdG9yOyAvLzZcblxuICAgIF90aGlzLmluY3JfcmFkaW8gPSBvYmouaW5jcl9yYWRpbzsgLy8yNVxuXG4gICAgX3RoaXMubnVtT3JiaXRzID0gb2JqLm51bU9yYml0czsgLy8zN1xuXG4gICAgX3RoaXMuYXJyYXlfdHJpYW5ndWxhciA9IG9iai5hcnJheV90cmlhbmd1bGFyO1xuICAgIF90aGlzLmFycmF5X2RvdFBvcyA9IG9iai5hcnJheV9kb3RQb3M7XG4gICAgX3RoaXMubnVtRG90cyA9IG9iai5udW1Eb3RzOyAvLy0tXG5cbiAgICBfdGhpcy5hcnJheUNvbG9yZXNfUkdCID0gW107XG4gICAgX3RoaXMuYXJyYXlDb2xvcmVzX1JHQl8wMSA9IFtdO1xuICAgIF90aGlzLmNvbG9yUG9zID0gMDtcblxuICAgIF90aGlzLl9pbml0X2NvbG9ycygpOyAvLy0tXG5cblxuICAgIF90aGlzLmF0dHJpYnV0ZXMgPSB7XG4gICAgICBhX3Bvc2ljaW9uZXM6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDMpLFxuICAgICAgYV9jb2xvcjogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMyksXG4gICAgICBhX29yYml0YWw6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV9wb3Nfb3JiaXRhOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfaW5jcl9hbmd1bG9SYWQ6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV9hbmd1bG9SYWQ6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV9yYWRpbzogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX2RpcjogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX2luY3I6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV94OiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfeTogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX3o6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpXG4gICAgfTsgLy8tLVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5hcnJheV9kb3RQb3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb3RQb3MgPSBfdGhpcy5hcnJheV9kb3RQb3NbaV07XG5cbiAgICAgIHZhciBkb3QgPSBfdGhpcy5fZ2V0X2RvdChkb3RQb3MpO1xuXG4gICAgICB2YXIgaTMgPSBpICogMztcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9wb3NpY2lvbmVzW2kzXSA9IGRvdC54O1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXNbaTMgKyAxXSA9IGRvdC55O1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXNbaTMgKyAyXSA9IGRvdC56OyAvLy0tXG5cbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9jb2xvcltpM10gPSBkb3QuY29sb3JbMF07XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfY29sb3JbaTMgKyAxXSA9IGRvdC5jb2xvclsxXTtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9jb2xvcltpMyArIDJdID0gZG90LmNvbG9yWzJdOyAvLy0tXG5cbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9vcmJpdGFsW2ldID0gZG90Lm9yYml0YWw7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfcG9zX29yYml0YVtpXSA9IGRvdC5wb3Nfb3JiaXRhO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX2luY3JfYW5ndWxvUmFkW2ldID0gZG90LmluY3JfYW5ndWxvUmFkO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX2FuZ3Vsb1JhZFtpXSA9IGRvdC5hbmd1bG9SYWQ7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfcmFkaW9baV0gPSBkb3QucmFkaW87XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfZGlyW2ldID0gZG90LmRpcjtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9pbmNyW2ldID0gZG90LmluY3I7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfeFtpXSA9IGRvdC55O1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3lbaV0gPSBkb3QueTtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV96W2ldID0gZG90Lno7XG4gICAgfSAvLy0tXG5cblxuICAgIF90aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQUklWQURBU1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEhvbWUxR2VvbWV0cnksIFt7XG4gICAga2V5OiBcIl9nZXRfZG90XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfZG90KG51bSkge1xuICAgICAgLy8gRGV2dWVsdmUgdW4gb2JqZXRvIGNvbiBsYSBpbmZvcm1hY2nDs24gZGUgdW4gcHVudG8gZGUgbGEgZ2VvbWV0cmlhIFwib3JiaXRhbCBNSU9USVwiXG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICBudW06IG51bSxcbiAgICAgICAgY29sb3I6IHRoaXMuX2dldF9jb2xvcigpLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB6OiAwLFxuICAgICAgICBvcmJpdGFsOiAwLFxuICAgICAgICBjb19vcmJpdGFudGVzOiAwLFxuICAgICAgICBwb3Nfb3JiaXRhOiAwLFxuICAgICAgICBpbmNyX2FuZ3Vsb1JhZDogMCxcbiAgICAgICAgYW5ndWxvUmFkOiAwLFxuICAgICAgICByYWRpbzogMFxuICAgICAgfTsgLy8tLVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB0aGlzLmFycmF5X3RyaWFuZ3VsYXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbVN1cCA9IHRoaXMuYXJyYXlfdHJpYW5ndWxhcltpXTsgLy9jb25zb2xlLmxvZyhcImxpbVN1cDogXCIrbGltU3VwKVxuXG4gICAgICAgIGlmIChudW0gPiBsaW1TdXApIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIipcIilcbiAgICAgICAgICBvYmoub3JiaXRhbCA9IGkgKyAxO1xuICAgICAgICAgIG9iai5jb19vcmJpdGFudGVzID0gKGkgKyAxKSAqIHRoaXMuZmFjdG9yO1xuICAgICAgICAgIG9iai5wb3Nfb3JiaXRhID0gbnVtIC0gbGltU3VwIC0gMTtcbiAgICAgICAgICBvYmouaW5jcl9hbmd1bG9SYWQgPSAyICogTWF0aC5QSSAvIG9iai5jb19vcmJpdGFudGVzO1xuXG4gICAgICAgICAgaWYgKG9iai5vcmJpdGFsICUgMiA9PSAwKSB7XG4gICAgICAgICAgICBvYmouZGlyID0gMTtcbiAgICAgICAgICAgIG9iai5pbmNyID0gMDtcbiAgICAgICAgICAgIG9iai5hbmd1bG9SYWQgPSBvYmoucG9zX29yYml0YSAqIG9iai5pbmNyX2FuZ3Vsb1JhZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqLmRpciA9IC0xO1xuICAgICAgICAgICAgb2JqLmluY3IgPSAxO1xuICAgICAgICAgICAgb2JqLmFuZ3Vsb1JhZCA9IG9iai5wb3Nfb3JiaXRhICogb2JqLmluY3JfYW5ndWxvUmFkICsgb2JqLmluY3JfYW5ndWxvUmFkIC8gMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvYmoucmFkaW8gPSBvYmoub3JiaXRhbCAqIHRoaXMuaW5jcl9yYWRpbzsgLy8tLVxuXG4gICAgICAgICAgb2JqLnggPSBNYXRoLmNvcyhvYmouYW5ndWxvUmFkKSAqIG9iai5yYWRpbztcbiAgICAgICAgICBvYmoueSA9IE1hdGguc2luKG9iai5hbmd1bG9SYWQpICogb2JqLnJhZGlvO1xuICAgICAgICAgIG9iai56ID0gMDtcbiAgICAgICAgfSAvL2JyZWFrXG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldF9jb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0X2NvbG9yKCkge1xuICAgICAgdmFyIGNvbG9yX1JHQl8wMSA9IHRoaXMuYXJyYXlDb2xvcmVzX1JHQl8wMVt0aGlzLmNvbG9yUG9zXTtcbiAgICAgIHRoaXMuY29sb3JQb3MrKztcblxuICAgICAgaWYgKHRoaXMuY29sb3JQb3MgPiB0aGlzLmFycmF5Q29sb3Jlc19SR0JfMDEubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLmNvbG9yUG9zID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbG9yX1JHQl8wMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRfY29sb3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0X2NvbG9ycygpIHtcbiAgICAgIHRoaXMuYXJyYXlDb2xvcmVzX1JHQiA9IFtdO1xuICAgICAgdGhpcy5hcnJheUNvbG9yZXNfUkdCLnB1c2goWzI1NSwgODcsIDEzMV0pOyAvLyBSb3NhXG5cbiAgICAgIHRoaXMuYXJyYXlDb2xvcmVzX1JHQi5wdXNoKFs4OSwgMiwgMl0pO1xuICAgICAgdGhpcy5hcnJheUNvbG9yZXNfUkdCLnB1c2goWzEsIDMsIDQ5XSk7XG4gICAgICB0aGlzLmFycmF5Q29sb3Jlc19SR0IucHVzaChbMCwgMTYsIDExNl0pO1xuICAgICAgdGhpcy5hcnJheUNvbG9yZXNfUkdCLnB1c2goWzE0LCAxMzMsIDI1NV0pO1xuICAgICAgdGhpcy5hcnJheUNvbG9yZXNfUkdCXzAxID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcnJheUNvbG9yZXNfUkdCLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2xvcl9SR0IgPSB0aGlzLmFycmF5Q29sb3Jlc19SR0JbaV07XG4gICAgICAgIHZhciBjb2xvcl9SR0JfMDEgPSBbY29sb3JfUkdCWzBdIC8gMjU1LCBjb2xvcl9SR0JbMV0gLyAyNTUsIGNvbG9yX1JHQlsyXSAvIDI1NV07XG4gICAgICAgIHRoaXMuYXJyYXlDb2xvcmVzX1JHQl8wMS5wdXNoKGNvbG9yX1JHQl8wMSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhvbWUxR2VvbWV0cnk7XG59KEV2ZW50RW1pdHRlcik7XG5cbmV4cG9ydCBkZWZhdWx0IEhvbWUxR2VvbWV0cnk7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCBnc2FwIGZyb20gXCJnc2FwXCI7XG5pbXBvcnQgRWFzaW5nIGZyb20gJ2Vhc2luZy1mdW5jdGlvbnMnO1xuaW1wb3J0IHZlcnRleCBmcm9tIFwiLi9zaGFkZXJzL2hvbWUxX2RvdHNfdmVydGV4Lmdsc2xcIjtcbmltcG9ydCBmcmFnbWVudCBmcm9tIFwiLi9zaGFkZXJzL2hvbWUxX2RvdHNfZnJhZ21lbnQuZ2xzbFwiOyAvL2ltcG9ydCB2ZXJ0ZXhfYmcgZnJvbSBcIi4vc2hhZGVycy9ob21lMV9iYWNrZ3JvdW5kX3ZlcnRleC5nbHNsXCJcbi8vaW1wb3J0IGZyYWdtZW50X2JnIGZyb20gXCIuL3NoYWRlcnMvaG9tZTFfYmFja2dyb3VuZF9mcmFnbWVudC5nbHNsXCJcblxuaW1wb3J0IEV2ZW50UHJvZ3Jlc3MgZnJvbSBcIi4uL0V2ZW50UHJvZ3Jlc3NcIjtcbmltcG9ydCBFYXNlZE91dFZhbHVlIGZyb20gJy4uL0Vhc2VkT3V0VmFsdWUnO1xuaW1wb3J0IEhvbWUxR2VvbWV0cnkgZnJvbSAnLi9Ib21lMUdlb21ldHJ5JztcblxudmFyIEhvbWUxRG90cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEhvbWUxRG90cyhvYmopIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSG9tZTFEb3RzKTtcblxuICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTFEb3RzLkNPTlNUUlVDVE9SQSkhIVwiKVxuICAgIC8vY29uc29sZS5sb2cob2JqKVxuICAgIHRoaXMud29ybGRHTCA9IG9iai53b3JsZEdMOyAvLy0tXG4gICAgLy8tLVxuXG4gICAgdGhpcy5zY2VuZSA9IHRoaXMud29ybGRHTC5zY2VuZTtcbiAgICB0aGlzLmNhbWVyYURpc3RhbmNlID0gdGhpcy53b3JsZEdMLmNhbWVyYURpc3RhbmNlOyAvL2NvbnNvbGUubG9nKFwidGhpcy53b3JsZEdMLmNhbWVyYURpc3RhbmNlOiBcIit0aGlzLndvcmxkR0wuY2FtZXJhRGlzdGFuY2UpXG4gICAgLy8tLVxuXG4gICAgdGhpcy5tYXRlcmlhbCA9IG51bGw7XG4gICAgdGhpcy5nZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5tZXNoID0gbnVsbDtcbiAgICB0aGlzLm51bVBhcnRpY2xlcyA9IG51bGw7XG4gICAgdGhpcy5jcmVhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5jbG9jayA9IG5ldyBUSFJFRS5DbG9jaygpO1xuICAgIHRoaXMucm90YXRpb24gPSAwOyAvLy0tXG4gICAgLy90aGlzLmV2ZW50X2ludHJvX2MxID0gbmV3IEV2ZW50UHJvY2Vzcyh7ZHVyYXRpb25TZWM6IDJ9KVxuXG4gICAgdGhpcy5ldmVudF9pbnRyb19jMSA9IG5ldyBFdmVudFByb2dyZXNzKCk7XG4gICAgdGhpcy5ldmVudF9pbnRyb19jMiA9IG5ldyBFdmVudFByb2dyZXNzKCk7XG4gICAgdGhpcy5ldmVudF9pbnRyb19jMyA9IG5ldyBFdmVudFByb2dyZXNzKCk7XG4gICAgdGhpcy5ldmVudF96b29tb3V0X2MxID0gbmV3IEV2ZW50UHJvZ3Jlc3MoKTtcbiAgICB0aGlzLmV2ZW50X3pvb21vdXRfYzIgPSBuZXcgRXZlbnRQcm9ncmVzcygpO1xuICAgIHRoaXMuZXZlbnRfem9vbW91dF9jMyA9IG5ldyBFdmVudFByb2dyZXNzKCk7XG4gICAgdGhpcy5lYXNlZF9zY3JvbGxEZWx0YV9mYXN0ID0gbmV3IEVhc2VkT3V0VmFsdWUodGhpcy53b3JsZEdMLnNldHRpbmdzLnNjcm9sbF9ub3JtYWxpemVkRGVsdGEgKiAwLjUsIDAuMSk7IC8vLS1cblxuICAgIHRoaXMuX3NldHVwX3NldHRpbmdzKCk7IC8vdGhpcy5faW5pdF9zY3JvbGxMaXN0ZW5lcnMoKVxuICAgIC8vdGhpcy5fc2V0dXBfZ3VpKClcbiAgICAvLy0tXG5cblxuICAgIHRoaXMub3JiaXRhbF9nZW9tZXRyeSA9IG5ldyBIb21lMUdlb21ldHJ5KHRoaXMuc2V0dGluZ3MpOyAvLy0tXG4gICAgLy8tLVxuICAgIC8vdGhpcy5fY3JlYXRlY3ViZSh0aGlzLnNjZW5lKVxuXG4gICAgdGhpcy5fY3JlYXRlKCk7IC8vLS1cbiAgICAvLy0tXG4gICAgLy8gY29uc3QgYW5pbVRpbWVfaW50cm8gPSAxLjVcbiAgICAvLyBjb25zdCBhbmltVGltZV9hY2VsRGVjZWwgPSAyXG4gICAgLy8gY29uc3QgYW5pbVRpbWVfdW56b29tID0gMC45XG4gICAgLy9jb25zdCBlYXNlRnVuY19pbnRybyA9IEVhc2luZy5FeHBvbmVudGlhbC5PdXRcbiAgICAvL2NvbnN0IGluaXRpYWxfcGF1c2UgPSAwLjNcbiAgICAvL3RoaXMuZXZlbnRGYXNlID0gXCJpbnRyb1wiXG4gICAgLy90aGlzLmV2ZW50X2ludHJvX2MxLnN0YXJ0KDAuOSwgMCwgZWFzZUZ1bmNfaW50cm8sIGluaXRpYWxfcGF1c2UrMC4wKVxuICAgIC8vdGhpcy5ldmVudF9pbnRyb19jMi5zdGFydCgxLjEsIDAsIGVhc2VGdW5jX2ludHJvLCBpbml0aWFsX3BhdXNlKzAuMSlcbiAgICAvL3RoaXMuZXZlbnRfaW50cm9fYzMuc3RhcnQoMS4yLCAwLCBlYXNlRnVuY19pbnRybywgaW5pdGlhbF9wYXVzZSswLjIpICAgICAgICAvLy0tXG4gICAgLy9cbiAgICAvL2dzYXAuZGVsYXllZENhbGwoaW5pdGlhbF9wYXVzZSsxLjIsICgpPT57XG4gICAgLy8gICAgdGhpcy53b3JsZEdMLmh3X3JlbmRlcmVyLmluaXRFbnRlckFuaW1hdGlvbigpO1xuICAgIC8vICAgIHRoaXMuZG9fem9vbU91dCgpO1xuICAgIC8vfSlcblxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEhvbWUxRG90cywgW3tcbiAgICBrZXk6IFwiZG9fem9vbU91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb196b29tT3V0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy9jb25zb2xlLmxvZyhcIigoSG9tZTFEb3RzLmRvX3pvb21PdXQpIVwiKVxuICAgICAgdmFyIGVhc2VGdW5jX3pvb21vdXQgPSBFYXNpbmcuUXVhcnRpYy5Jbk91dDsgLy9jb25zdCBlYXNlRnVuY196b29tb3V0ID0gRWFzaW5nLkV4cG9uZW50aWFsLkluT3V0XG5cbiAgICAgIHRoaXMuZXZlbnRGYXNlID0gXCJ1bnpvb21cIjsgLy8tLVxuXG4gICAgICB0aGlzLmV2ZW50X3pvb21vdXRfYzEuc3RhcnQoMS40LCAwLCBlYXNlRnVuY196b29tb3V0LCAwKTtcbiAgICAgIHRoaXMuZXZlbnRfem9vbW91dF9jMi5zdGFydCgxLjUsIDAsIGVhc2VGdW5jX3pvb21vdXQsIDAuMSk7XG4gICAgICB0aGlzLmV2ZW50X3pvb21vdXRfYzMuc3RhcnQoMS44LCAwLCBlYXNlRnVuY196b29tb3V0LCAwLjIpOyAvLy0tXG5cbiAgICAgIHRoaXMuZXZlbnRfem9vbW91dF9jMy5lbWl0dGVyLm9uKFwib25Qcm9ncmVzc0ZpbmlzaGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuZXZlbnRGYXNlID0gXCJpbnRlcmFjdGl2ZVwiO1xuICAgICAgfSk7XG4gICAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFBVQkxJQ0FTOiBcblxuICB9LCB7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIihIb21lMURvdHMuaW5pdCkhXCIpO1xuICAgICAgdmFyIGVhc2VGdW5jX2ludHJvID0gRWFzaW5nLkV4cG9uZW50aWFsLk91dDtcbiAgICAgIHZhciBpbml0aWFsX3BhdXNlID0gMDtcbiAgICAgIHRoaXMuZXZlbnRGYXNlID0gXCJpbnRyb1wiO1xuICAgICAgdGhpcy5ldmVudF9pbnRyb19jMS5zdGFydCgwLjksIDAsIGVhc2VGdW5jX2ludHJvLCBpbml0aWFsX3BhdXNlICsgMC4wKTtcbiAgICAgIHRoaXMuZXZlbnRfaW50cm9fYzIuc3RhcnQoMS4xLCAwLCBlYXNlRnVuY19pbnRybywgaW5pdGlhbF9wYXVzZSArIDAuMSk7XG4gICAgICB0aGlzLmV2ZW50X2ludHJvX2MzLnN0YXJ0KDEuMiwgMCwgZWFzZUZ1bmNfaW50cm8sIGluaXRpYWxfcGF1c2UgKyAwLjIpOyAvLy0tXG5cbiAgICAgIGdzYXAuZGVsYXllZENhbGwoaW5pdGlhbF9wYXVzZSArIDEuMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIud29ybGRHTC5od19yZW5kZXJlci5pbml0RW50ZXJBbmltYXRpb24oKTtcblxuICAgICAgICBfdGhpczIuZG9fem9vbU91dCgpO1xuICAgICAgfSk7XG4gICAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIGlmICh0aGlzLmNyZWF0ZWQpIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51VGltZS52YWx1ZSA9IHRoaXMuY2xvY2suZ2V0RWxhcHNlZFRpbWUoKTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Q2FtYXJhRGlzdGFuY2UudmFsdWUgPSB0aGlzLndvcmxkR0wuY2FtZXJhRGlzdGFuY2U7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudU9wZW5Qcm9ncmVzcy52YWx1ZSA9IHRoaXMuc2V0dGluZ3Mub3BlblByb2dyZXNzICogMjtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51UmVzcG9uc2l2ZVNjYWxlLnZhbHVlID0gdGhpcy53b3JsZEdMLnJlc3BvbnNpdmVTY2FsZTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51U2Nyb2xsRGVsdGEudmFsdWUgPSAtdGhpcy5lYXNlZF9zY3JvbGxEZWx0YV9mYXN0LmdldCh0aGlzLndvcmxkR0wuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSAqIDAuNSk7IC8vLS1cblxuICAgICAgICB2YXIgZXh0cmFTcGVlZDtcblxuICAgICAgICBpZiAodGhpcy5ldmVudEZhc2UgPT0gXCJpbnRlcmFjdGl2ZVwiKSB7XG4gICAgICAgICAgZXh0cmFTcGVlZCA9IDEgKyBNYXRoLmFicyh0aGlzLmVhc2VkX3Njcm9sbERlbHRhX2Zhc3QuZ2V0KHRoaXMud29ybGRHTC5zZXR0aW5ncy5zY3JvbGxfbm9ybWFsaXplZERlbHRhICogMC41KSAqIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRyYVNwZWVkID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0dGluZ3Mucm90YXRpb24xICs9IHRoaXMuc2V0dGluZ3Muc3BlZWRSb3RhdGlvbjEgKiBleHRyYVNwZWVkO1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJvdGF0aW9uMiArPSB0aGlzLnNldHRpbmdzLnNwZWVkUm90YXRpb24yICogZXh0cmFTcGVlZDtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5yb3RhdGlvbjMgKz0gdGhpcy5zZXR0aW5ncy5zcGVlZFJvdGF0aW9uMyAqIGV4dHJhU3BlZWQ7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVJvdGF0aW9uMS52YWx1ZSA9IHRoaXMuc2V0dGluZ3Mucm90YXRpb24xO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVSb3RhdGlvbjIudmFsdWUgPSAtdGhpcy5zZXR0aW5ncy5yb3RhdGlvbjI7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVJvdGF0aW9uMy52YWx1ZSA9IHRoaXMuc2V0dGluZ3Mucm90YXRpb24zOyAvL2NvbnNvbGUubG9nKHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVJvdGF0aW9uMS52YWx1ZSlcblxuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVJbnRyb1Byb2dyZXNzMS52YWx1ZSA9IHRoaXMuZXZlbnRfaW50cm9fYzEuZ2V0X3Byb2dyZXNzKCk7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudUludHJvUHJvZ3Jlc3MyLnZhbHVlID0gdGhpcy5ldmVudF9pbnRyb19jMi5nZXRfcHJvZ3Jlc3MoKTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51SW50cm9Qcm9ncmVzczMudmFsdWUgPSB0aGlzLmV2ZW50X2ludHJvX2MzLmdldF9wcm9ncmVzcygpO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVab29tT3V0UHJvZ3Jlc3MxLnZhbHVlID0gdGhpcy5ldmVudF96b29tb3V0X2MxLmdldF9wcm9ncmVzcygpO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVab29tT3V0UHJvZ3Jlc3MyLnZhbHVlID0gdGhpcy5ldmVudF96b29tb3V0X2MyLmdldF9wcm9ncmVzcygpO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVab29tT3V0UHJvZ3Jlc3MzLnZhbHVlID0gdGhpcy5ldmVudF96b29tb3V0X2MzLmdldF9wcm9ncmVzcygpOyAvL2NvbnNvbGUubG9nKHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVpvb21PdXRQcm9ncmVzczEudmFsdWUrXCIgLSBcIit0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVab29tT3V0UHJvZ3Jlc3MyLnZhbHVlK1wiIC0gXCIrdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Wm9vbU91dFByb2dyZXNzMy52YWx1ZSlcbiAgICAgICAgLy90aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVGYWxsUHJvY2Vzcy52YWx1ZSA9IHRoaXMuZXZlbnRfZmFsbC5nZXRfcHJvZ3Jlc3MoKVxuXG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudUZhbGxQcm9jZXNzLnZhbHVlID0gMTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51SGVpZ2h0LnZhbHVlID0gdGhpcy53b3JsZEdMLmhlaWdodDsgLy9jb25zb2xlLmxvZyhcInVJbnRyb1Byb2dyZXNzMTogXCIrdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51SW50cm9Qcm9ncmVzczEudmFsdWUpXG5cbiAgICAgICAgdmFyIHZpZGVvQm91bmRzID0gdGhpcy53b3JsZEdMLiR2aWRlby5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51VmlkZW9ZT2Zmc2V0LnZhbHVlID0gdmlkZW9Cb3VuZHMueTsgLy9jb25zb2xlLmxvZyh2aWRlb0JvdW5kcy55KVxuICAgICAgfVxuICAgIH1cbiAgICAvKlxyXG4gICAgb25VcGRhdGVHZW9tZXRyeVBvc1kocG9zWSl7XHJcbiAgICAgICAgLy8gRXN0ZSBzY3JpcHQgaGFjaWEgbG9zIGNhbGN1bG9zIHBhcmEgc2luY3Jvbml6YXIgbGEgcG9zaWNpbiBkZSBsYSBnZW9tZXRyaWEgY29uIGxhcyBkZSB1biBkaXYgcXVlIHNlIG1vdsOtYSB2ZXJ0aWNhbG1lbnRlIGNvbiBlbCBzY3JvbGwuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21lbnRhZG8gcG9yIHNpIHNpcnZlIGVuIGVsIGZ1dHVyby5cclxuICAgICAgICBjb25zb2xlLmxvZyhcInBvc1k6IFwiK3Bvc1kpXHJcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5nZW9tZXRyeVBvc1kgPSBwb3NZXHJcbiAgICAgICAgdGhpcy5tZXNoLnBvc2l0aW9uLnNldFkocG9zWSk7XHJcbiAgICB9XHJcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25VcGRhdGVPcGVuUHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25VcGRhdGVPcGVuUHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMuc2V0dGluZ3Mub3BlblByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFBVQkxJQ0FTOlxuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7Ly9jb25zb2xlLmxvZyhcIihHcmFkaWVudEJhY2tncm91bmQucmVzaXplKSFcIilcbiAgICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUFJJVkFEQVM6IFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldHVwX3NldHRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cF9zZXR0aW5ncygpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTFEb3RzLl9zZXR1cF9zZXR0aW5ncykhIVwiKVxuICAgICAgdmFyIHNwZWVkQmFzZSA9IDAuMDAyO1xuICAgICAgdGhpcy5zZXR0aW5ncyA9IHtcbiAgICAgICAgZmFjdG9yOiA2LFxuICAgICAgICBpbmNyX3JhZGlvOiAyNSxcbiAgICAgICAgbnVtT3JiaXRzOiAzMSxcbiAgICAgICAgLy9hcnJheU9yYml0czogWzUsIDYsIDcsIDgsIDksIDEwLCAxMywgMTcsIDE4LCAxOSwgMjIsIDIzLCAyNCwgMjUsIDI2LCAyN11cbiAgICAgICAgYXJyYXlPcmJpdHM6IFs5LCAxMywgMTddLFxuICAgICAgICAvL2FycmF5T3JiaXRzOiBbMSwgM11cbiAgICAgICAgLy8gT3J0Yml0IHJvdGF0aW9uXG4gICAgICAgIHNwZWVkQmFzZTogc3BlZWRCYXNlLFxuICAgICAgICByb3RhdGlvbjE6IDAsXG4gICAgICAgIHNwZWVkUm90YXRpb24xOiAzICogc3BlZWRCYXNlLFxuICAgICAgICByb3RhdGlvbjI6IDIsXG4gICAgICAgIHNwZWVkUm90YXRpb24yOiAyICogc3BlZWRCYXNlLFxuICAgICAgICByb3RhdGlvbjM6IDAsXG4gICAgICAgIHNwZWVkUm90YXRpb24zOiAxICogc3BlZWRCYXNlXG4gICAgICB9O1xuICAgICAgdGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyID0gdGhpcy5fZ2V0X2FycmF5X3RyaWFuZ3VsYXIodGhpcy5zZXR0aW5ncy5mYWN0b3IsIHRoaXMuc2V0dGluZ3MubnVtT3JiaXRzKTtcbiAgICAgIHRoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhID0gdGhpcy5fZ2V0X2FycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YSh0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXIsIHRoaXMuc2V0dGluZ3MuYXJyYXlPcmJpdHMpO1xuICAgICAgdGhpcy5zZXR0aW5ncy5hcnJheV9kb3RQb3MgPSB0aGlzLl9nZXRfYXJyYXlfZG90UG9zKHRoaXMuc2V0dGluZ3MuYXJyYXlPcmJpdHMsIHRoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhciwgdGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEpO1xuICAgICAgdGhpcy5zZXR0aW5ncy5udW1Eb3RzID0gdGhpcy5zZXR0aW5ncy5hcnJheV9kb3RQb3MubGVuZ3RoO1xuICAgICAgdGhpcy5zZXR0aW5ncy5vcGVuUHJvZ3Jlc3MgPSAwO1xuICAgICAgdGhpcy5zZXR0aW5ncy5nZW9tZXRyeVBvc1kgPSAwOyAvL3RoaXMuc2V0dGluZ3MubnVtRG90cyA9IHRoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhclt0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXIubGVuZ3RoLTFdXG4gICAgICAvL2NvbnNvbGUubG9nKFwidGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyOiBcIit0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXIpXG4gICAgICAvL2NvbnNvbGUubG9nKFwidGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGE6IFwiK3RoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhKVxuICAgICAgLy9jb25zb2xlLmxvZyhcInRoaXMuc2V0dGluZ3MubnVtRG90czogXCIrdGhpcy5zZXR0aW5ncy5udW1Eb3RzKVxuICAgICAgLy9jb25zb2xlLmxvZyhcInRoaXMuc2V0dGluZ3MuYXJyYXlPcmJpdHM6IFwiK3RoaXMuc2V0dGluZ3MuYXJyYXlPcmJpdHMpXG4gICAgICAvL2NvbnNvbGUubG9nKFwidGhpcy5zZXR0aW5ncy5hcnJheV9kb3RQb3M6IFwiK3RoaXMuc2V0dGluZ3MuYXJyYXlfZG90UG9zKVxuICAgICAgLy9jb25zb2xlLmxvZyhcInRoaXMuc2V0dGluZ3MuYXJyYXlfZG90UG9zLmxlbmd0aDogXCIrdGhpcy5zZXR0aW5ncy5hcnJheV9kb3RQb3MubGVuZ3RoKVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWUxRG90cy5fY3JlYXRlKSFcIilcbiAgICAgIC8vLS1cbiAgICAgIHZhciB2aWRlb0JvdW5kcyA9IHRoaXMud29ybGRHTC4kdmlkZW8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICAgIC8vYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcsXG4gICAgICAgIHZlcnRleENvbG9yczogdHJ1ZSxcbiAgICAgICAgdmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgdUNhbWFyYURpc3RhbmNlOiB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy53b3JsZEdMLmNhbWVyYURpc3RhbmNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1VGltZToge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vdVNjYWxlOnt2YWx1ZTogMX0sXG4gICAgICAgICAgdU9wZW5Qcm9ncmVzczoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVSZXNwb25zaXZlU2NhbGU6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1U2Nyb2xsRGVsdGE6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Um90YXRpb24xOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVJvdGF0aW9uMjoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVSb3RhdGlvbjM6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1SW50cm9Qcm9ncmVzczE6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1SW50cm9Qcm9ncmVzczI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1SW50cm9Qcm9ncmVzczM6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Wm9vbU91dFByb2dyZXNzMToge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVab29tT3V0UHJvZ3Jlc3MyOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVpvb21PdXRQcm9ncmVzczM6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1RmFsbFByb2Nlc3M6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1SGVpZ2h0OiB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy53b3JsZEdMLmhlaWdodFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVZpZGVvWU9mZnNldDoge1xuICAgICAgICAgICAgdmFsdWU6IHZpZGVvQm91bmRzLnlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVab29taW5nUHJvZ3Jlc3M6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSAvL3VWaWRlb0hlaWdodDp7dmFsdWU6IHZpZGVvQm91bmRzLmhlaWdodH0sXG5cbiAgICAgICAgfVxuICAgICAgfSk7IC8vLS1cbiAgICAgIC8vY29uc29sZS5sb2codGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9jb2xvcilcbiAgICAgIC8vLS1cblxuICAgICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXMsIDMpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfcG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfcG9zaWNpb25lcywgMykpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9jb2xvcicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9jb2xvciwgMykpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9vcmJpdGFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX29yYml0YWwsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfcG9zX29yYml0YScsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9wb3Nfb3JiaXRhLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX2luY3JfYW5ndWxvUmFkJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX2luY3JfYW5ndWxvUmFkLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX2FuZ3Vsb1JhZCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9hbmd1bG9SYWQsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfcmFkaW8nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfcmFkaW8sIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfZGlyJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX2RpciwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9pbmNyJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX2luY3IsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfeCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV94LCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX3knLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfeSwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV96JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3osIDEpKTtcbiAgICAgIHRoaXMubWVzaCA9IG5ldyBUSFJFRS5Qb2ludHModGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCk7XG4gICAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLm1lc2gpOyAvLy0tLS0tLS0tLVxuICAgICAgLy8gdGhpcy5tYXRlcmlhbDIgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgLy8gICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgLy8gICAgIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nLFxuICAgICAgLy8gICAgIHZlcnRleENvbG9yczogdHJ1ZSxcbiAgICAgIC8vICAgICB2ZXJ0ZXhTaGFkZXI6IHZlcnRleF9iZywgXG4gICAgICAvLyAgICAgZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50X2JnLFxuICAgICAgLy8gICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgLy8gICAgIHVuaWZvcm1zOiB7XG4gICAgICAvLyAgICAgICAgIHVDYW1hcmFEaXN0YW5jZToge3ZhbHVlOiB0aGlzLndvcmxkR0wuY2FtZXJhRGlzdGFuY2V9LFxuICAgICAgLy8gICAgICAgICB1VGltZToge3ZhbHVlOiAwfSxcbiAgICAgIC8vICAgICAgICAgLy91U2NhbGU6e3ZhbHVlOiAxLjV9LFxuICAgICAgLy8gICAgICAgICB1T3BlblByb2dyZXNzOnt2YWx1ZTogMH1cbiAgICAgIC8vICAgICB9XG4gICAgICAvLyB9KVxuICAgICAgLy8gdGhpcy5tZXNoMiA9IG5ldyBUSFJFRS5Qb2ludHModGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbDIpXG4gICAgICAvLyB0aGlzLm1lc2gyLnBvc2l0aW9uLnogPS0xXG4gICAgICAvLyB0aGlzLnNjZW5lLmFkZCh0aGlzLm1lc2gyKVxuICAgICAgLy8tLS0tLS0tLS1cblxuICAgICAgdGhpcy5jcmVhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRfc2Nyb2xsTGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0X3Njcm9sbExpc3RlbmVycygpIHtcbiAgICAgIC8qXHJcbiAgICAgIFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcclxuICAgICAgICAgIHRyaWdnZXI6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hYm91dF9faGVybycpLFxyXG4gICAgICAgICAgc3RhcnQ6ICd0b3AgdG9wJyxcclxuICAgICAgICAgIGVuZDogJ2JvdHRvbSB0b3AnLFxyXG4gICAgICAgICAgLy9vbmNlOiB0cnVlLFxyXG4gICAgICAgICAgLy8gbWFya2VyczogdHJ1ZSxcclxuICAgICAgICAgIHNjcnViOiB0cnVlLFxyXG4gICAgICAgICAgb25VcGRhdGU6IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgbGV0IGluY3IgPSBlLnByb2dyZXNzIC0gdGhpcy5sYXN0U2Nyb2xsVmFsdWVcclxuICAgICAgICAgICAgICBpbmNyID0gTWF0aC5yb3VuZChpbmNyICogMTAwMClcclxuICAgICAgICAgICAgICB0aGlzLmxhc3RTY3JvbGxWYWx1ZSA9IGUucHJvZ3Jlc3NcclxuICAgICAgICAgICAgICBpbmNyID0gTWF0aC5taW4oTWF0aC5tYXgocGFyc2VJbnQoaW5jciksIC0yMCksIDIwKTtcclxuICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnNjcm9sbFNwZWVkID0gaW5jci8yMFxyXG4gICAgICAgICAgICAgIC8vLS1jb25zb2xlLmxvZyhlKVxyXG4gICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MucHJvZ3Jlc3M1ID0gZS5wcm9ncmVzcyo1IC8vUm90YWNpb25lc1xyXG4gICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MucHJvZ3Jlc3MwID0gZS5wcm9ncmVzcyoxMCAvL1xyXG4gICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MucHJvZ3Jlc3M2ID0gZS5wcm9ncmVzcyoxMFxyXG4gICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MucHJvZ3Jlc3M0ID0gZS5wcm9ncmVzcyo1MFxyXG4gICAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICAvLyBQcm9ncmVzbyBzZWNjacOzbiBUb3VjaFxyXG4gICAgICBTY3JvbGxUcmlnZ2VyLmNyZWF0ZSh7XHJcbiAgICAgICAgICB0cmlnZ2VyOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYWJvdXRfX3RvdWNoJyksXHJcbiAgICAgICAgICBzdGFydDogJ3RvcCBib3R0b20nLFxyXG4gICAgICAgICAgZW5kOiAnYm90dG9tIGJvdHRvbScsXHJcbiAgICAgICAgICAvL29uY2U6IHRydWUsXHJcbiAgICAgICAgICAvLyBtYXJrZXJzOiB0cnVlLFxyXG4gICAgICAgICAgc2NydWI6IHRydWUsXHJcbiAgICAgICAgICBvblVwZGF0ZTogKGUpID0+IHtcclxuICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnByb2dyZXNzMSA9IGUucHJvZ3Jlc3NcclxuICAgICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgKi9cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldF9hcnJheV9kb3RQb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9hcnJheV9kb3RQb3MoX2FycmF5T3JiaXRzLCBfYXJyYXlfdHJpYW5ndWxhciwgX2FycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YSkge1xuICAgICAgdmFyIG1pQXJyYXkgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYXJyYXlPcmJpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9yYml0TnVtID0gX2FycmF5T3JiaXRzW2ldO1xuICAgICAgICB2YXIgZG90c194X29yYml0ID0gX2FycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YVtpXTtcbiAgICAgICAgdmFyIGRvdE51bV9iYXNlID0gX2FycmF5X3RyaWFuZ3VsYXJbX2FycmF5T3JiaXRzW2ldIC0gMV07IC8vIGNvbnNvbGUubG9nKFwib3JiaXROdW06IFwiK29yYml0TnVtKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImRvdHNfeF9vcmJpdDogXCIrZG90c194X29yYml0KVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImRvdE51bV9iYXNlOiBcIitkb3ROdW1fYmFzZSlcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvdHNfeF9vcmJpdDsgaisrKSB7XG4gICAgICAgICAgbWlBcnJheS5wdXNoKGRvdE51bV9iYXNlICsgaiArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaUFycmF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0X251bURvdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9udW1Eb3RzKF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEpIHtcbiAgICAgIHZhciBudW1Eb3RzID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gX2FycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbnVtRG90cyArPSBfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVtRG90cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEoX2FycmF5X3RyaWFuZ3VsYXIsIF9hcnJheU9yYml0cykge1xuICAgICAgLy8gR2VuZXJhIHVuYSBhcnJheSBiYXNhZGEgZW4gbGEgcHJvZ3Jlc2nDs24gdHJpYW5ndWxhciAoKiBmYWN0b3IpLlxuICAgICAgLy8gLi4uIGRvbmRlIHNlIGluZGljYSBlbCBudW1lcm8gZGUgZG90cyBwb3Igb3JiaXRhbFxuICAgICAgLy8gVW5hIHByb2dyZXNpw7NuIHRyaWFuZ3VsYXIgZXM6IDEsIDMsIDYsIDEwLCAxNSAoaHR0cHM6Ly9zaWduaWZpY2F0aXZhLm9yZy9kaWNjaW9uYXJpb3MvbnVtZXJvcy1maWd1cmFkb3MvIzp+OnRleHQ9My4xLjEuMS4tLERlZmluaWNpJUMzJUIzbixhbnRlcmlvciUyMG5vJTIwb2J0ZW5lbW9zJTIwdW5hJTIwY29uc3RhbnRlLilcbiAgICAgIHZhciBtaUFycmF5ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IF9hcnJheU9yYml0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgLy9hcnJheV9udW1UcmlhZ3VsYXJlcy5wdXNoKGkqKGkrMSkvMilcbiAgICAgICAgdmFyIG51bURvdHNfb3JiaXRhX2FjdHVhbCA9IF9hcnJheV90cmlhbmd1bGFyW19hcnJheU9yYml0c1tpXV07XG4gICAgICAgIHZhciBudW1Eb3RzX29yYml0YV9hbnRlcmlvciA9IF9hcnJheV90cmlhbmd1bGFyW19hcnJheU9yYml0c1tpXSAtIDFdO1xuICAgICAgICB2YXIgbnVtRG90c19vcmJpdGEgPSBudW1Eb3RzX29yYml0YV9hY3R1YWwgLSBudW1Eb3RzX29yYml0YV9hbnRlcmlvcjtcbiAgICAgICAgbWlBcnJheS5wdXNoKG51bURvdHNfb3JiaXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1pQXJyYXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRfYXJyYXlfdHJpYW5ndWxhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0X2FycmF5X3RyaWFuZ3VsYXIoX2ZhY3RvciwgX251bU9iaXRzKSB7XG4gICAgICAvLyBHZW5lcmEgdW5hIGFycmF5IGRlIHByb2dyZXNpw7NuIHRyaWFuZ3VsYXIgKCogZmFjdG9yKS5cbiAgICAgIC8vIFVuYSBwcm9ncmVzacOzbiB0cmlhbmd1bGFyIGVzOiAxLCAzLCA2LCAxMCwgMTUgKGh0dHBzOi8vc2lnbmlmaWNhdGl2YS5vcmcvZGljY2lvbmFyaW9zL251bWVyb3MtZmlndXJhZG9zLyM6fjp0ZXh0PTMuMS4xLjEuLSxEZWZpbmljaSVDMyVCM24sYW50ZXJpb3IlMjBubyUyMG9idGVuZW1vcyUyMHVuYSUyMGNvbnN0YW50ZS4pXG4gICAgICB2YXIgbWlBcnJheSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBfbnVtT2JpdHM7IGkrKykge1xuICAgICAgICAvL2FycmF5X251bVRyaWFndWxhcmVzLnB1c2goaSooaSsxKS8yKVxuICAgICAgICBtaUFycmF5LnB1c2goaSAqIChpICsgMSkgLyAyICogX2ZhY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaUFycmF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0dXBfZ3VpXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cF9ndWkoKSB7Ly9jb25zb2xlLmxvZyhcIihIb21lMURvdHMuX3NldHVwX2d1aSkhXCIpXG4gICAgICAvLyB0aGlzLmd1aSA9IG5ldyBkYXQuR1VJKCk7XG4gICAgICAvLyB0aGlzLmd1aS53aWR0aCA9IDQwMFxuICAgICAgLy8gY29uc3QgZm9sZGVyMCA9IHRoaXMuZ3VpLmFkZEZvbGRlcihcIk9yYml0IHNwaW5uaW5nXCIpXG4gICAgICAvLyBmb2xkZXIwLmFkZCh0aGlzLnNldHRpbmdzLCBcInByb2dyZXNzNVwiLCAwLCAxMCwgMC4wMSkubmFtZShcIlByb2dyZXNzXCIpXG4gICAgICAvLyBmb2xkZXIwLm9wZW4oKVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlY3ViZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlY3ViZShfc2NlbmUpIHtcbiAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgxMDAsIDEwMCwgMTAwKTtcbiAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgIGNvbG9yOiAweGZmMDAwMFxuICAgICAgfSk7XG4gICAgICB2YXIgY3ViZSA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cbiAgICAgIF9zY2VuZS5hZGQoY3ViZSk7XG4gICAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgfV0pO1xuXG4gIHJldHVybiBIb21lMURvdHM7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IEhvbWUxRG90czsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8vIEZQUy1NZXRlcjpcbi8vKGZ1bmN0aW9uKCl7dmFyIHNjcmlwdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtzY3JpcHQub25sb2FkPWZ1bmN0aW9uKCl7dmFyIHN0YXRzPW5ldyBTdGF0cygpO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHMuZG9tKTtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCgpe3N0YXRzLnVwZGF0ZSgpO3JlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKX0pO307c2NyaXB0LnNyYz0nLy9jZG4uanNkZWxpdnIubmV0L2doL0tldm56L3N0YXRzLmpzL2J1aWxkL3N0YXRzLm1pbi5qcyc7ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO30pKClcbmltcG9ydCB7IE9yYml0Q29udHJvbHMgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvT3JiaXRDb250cm9scyc7XG5pbXBvcnQgKiBhcyBkYXQgZnJvbSBcImRhdC5ndWlcIjtcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCBnc2FwIGZyb20gJ2dzYXAnO1xuaW1wb3J0IFNjcm9sbFRyaWdnZXIgZnJvbSAnZ3NhcC9TY3JvbGxUcmlnZ2VyJztcbmltcG9ydCBXZWJHTFV0aWxzIGZyb20gJy4uL1dlYkdMVXRpbHMnO1xuaW1wb3J0IEhvbWUxRG90cyBmcm9tICcuL0hvbWUxRG90cyc7XG5cbnZhciBIb21lMUFwcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEhvbWUxQXBwKG9iaikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIb21lMUFwcCk7XG5cbiAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWUxQXBwLkNPTlNUUlVDVE9SQSkhIVwiLCBvYmopIFxuICAgIHRoaXMuaHdfcmVuZGVyZXIgPSBvYmoucmVuZGVyZXI7IC8vIFJlZGVyZXIvcGFnaW5hIGRlIEhpZ2hXYXkuIE5vIGNvbmZ1bmRpciBjb24gZWwgcmVuZGVyL3JlbmRlcmVyIGRlIFRocmVlLmpzXG5cbiAgICB0aGlzLiRjb250YWluZXIgPSBvYmouZG9tRWxlbWVudDsgLy8tLVxuXG4gICAgdGhpcy4kdmlkZW8gPSB0aGlzLmh3X3JlbmRlcmVyLiR2aWRlbztcbiAgICB0aGlzLiRpbm5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbm5lcicpO1xuICAgIHRoaXMuJHZpZGVvID0gdGhpcy5od19yZW5kZXJlci4kdmlkZW87IC8vLS1cblxuICAgIHRoaXMud2lkdGggPSB0aGlzLiRjb250YWluZXIub2Zmc2V0V2lkdGg7IC8vY29uc29sZS5sb2coXCJ3aWR0aDogXCIrdGhpcy53aWR0aClcblxuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy4kY29udGFpbmVyLm9mZnNldEhlaWdodDsgLy8tLVxuXG4gICAgdGhpcy5yZWZSZXNvbHV0aW9uID0gMTkyMDtcbiAgICB0aGlzLnJlc3BvbnNpdmVTY2FsZSA9IHRoaXMud2lkdGggLyB0aGlzLnJlZlJlc29sdXRpb247IC8vLS1cblxuICAgIHRoaXMuY2FtZXJhRGlzdGFuY2UgPSA1MDA7IC8vLS1cblxuICAgIHRoaXMuc2V0dGluZ3MgPSB7XG4gICAgICBzY3JvbGxfbGFzdElubmVyWTogMCxcbiAgICAgIC8vIFVsdGltYSBwb3NpY2nDs24gZGVsIGVsZW1lbnRvIGRlIHJlZmVyZW5jaWFcbiAgICAgIHNjcm9sbF9kZWx0YTogMCxcbiAgICAgIC8vIEluY3JlbWVudG8gZGUgcGl4ZWxzIGRlbCBzY3JvbGxcbiAgICAgIHNjcm9sbF9saW1pdGVkRGVsdGE6IDAsXG4gICAgICAvLyBMaW1pdGEgbG9zIHZhbG9yZXMgYSAtMjAgLT4gKzIwXG4gICAgICBzY3JvbGxfbm9ybWFsaXplZERlbHRhOiAwLFxuICAgICAgLy8gUGFzYSBlbCBkZWx0YSBhIC0xIC0+ICsxXG4gICAgICBzY3JvbGxfZmFjdG9yZERlbHRhOiAxLFxuICAgICAgLy8gVmFsb3JlcyBhYnNvbHV0b3MgZGUgMCAtPiAxXG4gICAgICBzY3JvbGxfZGlyZWN0aW9uOiAxIC8vIERpcmVjY2lvbiBkZWwgZGVsdGEuIDEgc2kgZXN0w6EgcGFyYWRvXG5cbiAgICB9OyAvLy0tXG4gICAgLy8gU2NlbmVcblxuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTsgLy8tLVxuICAgIC8vIENhbWVyYVxuICAgIC8vUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiA6IE51bWJlciwgYXNwZWN0IDogTnVtYmVyLCBuZWFyIDogTnVtYmVyLCBmYXIgOiBOdW1iZXIgKVxuXG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoMzAsIHRoaXMud2lkdGggLyB0aGlzLmhlaWdodCwgMC4xLCAyMDAwKTtcbiAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi56ID0gdGhpcy5jYW1lcmFEaXN0YW5jZTtcbiAgICB0aGlzLmNhbWVyYS5mb3YgPSAyICogTWF0aC5hdGFuKHRoaXMuaGVpZ2h0IC8gMiAvIHRoaXMuY2FtZXJhRGlzdGFuY2UpICogKDE4MCAvIE1hdGguUEkpOyAvLy0tXG4gICAgLy8gUmVuZGVyZXJcbiAgICAvLy0tXG5cbiAgICB0aGlzLkFDVElWRV9SRU5ERVIgPSBmYWxzZTsgLy8tLVxuXG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTDFSZW5kZXJlcih7XG4gICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICBhbHBoYTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyZXIuYXV0b0NsZWFyID0gZmFsc2U7IC8vIFZhbW9zIGEgdXNhciAyIHNjZW5hcyAodW5hIHBhcmEgZWwgYmFja2dyb3VuZCB5IG90cmEgcGFyYSBsb3MgcHVudG9zKSBxdWUgaW1wbGljYXLDoW4gdXNhciAyIGFjY2lvbmVzIGRlIHJlbmRlci4gQ29uIGF1dG9jbGVhciBmYWxzZSBwZXJtaXRpbW9zIHF1ZSBsYSBzZWd1bmRhIG5vIGJvcnJlIGxhIHByaW1lcmEuXG4gICAgLy9jb25zb2xlLmxvZyhcIndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIChvcmlnaW5hbCk6IFwiK3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKVxuXG4gICAgdGhpcy5yZW5kZXJlci5zZXRQaXhlbFJhdGlvKE1hdGgubWluKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCAxKSk7IC8vY29uc29sZS5sb2coXCJ3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAoZmlsdHJhZG8pOiBcIit3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbylcbiAgICAvL2NvbnNvbGUubG9nKFwiV2ViR0wyPzogXCIrdGhpcy5yZW5kZXJlci5jYXBhYmlsaXRpZXMuaXNXZWJHTDIpXG4gICAgLy8tLVxuICAgIC8vdGhpcy5jb250cm9scyA9IG5ldyBPcmJpdENvbnRyb2xzKCB0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJlci5kb21FbGVtZW50ICk7XG4gICAgLy8gdGhpcy5jb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT57XG4gICAgLy8gICAgIHRoaXMub25DYW1lcmFQb3NpdGlvbkNoYW5nZShlKVxuICAgIC8vIH0pO1xuICAgIC8vLS1cblxuICAgIHRoaXMuJGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpOyAvLy0tXG5cbiAgICB0aGlzLmRvdHMgPSBuZXcgSG9tZTFEb3RzKHtcbiAgICAgIHdvcmxkR0w6IHRoaXNcbiAgICB9KTsgLy8tLVxuXG4gICAgdGhpcy5fcmVzaXplKCk7IC8vdGhpcy5fcmVuZGVyKCk7XG4gICAgLy90aGlzLl9pbml0X3Njcm9sbExpc3RlbmVycygpXG5cbiAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQVUJMSUNBUzpcblxuXG4gIF9jcmVhdGVDbGFzcyhIb21lMUFwcCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy4kdmlkZW8gPSB0aGlzLmh3X3JlbmRlcmVyLiR2aWRlbztcbiAgICAgIHRoaXMuJGlubmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmlubmVyJyk7XG4gICAgICB0aGlzLiR2aWRlbyA9IHRoaXMuaHdfcmVuZGVyZXIuJHZpZGVvOyAvLy0tXG5cbiAgICAgIHRoaXMuZG90cy5pbml0KCk7IC8vLS1cblxuICAgICAgdGhpcy5faW5pdF9zY3JvbGxMaXN0ZW5lcnMoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImtpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgIHRoaXMudHJpZ2dlci5raWxsKCk7XG4gICAgICBnc2FwLnRpY2tlci5yZW1vdmUodGhpcy5fYmluZGVkX3JlbmRlcik7XG4gICAgICBnc2FwLnRpY2tlci5yZW1vdmUodGhpcy5fYmluZGVkX2V2YWxfc2Nyb2xsKTtcbiAgICAgIHRoaXMuZG90cyA9IG51bGw7XG4gICAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIH0sIHtcbiAgICBrZXk6IFwib25VcGRhdGVPcGVuUHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25VcGRhdGVPcGVuUHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICAgIGlmICh0aGlzLmRvdHMpIHtcbiAgICAgICAgdGhpcy5kb3RzLm9uVXBkYXRlT3BlblByb2dyZXNzKHByb2dyZXNzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25SZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWUxQXBwLm9uUmVzaXplKSFcIilcbiAgICAgIHRoaXMuX3Jlc2l6ZSgpO1xuICAgIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBQUklWQURBUzpcblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0X3Njcm9sbExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdF9zY3JvbGxMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgYmluZGVkX3JlbmRlciA9IGZ1bmN0aW9uIGJpbmRlZF9yZW5kZXIoKSB7XG4gICAgICAgIF90aGlzLl9yZW5kZXIoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBiaW5kZWRfZXZhbF9zY3JvbGwgPSBmdW5jdGlvbiBiaW5kZWRfZXZhbF9zY3JvbGwoKSB7XG4gICAgICAgIF90aGlzLl9ldmFsX3Njcm9sbChfdGhpcy50cmlnZ2VyLnByb2dyZXNzKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2JpbmRlZF9yZW5kZXIgPSBiaW5kZWRfcmVuZGVyO1xuICAgICAgdGhpcy5fYmluZGVkX2V2YWxfc2Nyb2xsID0gYmluZGVkX2V2YWxfc2Nyb2xsO1xuICAgICAgdGhpcy50cmlnZ2VyID0gU2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xuICAgICAgICB0cmlnZ2VyOiB0aGlzLiR2aWRlbyxcbiAgICAgICAgc3RhcnQ6ICd0b3AgYm90dG9tJyxcbiAgICAgICAgZW5kOiAnYm90dG9tIHRvcCcsXG4gICAgICAgIHNjcnViOiB0cnVlLFxuICAgICAgICAvLyBTY3J1YjogR2VuZXJhIGV2ZW50b3MgZW4gdW5hIGZyYW5qYSBtYXMgcXVlIGVuIHVuIHB1bnRvLlxuICAgICAgICAvL21hcmtlcnM6IHRydWUsXG4gICAgICAgIG9uVG9nZ2xlOiBmdW5jdGlvbiBvblRvZ2dsZShzZWxmKSB7XG4gICAgICAgICAgaWYgKHNlbGYuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiTUFJTl9BQ1RJVkVcIilcbiAgICAgICAgICAgIGdzYXAudGlja2VyLmFkZChiaW5kZWRfcmVuZGVyKTtcbiAgICAgICAgICAgIGdzYXAudGlja2VyLmFkZChiaW5kZWRfZXZhbF9zY3JvbGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIk1BSU5fTk9UX0FDVElWRVwiKVxuICAgICAgICAgICAgZ3NhcC50aWNrZXIucmVtb3ZlKGJpbmRlZF9yZW5kZXIpO1xuICAgICAgICAgICAgZ3NhcC50aWNrZXIucmVtb3ZlKGJpbmRlZF9ldmFsX3Njcm9sbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2YWxfc2Nyb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmFsX3Njcm9sbChwcm9ncmVzcykge1xuICAgICAgdmFyIGlubmVyRGF0YSA9IHRoaXMuJGlubmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIG5ld0lubmVyWSA9IGlubmVyRGF0YS55O1xuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfZGVsdGEgPSBuZXdJbm5lclkgLSB0aGlzLnNldHRpbmdzLnNjcm9sbF9sYXN0SW5uZXJZO1xuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfbGFzdElubmVyWSA9IG5ld0lubmVyWTtcbiAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX2xpbWl0ZWREZWx0YSA9IFdlYkdMVXRpbHMuY2xhbXAodGhpcy5zZXR0aW5ncy5zY3JvbGxfZGVsdGEsIC0yMCwgMjApOyAvLyBMaW1pdGEgbG9zIHZhbG9yZXMgYSAtMjAgLT4gKzIwXG5cbiAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSA9ICh0aGlzLnNldHRpbmdzLnNjcm9sbF9saW1pdGVkRGVsdGEgLyAyMCkudG9GaXhlZCgzKTsgLy8gUGFzYSBlbCBkZWx0YSBhIC0xIC0+ICsxXG5cbiAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX2ZhY3RvcmREZWx0YSA9IE1hdGguYWJzKHRoaXMuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSkgKyAwOyAvLyBWYWxvcmVzIGFic29sdXRvcyBkZSAwIC0+IDFcblxuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfZGlyZWN0aW9uID0gMTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSA8IDApIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfZGlyZWN0aW9uID0gLTE7XG4gICAgICB9IC8vIGNvbnNvbGUubG9nKFwidGhpcy5zZXR0aW5ncy5zY3JvbGxfbm9ybWFsaXplZERlbHRhOiBcIit0aGlzLnNldHRpbmdzLnNjcm9sbF9ub3JtYWxpemVkRGVsdGEpXG4gICAgICAvL2NvbnNvbGUubG9nKFwidGhpcy5zZXR0aW5ncy5zY3JvbGxfZmFjdG9yZERlbHRhOiBcIit0aGlzLnNldHRpbmdzLnNjcm9sbF9mYWN0b3JkRGVsdGEpXG5cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lMUFwcC5fcmVzaXplKSEhXCIpXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy4kY29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLiRjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgdGhpcy5yZXNwb25zaXZlU2NhbGUgPSB0aGlzLndpZHRoIC8gdGhpcy5yZWZSZXNvbHV0aW9uO1xuICAgICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMuY2FtZXJhLmFzcGVjdCA9IHRoaXMud2lkdGggLyB0aGlzLmhlaWdodDtcbiAgICAgIHRoaXMuY2FtZXJhRGlzdGFuY2UgPSB0aGlzLmNhbWVyYS5wb3NpdGlvbi56O1xuICAgICAgdGhpcy5jYW1lcmEuZm92ID0gMiAqIE1hdGguYXRhbih0aGlzLmhlaWdodCAvIDIgLyB0aGlzLmNhbWVyYURpc3RhbmNlKSAqICgxODAgLyBNYXRoLlBJKTsgLy8tLVxuXG4gICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7IC8vLS1cblxuICAgICAgaWYgKHRoaXMuZG90cykgey8vdGhpcy5kb3RzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlcigpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTFBcHAuX3JlbmRlcikhXCIpXG4gICAgICBpZiAodGhpcy5oZWlnaHQgIT0gdGhpcy4kY29udGFpbmVyLm9mZnNldEhlaWdodCB8fCB0aGlzLndpZHRoICE9IHRoaXMuJGNvbnRhaW5lci5vZmZzZXRXaWR0aCkge1xuICAgICAgICB0aGlzLl9yZXNpemUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZG90cykge1xuICAgICAgICB0aGlzLmRvdHMucmVuZGVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTsgLy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVyLmJpbmQodGhpcykpIC8vIEVsIGJ1Y2xlIGRlIHJlbmRlciBsbyBnZW5lcmEgZWwgb25VcGRhdGUgZGVsIFNjcm9sbFRyaWdnZXJcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSG9tZTFBcHA7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IEhvbWUxQXBwOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8vaW1wb3J0ICogYXMgVEhSRUUgZnJvbSBcInRocmVlXCJcbi8vaW1wb3J0IGdzYXAgZnJvbSBcImdzYXBcIlxuLy9pbXBvcnQge0dMVEZMb2FkZXIsIEdMVExvYWRlcn0gZnJvbSBcInRocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0dMVEZMb2FkZXJcIlxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG52YXIgSG9tZTJHZW9tZXRyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoSG9tZTJHZW9tZXRyeSwgX0V2ZW50RW1pdHRlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihIb21lMkdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBIb21lMkdlb21ldHJ5KG9iaikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIb21lMkdlb21ldHJ5KTtcblxuICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTJHZW9tZXRyeS5DT05TVFJVQ1RPUkEpIVwiKVxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7IC8vLS1cblxuICAgIF90aGlzLmZhY3RvciA9IG9iai5mYWN0b3I7IC8vNlxuXG4gICAgX3RoaXMuaW5jcl9yYWRpbyA9IG9iai5pbmNyX3JhZGlvOyAvLzI1XG5cbiAgICBfdGhpcy5udW1PcmJpdHMgPSBvYmoubnVtT3JiaXRzOyAvLzM3XG5cbiAgICBfdGhpcy5hcnJheV90cmlhbmd1bGFyID0gb2JqLmFycmF5X3RyaWFuZ3VsYXI7XG4gICAgX3RoaXMuYXJyYXlfZG90UG9zID0gb2JqLmFycmF5X2RvdFBvcztcbiAgICBfdGhpcy5udW1Eb3RzID0gb2JqLm51bURvdHM7IC8vLS1cblxuICAgIF90aGlzLmFycmF5Q29sb3Jlc19SR0IgPSBbXTtcbiAgICBfdGhpcy5hcnJheUNvbG9yZXNfUkdCXzAxID0gW107XG4gICAgX3RoaXMuY29sb3JQb3MgPSAwO1xuXG4gICAgX3RoaXMuX2luaXRfY29sb3JzKCk7IC8vLS1cblxuXG4gICAgX3RoaXMuYXR0cmlidXRlcyA9IHtcbiAgICAgIGFfcG9zaWNpb25lczogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMyksXG4gICAgICBhX2NvbG9yOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAzKSxcbiAgICAgIGFfb3JiaXRhbDogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX3Bvc19vcmJpdGE6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV9pbmNyX2FuZ3Vsb1JhZDogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX2FuZ3Vsb1JhZDogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX3JhZGlvOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfZGlyOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfaW5jcjogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX3g6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV95OiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfejogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSlcbiAgICB9OyAvLy0tXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLmFycmF5X2RvdFBvcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvdFBvcyA9IF90aGlzLmFycmF5X2RvdFBvc1tpXTtcblxuICAgICAgdmFyIGRvdCA9IF90aGlzLl9nZXRfZG90KGRvdFBvcyk7XG5cbiAgICAgIHZhciBpMyA9IGkgKiAzO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXNbaTNdID0gZG90Lng7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfcG9zaWNpb25lc1tpMyArIDFdID0gZG90Lnk7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfcG9zaWNpb25lc1tpMyArIDJdID0gZG90Lno7IC8vLS1cblxuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX2NvbG9yW2kzXSA9IGRvdC5jb2xvclswXTtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9jb2xvcltpMyArIDFdID0gZG90LmNvbG9yWzFdO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX2NvbG9yW2kzICsgMl0gPSBkb3QuY29sb3JbMl07IC8vLS1cblxuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX29yYml0YWxbaV0gPSBkb3Qub3JiaXRhbDtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9wb3Nfb3JiaXRhW2ldID0gZG90LnBvc19vcmJpdGE7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfaW5jcl9hbmd1bG9SYWRbaV0gPSBkb3QuaW5jcl9hbmd1bG9SYWQ7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfYW5ndWxvUmFkW2ldID0gZG90LmFuZ3Vsb1JhZDtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9yYWRpb1tpXSA9IGRvdC5yYWRpbztcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9kaXJbaV0gPSBkb3QuZGlyO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX2luY3JbaV0gPSBkb3QuaW5jcjtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV94W2ldID0gZG90Lnk7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfeVtpXSA9IGRvdC55O1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3pbaV0gPSBkb3QuejtcbiAgICB9IC8vLS1cblxuXG4gICAgX3RoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFBSSVZBREFTXG5cblxuICBfY3JlYXRlQ2xhc3MoSG9tZTJHZW9tZXRyeSwgW3tcbiAgICBrZXk6IFwiX2dldF9kb3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9kb3QobnVtKSB7XG4gICAgICAvLyBEZXZ1ZWx2ZSB1biBvYmpldG8gY29uIGxhIGluZm9ybWFjacOzbiBkZSB1biBwdW50byBkZSBsYSBnZW9tZXRyaWEgXCJvcmJpdGFsIE1JT1RJXCJcbiAgICAgIHZhciBvYmogPSB7XG4gICAgICAgIG51bTogbnVtLFxuICAgICAgICBjb2xvcjogdGhpcy5fZ2V0X2NvbG9yKCksXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHo6IDAsXG4gICAgICAgIG9yYml0YWw6IDAsXG4gICAgICAgIGNvX29yYml0YW50ZXM6IDAsXG4gICAgICAgIHBvc19vcmJpdGE6IDAsXG4gICAgICAgIGluY3JfYW5ndWxvUmFkOiAwLFxuICAgICAgICBhbmd1bG9SYWQ6IDAsXG4gICAgICAgIHJhZGlvOiAwXG4gICAgICB9OyAvLy0tXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHRoaXMuYXJyYXlfdHJpYW5ndWxhci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGltU3VwID0gdGhpcy5hcnJheV90cmlhbmd1bGFyW2ldOyAvL2NvbnNvbGUubG9nKFwibGltU3VwOiBcIitsaW1TdXApXG5cbiAgICAgICAgaWYgKG51bSA+IGxpbVN1cCkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiKlwiKVxuICAgICAgICAgIG9iai5vcmJpdGFsID0gaSArIDE7XG4gICAgICAgICAgb2JqLmNvX29yYml0YW50ZXMgPSAoaSArIDEpICogdGhpcy5mYWN0b3I7XG4gICAgICAgICAgb2JqLnBvc19vcmJpdGEgPSBudW0gLSBsaW1TdXAgLSAxO1xuICAgICAgICAgIG9iai5pbmNyX2FuZ3Vsb1JhZCA9IDIgKiBNYXRoLlBJIC8gb2JqLmNvX29yYml0YW50ZXM7XG5cbiAgICAgICAgICBpZiAob2JqLm9yYml0YWwgJSAyID09IDApIHtcbiAgICAgICAgICAgIG9iai5kaXIgPSAxO1xuICAgICAgICAgICAgb2JqLmluY3IgPSAwO1xuICAgICAgICAgICAgb2JqLmFuZ3Vsb1JhZCA9IG9iai5wb3Nfb3JiaXRhICogb2JqLmluY3JfYW5ndWxvUmFkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmouZGlyID0gLTE7XG4gICAgICAgICAgICBvYmouaW5jciA9IDE7XG4gICAgICAgICAgICBvYmouYW5ndWxvUmFkID0gb2JqLnBvc19vcmJpdGEgKiBvYmouaW5jcl9hbmd1bG9SYWQgKyBvYmouaW5jcl9hbmd1bG9SYWQgLyAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9iai5yYWRpbyA9IG9iai5vcmJpdGFsICogdGhpcy5pbmNyX3JhZGlvOyAvLy0tXG5cbiAgICAgICAgICBvYmoueCA9IE1hdGguY29zKG9iai5hbmd1bG9SYWQpICogb2JqLnJhZGlvO1xuICAgICAgICAgIG9iai55ID0gTWF0aC5zaW4ob2JqLmFuZ3Vsb1JhZCkgKiBvYmoucmFkaW87XG4gICAgICAgICAgb2JqLnogPSAwO1xuICAgICAgICB9IC8vYnJlYWtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0X2NvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfY29sb3IoKSB7XG4gICAgICB2YXIgY29sb3JfUkdCXzAxID0gdGhpcy5hcnJheUNvbG9yZXNfUkdCXzAxW3RoaXMuY29sb3JQb3NdO1xuICAgICAgdGhpcy5jb2xvclBvcysrO1xuXG4gICAgICBpZiAodGhpcy5jb2xvclBvcyA+IHRoaXMuYXJyYXlDb2xvcmVzX1JHQl8wMS5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMuY29sb3JQb3MgPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sb3JfUkdCXzAxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdF9jb2xvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRfY29sb3JzKCkge1xuICAgICAgdGhpcy5hcnJheUNvbG9yZXNfUkdCID0gW107XG4gICAgICB0aGlzLmFycmF5Q29sb3Jlc19SR0IucHVzaChbMjMyLCA2NywgMTMxXSk7XG4gICAgICB0aGlzLmFycmF5Q29sb3Jlc19SR0IucHVzaChbMCwgMTI2LCAyNTVdKTtcbiAgICAgIHRoaXMuYXJyYXlDb2xvcmVzX1JHQl8wMSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXJyYXlDb2xvcmVzX1JHQi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29sb3JfUkdCID0gdGhpcy5hcnJheUNvbG9yZXNfUkdCW2ldO1xuICAgICAgICB2YXIgY29sb3JfUkdCXzAxID0gW2NvbG9yX1JHQlswXSAvIDI1NSwgY29sb3JfUkdCWzFdIC8gMjU1LCBjb2xvcl9SR0JbMl0gLyAyNTVdO1xuICAgICAgICB0aGlzLmFycmF5Q29sb3Jlc19SR0JfMDEucHVzaChjb2xvcl9SR0JfMDEpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIb21lMkdlb21ldHJ5O1xufShFdmVudEVtaXR0ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBIb21lMkdlb21ldHJ5OyIsImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhX3JhbmRvbW5lc3M7XFxuYXR0cmlidXRlIHZlYzMgYV9nZW8xX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfZ2VvMV9jb2xvcjtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9nZW8xX2FuZ3Vsb1JhZDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9nZW8xX29yYml0YWw7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9wb3Nfb3JiaXRhO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfaW5jcl9hbmd1bG9SYWQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9pbmNyO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfZGlyO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfcmFkaW87XFxuXFxudW5pZm9ybSBmbG9hdCB1Q2FtYXJhRGlzdGFuY2U7XFxudW5pZm9ybSBmbG9hdCB1VGltZTtcXG51bmlmb3JtIGZsb2F0IHVSZXNwb25zaXZlU2NhbGU7XFxudW5pZm9ybSBmbG9hdCB1U2Nyb2xsRGVsdGE7XFxudW5pZm9ybSBmbG9hdCB1Um90YXRpb24xO1xcbnVuaWZvcm0gZmxvYXQgdVJvdGF0aW9uMjtcXG51bmlmb3JtIGZsb2F0IHVSb3RhdGlvbjM7XFxuXFxudmFyeWluZyBmbG9hdCB2X2FuZ2xlUmFkO1xcbnZhcnlpbmcgdmVjMyB2X2NvbG9yO1xcbnZhcnlpbmcgZmxvYXQgdl9wdWxzZVN0cmVuZ3RoTm9ybTE7XFxudmFyeWluZyBmbG9hdCB2X3B1bHNlU3RyZW5ndGhOb3JtMjtcXG5cXG4jZGVmaW5lIFBJIDMuMTQxNTkyNjUzOFxcblxcbnZlYzMgZ2V0X3BvczEoZmxvYXQgYW5ndWxvUmFkKXtcXG4gICAgLy9mbG9hdCBhbmd1bG9SYWQgPSBhX2dlbzFfcG9zX29yYml0YSphX2dlbzFfaW5jcl9hbmd1bG9SYWQrKChhX2dlbzFfaW5jcl9hbmd1bG9SYWQvMi4pKmFfZ2VvMV9pbmNyKSsoMS4qYV9nZW8xX2RpciowLjIpO1xcbiAgICBmbG9hdCB4ID0gY29zKGFuZ3Vsb1JhZCkqYV9nZW8xX3JhZGlvO1xcbiAgICBmbG9hdCB5ID0gc2luKGFuZ3Vsb1JhZCkqYV9nZW8xX3JhZGlvO1xcbiAgICBmbG9hdCB6ID0gMC4wO1xcbiAgICB2ZWMzIG5ld1BvcyA9IHZlYzMoeCwgeSwgeik7XFxuICAgIHJldHVybiBuZXdQb3M7XFxufVxcblxcbmZsb2F0IGdldF9jb3NUaW1lKGZsb2F0IHRpbWUsIGZsb2F0IHJhZGl1cyl7XFxuICAgIC8vXFxuICAgIC8vZmxvYXQgdmFsdWUgPSBzaW4odVRpbWUpKjIuKlBJO1xcbiAgICBmbG9hdCB2YWx1ZSA9IHNpbih0aW1lKSpyYWRpdXM7XFxuICAgIHJldHVybiB2YWx1ZTtcXG59XFxuXFxuZmxvYXQgZ2V0X3goZmxvYXQgYW5nbGVSYWQsIGZsb2F0IHJhZGl1cyl7XFxuICAgIHJldHVybiBjb3MoYW5nbGVSYWQpKmFfZ2VvMV9yYWRpbztcXG59XFxuXFxuZmxvYXQgZ2V0X3B1bHNlU3RyZW5ndGhOb3JtKCBmbG9hdCBkaXJlY3Rpb24pe1xcbiAgICBmbG9hdCBkb3RBZ3VsZU5vcm0gPSBhX2dlbzFfYW5ndWxvUmFkLygyLipQSSk7IC8vIFBhc2Ftb3MgZWwgYW5ndWxvIGRlbCBwdW50byBxdWUgZXN0w6EgZW4gcmFkaWFuZXMgYSB1biB2YWxvciBkZSAwIGEgMS5cXG5cXG4gICAgZmxvYXQgbW9kU3BlZWQgPSBtaXgoMS4sIDIuNSwgMTMuL2FfZ2VvMV9vcmJpdGFsKSpkaXJlY3Rpb247XFxuICAgIGZsb2F0IHJhZGlhbFNwZWVkID0gdVRpbWUqMC4wMiptb2RTcGVlZDsgLy8gTW9kaWZpY2Ftb3MgdVRpbWUgcGFyYSBkZXRlcm1pbmFyIGxhIHZlbG9jaWRhZCByYWRpYWwuXFxuXFxuICAgIGZsb2F0IHB1bHNlQW5nbGVSYWQgPSByYWRpYWxTcGVlZCooNC4qUEkpO1xcblxcbiAgICAvLyBFbCB2YWxvciBkZSBwdWxzZUFuZ2xlUmFkIGRlYmUgZXN0YXIgZW50cmUgMCB5IDJQSSAoaW5pY2lvIHkgZmluIGRlIHVuYSBjaXJjdW5mZXJlbmNpYSkuXFxuICAgIC8vIENvbW8gZGVwZW5kZSBkZSB1VGltZSBlbCB2YWxvciBzYWxkcsOhIGRlIGVzZSByYW5nbyBwcm9udG8gcG9yIGxvIHF1ZSB0b21hcmVtb3MgZWwgcmVzdG8gKG1vZHVsbyksXFxuICAgIC8vIGRlIGRpdmlkaXIgcHVsc2VBbmdsZVJhZCBwb3IgMlBJLlxcbiAgICBpZihwdWxzZUFuZ2xlUmFkID4gMi4qUEkpe1xcbiAgICAgICAgcHVsc2VBbmdsZVJhZCA9IG1vZChwdWxzZUFuZ2xlUmFkLCAoMi4qUEkpKTtcXG4gICAgfVxcbiAgICBpZihwdWxzZUFuZ2xlUmFkIDwgMC4pe1xcbiAgICAgICAgcHVsc2VBbmdsZVJhZCA9IG1vZChwdWxzZUFuZ2xlUmFkLCAoMi4qUEkpKTtcXG4gICAgfVxcblxcbiAgICBmbG9hdCBwdWxzZUFuZ2xlTm9ybSA9IHB1bHNlQW5nbGVSYWQvKDIuKlBJKTsgLy8gTm9ybWFsaXphbW9zIGVsIHZhbG9yIChkZSAwIGEgMSlcXG5cXG4gICAgZmxvYXQgZGlzdEFuZ2xlTm9ybSA9IGFicyhwdWxzZUFuZ2xlTm9ybS1kb3RBZ3VsZU5vcm0pOyAvLyBDYWxjdWxhbW9zIGxhIGRpc3RhbmNpYSByYWRpYWwgZGVsIHB1bHNvIGFsIHB1bnRvXFxuXFxuICAgIC8vIEFwYcOxYW1vcyBsYSBkaXN0YW5jaWEgZGUgdGFsIGZvcm1hIHF1ZSBubyBsZSBhZmVjdGUgZWwgcHVudG8gZGUgZGlzY29udGludWlkYWQgT1BJID0gMlBJXFxuICAgIGlmKGRpc3RBbmdsZU5vcm0gPiAwLjUpeyBcXG4gICAgICAgIGRpc3RBbmdsZU5vcm0gPSAwLjUtKGRpc3RBbmdsZU5vcm0tMC41KTtcXG4gICAgfVxcblxcbiAgICAvLyBMYSBtYXhpbWEgZGlzdGFuY2lhIGVzIGRlIG1lZGlvIGNpcmN1bG8geSBlbiB0ZXJtaW5vcyBub3JtYWxpemFkb3MgZXMgMC41XFxuICAgIC8vIENyZWFtb3MgdW5hIHZhcmlhYmxlIHF1ZSBub3JtYWxpY2UgZXNlIHZhbG9yIGVudHJlIDAgeSAxLlxcbiAgICBmbG9hdCBwdWxzZVN0cmVuZ3RoTm9ybSAgPSBkaXN0QW5nbGVOb3JtKjIuOyBcXG5cXG4gICAgZmxvYXQgcGljbyA9IDAuOTI7XFxuICAgIHBpY28gPSBtaXgocGljbyowLjk5LCBwaWNvKjEuMDEsIGFfZ2VvMV9vcmJpdGFsLzEzLik7XFxuXFxuICAgIC8vIE5vcyBpbnRlcmVzYSBzb2xvIGVsIHBpY28sIGxhIHpvbmEgcXVlIHZhIGVudHJlIDAuOTUgeSAxLlxcbiAgICAvLyBUb29kbyBsbyBxdWUgaGF5YSBwb3IgZGViYWpvIGRlIDAuOTUgbG8gcGFzYW1vcyBhIDAuOTVcXG4gICAgLy8geSBsZSByZXN0YW1vcyBlc2UgbWlzbW8gMC45NSBwYXJhIHF1ZWRhcm5vcyBjb24gZWwgcGljbyBkZSAwLjA1IGVvbCBjdWFsIGFtcGxpZmljYW1vcyB4MjAgcGFyYSBub3JtYWxpemFybG8gKGRlIDAgYSAxKS5cXG4gICAgcHVsc2VTdHJlbmd0aE5vcm0gPSAoY2xhbXAocHVsc2VTdHJlbmd0aE5vcm0sIHBpY28sIDEuKS1waWNvKSoxMC47XFxuICAgIC8vLS1cXG4gICAgcmV0dXJuIHB1bHNlU3RyZW5ndGhOb3JtO1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIGZsb2F0IHB1bHNlU3RyZW5ndGhOb3JtMSA9IGdldF9wdWxzZVN0cmVuZ3RoTm9ybSgxLjUpO1xcbiAgICBmbG9hdCBwdWxzZVN0cmVuZ3RoTm9ybTIgPSBnZXRfcHVsc2VTdHJlbmd0aE5vcm0oLTEuKTtcXG5cXG4gICAgLy8gRGV0ZXJtaW5hbW9zIGVsIHRhbWHDsW8gZGVsIHB1bnRvIHRlbmllbmRvIHVuIG1pbmltbyBkZSA1IHkgYW1wbGlmaWNhbmRvIGVsIG1heGltbyBwYXJhIHF1ZSB2aXN1YWxtZW50ZSBzZWEgYm9uaXRvXFxuICAgIC8vZmxvYXQgc2l6ZSA9IDUuKyhwdWxzZVN0cmVuZ3RoTm9ybSoxNS4qbG9uZ1BlcmlvZCk7XFxuICAgIGZsb2F0IHNpemUgPSA1LjtcXG4gICAgc2l6ZSArPSAocHVsc2VTdHJlbmd0aE5vcm0xKjUuKTtcXG4gICAgc2l6ZSArPSAocHVsc2VTdHJlbmd0aE5vcm0yKjUuKTtcXG4gICAgc2l6ZSAqPSB1UmVzcG9uc2l2ZVNjYWxlO1xcblxcbiAgICBmbG9hdCBhbmd1bG9SYWRfdGltZSA9IDAuO1xcblxcbiAgICBpZihhYnMoYV9nZW8xX29yYml0YWwtNi4pIDwgMC41KXsgLy8gRGV0ZWN0YSBlbCBvcmJpdGFsIDZcXG4gICAgICAgIGFuZ3Vsb1JhZF90aW1lID0gYV9nZW8xX2FuZ3Vsb1JhZCt1Um90YXRpb24xO1xcbiAgICB9ZWxzZSBpZihhYnMoYV9nZW8xX29yYml0YWwtMTAuKSA8IDAuNSl7IC8vIERldGVjdGEgZWwgb3JiaXRhbCAxMVxcbiAgICAgICAgYW5ndWxvUmFkX3RpbWUgPSBhX2dlbzFfYW5ndWxvUmFkK3VSb3RhdGlvbjI7XFxuICAgIH1lbHNlIGlmKGFicyhhX2dlbzFfb3JiaXRhbC0xNC4pIDwgMC41KXsgLy8gRGV0ZWN0YSBlbCBvcmJpdGFsIDEzXFxuICAgICAgICBhbmd1bG9SYWRfdGltZSA9IGFfZ2VvMV9hbmd1bG9SYWQrdVJvdGF0aW9uMztcXG4gICAgfVxcbiAgICBcXG4gICAgLy9mbG9hdCBhbmd1bG9SYWRfdGltZSA9IGFfZ2VvMV9hbmd1bG9SYWQrKGRpcmVjdGlvbipzaW4odVRpbWUrYV9nZW8xX29yYml0YWwpKjAuMik7XFxuICAgIHZlYzMgcG9zMSA9IGdldF9wb3MxKGFuZ3Vsb1JhZF90aW1lKTtcXG4gICAgcG9zMSAqPSAyLjtcXG4gICAgLy9wb3MxICo9IDEuKyh1U2Nyb2xsRGVsdGEqMC4yKTtcXG4gICAgcG9zMSAqPSB1UmVzcG9uc2l2ZVNjYWxlO1xcbiAgICAvL3ZlYzMgcG9zMiA9IHBvczEqMS4wO1xcbiAgICAvL3BvczE9IG1peChwb3MxLCBwb3MyLCBwdWxzZVN0cmVuZ3RoTm9ybSk7XFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyBWRVJURVhcXG4gICAgdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zMSwgMS4wICk7XFxuICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxuICAgIGdsX1BvaW50U2l6ZSA9IHNpemUqKHVDYW1hcmFEaXN0YW5jZS8tbXZQb3NpdGlvbi56KTtcXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgLy8gVkFSWUlOR1M6XFxuICAgIHZfYW5nbGVSYWQgPSBhbmd1bG9SYWRfdGltZTtcXG4gICAgdl9jb2xvciA9IGFfZ2VvMV9jb2xvcjsgXFxuICAgIHZfcHVsc2VTdHJlbmd0aE5vcm0xID0gcHVsc2VTdHJlbmd0aE5vcm0xOyBcXG4gICAgdl9wdWxzZVN0cmVuZ3RoTm9ybTIgPSBwdWxzZVN0cmVuZ3RoTm9ybTI7IFxcblxcbn1cXG5cXG5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIiNkZWZpbmUgR0xTTElGWSAxXFxudW5pZm9ybSB2ZWMzIHVDb2xvcjE7XFxudW5pZm9ybSB2ZWMzIHVDb2xvcjI7XFxuXFxudmFyeWluZyBmbG9hdCB2X2FuZ2xlUmFkO1xcbnZhcnlpbmcgdmVjMyB2X2NvbG9yO1xcbnZhcnlpbmcgZmxvYXQgdl9wdWxzZVN0cmVuZ3RoTm9ybTE7XFxudmFyeWluZyBmbG9hdCB2X3B1bHNlU3RyZW5ndGhOb3JtMjtcXG5cXG4jZGVmaW5lIFBJIDMuMTQxNTkyNjUzOFxcblxcbmZsb2F0IGNpcmN1bGl6YXIoZmxvYXQgcmFkaW8pe1xcbiAgICAvLyByYWRpbyBlcyB1biB2YWxvciBlbnRyZSAwIHkgMS4gMCBlcyAwIGRlIHJhZGlvIHkgMSBlcyBlbCBtYXhpbW8gZGVsIHJhZGlvIGRlbnRybyBkZVxcbiAgICByYWRpbyA9IDEuMC0oMC41KnJhZGlvKTtcXG4gICAgZmxvYXQgcmVzdWx0ID0gZGlzdGFuY2UoZ2xfUG9pbnRDb29yZCwgdmVjMigwLjUsIDAuNSkpO1xcbiAgICByZXN1bHQgPSAxLiAtcmVzdWx0O1xcbiAgICByZXN1bHQgPSBwb3cocmVzdWx0LCAxLik7XFxuICAgIHJlc3VsdCA9IHN0ZXAocmFkaW8sIHJlc3VsdCk7XFxuICAgIHJldHVybiByZXN1bHQ7XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMyB3aGl0ZSA9IHZlYzMoMS4sIDEuLCAxLik7XFxuICAgIGZsb2F0IHB1bHNlID0gdl9wdWxzZVN0cmVuZ3RoTm9ybTErdl9wdWxzZVN0cmVuZ3RoTm9ybTI7XFxuICAgIHB1bHNlID0gY2xhbXAocHVsc2UsIDAuLCAxLik7XFxuICAgIHZlYzMgZmluYWxDb2xvciA9IHZfY29sb3I7XFxuICAgIC8vZmluYWxDb2xvciA9IG1peChmaW5hbENvbG9yLCB3aGl0ZSwgcHVsc2UqNS4pO1xcbiAgICAvL2ZpbmFsQ29sb3IgPSBtaXgoZmluYWxDb2xvciwgd2hpdGUsIDAuKTtcXG4gICAgZmxvYXQgYWxwaGEgPSBjaXJjdWxpemFyKDEuMCk7XFxuXFxuICAgIGZsb2F0IG1vZF9hbmdsZVJhZCA9IG1vZCh2X2FuZ2xlUmFkLCAoMi4qUEkpKTtcXG4gICAgZmxvYXQgaGVtaXNwaGVyZSA9IHN0ZXAoUEksIG1vZF9hbmdsZVJhZCk7XFxuXFxuICAgIGZpbmFsQ29sb3IgPSBtaXgodUNvbG9yMSwgdUNvbG9yMiwgaGVtaXNwaGVyZSk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoZmluYWxDb2xvciwgYWxwaGEqMC44KTtcXG59XCI7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tIFwidGhyZWVcIjsgLy9pbXBvcnQgZ3NhcCBmcm9tIFwiZ3NhcFwiXG5cbmltcG9ydCBFYXNlZE91dFZhbHVlIGZyb20gJy4uL0Vhc2VkT3V0VmFsdWUnO1xuaW1wb3J0IEhvbWUyR2VvbWV0cnkgZnJvbSAnLi9Ib21lMkdlb21ldHJ5JztcbmltcG9ydCB2ZXJ0ZXggZnJvbSBcIi4vc2hhZGVycy9ob21lMl9kb3RzX3ZlcnRleC5nbHNsXCI7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSBcIi4vc2hhZGVycy9ob21lMl9kb3RzX2ZyYWdtZW50Lmdsc2xcIjtcblxudmFyIEhvbWUyRG90cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEhvbWUyRG90cyhvYmopIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSG9tZTJEb3RzKTtcblxuICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTJEb3RzLkNPTlNUUlVDVE9SQSkhXCIpXG4gICAgLy9jb25zb2xlLmxvZyhvYmopXG4gICAgdGhpcy53b3JsZEdMID0gb2JqLndvcmxkR0w7IC8vLS1cblxuICAgIHRoaXMuc2NlbmUgPSB0aGlzLndvcmxkR0wuc2NlbmU7XG4gICAgdGhpcy5jYW1lcmFEaXN0YW5jZSA9IHRoaXMud29ybGRHTC5jYW1lcmFEaXN0YW5jZTsgLy8tLVxuXG4gICAgdGhpcy5tYXRlcmlhbCA9IG51bGw7XG4gICAgdGhpcy5nZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5tZXNoID0gbnVsbDtcbiAgICB0aGlzLm51bVBhcnRpY2xlcyA9IG51bGw7XG4gICAgdGhpcy5jcmVhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5jbG9jayA9IG5ldyBUSFJFRS5DbG9jaygpOyAvLy0tXG5cbiAgICB0aGlzLmVhc2VkX3Njcm9sbERlbHRhID0gbmV3IEVhc2VkT3V0VmFsdWUodGhpcy53b3JsZEdMLnNldHRpbmdzLnNjcm9sbF9ub3JtYWxpemVkRGVsdGEgKiAwLjUsIDAuMDEpO1xuICAgIHRoaXMuZWVhc2VkX3Njcm9sbERlbHRhX2Zhc3QgPSBuZXcgRWFzZWRPdXRWYWx1ZSh0aGlzLndvcmxkR0wuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSAqIDAuNSwgMC4xKTsgLy8tLVxuXG4gICAgdGhpcy5fc2V0dXBfc2V0dGluZ3MoKTsgLy8tLVxuXG5cbiAgICB0aGlzLm9yYml0YWxfZ2VvbWV0cnkgPSBuZXcgSG9tZTJHZW9tZXRyeSh0aGlzLnNldHRpbmdzKTsgLy8tLVxuICAgIC8vLS1cbiAgICAvL3RoaXMuX2NyZWF0ZWN1YmUodGhpcy5zY2VuZSlcblxuICAgIHRoaXMuX2NyZWF0ZSgpO1xuXG4gICAgdGhpcy5yZXNpemUoKTtcbiAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQVUJMSUNBUzogXG5cblxuICBfY3JlYXRlQ2xhc3MoSG9tZTJEb3RzLCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgaWYgKHRoaXMuY3JlYXRlZCkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVUaW1lLnZhbHVlID0gdGhpcy5jbG9jay5nZXRFbGFwc2VkVGltZSgpO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVDYW1hcmFEaXN0YW5jZS52YWx1ZSA9IHRoaXMud29ybGRHTC5jYW1lcmFEaXN0YW5jZTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51UmVzcG9uc2l2ZVNjYWxlLnZhbHVlID0gdGhpcy53b3JsZEdMLnJlc3BvbnNpdmVTY2FsZTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51U2Nyb2xsRGVsdGEudmFsdWUgPSAtdGhpcy5lZWFzZWRfc2Nyb2xsRGVsdGFfZmFzdC5nZXQodGhpcy53b3JsZEdMLnNldHRpbmdzLnNjcm9sbF9ub3JtYWxpemVkRGVsdGEgKiAwLjUpOyAvLy0tXG5cbiAgICAgICAgdmFyIGV4dHJhU3BlZWQgPSAxICsgTWF0aC5hYnModGhpcy5lZWFzZWRfc2Nyb2xsRGVsdGFfZmFzdC5nZXQodGhpcy53b3JsZEdMLnNldHRpbmdzLnNjcm9sbF9ub3JtYWxpemVkRGVsdGEgKiAwLjUpICogMTApO1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJvdGF0aW9uMSArPSB0aGlzLnNldHRpbmdzLnNwZWVkUm90YXRpb24xICogZXh0cmFTcGVlZDtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5yb3RhdGlvbjIgKz0gdGhpcy5zZXR0aW5ncy5zcGVlZFJvdGF0aW9uMiAqIGV4dHJhU3BlZWQ7XG4gICAgICAgIHRoaXMuc2V0dGluZ3Mucm90YXRpb24zICs9IHRoaXMuc2V0dGluZ3Muc3BlZWRSb3RhdGlvbjMgKiBleHRyYVNwZWVkO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVSb3RhdGlvbjEudmFsdWUgPSB0aGlzLnNldHRpbmdzLnJvdGF0aW9uMTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Um90YXRpb24yLnZhbHVlID0gLXRoaXMuc2V0dGluZ3Mucm90YXRpb24yO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVSb3RhdGlvbjMudmFsdWUgPSB0aGlzLnNldHRpbmdzLnJvdGF0aW9uMztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWUyRG90cy5yZXNpemUpIVwiKVxuICAgICAgaWYgKHRoaXMubWVzaCkge1xuICAgICAgICB0aGlzLm1lc2gucG9zaXRpb24uc2V0WCh0aGlzLndvcmxkR0wud2lkdGggLyAyKTtcbiAgICAgIH1cbiAgICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUFJJVkFEQVM6IFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldHVwX3NldHRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cF9zZXR0aW5ncygpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTJEb3RzLl9zZXR1cF9zZXR0aW5ncykhXCIpXG4gICAgICB2YXIgc3BlZWRCYXNlID0gMC4wMDI7XG4gICAgICB0aGlzLnNldHRpbmdzID0ge1xuICAgICAgICBmYWN0b3I6IDYsXG4gICAgICAgIGluY3JfcmFkaW86IDI1LFxuICAgICAgICBudW1PcmJpdHM6IDI2LFxuICAgICAgICAvL2FycmF5T3JiaXRzOiBbMTIsIDE5LCAyNl1cbiAgICAgICAgYXJyYXlPcmJpdHM6IFs2LCAxMCwgMTRdLFxuICAgICAgICAvLyBPcnRiaXQgcm90YXRpb25cbiAgICAgICAgcm90YXRpb24xOiAwLFxuICAgICAgICBzcGVlZFJvdGF0aW9uMTogMyAqIHNwZWVkQmFzZSxcbiAgICAgICAgcm90YXRpb24yOiAyLFxuICAgICAgICBzcGVlZFJvdGF0aW9uMjogMiAqIHNwZWVkQmFzZSxcbiAgICAgICAgcm90YXRpb24zOiAwLFxuICAgICAgICBzcGVlZFJvdGF0aW9uMzogMSAqIHNwZWVkQmFzZVxuICAgICAgfTtcbiAgICAgIHRoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhciA9IHRoaXMuX2dldF9hcnJheV90cmlhbmd1bGFyKHRoaXMuc2V0dGluZ3MuZmFjdG9yLCB0aGlzLnNldHRpbmdzLm51bU9yYml0cyk7XG4gICAgICB0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YSA9IHRoaXMuX2dldF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEodGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyLCB0aGlzLnNldHRpbmdzLmFycmF5T3JiaXRzKTtcbiAgICAgIHRoaXMuc2V0dGluZ3MuYXJyYXlfZG90UG9zID0gdGhpcy5fZ2V0X2FycmF5X2RvdFBvcyh0aGlzLnNldHRpbmdzLmFycmF5T3JiaXRzLCB0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXIsIHRoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhKTtcbiAgICAgIHRoaXMuc2V0dGluZ3MubnVtRG90cyA9IHRoaXMuc2V0dGluZ3MuYXJyYXlfZG90UG9zLmxlbmd0aDsgLy90aGlzLnNldHRpbmdzLm51bURvdHMgPSB0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXJbdGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyLmxlbmd0aC0xXVxuICAgICAgLy9jb25zb2xlLmxvZyhcInRoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhcjogXCIrdGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyKVxuICAgICAgLy9jb25zb2xlLmxvZyhcInRoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhOiBcIit0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YSlcbiAgICAgIC8vY29uc29sZS5sb2coXCJ0aGlzLnNldHRpbmdzLm51bURvdHM6IFwiK3RoaXMuc2V0dGluZ3MubnVtRG90cylcbiAgICAgIC8vY29uc29sZS5sb2coXCJ0aGlzLnNldHRpbmdzLmFycmF5T3JiaXRzOiBcIit0aGlzLnNldHRpbmdzLmFycmF5T3JiaXRzKVxuICAgICAgLy9jb25zb2xlLmxvZyhcInRoaXMuc2V0dGluZ3MuYXJyYXlfZG90UG9zOiBcIit0aGlzLnNldHRpbmdzLmFycmF5X2RvdFBvcylcbiAgICAgIC8vY29uc29sZS5sb2coXCJ0aGlzLnNldHRpbmdzLmFycmF5X2RvdFBvcy5sZW5ndGg6IFwiK3RoaXMuc2V0dGluZ3MuYXJyYXlfZG90UG9zLmxlbmd0aClcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lMkRvdHMuX2NyZWF0ZSkhXCIpXG4gICAgICAvLy0tXG4gICAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICAgIC8vYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcsXG4gICAgICAgIHZlcnRleENvbG9yczogdHJ1ZSxcbiAgICAgICAgdmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgdUNvbG9yMToge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweGU4NDM3MSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVDb2xvcjI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoMHgwMDdlZmYpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Q2FtYXJhRGlzdGFuY2U6IHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLndvcmxkR0wuY2FtZXJhRGlzdGFuY2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVUaW1lOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVNjcm9sbERlbHRhOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVJlc3BvbnNpdmVTY2FsZToge1xuICAgICAgICAgICAgdmFsdWU6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVSb3RhdGlvbjE6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Um90YXRpb24yOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVJvdGF0aW9uMzoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLy0tXG4gICAgICAvL2NvbnNvbGUubG9nKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfY29sb3IpXG4gICAgICAvLy0tXG5cbiAgICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9wb3NpY2lvbmVzLCAzKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXMsIDMpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfY29sb3IsIDMpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfb3JiaXRhbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9vcmJpdGFsLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX3Bvc19vcmJpdGEnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfcG9zX29yYml0YSwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9pbmNyX2FuZ3Vsb1JhZCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9pbmNyX2FuZ3Vsb1JhZCwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9hbmd1bG9SYWQnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfYW5ndWxvUmFkLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX3JhZGlvJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3JhZGlvLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX2RpcicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9kaXIsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfaW5jcicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9pbmNyLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX3gnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfeCwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV95JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3ksIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfeicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV96LCAxKSk7XG4gICAgICB0aGlzLm1lc2ggPSBuZXcgVEhSRUUuUG9pbnRzKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgICAgdGhpcy5zY2VuZS5hZGQodGhpcy5tZXNoKTsgLy8tLS0tLS0tLS1cblxuICAgICAgLypcbiAgICAgIHRoaXMubWF0ZXJpYWwyID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgICAgICBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyxcbiAgICAgICAgICB2ZXJ0ZXhDb2xvcnM6IHRydWUsXG4gICAgICAgICAgdmVydGV4U2hhZGVyOiB2ZXJ0ZXhfYmcsIFxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudF9iZyxcbiAgICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgICB1Q2FtYXJhRGlzdGFuY2U6IHt2YWx1ZTogdGhpcy53b3JsZEdMLmNhbWVyYURpc3RhbmNlfSxcbiAgICAgICAgICAgICAgdVRpbWU6IHt2YWx1ZTogMH0sXG4gICAgICAgICAgICAgIHVTY2FsZTp7dmFsdWU6IDEuNX1cbiAgICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdGhpcy5tZXNoMiA9IG5ldyBUSFJFRS5Qb2ludHModGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbDIpXG4gICAgICB0aGlzLm1lc2gyLnBvc2l0aW9uLnogPS0xXG4gICAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLm1lc2gyKVxuICAgICAgKi9cbiAgICAgIC8vLS0tLS0tLS0tXG5cbiAgICAgIHRoaXMuY3JlYXRlZCA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRfYXJyYXlfZG90UG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfYXJyYXlfZG90UG9zKF9hcnJheU9yYml0cywgX2FycmF5X3RyaWFuZ3VsYXIsIF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEpIHtcbiAgICAgIHZhciBtaUFycmF5ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2FycmF5T3JiaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvcmJpdE51bSA9IF9hcnJheU9yYml0c1tpXTtcbiAgICAgICAgdmFyIGRvdHNfeF9vcmJpdCA9IF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGFbaV07XG4gICAgICAgIHZhciBkb3ROdW1fYmFzZSA9IF9hcnJheV90cmlhbmd1bGFyW19hcnJheU9yYml0c1tpXSAtIDFdOyAvLyBjb25zb2xlLmxvZyhcIm9yYml0TnVtOiBcIitvcmJpdE51bSlcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJkb3RzX3hfb3JiaXQ6IFwiK2RvdHNfeF9vcmJpdClcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJkb3ROdW1fYmFzZTogXCIrZG90TnVtX2Jhc2UpXG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb3RzX3hfb3JiaXQ7IGorKykge1xuICAgICAgICAgIG1pQXJyYXkucHVzaChkb3ROdW1fYmFzZSArIGogKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWlBcnJheTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldF9udW1Eb3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfbnVtRG90cyhfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhKSB7XG4gICAgICB2YXIgbnVtRG90cyA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIG51bURvdHMgKz0gX2FycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YVtpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bURvdHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhKF9hcnJheV90cmlhbmd1bGFyLCBfYXJyYXlPcmJpdHMpIHtcbiAgICAgIC8vIEdlbmVyYSB1bmEgYXJyYXkgYmFzYWRhIGVuIGxhIHByb2dyZXNpw7NuIHRyaWFuZ3VsYXIgKCogZmFjdG9yKS5cbiAgICAgIC8vIC4uLiBkb25kZSBzZSBpbmRpY2EgZWwgbnVtZXJvIGRlIGRvdHMgcG9yIG9yYml0YWxcbiAgICAgIC8vIFVuYSBwcm9ncmVzacOzbiB0cmlhbmd1bGFyIGVzOiAxLCAzLCA2LCAxMCwgMTUgKGh0dHBzOi8vc2lnbmlmaWNhdGl2YS5vcmcvZGljY2lvbmFyaW9zL251bWVyb3MtZmlndXJhZG9zLyM6fjp0ZXh0PTMuMS4xLjEuLSxEZWZpbmljaSVDMyVCM24sYW50ZXJpb3IlMjBubyUyMG9idGVuZW1vcyUyMHVuYSUyMGNvbnN0YW50ZS4pXG4gICAgICB2YXIgbWlBcnJheSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBfYXJyYXlPcmJpdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIC8vYXJyYXlfbnVtVHJpYWd1bGFyZXMucHVzaChpKihpKzEpLzIpXG4gICAgICAgIHZhciBudW1Eb3RzX29yYml0YV9hY3R1YWwgPSBfYXJyYXlfdHJpYW5ndWxhcltfYXJyYXlPcmJpdHNbaV1dO1xuICAgICAgICB2YXIgbnVtRG90c19vcmJpdGFfYW50ZXJpb3IgPSBfYXJyYXlfdHJpYW5ndWxhcltfYXJyYXlPcmJpdHNbaV0gLSAxXTtcbiAgICAgICAgdmFyIG51bURvdHNfb3JiaXRhID0gbnVtRG90c19vcmJpdGFfYWN0dWFsIC0gbnVtRG90c19vcmJpdGFfYW50ZXJpb3I7XG4gICAgICAgIG1pQXJyYXkucHVzaChudW1Eb3RzX29yYml0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaUFycmF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0X2FycmF5X3RyaWFuZ3VsYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9hcnJheV90cmlhbmd1bGFyKF9mYWN0b3IsIF9udW1PYml0cykge1xuICAgICAgLy8gR2VuZXJhIHVuYSBhcnJheSBkZSBwcm9ncmVzacOzbiB0cmlhbmd1bGFyICgqIGZhY3RvcikuXG4gICAgICAvLyBVbmEgcHJvZ3Jlc2nDs24gdHJpYW5ndWxhciBlczogMSwgMywgNiwgMTAsIDE1IChodHRwczovL3NpZ25pZmljYXRpdmEub3JnL2RpY2Npb25hcmlvcy9udW1lcm9zLWZpZ3VyYWRvcy8jOn46dGV4dD0zLjEuMS4xLi0sRGVmaW5pY2klQzMlQjNuLGFudGVyaW9yJTIwbm8lMjBvYnRlbmVtb3MlMjB1bmElMjBjb25zdGFudGUuKVxuICAgICAgdmFyIG1pQXJyYXkgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gX251bU9iaXRzOyBpKyspIHtcbiAgICAgICAgLy9hcnJheV9udW1UcmlhZ3VsYXJlcy5wdXNoKGkqKGkrMSkvMilcbiAgICAgICAgbWlBcnJheS5wdXNoKGkgKiAoaSArIDEpIC8gMiAqIF9mYWN0b3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWlBcnJheTtcbiAgICB9XG4gICAgLyogXG4gICAgX2NyZWF0ZWN1YmUoX3NjZW5lKXtcbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMTAwLDEwMCwxMDApO1xuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7Y29sb3I6IDB4ZmYwMDAwfSk7XG4gICAgICAgIGNvbnN0IGN1YmUgPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSxtYXRlcmlhbCk7XG4gICAgICAgIF9zY2VuZS5hZGQoY3ViZSk7XG4gICAgfVxuICAgICovXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIH1dKTtcblxuICByZXR1cm4gSG9tZTJEb3RzO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBIb21lMkRvdHM7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vLyhmdW5jdGlvbigpe3ZhciBzY3JpcHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7c2NyaXB0Lm9ubG9hZD1mdW5jdGlvbigpe3ZhciBzdGF0cz1uZXcgU3RhdHMoKTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXRzLmRvbSk7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGxvb3AoKXtzdGF0cy51cGRhdGUoKTtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCl9KTt9O3NjcmlwdC5zcmM9Jy8vY2RuLmpzZGVsaXZyLm5ldC9naC9LZXZuei9zdGF0cy5qcy9idWlsZC9zdGF0cy5taW4uanMnO2RvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTt9KSgpXG5pbXBvcnQgeyBPcmJpdENvbnRyb2xzIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2NvbnRyb2xzL09yYml0Q29udHJvbHMnO1xuaW1wb3J0ICogYXMgZGF0IGZyb20gXCJkYXQuZ3VpXCI7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgZ3NhcCBmcm9tICdnc2FwJztcbmltcG9ydCBTY3JvbGxUcmlnZ2VyIGZyb20gJ2dzYXAvU2Nyb2xsVHJpZ2dlcic7XG5pbXBvcnQgV2ViR0xVdGlscyBmcm9tICcuLi9XZWJHTFV0aWxzJztcbmltcG9ydCBIb21lMkRvdHMgZnJvbSAnLi9Ib21lMkRvdHMnO1xuXG52YXIgSG9tZTJBcHAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIb21lMkFwcChvYmopIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSG9tZTJBcHApO1xuXG4gICAgLy9jb25zb2xlLmxvZyhcIihIb21lMkFwcC5DT05TVFJVQ1RPUkEpISFcIiwgb2JqKSBcbiAgICB0aGlzLmh3X3JlbmRlcmVyID0gb2JqLnJlbmRlcmVyOyAvLyBSZWRlcmVyL3BhZ2luYSBkZSBIaWdoV2F5LiBObyBjb25mdW5kaXIgY29uIGVsIHJlbmRlci9yZW5kZXJlciBkZSBUaHJlZS5qc1xuXG4gICAgdGhpcy4kY29udGFpbmVyID0gb2JqLmRvbUVsZW1lbnQ7IC8vLS1cblxuICAgIHRoaXMuJHNlcnZpY2VzID0gdGhpcy5od19yZW5kZXJlci4kc2VydmljZXM7XG4gICAgdGhpcy4kaW5uZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW5uZXInKTsgLy8tLVxuXG4gICAgdGhpcy53aWR0aCA9IHRoaXMuJGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuJGNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7IC8vLS1cblxuICAgIHRoaXMucmVmUmVzb2x1dGlvbiA9IDE5MjA7XG4gICAgdGhpcy5yZXNwb25zaXZlU2NhbGUgPSB0aGlzLndpZHRoIC8gdGhpcy5yZWZSZXNvbHV0aW9uOyAvLy0tXG5cbiAgICB0aGlzLmNhbWVyYURpc3RhbmNlID0gNTAwOyAvLy0tXG5cbiAgICB0aGlzLnNldHRpbmdzID0ge1xuICAgICAgc2Nyb2xsX2xhc3RJbm5lclk6IDAsXG4gICAgICAvLyBVbHRpbWEgcG9zaWNpw7NuIGRlbCBlbGVtZW50byBkZSByZWZlcmVuY2lhXG4gICAgICBzY3JvbGxfZGVsdGE6IDAsXG4gICAgICAvLyBJbmNyZW1lbnRvIGRlIHBpeGVscyBkZWwgc2Nyb2xsXG4gICAgICBzY3JvbGxfbGltaXRlZERlbHRhOiAwLFxuICAgICAgLy8gTGltaXRhIGxvcyB2YWxvcmVzIGEgLTIwIC0+ICsyMFxuICAgICAgc2Nyb2xsX25vcm1hbGl6ZWREZWx0YTogMCxcbiAgICAgIC8vIFBhc2EgZWwgZGVsdGEgYSAtMSAtPiArMVxuICAgICAgc2Nyb2xsX2ZhY3RvcmREZWx0YTogMSxcbiAgICAgIC8vIFZhbG9yZXMgYWJzb2x1dG9zIGRlIDAgLT4gMVxuICAgICAgc2Nyb2xsX2RpcmVjdGlvbjogMSAvLyBEaXJlY2Npb24gZGVsIGRlbHRhLiAxIHNpIGVzdMOhIHBhcmFkb1xuXG4gICAgfTsgLy8tLVxuICAgIC8vIFNjZW5lXG5cbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7IC8vLS1cbiAgICAvLyBDYW1lcmFcbiAgICAvL1BlcnNwZWN0aXZlQ2FtZXJhKCBmb3YgOiBOdW1iZXIsIGFzcGVjdCA6IE51bWJlciwgbmVhciA6IE51bWJlciwgZmFyIDogTnVtYmVyIClcblxuICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDMwLCB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQsIDAuMSwgMjAwMCk7XG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueiA9IHRoaXMuY2FtZXJhRGlzdGFuY2U7XG4gICAgdGhpcy5jYW1lcmEuZm92ID0gMiAqIE1hdGguYXRhbih0aGlzLmhlaWdodCAvIDIgLyB0aGlzLmNhbWVyYURpc3RhbmNlKSAqICgxODAgLyBNYXRoLlBJKTsgLy8tLVxuICAgIC8vIFJlbmRlcmVyXG5cbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMMVJlbmRlcmVyKHtcbiAgICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlOyAvLyBWYW1vcyBhIHVzYXIgMiBzY2VuYXMgKHVuYSBwYXJhIGVsIGJhY2tncm91bmQgeSBvdHJhIHBhcmEgbG9zIHB1bnRvcykgcXVlIGltcGxpY2Fyw6FuIHVzYXIgMiBhY2Npb25lcyBkZSByZW5kZXIuIENvbiBhdXRvY2xlYXIgZmFsc2UgcGVybWl0aW1vcyBxdWUgbGEgc2VndW5kYSBubyBib3JyZSBsYSBwcmltZXJhLlxuICAgIC8vY29uc29sZS5sb2coXCJ3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAob3JpZ2luYWwpOiBcIit3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbylcblxuICAgIHRoaXMucmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyhNYXRoLm1pbih3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgMSkpOyAvL2NvbnNvbGUubG9nKFwid2luZG93LmRldmljZVBpeGVsUmF0aW8gKGZpbHRyYWRvKTogXCIrd2luZG93LmRldmljZVBpeGVsUmF0aW8pXG4gICAgLy9jb25zb2xlLmxvZyhcIldlYkdMMj86IFwiK3RoaXMucmVuZGVyZXIuY2FwYWJpbGl0aWVzLmlzV2ViR0wyKVxuICAgIC8vLS1cbiAgICAvL3RoaXMuY29udHJvbHMgPSBuZXcgT3JiaXRDb250cm9scyggdGhpcy5jYW1lcmEsIHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCApO1xuICAgIC8vIHRoaXMuY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+e1xuICAgIC8vICAgICB0aGlzLm9uQ2FtZXJhUG9zaXRpb25DaGFuZ2UoZSlcbiAgICAvLyB9KTtcbiAgICAvLy0tXG5cbiAgICB0aGlzLiRjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTsgLy8tLVxuICAgIC8vIHRoaXMuYmFja2dyb3VuZCA9IG5ldyBIb21lMkFwcF9iYWNrZ3JvdW5kKHtcbiAgICAvLyAgICAgd29ybGRHTDp0aGlzLFxuICAgIC8vIH0pXG4gICAgLy8tLVxuXG4gICAgdGhpcy5kb3RzID0gbmV3IEhvbWUyRG90cyh7XG4gICAgICB3b3JsZEdMOiB0aGlzXG4gICAgfSk7IC8vLS1cblxuICAgIHRoaXMuX3Jlc2l6ZSgpOyAvL3RoaXMuX3JlbmRlcigpO1xuICAgIC8vdGhpcy5faW5pdF9zY3JvbGxMaXN0ZW5lcnMoKVxuXG4gIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUFVCTElDQVM6XG5cblxuICBfY3JlYXRlQ2xhc3MoSG9tZTJBcHAsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuX2luaXRfc2Nyb2xsTGlzdGVuZXJzKCk7XG5cbiAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJraWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKFNvbHV0aW9uczFBcHAua2lsbCkhXCIpIFxuICAgICAgdGhpcy50cmlnZ2VyLmtpbGwoKTtcbiAgICAgIGdzYXAudGlja2VyLnJlbW92ZSh0aGlzLl9iaW5kZWRfcmVuZGVyKTtcbiAgICAgIGdzYXAudGlja2VyLnJlbW92ZSh0aGlzLl9iaW5kZWRfZXZhbF9zY3JvbGwpO1xuICAgICAgdGhpcy5kb3RzID0gbnVsbDtcbiAgICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgfSwge1xuICAgIGtleTogXCJvblJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTFBcHAub25SZXNpemUpIVwiKVxuICAgICAgdGhpcy5fcmVzaXplKCk7XG4gICAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFBSSVZBREFTOlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRfc2Nyb2xsTGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0X3Njcm9sbExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBiaW5kZWRfcmVuZGVyID0gZnVuY3Rpb24gYmluZGVkX3JlbmRlcigpIHtcbiAgICAgICAgX3RoaXMuX3JlbmRlcigpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGJpbmRlZF9ldmFsX3Njcm9sbCA9IGZ1bmN0aW9uIGJpbmRlZF9ldmFsX3Njcm9sbCgpIHtcbiAgICAgICAgX3RoaXMuX2V2YWxfc2Nyb2xsKF90aGlzLnRyaWdnZXIucHJvZ3Jlc3MpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fYmluZGVkX3JlbmRlciA9IGJpbmRlZF9yZW5kZXI7XG4gICAgICB0aGlzLl9iaW5kZWRfZXZhbF9zY3JvbGwgPSBiaW5kZWRfZXZhbF9zY3JvbGw7XG4gICAgICB0aGlzLnRyaWdnZXIgPSBTY3JvbGxUcmlnZ2VyLmNyZWF0ZSh7XG4gICAgICAgIHRyaWdnZXI6IHRoaXMuJHNlcnZpY2VzLFxuICAgICAgICBzdGFydDogJ3RvcCBib3R0b20nLFxuICAgICAgICBlbmQ6ICdib3R0b20gdG9wJyxcbiAgICAgICAgc2NydWI6IHRydWUsXG4gICAgICAgIC8vIFNjcnViOiBHZW5lcmEgZXZlbnRvcyBlbiB1bmEgZnJhbmphIG1hcyBxdWUgZW4gdW4gcHVudG8uXG4gICAgICAgIC8vIG1hcmtlcnM6IHRydWUsXG4gICAgICAgIG9uVG9nZ2xlOiBmdW5jdGlvbiBvblRvZ2dsZShzZWxmKSB7XG4gICAgICAgICAgaWYgKHNlbGYuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIGdzYXAudGlja2VyLmFkZChiaW5kZWRfcmVuZGVyKTtcbiAgICAgICAgICAgIGdzYXAudGlja2VyLmFkZChiaW5kZWRfZXZhbF9zY3JvbGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnc2FwLnRpY2tlci5yZW1vdmUoYmluZGVkX3JlbmRlcik7XG4gICAgICAgICAgICBnc2FwLnRpY2tlci5yZW1vdmUoYmluZGVkX2V2YWxfc2Nyb2xsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZXZhbF9zY3JvbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2YWxfc2Nyb2xsKHByb2dyZXNzKSB7XG4gICAgICB2YXIgaW5uZXJEYXRhID0gdGhpcy4kaW5uZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgbmV3SW5uZXJZID0gaW5uZXJEYXRhLnk7XG4gICAgICB0aGlzLnNldHRpbmdzLnNjcm9sbF9kZWx0YSA9IG5ld0lubmVyWSAtIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX2xhc3RJbm5lclk7XG4gICAgICB0aGlzLnNldHRpbmdzLnNjcm9sbF9sYXN0SW5uZXJZID0gbmV3SW5uZXJZO1xuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfbGltaXRlZERlbHRhID0gV2ViR0xVdGlscy5jbGFtcCh0aGlzLnNldHRpbmdzLnNjcm9sbF9kZWx0YSwgLTIwLCAyMCk7IC8vIExpbWl0YSBsb3MgdmFsb3JlcyBhIC0yMCAtPiArMjBcblxuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfbm9ybWFsaXplZERlbHRhID0gKHRoaXMuc2V0dGluZ3Muc2Nyb2xsX2xpbWl0ZWREZWx0YSAvIDIwKS50b0ZpeGVkKDMpOyAvLyBQYXNhIGVsIGRlbHRhIGEgLTEgLT4gKzFcblxuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfZmFjdG9yZERlbHRhID0gTWF0aC5hYnModGhpcy5zZXR0aW5ncy5zY3JvbGxfbm9ybWFsaXplZERlbHRhKSArIDA7IC8vIFZhbG9yZXMgYWJzb2x1dG9zIGRlIDAgLT4gMVxuXG4gICAgICB0aGlzLnNldHRpbmdzLnNjcm9sbF9kaXJlY3Rpb24gPSAxO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5zY3JvbGxfbm9ybWFsaXplZERlbHRhIDwgMCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzLnNjcm9sbF9kaXJlY3Rpb24gPSAtMTtcbiAgICAgIH0gLy8gY29uc29sZS5sb2coXCJ0aGlzLnNldHRpbmdzLnNjcm9sbF9ub3JtYWxpemVkRGVsdGE6IFwiK3RoaXMuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSlcbiAgICAgIC8vY29uc29sZS5sb2coXCJ0aGlzLnNldHRpbmdzLnNjcm9sbF9mYWN0b3JkRGVsdGE6IFwiK3RoaXMuc2V0dGluZ3Muc2Nyb2xsX2ZhY3RvcmREZWx0YSlcblxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNpemUoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWUyQXBwLnJlc2l6ZSkhXCIpXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy4kY29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLiRjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgdGhpcy5yZXNwb25zaXZlU2NhbGUgPSB0aGlzLndpZHRoIC8gdGhpcy5yZWZSZXNvbHV0aW9uO1xuICAgICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMuY2FtZXJhLmFzcGVjdCA9IHRoaXMud2lkdGggLyB0aGlzLmhlaWdodDtcbiAgICAgIHRoaXMuY2FtZXJhRGlzdGFuY2UgPSB0aGlzLmNhbWVyYS5wb3NpdGlvbi56O1xuICAgICAgdGhpcy5jYW1lcmEuZm92ID0gMiAqIE1hdGguYXRhbih0aGlzLmhlaWdodCAvIDIgLyB0aGlzLmNhbWVyYURpc3RhbmNlKSAqICgxODAgLyBNYXRoLlBJKTsgLy8tLVxuXG4gICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7IC8vLS1cblxuICAgICAgaWYgKHRoaXMuZG90cykge1xuICAgICAgICB0aGlzLmRvdHMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lMkFwcC5fcmVuZGVyKSFcIilcbiAgICAgIGlmICh0aGlzLmhlaWdodCAhPSB0aGlzLiRjb250YWluZXIub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kb3RzKSB7XG4gICAgICAgIHRoaXMuZG90cy5yZW5kZXIoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpOyAvL3JlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXIuYmluZCh0aGlzKSlcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSG9tZTJBcHA7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IEhvbWUyQXBwOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8vaW1wb3J0ICogYXMgVEhSRUUgZnJvbSBcInRocmVlXCJcbi8vaW1wb3J0IGdzYXAgZnJvbSBcImdzYXBcIlxuLy9pbXBvcnQge0dMVEZMb2FkZXIsIEdMVExvYWRlcn0gZnJvbSBcInRocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0dMVEZMb2FkZXJcIlxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG52YXIgSG9tZTNHZW9tZXRyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoSG9tZTNHZW9tZXRyeSwgX0V2ZW50RW1pdHRlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihIb21lM0dlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBIb21lM0dlb21ldHJ5KG9iaikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIb21lM0dlb21ldHJ5KTtcblxuICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTNHZW9tZXRyeS5DT05TVFJVQ1RPUkEpIVwiKVxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7IC8vLS1cblxuICAgIF90aGlzLmZhY3RvciA9IG9iai5mYWN0b3I7IC8vNlxuXG4gICAgX3RoaXMuaW5jcl9yYWRpbyA9IG9iai5pbmNyX3JhZGlvOyAvLzI1XG5cbiAgICBfdGhpcy5udW1PcmJpdHMgPSBvYmoubnVtT3JiaXRzOyAvLzM3XG5cbiAgICBfdGhpcy5hcnJheV90cmlhbmd1bGFyID0gb2JqLmFycmF5X3RyaWFuZ3VsYXI7XG4gICAgX3RoaXMuYXJyYXlfZG90UG9zID0gb2JqLmFycmF5X2RvdFBvcztcbiAgICBfdGhpcy5udW1Eb3RzID0gb2JqLm51bURvdHM7IC8vLS1cblxuICAgIF90aGlzLmFycmF5Q29sb3Jlc19SR0IgPSBbXTtcbiAgICBfdGhpcy5hcnJheUNvbG9yZXNfUkdCXzAxID0gW107XG4gICAgX3RoaXMuY29sb3JQb3MgPSAwO1xuXG4gICAgX3RoaXMuX2luaXRfY29sb3JzKCk7IC8vLS1cblxuXG4gICAgX3RoaXMuYXR0cmlidXRlcyA9IHtcbiAgICAgIGFfcG9zaWNpb25lczogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMyksXG4gICAgICBhX2NvbG9yOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAzKSxcbiAgICAgIGFfb3JiaXRhbDogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX3Bvc19vcmJpdGE6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV9pbmNyX2FuZ3Vsb1JhZDogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX2FuZ3Vsb1JhZDogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX3JhZGlvOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfZGlyOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfaW5jcjogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX3g6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV95OiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfejogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSlcbiAgICB9OyAvLy0tXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLmFycmF5X2RvdFBvcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvdFBvcyA9IF90aGlzLmFycmF5X2RvdFBvc1tpXTtcblxuICAgICAgdmFyIGRvdCA9IF90aGlzLl9nZXRfZG90KGRvdFBvcyk7XG5cbiAgICAgIHZhciBpMyA9IGkgKiAzO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXNbaTNdID0gZG90Lng7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfcG9zaWNpb25lc1tpMyArIDFdID0gZG90Lnk7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfcG9zaWNpb25lc1tpMyArIDJdID0gZG90Lno7IC8vLS1cblxuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX2NvbG9yW2kzXSA9IGRvdC5jb2xvclswXTtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9jb2xvcltpMyArIDFdID0gZG90LmNvbG9yWzFdO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX2NvbG9yW2kzICsgMl0gPSBkb3QuY29sb3JbMl07IC8vLS1cblxuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX29yYml0YWxbaV0gPSBkb3Qub3JiaXRhbDtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9wb3Nfb3JiaXRhW2ldID0gZG90LnBvc19vcmJpdGE7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfaW5jcl9hbmd1bG9SYWRbaV0gPSBkb3QuaW5jcl9hbmd1bG9SYWQ7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfYW5ndWxvUmFkW2ldID0gZG90LmFuZ3Vsb1JhZDtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9yYWRpb1tpXSA9IGRvdC5yYWRpbztcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9kaXJbaV0gPSBkb3QuZGlyO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX2luY3JbaV0gPSBkb3QuaW5jcjtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV94W2ldID0gZG90Lnk7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfeVtpXSA9IGRvdC55O1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3pbaV0gPSBkb3QuejtcbiAgICB9IC8vLS1cblxuXG4gICAgX3RoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFBSSVZBREFTXG5cblxuICBfY3JlYXRlQ2xhc3MoSG9tZTNHZW9tZXRyeSwgW3tcbiAgICBrZXk6IFwiX2dldF9kb3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9kb3QobnVtKSB7XG4gICAgICAvLyBEZXZ1ZWx2ZSB1biBvYmpldG8gY29uIGxhIGluZm9ybWFjacOzbiBkZSB1biBwdW50byBkZSBsYSBnZW9tZXRyaWEgXCJvcmJpdGFsIE1JT1RJXCJcbiAgICAgIHZhciBvYmogPSB7XG4gICAgICAgIG51bTogbnVtLFxuICAgICAgICBjb2xvcjogdGhpcy5fZ2V0X2NvbG9yKCksXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHo6IDAsXG4gICAgICAgIG9yYml0YWw6IDAsXG4gICAgICAgIGNvX29yYml0YW50ZXM6IDAsXG4gICAgICAgIHBvc19vcmJpdGE6IDAsXG4gICAgICAgIGluY3JfYW5ndWxvUmFkOiAwLFxuICAgICAgICBhbmd1bG9SYWQ6IDAsXG4gICAgICAgIHJhZGlvOiAwXG4gICAgICB9OyAvLy0tXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHRoaXMuYXJyYXlfdHJpYW5ndWxhci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGltU3VwID0gdGhpcy5hcnJheV90cmlhbmd1bGFyW2ldOyAvL2NvbnNvbGUubG9nKFwibGltU3VwOiBcIitsaW1TdXApXG5cbiAgICAgICAgaWYgKG51bSA+IGxpbVN1cCkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiKlwiKVxuICAgICAgICAgIG9iai5vcmJpdGFsID0gaSArIDE7XG4gICAgICAgICAgb2JqLmNvX29yYml0YW50ZXMgPSAoaSArIDEpICogdGhpcy5mYWN0b3I7XG4gICAgICAgICAgb2JqLnBvc19vcmJpdGEgPSBudW0gLSBsaW1TdXAgLSAxO1xuICAgICAgICAgIG9iai5pbmNyX2FuZ3Vsb1JhZCA9IDIgKiBNYXRoLlBJIC8gb2JqLmNvX29yYml0YW50ZXM7XG5cbiAgICAgICAgICBpZiAob2JqLm9yYml0YWwgJSAyID09IDApIHtcbiAgICAgICAgICAgIG9iai5kaXIgPSAxO1xuICAgICAgICAgICAgb2JqLmluY3IgPSAwO1xuICAgICAgICAgICAgb2JqLmFuZ3Vsb1JhZCA9IG9iai5wb3Nfb3JiaXRhICogb2JqLmluY3JfYW5ndWxvUmFkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmouZGlyID0gLTE7XG4gICAgICAgICAgICBvYmouaW5jciA9IDE7XG4gICAgICAgICAgICBvYmouYW5ndWxvUmFkID0gb2JqLnBvc19vcmJpdGEgKiBvYmouaW5jcl9hbmd1bG9SYWQgKyBvYmouaW5jcl9hbmd1bG9SYWQgLyAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9iai5yYWRpbyA9IG9iai5vcmJpdGFsICogdGhpcy5pbmNyX3JhZGlvOyAvLy0tXG5cbiAgICAgICAgICBvYmoueCA9IE1hdGguY29zKG9iai5hbmd1bG9SYWQpICogb2JqLnJhZGlvO1xuICAgICAgICAgIG9iai55ID0gTWF0aC5zaW4ob2JqLmFuZ3Vsb1JhZCkgKiBvYmoucmFkaW87XG4gICAgICAgICAgb2JqLnogPSAwO1xuICAgICAgICB9IC8vYnJlYWtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0X2NvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfY29sb3IoKSB7XG4gICAgICB2YXIgY29sb3JfUkdCXzAxID0gdGhpcy5hcnJheUNvbG9yZXNfUkdCXzAxW3RoaXMuY29sb3JQb3NdO1xuICAgICAgdGhpcy5jb2xvclBvcysrO1xuXG4gICAgICBpZiAodGhpcy5jb2xvclBvcyA+IHRoaXMuYXJyYXlDb2xvcmVzX1JHQl8wMS5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMuY29sb3JQb3MgPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sb3JfUkdCXzAxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdF9jb2xvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRfY29sb3JzKCkge1xuICAgICAgdGhpcy5hcnJheUNvbG9yZXNfUkdCID0gW107XG4gICAgICB0aGlzLmFycmF5Q29sb3Jlc19SR0IucHVzaChbMjMyLCA2NywgMTMxXSk7XG4gICAgICB0aGlzLmFycmF5Q29sb3Jlc19SR0IucHVzaChbMCwgMTI2LCAyNTVdKTtcbiAgICAgIHRoaXMuYXJyYXlDb2xvcmVzX1JHQl8wMSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXJyYXlDb2xvcmVzX1JHQi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29sb3JfUkdCID0gdGhpcy5hcnJheUNvbG9yZXNfUkdCW2ldO1xuICAgICAgICB2YXIgY29sb3JfUkdCXzAxID0gW2NvbG9yX1JHQlswXSAvIDI1NSwgY29sb3JfUkdCWzFdIC8gMjU1LCBjb2xvcl9SR0JbMl0gLyAyNTVdO1xuICAgICAgICB0aGlzLmFycmF5Q29sb3Jlc19SR0JfMDEucHVzaChjb2xvcl9SR0JfMDEpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIb21lM0dlb21ldHJ5O1xufShFdmVudEVtaXR0ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBIb21lM0dlb21ldHJ5OyIsImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhX3JhbmRvbW5lc3M7XFxuYXR0cmlidXRlIHZlYzMgYV9nZW8xX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfZ2VvMV9jb2xvcjtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9nZW8xX2FuZ3Vsb1JhZDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9nZW8xX29yYml0YWw7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9wb3Nfb3JiaXRhO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfaW5jcl9hbmd1bG9SYWQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9pbmNyO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfZGlyO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfcmFkaW87XFxuXFxudW5pZm9ybSBmbG9hdCB1Q2FtYXJhRGlzdGFuY2U7XFxudW5pZm9ybSBmbG9hdCB1VGltZTtcXG51bmlmb3JtIGZsb2F0IHVSZXNwb25zaXZlU2NhbGU7XFxudW5pZm9ybSBmbG9hdCB1U2Nyb2xsRGVsdGE7XFxudW5pZm9ybSBmbG9hdCB1Um90YXRpb24xO1xcbnVuaWZvcm0gZmxvYXQgdVJvdGF0aW9uMjtcXG51bmlmb3JtIGZsb2F0IHVSb3RhdGlvbjM7XFxuXFxudW5pZm9ybSBmbG9hdCB1Q2hhbmdlQW5pbTtcXG51bmlmb3JtIGZsb2F0IHVDaGFuZ2VQcm9ncmVzcztcXG5cXG51bmlmb3JtIHZlYzMgdVByZXZDb2xvcjtcXG51bmlmb3JtIHZlYzMgdU5leHRDb2xvcjtcXG5cXG52YXJ5aW5nIGZsb2F0IHZfYW5nbGVSYWQ7XFxudmFyeWluZyBmbG9hdCB2X2NvbG9yUG9zaXRpb247XFxudmFyeWluZyBmbG9hdCB2X3B1bHNlU3RyZW5ndGhOb3JtMTtcXG52YXJ5aW5nIGZsb2F0IHZfcHVsc2VTdHJlbmd0aE5vcm0yO1xcblxcbnZhcnlpbmcgdmVjMyB2X3ByZXZDb2xvcjtcXG52YXJ5aW5nIHZlYzMgdl9uZXh0Q29sb3I7XFxuXFxuI2RlZmluZSBQSSAzLjE0MTU5MjY1MzhcXG5cXG52ZWMzIGdldF9wb3MxKGZsb2F0IGFuZ3Vsb1JhZCl7XFxuICAgIC8vZmxvYXQgYW5ndWxvUmFkID0gYV9nZW8xX3Bvc19vcmJpdGEqYV9nZW8xX2luY3JfYW5ndWxvUmFkKygoYV9nZW8xX2luY3JfYW5ndWxvUmFkLzIuKSphX2dlbzFfaW5jcikrKDEuKmFfZ2VvMV9kaXIqMC4yKTtcXG4gICAgZmxvYXQgeCA9IGNvcyhhbmd1bG9SYWQpKmFfZ2VvMV9yYWRpbztcXG4gICAgZmxvYXQgeSA9IHNpbihhbmd1bG9SYWQpKmFfZ2VvMV9yYWRpbztcXG4gICAgZmxvYXQgeiA9IDAuMDtcXG4gICAgdmVjMyBuZXdQb3MgPSB2ZWMzKHgsIHksIHopO1xcbiAgICByZXR1cm4gbmV3UG9zO1xcbn1cXG5cXG5mbG9hdCBnZXRfY29zVGltZShmbG9hdCB0aW1lLCBmbG9hdCByYWRpdXMpe1xcbiAgICAvL1xcbiAgICAvL2Zsb2F0IHZhbHVlID0gc2luKHVUaW1lKSoyLipQSTtcXG4gICAgZmxvYXQgdmFsdWUgPSBzaW4odGltZSkqcmFkaXVzO1xcbiAgICByZXR1cm4gdmFsdWU7XFxufVxcblxcbmZsb2F0IGdldF94KGZsb2F0IGFuZ2xlUmFkLCBmbG9hdCByYWRpdXMpe1xcbiAgICByZXR1cm4gY29zKGFuZ2xlUmFkKSphX2dlbzFfcmFkaW87XFxufVxcblxcbmZsb2F0IGdldF9wdWxzZVN0cmVuZ3RoTm9ybSggZmxvYXQgZGlyZWN0aW9uKXtcXG4gICAgZmxvYXQgZG90QWd1bGVOb3JtID0gYV9nZW8xX2FuZ3Vsb1JhZC8oMi4qUEkpOyAvLyBQYXNhbW9zIGVsIGFuZ3VsbyBkZWwgcHVudG8gcXVlIGVzdMOhIGVuIHJhZGlhbmVzIGEgdW4gdmFsb3IgZGUgMCBhIDEuXFxuXFxuICAgIGZsb2F0IG1vZFNwZWVkID0gbWl4KDEuLCAyLjUsIDEzLi9hX2dlbzFfb3JiaXRhbCkqZGlyZWN0aW9uO1xcbiAgICBmbG9hdCByYWRpYWxTcGVlZCA9IHVUaW1lKjAuMDIqbW9kU3BlZWQ7IC8vIE1vZGlmaWNhbW9zIHVUaW1lIHBhcmEgZGV0ZXJtaW5hciBsYSB2ZWxvY2lkYWQgcmFkaWFsLlxcblxcbiAgICBmbG9hdCBwdWxzZUFuZ2xlUmFkID0gcmFkaWFsU3BlZWQqKDQuKlBJKTtcXG5cXG4gICAgLy8gRWwgdmFsb3IgZGUgcHVsc2VBbmdsZVJhZCBkZWJlIGVzdGFyIGVudHJlIDAgeSAyUEkgKGluaWNpbyB5IGZpbiBkZSB1bmEgY2lyY3VuZmVyZW5jaWEpLlxcbiAgICAvLyBDb21vIGRlcGVuZGUgZGUgdVRpbWUgZWwgdmFsb3Igc2FsZHLDoSBkZSBlc2UgcmFuZ28gcHJvbnRvIHBvciBsbyBxdWUgdG9tYXJlbW9zIGVsIHJlc3RvIChtb2R1bG8pLFxcbiAgICAvLyBkZSBkaXZpZGlyIHB1bHNlQW5nbGVSYWQgcG9yIDJQSS5cXG4gICAgaWYocHVsc2VBbmdsZVJhZCA+IDIuKlBJKXtcXG4gICAgICAgIHB1bHNlQW5nbGVSYWQgPSBtb2QocHVsc2VBbmdsZVJhZCwgKDIuKlBJKSk7XFxuICAgIH1cXG4gICAgaWYocHVsc2VBbmdsZVJhZCA8IDAuKXtcXG4gICAgICAgIHB1bHNlQW5nbGVSYWQgPSBtb2QocHVsc2VBbmdsZVJhZCwgKDIuKlBJKSk7XFxuICAgIH1cXG5cXG4gICAgZmxvYXQgcHVsc2VBbmdsZU5vcm0gPSBwdWxzZUFuZ2xlUmFkLygyLipQSSk7IC8vIE5vcm1hbGl6YW1vcyBlbCB2YWxvciAoZGUgMCBhIDEpXFxuXFxuICAgIGZsb2F0IGRpc3RBbmdsZU5vcm0gPSBhYnMocHVsc2VBbmdsZU5vcm0tZG90QWd1bGVOb3JtKTsgLy8gQ2FsY3VsYW1vcyBsYSBkaXN0YW5jaWEgcmFkaWFsIGRlbCBwdWxzbyBhbCBwdW50b1xcblxcbiAgICAvLyBBcGHDsWFtb3MgbGEgZGlzdGFuY2lhIGRlIHRhbCBmb3JtYSBxdWUgbm8gbGUgYWZlY3RlIGVsIHB1bnRvIGRlIGRpc2NvbnRpbnVpZGFkIE9QSSA9IDJQSVxcbiAgICBpZihkaXN0QW5nbGVOb3JtID4gMC41KXsgXFxuICAgICAgICBkaXN0QW5nbGVOb3JtID0gMC41LShkaXN0QW5nbGVOb3JtLTAuNSk7XFxuICAgIH1cXG5cXG4gICAgLy8gTGEgbWF4aW1hIGRpc3RhbmNpYSBlcyBkZSBtZWRpbyBjaXJjdWxvIHkgZW4gdGVybWlub3Mgbm9ybWFsaXphZG9zIGVzIDAuNVxcbiAgICAvLyBDcmVhbW9zIHVuYSB2YXJpYWJsZSBxdWUgbm9ybWFsaWNlIGVzZSB2YWxvciBlbnRyZSAwIHkgMS5cXG4gICAgZmxvYXQgcHVsc2VTdHJlbmd0aE5vcm0gID0gZGlzdEFuZ2xlTm9ybSoyLjsgXFxuXFxuICAgIGZsb2F0IHBpY28gPSAwLjkyO1xcbiAgICBwaWNvID0gbWl4KHBpY28qMC45OSwgcGljbyoxLjAxLCBhX2dlbzFfb3JiaXRhbC8xMy4pO1xcblxcbiAgICAvLyBOb3MgaW50ZXJlc2Egc29sbyBlbCBwaWNvLCBsYSB6b25hIHF1ZSB2YSBlbnRyZSAwLjk1IHkgMS5cXG4gICAgLy8gVG9vZG8gbG8gcXVlIGhheWEgcG9yIGRlYmFqbyBkZSAwLjk1IGxvIHBhc2Ftb3MgYSAwLjk1XFxuICAgIC8vIHkgbGUgcmVzdGFtb3MgZXNlIG1pc21vIDAuOTUgcGFyYSBxdWVkYXJub3MgY29uIGVsIHBpY28gZGUgMC4wNSBlb2wgY3VhbCBhbXBsaWZpY2Ftb3MgeDIwIHBhcmEgbm9ybWFsaXphcmxvIChkZSAwIGEgMSkuXFxuICAgIHB1bHNlU3RyZW5ndGhOb3JtID0gKGNsYW1wKHB1bHNlU3RyZW5ndGhOb3JtLCBwaWNvLCAxLiktcGljbykqMTAuO1xcbiAgICAvLy0tXFxuICAgIHJldHVybiBwdWxzZVN0cmVuZ3RoTm9ybTtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcblxcbiAgICBmbG9hdCBwdWxzZVN0cmVuZ3RoTm9ybTEgPSBnZXRfcHVsc2VTdHJlbmd0aE5vcm0oMS41KTtcXG4gICAgZmxvYXQgcHVsc2VTdHJlbmd0aE5vcm0yID0gZ2V0X3B1bHNlU3RyZW5ndGhOb3JtKC0xLik7XFxuXFxuICAgIFxcblxcbiAgICBmbG9hdCBhbmd1bG9SYWRfdGltZSA9IDAuO1xcbiAgICBmbG9hdCBjaGFuZ2VTY2FsZSA9IDAuNTtcXG5cXG4gICAgaWYoYWJzKGFfZ2VvMV9vcmJpdGFsLTEyLikgPCAwLjUpeyAvLyBEZXRlY3RhIGVsIG9yYml0YWwgMTRcXG4gICAgICAgIGFuZ3Vsb1JhZF90aW1lID0gYV9nZW8xX2FuZ3Vsb1JhZCt1Um90YXRpb24xO1xcbiAgICAgICAgdl9jb2xvclBvc2l0aW9uID0gMS47XFxuICAgICAgICBjaGFuZ2VTY2FsZSA9IDAuMztcXG4gICAgfWVsc2UgaWYoYWJzKGFfZ2VvMV9vcmJpdGFsLTE1LikgPCAwLjUpeyAvLyBEZXRlY3RhIGVsIG9yYml0YWwgMTRcXG4gICAgICAgIGFuZ3Vsb1JhZF90aW1lID0gYV9nZW8xX2FuZ3Vsb1JhZCt1Um90YXRpb24yO1xcbiAgICAgICAgdl9jb2xvclBvc2l0aW9uID0gMC47XFxuICAgICAgICBjaGFuZ2VTY2FsZSA9IDAuNTtcXG4gICAgfWVsc2UgaWYoYWJzKGFfZ2VvMV9vcmJpdGFsLTE4LikgPCAwLjUpeyAvLyBEZXRlY3RhIGVsIG9yYml0YWwgMTdcXG4gICAgICAgIGFuZ3Vsb1JhZF90aW1lID0gYV9nZW8xX2FuZ3Vsb1JhZCt1Um90YXRpb24zO1xcbiAgICAgICAgdl9jb2xvclBvc2l0aW9uID0gMS47XFxuICAgICAgICBjaGFuZ2VTY2FsZSA9IDAuODtcXG4gICAgfVxcbiAgICBcXG4gICAgLy9mbG9hdCBhbmd1bG9SYWRfdGltZSA9IGFfZ2VvMV9hbmd1bG9SYWQrKGRpcmVjdGlvbipzaW4odVRpbWUrYV9nZW8xX29yYml0YWwpKjAuMik7XFxuICAgIHZlYzMgcG9zMSA9IGdldF9wb3MxKGFuZ3Vsb1JhZF90aW1lKTtcXG4gICAgLy9wb3MxICo9IDIuO1xcbiAgICAvL3BvczEgKj0gMS4rKHVTY3JvbGxEZWx0YSowLjIpO1xcbiAgICBwb3MxICo9IG1peCgxLiwgY2hhbmdlU2NhbGUsIHVDaGFuZ2VBbmltKTtcXG4gICAgcG9zMSAqPSB1UmVzcG9uc2l2ZVNjYWxlO1xcbiAgICAvL3ZlYzMgcG9zMiA9IHBvczEqMS4wO1xcbiAgICAvL3BvczE9IG1peChwb3MxLCBwb3MyLCBwdWxzZVN0cmVuZ3RoTm9ybSk7XFxuXFxuICAgIGZsb2F0IG9iaXRhbEZhY3RvciA9IGFfZ2VvMV9vcmJpdGFsLzE4LjtcXG4gICAgaWYodUNoYW5nZVByb2dyZXNzID49IG9iaXRhbEZhY3Rvcil7XFxuICAgICAgICB2X25leHRDb2xvciA9IHVOZXh0Q29sb3I7XFxuICAgIH1lbHNle1xcbiAgICAgICAgdl9uZXh0Q29sb3IgPSB1UHJldkNvbG9yO1xcbiAgICB9XFxuXFxuICAgIC8vIERldGVybWluYW1vcyBlbCB0YW1hw7FvIGRlbCBwdW50byB0ZW5pZW5kbyB1biBtaW5pbW8gZGUgNSB5IGFtcGxpZmljYW5kbyBlbCBtYXhpbW8gcGFyYSBxdWUgdmlzdWFsbWVudGUgc2VhIGJvbml0b1xcbiAgICAvL2Zsb2F0IHNpemUgPSA1LisocHVsc2VTdHJlbmd0aE5vcm0qMTUuKmxvbmdQZXJpb2QpO1xcbiAgICBmbG9hdCBzaXplID0gMy47XFxuICAgIHNpemUgKz0gKHB1bHNlU3RyZW5ndGhOb3JtMSoxLik7XFxuICAgIHNpemUgKz0gKHB1bHNlU3RyZW5ndGhOb3JtMioxLik7XFxuICAgIHNpemUgKj0gdVJlc3BvbnNpdmVTY2FsZTtcXG5cXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIC8vIFZFUlRFWFxcbiAgICB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3MxLCAxLjAgKTtcXG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG4gICAgZ2xfUG9pbnRTaXplID0gc2l6ZSoodUNhbWFyYURpc3RhbmNlLy1tdlBvc2l0aW9uLnopO1xcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyBWQVJZSU5HUzpcXG4gICAgdl9hbmdsZVJhZCA9IGFuZ3Vsb1JhZF90aW1lO1xcbiAgICB2X3B1bHNlU3RyZW5ndGhOb3JtMSA9IHB1bHNlU3RyZW5ndGhOb3JtMTsgXFxuICAgIHZfcHVsc2VTdHJlbmd0aE5vcm0yID0gcHVsc2VTdHJlbmd0aE5vcm0yOyBcXG5cXG4gICAgLy92X3ByZXZDb2xvciA9IHVQcmV2Q29sb3I7XFxuICAgIC8vdl9uZXh0Q29sb3IgPSB1TmV4dENvbG9yO1xcblxcbn1cXG5cXG5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIiNkZWZpbmUgR0xTTElGWSAxXFxudW5pZm9ybSB2ZWMzIHVDb2xvcjE7XFxudW5pZm9ybSB2ZWMzIHVDb2xvcjI7XFxuXFxudmFyeWluZyBmbG9hdCB2X2FuZ2xlUmFkO1xcbnZhcnlpbmcgZmxvYXQgdl9jb2xvclBvc2l0aW9uO1xcbnZhcnlpbmcgZmxvYXQgdl9wdWxzZVN0cmVuZ3RoTm9ybTE7XFxudmFyeWluZyBmbG9hdCB2X3B1bHNlU3RyZW5ndGhOb3JtMjtcXG5cXG52YXJ5aW5nIHZlYzMgdl9wcmV2Q29sb3I7XFxudmFyeWluZyB2ZWMzIHZfbmV4dENvbG9yO1xcblxcbiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM4XFxuXFxuZmxvYXQgY2lyY3VsaXphcihmbG9hdCByYWRpbyl7XFxuICAgIC8vIHJhZGlvIGVzIHVuIHZhbG9yIGVudHJlIDAgeSAxLiAwIGVzIDAgZGUgcmFkaW8geSAxIGVzIGVsIG1heGltbyBkZWwgcmFkaW8gZGVudHJvIGRlXFxuICAgIHJhZGlvID0gMS4wLSgwLjUqcmFkaW8pO1xcbiAgICBmbG9hdCByZXN1bHQgPSBkaXN0YW5jZShnbF9Qb2ludENvb3JkLCB2ZWMyKDAuNSwgMC41KSk7XFxuICAgIHJlc3VsdCA9IDEuIC1yZXN1bHQ7XFxuICAgIHJlc3VsdCA9IHBvdyhyZXN1bHQsIDEuKTtcXG4gICAgcmVzdWx0ID0gc3RlcChyYWRpbywgcmVzdWx0KTtcXG4gICAgcmV0dXJuIHJlc3VsdDtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBmbG9hdCBhbHBoYSA9IGNpcmN1bGl6YXIoMS4wKTtcXG4gICAgLy92ZWMzIGZpbmFsQ29sb3IgPSBtaXgodUNvbG9yMSwgdUNvbG9yMiwgdl9jb2xvclBvc2l0aW9uKTtcXG4gICAgdmVjMyBmaW5hbENvbG9yID0gdl9uZXh0Q29sb3I7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoZmluYWxDb2xvciwgYWxwaGEqMC44KTtcXG59XCI7IiwiZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gXCJ0aHJlZVwiOyAvL2ltcG9ydCBnc2FwIGZyb20gXCJnc2FwXCJcblxuaW1wb3J0IEVhc2luZyBmcm9tICdlYXNpbmctZnVuY3Rpb25zJztcbmltcG9ydCBFdmVudFByb2dyZXNzIGZyb20gXCIuLi9FdmVudFByb2dyZXNzXCI7XG5pbXBvcnQgRWFzZWRPdXRWYWx1ZSBmcm9tICcuLi9FYXNlZE91dFZhbHVlJztcbmltcG9ydCBIb21lM0dlb21ldHJ5IGZyb20gJy4vSG9tZTNHZW9tZXRyeSc7XG5pbXBvcnQgdmVydGV4IGZyb20gXCIuL3NoYWRlcnMvaG9tZTNfZG90c192ZXJ0ZXguZ2xzbFwiO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gXCIuL3NoYWRlcnMvaG9tZTNfZG90c19mcmFnbWVudC5nbHNsXCI7XG5cbnZhciBIb21lM0RvdHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIb21lM0RvdHMob2JqKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIb21lM0RvdHMpO1xuXG4gICAgLy9jb25zb2xlLmxvZyhcIihIb21lM0RvdHMuQ09OU1RSVUNUT1JBKSFcIilcbiAgICAvL2NvbnNvbGUubG9nKG9iailcbiAgICB0aGlzLndvcmxkR0wgPSBvYmoud29ybGRHTDsgLy8tLVxuXG4gICAgdGhpcy5zY2VuZSA9IHRoaXMud29ybGRHTC5zY2VuZTtcbiAgICB0aGlzLmNhbWVyYURpc3RhbmNlID0gdGhpcy53b3JsZEdMLmNhbWVyYURpc3RhbmNlOyAvLy0tXG5cbiAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcbiAgICB0aGlzLmdlb21ldHJ5ID0gbnVsbDtcbiAgICB0aGlzLm1lc2ggPSBudWxsO1xuICAgIHRoaXMubnVtUGFydGljbGVzID0gbnVsbDtcbiAgICB0aGlzLmNyZWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNsb2NrID0gbmV3IFRIUkVFLkNsb2NrKCk7IC8vLS1cblxuICAgIHRoaXMuY2hhbmdlQW5pbV9mYXNlID0gMDsgLy8gMDogaWRsZSAxLE91dCwgMjpJblxuXG4gICAgdGhpcy5jaGFuZ2VBbmltX2R1cmF0aW9uID0gbnVsbDtcbiAgICB0aGlzLmV2ZW50UHJvZ3Jlc3NfY2hhbmdlQW5pbV9PVVQgPSBuZXcgRXZlbnRQcm9ncmVzcyhcIk9VVFwiKTtcbiAgICB0aGlzLmV2ZW50UHJvZ3Jlc3NfY2hhbmdlQW5pbV9PVVQuZW1pdHRlci5vbihcIm9uUHJvZ3Jlc3NGaW5pc2hlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5fZmFzZU91dEVuZGVkKCk7XG4gICAgfSk7XG4gICAgdGhpcy5ldmVudFByb2dyZXNzX2NoYW5nZUFuaW1fSU4gPSBuZXcgRXZlbnRQcm9ncmVzcyhcIklOXCIpO1xuICAgIHRoaXMuZXZlbnRQcm9ncmVzc19jaGFuZ2VBbmltX0lOLmVtaXR0ZXIub24oXCJvblByb2dyZXNzRmluaXNoZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX2Zhc2VJbkVuZGVkKCk7XG4gICAgfSk7IC8vLS1cblxuICAgIHRoaXMuZWFzZWRfc2Nyb2xsRGVsdGEgPSBuZXcgRWFzZWRPdXRWYWx1ZSh0aGlzLndvcmxkR0wuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSAqIDAuNSwgMC4wMSk7XG4gICAgdGhpcy5lZWFzZWRfc2Nyb2xsRGVsdGFfZmFzdCA9IG5ldyBFYXNlZE91dFZhbHVlKHRoaXMud29ybGRHTC5zZXR0aW5ncy5zY3JvbGxfbm9ybWFsaXplZERlbHRhICogMC41LCAwLjEpOyAvLy0tXG5cbiAgICB0aGlzLl9zZXR1cF9zZXR0aW5ncygpOyAvLy0tXG5cblxuICAgIHRoaXMub3JiaXRhbF9nZW9tZXRyeSA9IG5ldyBIb21lM0dlb21ldHJ5KHRoaXMuc2V0dGluZ3MpOyAvLy0tXG4gICAgLy8tLVxuICAgIC8vdGhpcy5fY3JlYXRlY3ViZSh0aGlzLnNjZW5lKVxuXG4gICAgdGhpcy5fY3JlYXRlKCk7XG5cbiAgICB0aGlzLnJlc2l6ZSgpO1xuICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFBVQkxJQ0FTOiBcblxuXG4gIF9jcmVhdGVDbGFzcyhIb21lM0RvdHMsIFt7XG4gICAga2V5OiBcImRvQ2hhbmdlQW5pbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb0NoYW5nZUFuaW0ob2JqKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIihIb21lM0RvdHMuZG9DaGFuZ2VBbmltKTogXCIsIG9iailcbiAgICAgIHRoaXMuY2hhbmdlQW5pbV9kdXJhdGlvbiA9IG9iai5kdXJhdGlvbiAqIDAuOTtcbiAgICAgIHZhciB0O1xuXG4gICAgICBpZiAodGhpcy5jaGFuZ2VBbmltX2Zhc2UgPT0gMCkge1xuICAgICAgICAvLyBQaWxsYSBlbiBlc3RhZG8gaWRlbC5cbiAgICAgICAgdCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY2hhbmdlQW5pbV9mYXNlID09IDEpIHtcbiAgICAgICAgLy8gQ29ydGEgbGEgYW5pbWFjacOzbiBkZSBvdXRcbiAgICAgICAgdCA9IHRoaXMuZXZlbnRQcm9ncmVzc19jaGFuZ2VBbmltX09VVC5nZXRfdCgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNoYW5nZUFuaW1fZmFzZSA9PSAyKSB7XG4gICAgICAgIC8vIENvcnRhIGxhIGFuaW1hY2nDs24gZGUgaW5cbiAgICAgICAgLy90ID0gdGhpcy5ldmVudFByb2dyZXNzX2NoYW5nZUFuaW1fSU4uZ2V0X3QoKVxuICAgICAgICB0ID0gMSAtIHRoaXMuZXZlbnRQcm9ncmVzc19jaGFuZ2VBbmltX0lOLmdldF9wcm9ncmVzcygpO1xuICAgICAgfSAvL2NvbnNvbGUubG9nKFwidDogXCIrdClcblxuXG4gICAgICB0aGlzLnNldHRpbmdzLnByZXZDb2xvciA9IF90b0NvbnN1bWFibGVBcnJheSh0aGlzLnNldHRpbmdzLm5leHRDb2xvcik7XG4gICAgICB0aGlzLnNldHRpbmdzLm5leHRDb2xvciA9IG9iai5jb2xvci5zcGxpdChcIixcIik7XG4gICAgICB0aGlzLnNldHRpbmdzLm5leHRDb2xvclswXSA9IHRoaXMuc2V0dGluZ3MubmV4dENvbG9yWzBdIC8gMjU1O1xuICAgICAgdGhpcy5zZXR0aW5ncy5uZXh0Q29sb3JbMV0gPSB0aGlzLnNldHRpbmdzLm5leHRDb2xvclsxXSAvIDI1NTtcbiAgICAgIHRoaXMuc2V0dGluZ3MubmV4dENvbG9yWzJdID0gdGhpcy5zZXR0aW5ncy5uZXh0Q29sb3JbMl0gLyAyNTU7IC8vY29uc29sZS5sb2coXCJjb2xvcjogXCIrdGhpcy5zZXR0aW5ncy5uZXh0Q29sb3IpXG5cbiAgICAgIHRoaXMuX3N0YXJ0Q2hhbmdlQW5pbSh0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIGlmICh0aGlzLmNyZWF0ZWQpIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51VGltZS52YWx1ZSA9IHRoaXMuY2xvY2suZ2V0RWxhcHNlZFRpbWUoKTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Q2FtYXJhRGlzdGFuY2UudmFsdWUgPSB0aGlzLndvcmxkR0wuY2FtZXJhRGlzdGFuY2U7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVJlc3BvbnNpdmVTY2FsZS52YWx1ZSA9IHRoaXMud29ybGRHTC5yZXNwb25zaXZlU2NhbGU7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVNjcm9sbERlbHRhLnZhbHVlID0gLXRoaXMuZWVhc2VkX3Njcm9sbERlbHRhX2Zhc3QuZ2V0KHRoaXMud29ybGRHTC5zZXR0aW5ncy5zY3JvbGxfbm9ybWFsaXplZERlbHRhICogMC41KTsgLy8tLVxuXG4gICAgICAgIHZhciBleHRyYVNwZWVkID0gMSArIE1hdGguYWJzKHRoaXMuZWVhc2VkX3Njcm9sbERlbHRhX2Zhc3QuZ2V0KHRoaXMud29ybGRHTC5zZXR0aW5ncy5zY3JvbGxfbm9ybWFsaXplZERlbHRhICogMC41KSAqIDEwKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5yb3RhdGlvbjEgKz0gdGhpcy5zZXR0aW5ncy5zcGVlZFJvdGF0aW9uMSAqIGV4dHJhU3BlZWQ7XG4gICAgICAgIHRoaXMuc2V0dGluZ3Mucm90YXRpb24yICs9IHRoaXMuc2V0dGluZ3Muc3BlZWRSb3RhdGlvbjIgKiBleHRyYVNwZWVkO1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJvdGF0aW9uMyArPSB0aGlzLnNldHRpbmdzLnNwZWVkUm90YXRpb24zICogZXh0cmFTcGVlZDtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Um90YXRpb24xLnZhbHVlID0gdGhpcy5zZXR0aW5ncy5yb3RhdGlvbjE7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVJvdGF0aW9uMi52YWx1ZSA9IC10aGlzLnNldHRpbmdzLnJvdGF0aW9uMjtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Um90YXRpb24zLnZhbHVlID0gdGhpcy5zZXR0aW5ncy5yb3RhdGlvbjM7IC8vLS1cblxuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVQcmV2Q29sb3IudmFsdWUgPSBuZXcgVEhSRUUuQ29sb3IodGhpcy5zZXR0aW5ncy5wcmV2Q29sb3JbMF0sIHRoaXMuc2V0dGluZ3MucHJldkNvbG9yWzFdLCB0aGlzLnNldHRpbmdzLnByZXZDb2xvclsyXSk7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudU5leHRDb2xvci52YWx1ZSA9IG5ldyBUSFJFRS5Db2xvcih0aGlzLnNldHRpbmdzLm5leHRDb2xvclswXSwgdGhpcy5zZXR0aW5ncy5uZXh0Q29sb3JbMV0sIHRoaXMuc2V0dGluZ3MubmV4dENvbG9yWzJdKTsgLy8tLVxuXG4gICAgICAgIGlmICh0aGlzLmV2ZW50UHJvZ3Jlc3NfY2hhbmdlQW5pbV9JTiAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGNoYW5nZUFuaW07XG4gICAgICAgICAgdmFyIGNoYW5nZVByb2dyZXNzO1xuXG4gICAgICAgICAgaWYgKHRoaXMuY2hhbmdlQW5pbV9mYXNlID09IDApIHtcbiAgICAgICAgICAgIGNoYW5nZUFuaW0gPSAwO1xuICAgICAgICAgICAgY2hhbmdlUHJvZ3Jlc3MgPSAxOyAvL2NvbnNvbGUubG9nKFwiMDogXCIrY2hhbmdlQW5pbSlcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hhbmdlQW5pbV9mYXNlID09IDEpIHtcbiAgICAgICAgICAgIGNoYW5nZUFuaW0gPSB0aGlzLmV2ZW50UHJvZ3Jlc3NfY2hhbmdlQW5pbV9PVVQuZ2V0X3Byb2dyZXNzKCk7XG4gICAgICAgICAgICBjaGFuZ2VQcm9ncmVzcyA9IGNoYW5nZUFuaW0gKiAwLjU7IC8vY29uc3QgdCA9IHRoaXMuZXZlbnRQcm9ncmVzc19jaGFuZ2VBbmltX09VVC5nZXRfdCgpXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2hhbmdlQW5pbTogXCIrY2hhbmdlQW5pbSlcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjaGFuZ2VQcm9ncmVzczogXCIrY2hhbmdlUHJvZ3Jlc3MpXG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNoYW5nZUFuaW1fZmFzZSA9PSAyKSB7XG4gICAgICAgICAgICBjaGFuZ2VBbmltID0gMSAtIHRoaXMuZXZlbnRQcm9ncmVzc19jaGFuZ2VBbmltX0lOLmdldF9wcm9ncmVzcygpO1xuICAgICAgICAgICAgY2hhbmdlUHJvZ3Jlc3MgPSAwLjUgKyB0aGlzLmV2ZW50UHJvZ3Jlc3NfY2hhbmdlQW5pbV9JTi5nZXRfcHJvZ3Jlc3MoKSAqIDAuNTsgLy9jb25zdCB0ID0gdGhpcy5ldmVudFByb2dyZXNzX2NoYW5nZUFuaW1fSU4uZ2V0X3QoKVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCIyOiBcIitjaGFuZ2VBbmltK1wiIHQ6XCIrdClcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiY2hhbmdlUHJvZ3Jlc3M6IFwiK2NoYW5nZVByb2dyZXNzKVxuICAgICAgICAgIH0gLy9jb25zb2xlLmxvZyhcImNoYW5nZVByb2dyZXNzOiBcIitjaGFuZ2VQcm9ncmVzcylcblxuXG4gICAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Q2hhbmdlQW5pbS52YWx1ZSA9IGNoYW5nZUFuaW07XG4gICAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Q2hhbmdlUHJvZ3Jlc3MudmFsdWUgPSBjaGFuZ2VQcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTNEb3RzLnJlc2l6ZSkhXCIpXG4gICAgICBpZiAodGhpcy5tZXNoKSB7Ly90aGlzLm1lc2gucG9zaXRpb24uc2V0WCh0aGlzLndvcmxkR0wud2lkdGgvMilcbiAgICAgIH1cbiAgICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUFJJVkFEQVM6IFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0YXJ0Q2hhbmdlQW5pbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhcnRDaGFuZ2VBbmltKHN0YXJ0aW5nX3QpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTNEb3RzLl9zdGFydENoYW5nZUFuaW0pOiBcIitzdGFydGluZ190K1wiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKVxuICAgICAgdGhpcy5jaGFuZ2VBbmltX2Zhc2UgPSAxO1xuICAgICAgdGhpcy5ldmVudFByb2dyZXNzX2NoYW5nZUFuaW1fT1VULnN0b3AoKTtcbiAgICAgIHRoaXMuZXZlbnRQcm9ncmVzc19jaGFuZ2VBbmltX0lOLnN0b3AoKTsgLy8tLVxuXG4gICAgICB2YXIgZWFzZUZ1bmM7XG5cbiAgICAgIGlmIChzdGFydGluZ190ID09IDApIHtcbiAgICAgICAgZWFzZUZ1bmMgPSBFYXNpbmcuRXhwb25lbnRpYWwuSW5PdXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlYXNlRnVuYyA9IEVhc2luZy5FeHBvbmVudGlhbC5Jbk91dDsgLy9lYXNlRnVuYyA9IEVhc2luZy5MaW5lYXIuTm9uZVxuICAgICAgfVxuXG4gICAgICB0aGlzLmV2ZW50UHJvZ3Jlc3NfY2hhbmdlQW5pbV9PVVQuc3RhcnQodGhpcy5jaGFuZ2VBbmltX2R1cmF0aW9uLCBzdGFydGluZ190LCBlYXNlRnVuYywgMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9mYXNlT3V0RW5kZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Zhc2VPdXRFbmRlZCgpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTNEb3RzLl9mYXNlT3V0RW5kZWQpIS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIilcbiAgICAgIHRoaXMuY2hhbmdlQW5pbV9mYXNlID0gMjtcbiAgICAgIHRoaXMuZXZlbnRQcm9ncmVzc19jaGFuZ2VBbmltX0lOLnN0YXJ0KHRoaXMuY2hhbmdlQW5pbV9kdXJhdGlvbiwgMCwgRWFzaW5nLlF1YWRyYXRpYy5Jbk91dCwgMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9mYXNlSW5FbmRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmFzZUluRW5kZWQoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWUzRG90cy5fZmFzZUluRW5kZWQpIS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIilcbiAgICAgIHRoaXMuY2hhbmdlQW5pbV9mYXNlID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldHVwX3NldHRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cF9zZXR0aW5ncygpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTNEb3RzLl9zZXR1cF9zZXR0aW5ncykhXCIpXG4gICAgICB2YXIgc3BlZWRCYXNlID0gMC4wMDI7XG4gICAgICB0aGlzLnNldHRpbmdzID0ge1xuICAgICAgICBmYWN0b3I6IDYsXG4gICAgICAgIGluY3JfcmFkaW86IDI1LFxuICAgICAgICBudW1PcmJpdHM6IDI2LFxuICAgICAgICBhcnJheU9yYml0czogWzEyLCAxNSwgMThdLFxuICAgICAgICByb3RhdGlvbjE6IDAsXG4gICAgICAgIHNwZWVkUm90YXRpb24xOiAzICogc3BlZWRCYXNlLFxuICAgICAgICByb3RhdGlvbjI6IDIsXG4gICAgICAgIHNwZWVkUm90YXRpb24yOiAyICogc3BlZWRCYXNlLFxuICAgICAgICByb3RhdGlvbjM6IDAsXG4gICAgICAgIHNwZWVkUm90YXRpb24zOiAxICogc3BlZWRCYXNlLFxuICAgICAgICBwcmV2Q29sb3I6IFswLjkwOSwgMC4yNjIsIDAuNDQzXSxcbiAgICAgICAgbmV4dENvbG9yOiBbMC45MDksIDAuMjYyLCAwLjQ0M11cbiAgICAgIH07XG4gICAgICB0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXIgPSB0aGlzLl9nZXRfYXJyYXlfdHJpYW5ndWxhcih0aGlzLnNldHRpbmdzLmZhY3RvciwgdGhpcy5zZXR0aW5ncy5udW1PcmJpdHMpO1xuICAgICAgdGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEgPSB0aGlzLl9nZXRfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhKHRoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhciwgdGhpcy5zZXR0aW5ncy5hcnJheU9yYml0cyk7XG4gICAgICB0aGlzLnNldHRpbmdzLmFycmF5X2RvdFBvcyA9IHRoaXMuX2dldF9hcnJheV9kb3RQb3ModGhpcy5zZXR0aW5ncy5hcnJheU9yYml0cywgdGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyLCB0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YSk7XG4gICAgICB0aGlzLnNldHRpbmdzLm51bURvdHMgPSB0aGlzLnNldHRpbmdzLmFycmF5X2RvdFBvcy5sZW5ndGg7IC8vdGhpcy5zZXR0aW5ncy5udW1Eb3RzID0gdGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyW3RoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhci5sZW5ndGgtMV1cbiAgICAgIC8vY29uc29sZS5sb2coXCJ0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXI6IFwiK3RoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhcilcbiAgICAgIC8vY29uc29sZS5sb2coXCJ0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YTogXCIrdGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEpXG4gICAgICAvL2NvbnNvbGUubG9nKFwidGhpcy5zZXR0aW5ncy5udW1Eb3RzOiBcIit0aGlzLnNldHRpbmdzLm51bURvdHMpXG4gICAgICAvL2NvbnNvbGUubG9nKFwidGhpcy5zZXR0aW5ncy5hcnJheU9yYml0czogXCIrdGhpcy5zZXR0aW5ncy5hcnJheU9yYml0cylcbiAgICAgIC8vY29uc29sZS5sb2coXCJ0aGlzLnNldHRpbmdzLmFycmF5X2RvdFBvczogXCIrdGhpcy5zZXR0aW5ncy5hcnJheV9kb3RQb3MpXG4gICAgICAvL2NvbnNvbGUubG9nKFwidGhpcy5zZXR0aW5ncy5hcnJheV9kb3RQb3MubGVuZ3RoOiBcIit0aGlzLnNldHRpbmdzLmFycmF5X2RvdFBvcy5sZW5ndGgpXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTNEb3RzLl9jcmVhdGUpIVwiKVxuICAgICAgLy8tLVxuICAgICAgdGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7XG4gICAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgICAvL2JsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nLFxuICAgICAgICB2ZXJ0ZXhDb2xvcnM6IHRydWUsXG4gICAgICAgIHZlcnRleFNoYWRlcjogdmVydGV4LFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogZnJhZ21lbnQsXG4gICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIHVDb2xvcjE6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoMHgzMzMzMzMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Q29sb3IyOiB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKDB4OTk5OTk5KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdUNhbWFyYURpc3RhbmNlOiB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy53b3JsZEdMLmNhbWVyYURpc3RhbmNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1VGltZToge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVTY3JvbGxEZWx0YToge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVSZXNwb25zaXZlU2NhbGU6IHtcbiAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Um90YXRpb24xOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVJvdGF0aW9uMjoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVSb3RhdGlvbjM6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Q2hhbmdlQW5pbToge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVDaGFuZ2VQcm9ncmVzczoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVQcmV2Q29sb3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoMHgzMzMzMzMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1TmV4dENvbG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKDB4MzMzMzMzKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7IC8vLS1cbiAgICAgIC8vY29uc29sZS5sb2codGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9jb2xvcilcbiAgICAgIC8vLS1cblxuICAgICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXMsIDMpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfcG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfcG9zaWNpb25lcywgMykpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9jb2xvcicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9jb2xvciwgMykpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9vcmJpdGFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX29yYml0YWwsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfcG9zX29yYml0YScsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9wb3Nfb3JiaXRhLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX2luY3JfYW5ndWxvUmFkJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX2luY3JfYW5ndWxvUmFkLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX2FuZ3Vsb1JhZCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9hbmd1bG9SYWQsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfcmFkaW8nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfcmFkaW8sIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfZGlyJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX2RpciwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9pbmNyJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX2luY3IsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfeCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV94LCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX3knLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfeSwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV96JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3osIDEpKTtcbiAgICAgIHRoaXMubWVzaCA9IG5ldyBUSFJFRS5Qb2ludHModGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCk7XG4gICAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLm1lc2gpOyAvLy0tLS0tLS0tLVxuXG4gICAgICAvKlxuICAgICAgdGhpcy5tYXRlcmlhbDIgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgICAgIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nLFxuICAgICAgICAgIHZlcnRleENvbG9yczogdHJ1ZSxcbiAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IHZlcnRleF9iZywgXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50X2JnLFxuICAgICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgICAgIHVDYW1hcmFEaXN0YW5jZToge3ZhbHVlOiB0aGlzLndvcmxkR0wuY2FtZXJhRGlzdGFuY2V9LFxuICAgICAgICAgICAgICB1VGltZToge3ZhbHVlOiAwfSxcbiAgICAgICAgICAgICAgdVNjYWxlOnt2YWx1ZTogMS41fVxuICAgICAgICAgIH1cbiAgICAgIH0pXG4gICAgICB0aGlzLm1lc2gyID0gbmV3IFRIUkVFLlBvaW50cyh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsMilcbiAgICAgIHRoaXMubWVzaDIucG9zaXRpb24ueiA9LTFcbiAgICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMubWVzaDIpXG4gICAgICAqL1xuICAgICAgLy8tLS0tLS0tLS1cblxuICAgICAgdGhpcy5jcmVhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldF9hcnJheV9kb3RQb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9hcnJheV9kb3RQb3MoX2FycmF5T3JiaXRzLCBfYXJyYXlfdHJpYW5ndWxhciwgX2FycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YSkge1xuICAgICAgdmFyIG1pQXJyYXkgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYXJyYXlPcmJpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9yYml0TnVtID0gX2FycmF5T3JiaXRzW2ldO1xuICAgICAgICB2YXIgZG90c194X29yYml0ID0gX2FycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YVtpXTtcbiAgICAgICAgdmFyIGRvdE51bV9iYXNlID0gX2FycmF5X3RyaWFuZ3VsYXJbX2FycmF5T3JiaXRzW2ldIC0gMV07IC8vIGNvbnNvbGUubG9nKFwib3JiaXROdW06IFwiK29yYml0TnVtKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImRvdHNfeF9vcmJpdDogXCIrZG90c194X29yYml0KVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImRvdE51bV9iYXNlOiBcIitkb3ROdW1fYmFzZSlcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvdHNfeF9vcmJpdDsgaisrKSB7XG4gICAgICAgICAgbWlBcnJheS5wdXNoKGRvdE51bV9iYXNlICsgaiArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaUFycmF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0X251bURvdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9udW1Eb3RzKF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEpIHtcbiAgICAgIHZhciBudW1Eb3RzID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gX2FycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbnVtRG90cyArPSBfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVtRG90cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEoX2FycmF5X3RyaWFuZ3VsYXIsIF9hcnJheU9yYml0cykge1xuICAgICAgLy8gR2VuZXJhIHVuYSBhcnJheSBiYXNhZGEgZW4gbGEgcHJvZ3Jlc2nDs24gdHJpYW5ndWxhciAoKiBmYWN0b3IpLlxuICAgICAgLy8gLi4uIGRvbmRlIHNlIGluZGljYSBlbCBudW1lcm8gZGUgZG90cyBwb3Igb3JiaXRhbFxuICAgICAgLy8gVW5hIHByb2dyZXNpw7NuIHRyaWFuZ3VsYXIgZXM6IDEsIDMsIDYsIDEwLCAxNSAoaHR0cHM6Ly9zaWduaWZpY2F0aXZhLm9yZy9kaWNjaW9uYXJpb3MvbnVtZXJvcy1maWd1cmFkb3MvIzp+OnRleHQ9My4xLjEuMS4tLERlZmluaWNpJUMzJUIzbixhbnRlcmlvciUyMG5vJTIwb2J0ZW5lbW9zJTIwdW5hJTIwY29uc3RhbnRlLilcbiAgICAgIHZhciBtaUFycmF5ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IF9hcnJheU9yYml0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgLy9hcnJheV9udW1UcmlhZ3VsYXJlcy5wdXNoKGkqKGkrMSkvMilcbiAgICAgICAgdmFyIG51bURvdHNfb3JiaXRhX2FjdHVhbCA9IF9hcnJheV90cmlhbmd1bGFyW19hcnJheU9yYml0c1tpXV07XG4gICAgICAgIHZhciBudW1Eb3RzX29yYml0YV9hbnRlcmlvciA9IF9hcnJheV90cmlhbmd1bGFyW19hcnJheU9yYml0c1tpXSAtIDFdO1xuICAgICAgICB2YXIgbnVtRG90c19vcmJpdGEgPSBudW1Eb3RzX29yYml0YV9hY3R1YWwgLSBudW1Eb3RzX29yYml0YV9hbnRlcmlvcjtcbiAgICAgICAgbWlBcnJheS5wdXNoKG51bURvdHNfb3JiaXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1pQXJyYXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRfYXJyYXlfdHJpYW5ndWxhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0X2FycmF5X3RyaWFuZ3VsYXIoX2ZhY3RvciwgX251bU9iaXRzKSB7XG4gICAgICAvLyBHZW5lcmEgdW5hIGFycmF5IGRlIHByb2dyZXNpw7NuIHRyaWFuZ3VsYXIgKCogZmFjdG9yKS5cbiAgICAgIC8vIFVuYSBwcm9ncmVzacOzbiB0cmlhbmd1bGFyIGVzOiAxLCAzLCA2LCAxMCwgMTUgKGh0dHBzOi8vc2lnbmlmaWNhdGl2YS5vcmcvZGljY2lvbmFyaW9zL251bWVyb3MtZmlndXJhZG9zLyM6fjp0ZXh0PTMuMS4xLjEuLSxEZWZpbmljaSVDMyVCM24sYW50ZXJpb3IlMjBubyUyMG9idGVuZW1vcyUyMHVuYSUyMGNvbnN0YW50ZS4pXG4gICAgICB2YXIgbWlBcnJheSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBfbnVtT2JpdHM7IGkrKykge1xuICAgICAgICAvL2FycmF5X251bVRyaWFndWxhcmVzLnB1c2goaSooaSsxKS8yKVxuICAgICAgICBtaUFycmF5LnB1c2goaSAqIChpICsgMSkgLyAyICogX2ZhY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaUFycmF5O1xuICAgIH1cbiAgICAvKiBcbiAgICBfY3JlYXRlY3ViZShfc2NlbmUpe1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgxMDAsMTAwLDEwMCk7XG4gICAgICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtjb2xvcjogMHhmZjAwMDB9KTtcbiAgICAgICAgY29uc3QgY3ViZSA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LG1hdGVyaWFsKTtcbiAgICAgICAgX3NjZW5lLmFkZChjdWJlKTtcbiAgICB9XG4gICAgKi9cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgfV0pO1xuXG4gIHJldHVybiBIb21lM0RvdHM7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IEhvbWUzRG90czsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8vIEZQUy1NZXRlcjpcbi8vKGZ1bmN0aW9uKCl7dmFyIHNjcmlwdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtzY3JpcHQub25sb2FkPWZ1bmN0aW9uKCl7dmFyIHN0YXRzPW5ldyBTdGF0cygpO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHMuZG9tKTtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCgpe3N0YXRzLnVwZGF0ZSgpO3JlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKX0pO307c2NyaXB0LnNyYz0nLy9jZG4uanNkZWxpdnIubmV0L2doL0tldm56L3N0YXRzLmpzL2J1aWxkL3N0YXRzLm1pbi5qcyc7ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO30pKClcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IE9yYml0Q29udHJvbHMgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvT3JiaXRDb250cm9scyc7XG5pbXBvcnQgKiBhcyBkYXQgZnJvbSBcImRhdC5ndWlcIjtcbmltcG9ydCBnc2FwIGZyb20gJ2dzYXAnO1xuaW1wb3J0IFNjcm9sbFRyaWdnZXIgZnJvbSAnZ3NhcC9TY3JvbGxUcmlnZ2VyJztcbmltcG9ydCBXZWJHTFV0aWxzIGZyb20gJy4uL1dlYkdMVXRpbHMnO1xuaW1wb3J0IEhvbWUzRG90cyBmcm9tICcuL0hvbWUzRG90cyc7XG5cbnZhciBIb21lM0FwcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEhvbWUzQXBwKG9iaikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIb21lM0FwcCk7XG5cbiAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWUzQXBwLkNPTlNUUlVDVE9SQSkhXCIsIG9iaikgXG4gICAgdGhpcy5od19yZW5kZXJlciA9IG9iai5yZW5kZXJlcjsgLy8gUmVkZXJlci9wYWdpbmEgZGUgSGlnaFdheS4gTm8gY29uZnVuZGlyIGNvbiBlbCByZW5kZXIvcmVuZGVyZXIgZGUgVGhyZWUuanNcblxuICAgIHRoaXMuJGNvbnRhaW5lciA9IG9iai5kb21FbGVtZW50O1xuICAgIHRoaXMuZG90Q29sb3IgPSBvYmouZG90Q29sb3I7IC8vdGhpcy5zbGlkZXJSZWYgPSBvYmouc2xpZGVyUmVmXG4gICAgLy8tLVxuICAgIC8vdGhpcy5zbGlkZXJSZWYuZW1pdHRlci5vbihcIm9uU2xpZGVyQ2hhbmdlXCIsIChvYmopPT57XG4gICAgLy8gICAgdGhpcy5vblNsaWRlckNoYW5nZShvYmopXG4gICAgLy99KVxuICAgIC8vLS1cblxuICAgIHRoaXMuUkVGX1JFU09MVVRJT04gPSB7XG4gICAgICB3aWR0aDogMTkyMCxcbiAgICAgIGhlaWdodDogOTQ3XG4gICAgfTtcbiAgICB0aGlzLlJFRl9DQU1FUkFfRElTVEFOQ0UgPSA1MDA7IC8vLS1cblxuICAgIHRoaXMud2lkdGggPSB0aGlzLiRjb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLiRjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgIHRoaXMucmVzcG9uc2l2ZVNjYWxlID0gdGhpcy53aWR0aCAvIHRoaXMuUkVGX1JFU09MVVRJT04ud2lkdGg7XG4gICAgdGhpcy5jYW1lcmFEaXN0YW5jZSA9IHRoaXMuUkVGX0NBTUVSQV9ESVNUQU5DRSAqICh0aGlzLmhlaWdodCAvIHRoaXMuUkVGX1JFU09MVVRJT04uaGVpZ2h0KTsgLy8tLVxuXG4gICAgdGhpcy4kbWFpbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbm5lcicpO1xuICAgIHRoaXMuJGhlcm8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaGVybycpO1xuICAgIHRoaXMuJGZvb3RlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mb290ZXInKTtcbiAgICB0aGlzLiRpbWFnZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5haV9faGVybyAuaW1hZ2UnKTsgLy8tLVxuICAgIC8vdGhpcy5NQUlOX0FDVElWRSA9IGZhbHNlXG4gICAgLy8tLVxuXG4gICAgdGhpcy5tb3VzZU5vcm0gPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07IC8vLS1cblxuICAgIHRoaXMuc2V0dGluZ3MgPSB7XG4gICAgICBzY3JvbGxfbGFzdElubmVyWTogMCxcbiAgICAgIC8vIFVsdGltYSBwb3NpY2nDs24gZGVsIGVsZW1lbnRvIGRlIHJlZmVyZW5jaWFcbiAgICAgIHNjcm9sbF9kZWx0YTogMCxcbiAgICAgIC8vIEluY3JlbWVudG8gZGUgcGl4ZWxzIGRlbCBzY3JvbGxcbiAgICAgIHNjcm9sbF9saW1pdGVkRGVsdGE6IDAsXG4gICAgICAvLyBMaW1pdGEgbG9zIHZhbG9yZXMgYSAtMjAgLT4gKzIwXG4gICAgICBzY3JvbGxfbm9ybWFsaXplZERlbHRhOiAwLFxuICAgICAgLy8gUGFzYSBlbCBkZWx0YSBhIC0xIC0+ICsxXG4gICAgICBzY3JvbGxfZmFjdG9yZERlbHRhOiAxLFxuICAgICAgLy8gVmFsb3JlcyBhYnNvbHV0b3MgZGUgMCAtPiAxXG4gICAgICBzY3JvbGxfZGlyZWN0aW9uOiAxLFxuICAgICAgLy8gRGlyZWNjaW9uIGRlbCBkZWx0YS4gMSBzaSBlc3TDoSBwYXJhZG9cbiAgICAgIHNjcm9sbF9oZXJvX3Byb2dyZXNzOiAwLFxuICAgICAgc2Nyb2xsX2Zvb3Rlcl9wcm9ncmVzczogMCxcbiAgICAgIG1vcnBoaW5nUHJvZ3Jlc3M6IDBcbiAgICB9OyAvLy0tXG4gICAgLy8gU2NlbmVcblxuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTsgLy90aGlzLnNjZW5lLmJhY2tncm91bmQgPSBuZXcgVEhSRUUuQ29sb3IoMHgzMzMzMzMpXG4gICAgLy8tLVxuICAgIC8vIENhbWVyYVxuICAgIC8vUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiA6IE51bWJlciwgYXNwZWN0IDogTnVtYmVyLCBuZWFyIDogTnVtYmVyLCBmYXIgOiBOdW1iZXIgKVxuXG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoMzAsIHRoaXMud2lkdGggLyB0aGlzLmhlaWdodCwgMC4xLCAyMDAwKTtcbiAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi56ID0gdGhpcy5jYW1lcmFEaXN0YW5jZTsgLy9jb25zb2xlLmxvZyhcInRoaXMuY2FtZXJhLmZvdjogXCIrdGhpcy5jYW1lcmEuZm92KVxuXG4gICAgdGhpcy5jYW1lcmEuZm92ID0gMiAqIE1hdGguYXRhbih0aGlzLmhlaWdodCAvIDIgLyB0aGlzLmNhbWVyYURpc3RhbmNlKSAqICgxODAgLyBNYXRoLlBJKTsgLy9jb25zb2xlLmxvZyhcInRoaXMuY2FtZXJhLmZvdjogXCIrdGhpcy5jYW1lcmEuZm92KVxuICAgIC8vLS1cbiAgICAvLyBSZW5kZXJlclxuXG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTDFSZW5kZXJlcih7XG4gICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICBhbHBoYTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyZXIuYXV0b0NsZWFyID0gZmFsc2U7IC8vIFZhbW9zIGEgdXNhciAyIHNjZW5hcyAodW5hIHBhcmEgZWwgYmFja2dyb3VuZCB5IG90cmEgcGFyYSBsb3MgcHVudG9zKSBxdWUgaW1wbGljYXLDoW4gdXNhciAyIGFjY2lvbmVzIGRlIHJlbmRlci4gQ29uIGF1dG9jbGVhciBmYWxzZSBwZXJtaXRpbW9zIHF1ZSBsYSBzZWd1bmRhIG5vIGJvcnJlIGxhIHByaW1lcmEuXG5cbiAgICB0aGlzLnJlbmRlcmVyLnNldFBpeGVsUmF0aW8oTWF0aC5taW4od2luZG93LmRldmljZVBpeGVsUmF0aW8sIDEpKTsgLy8tLVxuXG4gICAgdGhpcy4kY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7IC8vLS1cbiAgICAvLy0tXG5cbiAgICB0aGlzLmRvdHMgPSBuZXcgSG9tZTNEb3RzKHtcbiAgICAgIHdvcmxkR0w6IHRoaXNcbiAgICB9KTsgLy8tLVxuXG4gICAgdGhpcy5fcmVzaXplKCk7IC8vdGhpcy5fcmVuZGVyKCk7XG4gICAgLy90aGlzLl9pbml0X3Njcm9sbExpc3RlbmVycygpXG5cbiAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQVUJMSUNBUzpcblxuXG4gIF9jcmVhdGVDbGFzcyhIb21lM0FwcCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KG9iaikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5zbGlkZXJSZWYgPSBvYmouc2xpZGVyUmVmOyAvLy0tXG5cbiAgICAgIHRoaXMuc2xpZGVyUmVmLmVtaXR0ZXIub24oXCJvblNsaWRlckNoYW5nZVwiLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIF90aGlzLm9uU2xpZGVyQ2hhbmdlKG9iaik7XG4gICAgICB9KTsgLy8tLVxuXG4gICAgICB0aGlzLl9pbml0X3Njcm9sbExpc3RlbmVycygpO1xuXG4gICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwia2lsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgdGhpcy4kY29udGFpbmVyX3Njcm9sbFRyaWdnZXIua2lsbCgpO1xuICAgICAgZ3NhcC50aWNrZXIucmVtb3ZlKHRoaXMuX2JpbmRlZF9yZW5kZXIpO1xuICAgICAgZ3NhcC50aWNrZXIucmVtb3ZlKHRoaXMuX2JpbmRlZF9ldmFsX3Njcm9sbCk7XG4gICAgICB0aGlzLmRvdHMgPSBudWxsO1xuICAgIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB9LCB7XG4gICAga2V5OiBcIm9uU2xpZGVyQ2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU2xpZGVyQ2hhbmdlKG9iaikge1xuICAgICAgaWYgKHRoaXMuZG90cykge1xuICAgICAgICB0aGlzLmRvdHMuZG9DaGFuZ2VBbmltKG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uUmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lM0FwcC5vblJlc2l6ZSkhXCIpXG4gICAgICB0aGlzLl9yZXNpemUoKTtcbiAgICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUFJJVkFEQVM6XG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdF9zY3JvbGxMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRfc2Nyb2xsTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBiaW5kZWRfcmVuZGVyID0gZnVuY3Rpb24gYmluZGVkX3JlbmRlcigpIHtcbiAgICAgICAgX3RoaXMyLl9yZW5kZXIoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBiaW5kZWRfZXZhbF9zY3JvbGwgPSBmdW5jdGlvbiBiaW5kZWRfZXZhbF9zY3JvbGwoKSB7XG4gICAgICAgIF90aGlzMi5fZXZhbF9pbmVydGlhX3Njcm9sbChfdGhpczIuJGNvbnRhaW5lcl9zY3JvbGxUcmlnZ2VyLnByb2dyZXNzKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2JpbmRlZF9yZW5kZXIgPSBiaW5kZWRfcmVuZGVyO1xuICAgICAgdGhpcy5fYmluZGVkX2V2YWxfc2Nyb2xsID0gYmluZGVkX2V2YWxfc2Nyb2xsO1xuICAgICAgdGhpcy4kY29udGFpbmVyX3Njcm9sbFRyaWdnZXIgPSBTY3JvbGxUcmlnZ2VyLmNyZWF0ZSh7XG4gICAgICAgIHRyaWdnZXI6IHRoaXMuJGNvbnRhaW5lcixcbiAgICAgICAgc3RhcnQ6ICd0b3AgYm90dG9tJyxcbiAgICAgICAgZW5kOiAnYm90dG9tIHRvcCcsXG4gICAgICAgIHNjcnViOiB0cnVlLFxuICAgICAgICAvLyBTY3J1YjogR2VuZXJhIGV2ZW50b3MgZW4gdW5hIGZyYW5qYSBtYXMgcXVlIGVuIHVuIHB1bnRvLlxuICAgICAgICAvL21hcmtlcnM6IHRydWUsXG4gICAgICAgIG9uVG9nZ2xlOiBmdW5jdGlvbiBvblRvZ2dsZShzZWxmKSB7XG4gICAgICAgICAgaWYgKHNlbGYuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIGdzYXAudGlja2VyLmFkZChiaW5kZWRfcmVuZGVyKTtcbiAgICAgICAgICAgIGdzYXAudGlja2VyLmFkZChiaW5kZWRfZXZhbF9zY3JvbGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnc2FwLnRpY2tlci5yZW1vdmUoYmluZGVkX3JlbmRlcik7XG4gICAgICAgICAgICBnc2FwLnRpY2tlci5yZW1vdmUoYmluZGVkX2V2YWxfc2Nyb2xsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZXZhbF9pbmVydGlhX3Njcm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZhbF9pbmVydGlhX3Njcm9sbChwcm9ncmVzcykge1xuICAgICAgdmFyIGlubmVyRGF0YSA9IHRoaXMuJG1haW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgbmV3SW5uZXJZID0gaW5uZXJEYXRhLnk7XG4gICAgICB0aGlzLnNldHRpbmdzLnNjcm9sbF9wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfZGVsdGEgPSBuZXdJbm5lclkgLSB0aGlzLnNldHRpbmdzLnNjcm9sbF9sYXN0SW5uZXJZO1xuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfbGFzdElubmVyWSA9IG5ld0lubmVyWTtcbiAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX2xpbWl0ZWREZWx0YSA9IFdlYkdMVXRpbHMuY2xhbXAodGhpcy5zZXR0aW5ncy5zY3JvbGxfZGVsdGEsIC0yMCwgMjApOyAvLyBMaW1pdGEgbG9zIHZhbG9yZXMgYSAtMjAgLT4gKzIwXG5cbiAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSA9ICh0aGlzLnNldHRpbmdzLnNjcm9sbF9saW1pdGVkRGVsdGEgLyAyMCkudG9GaXhlZCgzKTsgLy8gUGFzYSBlbCBkZWx0YSBhIC0xIC0+ICsxXG5cbiAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX2ZhY3RvcmREZWx0YSA9IE1hdGguYWJzKHRoaXMuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSkgKyAwOyAvLyBWYWxvcmVzIGFic29sdXRvcyBkZSAwIC0+IDFcblxuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfZGlyZWN0aW9uID0gMTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSA8IDApIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfZGlyZWN0aW9uID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9ldmFsX2Zvb3Rlcl9zY3JvbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2YWxfZm9vdGVyX3Njcm9sbChwcm9ncmVzcykge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lM0FwcC5fZXZhbF9mb290ZXJfc2Nyb2xsKTogXCIrcHJvZ3Jlc3MpXG4gICAgICB0aGlzLnNldHRpbmdzLnNjcm9sbF9mb290ZXJfcHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgIHRoaXMuc2V0dGluZ3MubW9ycGhpbmdQcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZXZhbF9oZXJvX3Njcm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZhbF9oZXJvX3Njcm9sbChwcm9ncmVzcykge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lM0FwcC5fZXZhbF9oZXJvX3Njcm9sbCk6IFwiK3Byb2dyZXNzKVxuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfaGVyb19wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNpemUoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWUzQXBwLl9yZXNpemUpIVwiKVxuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuJGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy4kY29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICAgIHRoaXMucmVzcG9uc2l2ZVNjYWxlID0gdGhpcy53aWR0aCAvIHRoaXMuUkVGX1JFU09MVVRJT04ud2lkdGg7XG4gICAgICB0aGlzLmNhbWVyYURpc3RhbmNlID0gdGhpcy5SRUZfQ0FNRVJBX0RJU1RBTkNFICogKHRoaXMuaGVpZ2h0IC8gdGhpcy5SRUZfUkVTT0xVVElPTi5oZWlnaHQpO1xuICAgICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMuY2FtZXJhLmFzcGVjdCA9IHRoaXMud2lkdGggLyB0aGlzLmhlaWdodDtcbiAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSB0aGlzLmNhbWVyYURpc3RhbmNlO1xuICAgICAgdGhpcy5jYW1lcmEuZm92ID0gMiAqIE1hdGguYXRhbih0aGlzLmhlaWdodCAvIDIgLyB0aGlzLmNhbWVyYURpc3RhbmNlKSAqICgxODAgLyBNYXRoLlBJKTsgLy8gY29uc29sZS5sb2coXCJ0aGlzLndpZHRoOiBcIit0aGlzLndpZHRoKVxuICAgICAgLy8gY29uc29sZS5sb2coXCJ0aGlzLmhlaWdodDogXCIrdGhpcy5oZWlnaHQpXG4gICAgICAvLyBjb25zb2xlLmxvZyhcInRoaXMucmVzcG9uc2l2ZVNjYWxlOiBcIit0aGlzLnJlc3BvbnNpdmVTY2FsZSlcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwidGhpcy5jYW1lcmEuYXNwZWN0OiBcIit0aGlzLmNhbWVyYS5hc3BlY3QpXG4gICAgICAvLyBjb25zb2xlLmxvZyhcInRoaXMuY2FtZXJhLnBvc2l0aW9uLno6IFwiK3RoaXMuY2FtZXJhLnBvc2l0aW9uLnopXG4gICAgICAvLyBjb25zb2xlLmxvZyhcInRoaXMuY2FtZXJhLmZvdjogXCIrdGhpcy5jYW1lcmEuZm92KVxuICAgICAgLy8tLVxuXG4gICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7IC8vLS1cblxuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZCkge1xuICAgICAgICB0aGlzLmJhY2tncm91bmQucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZG90cykge1xuICAgICAgICB0aGlzLmRvdHMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lM0FwcC5fcmVuZGVyKSFcIilcbiAgICAgIGlmICh0aGlzLmhlaWdodCAhPSB0aGlzLiRjb250YWluZXIub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kKSB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZC5yZW5kZXIoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZG90cykge1xuICAgICAgICB0aGlzLmRvdHMucmVuZGVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTsgLy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXIuYmluZCh0aGlzKSlcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSG9tZTNBcHA7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IEhvbWUzQXBwOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgTWVzaFN1cmZhY2VTYW1wbGVyIH0gZnJvbSBcInRocmVlL2V4YW1wbGVzL2pzbS9tYXRoL01lc2hTdXJmYWNlU2FtcGxlclwiO1xuaW1wb3J0IHsgR0xURkxvYWRlciwgR0xUTG9hZGVyIH0gZnJvbSBcInRocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0dMVEZMb2FkZXJcIjtcbmltcG9ydCB7IERSQUNPTG9hZGVyIH0gZnJvbSBcInRocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0RSQUNPTG9hZGVyXCI7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcblxudmFyIExvYWRlZEdlb21ldHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhMb2FkZWRHZW9tZXRyeSwgX0V2ZW50RW1pdHRlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihMb2FkZWRHZW9tZXRyeSk7XG5cbiAgZnVuY3Rpb24gTG9hZGVkR2VvbWV0cnkob2JqLCBzZXR0aW5ncykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb2FkZWRHZW9tZXRyeSk7XG5cbiAgICAvL2NvbnNvbGUubG9nKFwiKExvYWRlZEdlb21ldHJ5LkNPTlNUUlVDVE9SQSkhXCIpXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTsgLy8tLVxuXG4gICAgX3RoaXMuZmlsZSA9IG9iai5maWxlO1xuICAgIF90aGlzLmlkID0gb2JqLmlkO1xuICAgIF90aGlzLmlzRHJhY28gPSBvYmouaXNEcmFjbyB8fCBmYWxzZTtcbiAgICBfdGhpcy5zY2FsZSA9IG9iai5zY2FsZTtcbiAgICBfdGhpcy5yb3RhdGlvblkgPSBvYmoucm90YXRpb25ZIHx8IDA7IC8vLS1cblxuICAgIF90aGlzLm51bURvdHMgPSBzZXR0aW5ncy5udW1Eb3RzOyAvLy0tXG5cbiAgICBfdGhpcy5tZXNoID0gbnVsbDtcbiAgICBfdGhpcy5zYW1wbGVyID0gbnVsbDtcbiAgICBfdGhpcy5hdHRyaWJ1dGVzID0ge1xuICAgICAgYV9wb3NpY2lvbmVzOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAzKSxcbiAgICAgIGFfcmFuZG9tbmVzczogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMylcbiAgICB9O1xuICAgIF90aGlzLmxvYWRlciA9IG5ldyBHTFRGTG9hZGVyKCk7XG5cbiAgICBpZiAoX3RoaXMuaXNEcmFjbykge1xuICAgICAgX3RoaXMuZHJhY29Mb2FkZXIgPSBuZXcgRFJBQ09Mb2FkZXIoKTtcblxuICAgICAgX3RoaXMuZHJhY29Mb2FkZXIuc2V0RGVjb2RlclBhdGgoXCIuL2RyYWNvL1wiKTtcblxuICAgICAgX3RoaXMubG9hZGVyLnNldERSQUNPTG9hZGVyKF90aGlzLmRyYWNvTG9hZGVyKTtcbiAgICB9XG5cbiAgICBfdGhpcy5sb2FkZWQgPSBmYWxzZTsgLy8tLVxuICAgIC8vdGhpcy5pbml0KClcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMb2FkZWRHZW9tZXRyeSwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vY29uc29sZS5sb2coXCIoTG9hZGVkR2VvbWV0cnkuaW5pdCkhXCIpXG4gICAgICB0aGlzLmxvYWRlci5sb2FkKHRoaXMuZmlsZSwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCIgICBtZXNoIFwiK3RoaXMuaWQrXCIgbG9hZGVkIVwiKVxuICAgICAgICAvL2NvbnNvbGUubG9nKFwicmVzcG9uc2U6IFwiLCByZXNwb25zZSlcbiAgICAgICAgX3RoaXMyLm1lc2ggPSByZXNwb25zZS5zY2VuZS5jaGlsZHJlblswXTtcblxuICAgICAgICBfdGhpczIubWVzaC5nZW9tZXRyeS5yb3RhdGVZKF90aGlzMi5yb3RhdGlvblkpO1xuXG4gICAgICAgIF90aGlzMi5zYW1wbGVyID0gbmV3IE1lc2hTdXJmYWNlU2FtcGxlcihfdGhpczIubWVzaCkuYnVpbGQoKTsgLy8tLVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMyLm51bURvdHM7IGkrKykge1xuICAgICAgICAgIHZhciBuZXdQb3N0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAgIF90aGlzMi5zYW1wbGVyLnNhbXBsZShuZXdQb3N0aW9uKTtcblxuICAgICAgICAgIF90aGlzMi5hdHRyaWJ1dGVzLmFfcG9zaWNpb25lcy5zZXQoW25ld1Bvc3Rpb24ueCAqIF90aGlzMi5zY2FsZSwgbmV3UG9zdGlvbi55ICogX3RoaXMyLnNjYWxlLCBuZXdQb3N0aW9uLnogKiBfdGhpczIuc2NhbGVdLCBpICogMyk7XG5cbiAgICAgICAgICBfdGhpczIuYXR0cmlidXRlcy5hX3JhbmRvbW5lc3Muc2V0KFtNYXRoLnJhbmRvbSgpICogMiAtIDEsIE1hdGgucmFuZG9tKCkgKiAyIC0gMSwgTWF0aC5yYW5kb20oKSAqIDIgLSAxXSwgaSAqIDMpO1xuICAgICAgICB9IC8vLS1cblxuXG4gICAgICAgIF90aGlzMi5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgIF90aGlzMi5lbWl0KFwib25NZXNoTG9hZGVkXCIsIHtcbiAgICAgICAgICByZWY6IF90aGlzMlxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMb2FkZWRHZW9tZXRyeTtcbn0oRXZlbnRFbWl0dGVyKTtcblxuZXhwb3J0IGRlZmF1bHQgTG9hZGVkR2VvbWV0cnk7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuLy9pbXBvcnQgKiBhcyBUSFJFRSBmcm9tIFwidGhyZWVcIlxuLy9pbXBvcnQgZ3NhcCBmcm9tIFwiZ3NhcFwiXG4vL2ltcG9ydCB7R0xURkxvYWRlciwgR0xUTG9hZGVyfSBmcm9tIFwidGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvR0xURkxvYWRlclwiXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbnZhciBBYm91dDFHZW9tZXRyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoQWJvdXQxR2VvbWV0cnksIF9FdmVudEVtaXR0ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQWJvdXQxR2VvbWV0cnkpO1xuXG4gIGZ1bmN0aW9uIEFib3V0MUdlb21ldHJ5KG9iaikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBYm91dDFHZW9tZXRyeSk7XG5cbiAgICAvL2NvbnNvbGUubG9nKFwiKEFib3V0MUdlb21ldHJ5LkNPTlNUUlVDVE9SQSk6IFwiLCBvYmopXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTsgLy8tLVxuXG4gICAgX3RoaXMuZmFjdG9yID0gb2JqLmZhY3RvcjsgLy82XG5cbiAgICBfdGhpcy5pbmNyX3JhZGlvID0gb2JqLmluY3JfcmFkaW87IC8vMjVcblxuICAgIF90aGlzLm51bU9yYml0cyA9IG9iai5udW1PcmJpdHM7IC8vMzdcblxuICAgIF90aGlzLmFycmF5X3RyaWFuZ3VsYXIgPSBvYmouYXJyYXlfdHJpYW5ndWxhcjtcbiAgICBfdGhpcy5udW1Eb3RzID0gb2JqLm51bURvdHM7IC8vLS1cblxuICAgIF90aGlzLmF0dHJpYnV0ZXMgPSB7XG4gICAgICBhX3Bvc2ljaW9uZXM6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDMpLFxuICAgICAgYV9kb3RfbnVtOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfb3JiaXRhbDogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX3Bvc19vcmJpdGE6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV9pbmNyX2FuZ3Vsb1JhZDogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX2FuZ3Vsb1JhZDogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX3JhZGlvOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfZGlyOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfaW5jcjogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX3g6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV95OiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfejogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSlcbiAgICB9OyAvLy0tXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLm51bURvdHM7IGkrKykge1xuICAgICAgdmFyIGRvdCA9IF90aGlzLl9nZXRfZG90KGkpO1xuXG4gICAgICB2YXIgaTMgPSBpICogMztcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9wb3NpY2lvbmVzW2kzXSA9IGRvdC54O1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXNbaTMgKyAxXSA9IGRvdC55O1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXNbaTMgKyAyXSA9IGRvdC56OyAvLy0tXG5cbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9kb3RfbnVtW2ldID0gaTtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9vcmJpdGFsW2ldID0gZG90Lm9yYml0YWw7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfcG9zX29yYml0YVtpXSA9IGRvdC5wb3Nfb3JiaXRhO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX2luY3JfYW5ndWxvUmFkW2ldID0gZG90LmluY3JfYW5ndWxvUmFkO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX2FuZ3Vsb1JhZFtpXSA9IGRvdC5hbmd1bG9SYWQ7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfcmFkaW9baV0gPSBkb3QucmFkaW87XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfZGlyW2ldID0gZG90LmRpcjtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9pbmNyW2ldID0gZG90LmluY3I7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfeFtpXSA9IGRvdC55O1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3lbaV0gPSBkb3QueTtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV96W2ldID0gZG90Lno7XG4gICAgfSAvLy0tXG5cblxuICAgIF90aGlzLmxvYWRlZCA9IGZhbHNlOyAvL2NvbnNvbGUubG9nKHRoaXMuYXR0cmlidXRlcy5hX2RvdF9udW0pXG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQWJvdXQxR2VvbWV0cnksIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoQWJvdXQxR2VvbWV0cnkuaW5pdCkhXCIpXG4gICAgICAvLy0tXG4gICAgICAvLy0tXG4gICAgICB0aGlzLmVtaXQoXCJvbk1lc2hMb2FkZWRcIiwge1xuICAgICAgICByZWY6IHRoaXNcbiAgICAgIH0pO1xuICAgIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBQUklWQURBU1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldF9kb3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9kb3QobnVtKSB7XG4gICAgICAvLyBEZXZ1ZWx2ZSB1biBvYmpldG8gY29uIGxhIGluZm9ybWFjacOtbiBkZSB1biBwdW50byBkZSBsYSBnZW9tZXRyaWEgXCJvcmJpdGFsIE1JT1RJXCJcbiAgICAgIHZhciBvYmogPSB7XG4gICAgICAgIG51bTogbnVtLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB6OiAwLFxuICAgICAgICBvcmJpdGFsOiAwLFxuICAgICAgICBjb19vcmJpdGFudGVzOiAwLFxuICAgICAgICBwb3Nfb3JiaXRhOiAwLFxuICAgICAgICBpbmNyX2FuZ3Vsb1JhZDogMCxcbiAgICAgICAgYW5ndWxvUmFkOiAwLFxuICAgICAgICByYWRpbzogMFxuICAgICAgfTsgLy8tLVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB0aGlzLmFycmF5X3RyaWFuZ3VsYXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbVN1cCA9IHRoaXMuYXJyYXlfdHJpYW5ndWxhcltpXTsgLy9jb25zb2xlLmxvZyhcImxpbVN1cDogXCIrbGltU3VwKVxuXG4gICAgICAgIGlmIChudW0gPiBsaW1TdXApIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIipcIilcbiAgICAgICAgICBvYmoub3JiaXRhbCA9IGkgKyAxO1xuICAgICAgICAgIG9iai5jb19vcmJpdGFudGVzID0gKGkgKyAxKSAqIHRoaXMuZmFjdG9yO1xuICAgICAgICAgIG9iai5wb3Nfb3JiaXRhID0gbnVtIC0gbGltU3VwIC0gMTtcbiAgICAgICAgICBvYmouaW5jcl9hbmd1bG9SYWQgPSAyICogTWF0aC5QSSAvIG9iai5jb19vcmJpdGFudGVzO1xuXG4gICAgICAgICAgaWYgKG9iai5vcmJpdGFsICUgMiA9PSAwKSB7XG4gICAgICAgICAgICBvYmouZGlyID0gMTtcbiAgICAgICAgICAgIG9iai5pbmNyID0gMDtcbiAgICAgICAgICAgIG9iai5hbmd1bG9SYWQgPSBvYmoucG9zX29yYml0YSAqIG9iai5pbmNyX2FuZ3Vsb1JhZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqLmRpciA9IC0xO1xuICAgICAgICAgICAgb2JqLmluY3IgPSAxO1xuICAgICAgICAgICAgb2JqLmFuZ3Vsb1JhZCA9IG9iai5wb3Nfb3JiaXRhICogb2JqLmluY3JfYW5ndWxvUmFkICsgb2JqLmluY3JfYW5ndWxvUmFkIC8gMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvYmoucmFkaW8gPSBvYmoub3JiaXRhbCAqIHRoaXMuaW5jcl9yYWRpbzsgLy8tLVxuXG4gICAgICAgICAgb2JqLnggPSBNYXRoLmNvcyhvYmouYW5ndWxvUmFkKSAqIG9iai5yYWRpbztcbiAgICAgICAgICBvYmoueSA9IE1hdGguc2luKG9iai5hbmd1bG9SYWQpICogb2JqLnJhZGlvO1xuICAgICAgICAgIG9iai56ID0gMDtcbiAgICAgICAgfSAvL2JyZWFrXG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWJvdXQxR2VvbWV0cnk7XG59KEV2ZW50RW1pdHRlcik7XG5cbmV4cG9ydCBkZWZhdWx0IEFib3V0MUdlb21ldHJ5OyIsImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhX3JhbmRvbW5lc3M7XFxuYXR0cmlidXRlIHZlYzMgYV9nZW8xX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfZG90X251bTtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9nZW8xX29yYml0YWw7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9wb3Nfb3JiaXRhO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfaW5jcl9hbmd1bG9SYWQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9hbmd1bG9SYWQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9pbmNyO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfZGlyO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfcmFkaW87XFxuXFxuYXR0cmlidXRlIHZlYzMgYV9nZW8yX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfZ2VvM19wb3NpdGlvbjtcXG5cXG51bmlmb3JtIGZsb2F0IHVUaW1lO1xcbnVuaWZvcm0gZmxvYXQgdUNhbWFyYURpc3RhbmNlO1xcbnVuaWZvcm0gZmxvYXQgdVNjcm9sbFNwZWVkO1xcbnVuaWZvcm0gZmxvYXQgdVNjYWxlO1xcbnVuaWZvcm0gZmxvYXQgdVJlc3BvbnNpdmVTY2FsZTtcXG51bmlmb3JtIGZsb2F0IHVTY3JvbGxEZWx0YTtcXG51bmlmb3JtIGZsb2F0IHVTY3JvbGxQcm9ncmVzcztcXG51bmlmb3JtIGZsb2F0IHVNb3JwaGluZ1Byb2dyZXNzO1xcbnVuaWZvcm0gZmxvYXQgdUludHJvUHJvZ3Jlc3M7XFxuXFxudW5pZm9ybSBmbG9hdCB1Um90YXRpb25Jbm5lcjtcXG51bmlmb3JtIGZsb2F0IHVSb3RhdGlvbk91dHRlcjtcXG5cXG51bmlmb3JtIGZsb2F0IHVQcm9ncmVzczA7XFxudW5pZm9ybSBmbG9hdCB1UHJvZ3Jlc3MwYjtcXG5cXG51bmlmb3JtIGZsb2F0IHVQcm9ncmVzczE7XFxudW5pZm9ybSBmbG9hdCB1UHJvZ3Jlc3MyO1xcbnVuaWZvcm0gZmxvYXQgdVByb2dyZXNzMztcXG51bmlmb3JtIGZsb2F0IHVQcm9ncmVzczQ7XFxudW5pZm9ybSBmbG9hdCB1UHJvZ3Jlc3M0YjtcXG51bmlmb3JtIGZsb2F0IHVQcm9ncmVzczU7XFxudW5pZm9ybSBmbG9hdCB1UHJvZ3Jlc3M2O1xcbnVuaWZvcm0gZmxvYXQgdVByb2dyZXNzNmI7XFxuXFxuLy8gdmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcXG4vL3ZhcnlpbmcgdmVjMiB2VXY7XFxudmFyeWluZyB2ZWMzIHZfcmFuZG9tbmVzcztcXG52YXJ5aW5nIGZsb2F0IHZfY29sb3JTdHJlbmd0aDtcXG5cXG52YXJ5aW5nIGZsb2F0IHZfYWN0aXZlUHVsc2U7XFxudmFyeWluZyBmbG9hdCB2X2FjdGl2ZVB1bHNlUHJvZ3Jlc3M7XFxudmFyeWluZyBmbG9hdCB2X3Rlc3Q7XFxuXFxuLy9cXHRDbGFzc2ljIFBlcmxpbiAzRCBOb2lzZSBcXG4vL1xcdGJ5IFN0ZWZhbiBHdXN0YXZzb25cXG4vL1xcbnZlYzQgcGVybXV0ZSh2ZWM0IHgpe3JldHVybiBtb2QoKCh4KjM0LjApKzEuMCkqeCwgMjg5LjApO31cXG52ZWM0IHRheWxvckludlNxcnQodmVjNCByKXtyZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO31cXG52ZWMzIGZhZGUodmVjMyB0KSB7cmV0dXJuIHQqdCp0Kih0Kih0KjYuMC0xNS4wKSsxMC4wKTt9XFxuXFxuZmxvYXQgY25vaXNlKHZlYzMgUCl7XFxuICB2ZWMzIFBpMCA9IGZsb29yKFApOyAvLyBJbnRlZ2VyIHBhcnQgZm9yIGluZGV4aW5nXFxuICB2ZWMzIFBpMSA9IFBpMCArIHZlYzMoMS4wKTsgLy8gSW50ZWdlciBwYXJ0ICsgMVxcbiAgUGkwID0gbW9kKFBpMCwgMjg5LjApO1xcbiAgUGkxID0gbW9kKFBpMSwgMjg5LjApO1xcbiAgdmVjMyBQZjAgPSBmcmFjdChQKTsgLy8gRnJhY3Rpb25hbCBwYXJ0IGZvciBpbnRlcnBvbGF0aW9uXFxuICB2ZWMzIFBmMSA9IFBmMCAtIHZlYzMoMS4wKTsgLy8gRnJhY3Rpb25hbCBwYXJ0IC0gMS4wXFxuICB2ZWM0IGl4ID0gdmVjNChQaTAueCwgUGkxLngsIFBpMC54LCBQaTEueCk7XFxuICB2ZWM0IGl5ID0gdmVjNChQaTAueXksIFBpMS55eSk7XFxuICB2ZWM0IGl6MCA9IFBpMC56enp6O1xcbiAgdmVjNCBpejEgPSBQaTEuenp6ejtcXG5cXG4gIHZlYzQgaXh5ID0gcGVybXV0ZShwZXJtdXRlKGl4KSArIGl5KTtcXG4gIHZlYzQgaXh5MCA9IHBlcm11dGUoaXh5ICsgaXowKTtcXG4gIHZlYzQgaXh5MSA9IHBlcm11dGUoaXh5ICsgaXoxKTtcXG5cXG4gIHZlYzQgZ3gwID0gaXh5MCAvIDcuMDtcXG4gIHZlYzQgZ3kwID0gZnJhY3QoZmxvb3IoZ3gwKSAvIDcuMCkgLSAwLjU7XFxuICBneDAgPSBmcmFjdChneDApO1xcbiAgdmVjNCBnejAgPSB2ZWM0KDAuNSkgLSBhYnMoZ3gwKSAtIGFicyhneTApO1xcbiAgdmVjNCBzejAgPSBzdGVwKGd6MCwgdmVjNCgwLjApKTtcXG4gIGd4MCAtPSBzejAgKiAoc3RlcCgwLjAsIGd4MCkgLSAwLjUpO1xcbiAgZ3kwIC09IHN6MCAqIChzdGVwKDAuMCwgZ3kwKSAtIDAuNSk7XFxuXFxuICB2ZWM0IGd4MSA9IGl4eTEgLyA3LjA7XFxuICB2ZWM0IGd5MSA9IGZyYWN0KGZsb29yKGd4MSkgLyA3LjApIC0gMC41O1xcbiAgZ3gxID0gZnJhY3QoZ3gxKTtcXG4gIHZlYzQgZ3oxID0gdmVjNCgwLjUpIC0gYWJzKGd4MSkgLSBhYnMoZ3kxKTtcXG4gIHZlYzQgc3oxID0gc3RlcChnejEsIHZlYzQoMC4wKSk7XFxuICBneDEgLT0gc3oxICogKHN0ZXAoMC4wLCBneDEpIC0gMC41KTtcXG4gIGd5MSAtPSBzejEgKiAoc3RlcCgwLjAsIGd5MSkgLSAwLjUpO1xcblxcbiAgdmVjMyBnMDAwID0gdmVjMyhneDAueCxneTAueCxnejAueCk7XFxuICB2ZWMzIGcxMDAgPSB2ZWMzKGd4MC55LGd5MC55LGd6MC55KTtcXG4gIHZlYzMgZzAxMCA9IHZlYzMoZ3gwLnosZ3kwLnosZ3owLnopO1xcbiAgdmVjMyBnMTEwID0gdmVjMyhneDAudyxneTAudyxnejAudyk7XFxuICB2ZWMzIGcwMDEgPSB2ZWMzKGd4MS54LGd5MS54LGd6MS54KTtcXG4gIHZlYzMgZzEwMSA9IHZlYzMoZ3gxLnksZ3kxLnksZ3oxLnkpO1xcbiAgdmVjMyBnMDExID0gdmVjMyhneDEueixneTEueixnejEueik7XFxuICB2ZWMzIGcxMTEgPSB2ZWMzKGd4MS53LGd5MS53LGd6MS53KTtcXG5cXG4gIHZlYzQgbm9ybTAgPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KGcwMDAsIGcwMDApLCBkb3QoZzAxMCwgZzAxMCksIGRvdChnMTAwLCBnMTAwKSwgZG90KGcxMTAsIGcxMTApKSk7XFxuICBnMDAwICo9IG5vcm0wLng7XFxuICBnMDEwICo9IG5vcm0wLnk7XFxuICBnMTAwICo9IG5vcm0wLno7XFxuICBnMTEwICo9IG5vcm0wLnc7XFxuICB2ZWM0IG5vcm0xID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChnMDAxLCBnMDAxKSwgZG90KGcwMTEsIGcwMTEpLCBkb3QoZzEwMSwgZzEwMSksIGRvdChnMTExLCBnMTExKSkpO1xcbiAgZzAwMSAqPSBub3JtMS54O1xcbiAgZzAxMSAqPSBub3JtMS55O1xcbiAgZzEwMSAqPSBub3JtMS56O1xcbiAgZzExMSAqPSBub3JtMS53O1xcblxcbiAgZmxvYXQgbjAwMCA9IGRvdChnMDAwLCBQZjApO1xcbiAgZmxvYXQgbjEwMCA9IGRvdChnMTAwLCB2ZWMzKFBmMS54LCBQZjAueXopKTtcXG4gIGZsb2F0IG4wMTAgPSBkb3QoZzAxMCwgdmVjMyhQZjAueCwgUGYxLnksIFBmMC56KSk7XFxuICBmbG9hdCBuMTEwID0gZG90KGcxMTAsIHZlYzMoUGYxLnh5LCBQZjAueikpO1xcbiAgZmxvYXQgbjAwMSA9IGRvdChnMDAxLCB2ZWMzKFBmMC54eSwgUGYxLnopKTtcXG4gIGZsb2F0IG4xMDEgPSBkb3QoZzEwMSwgdmVjMyhQZjEueCwgUGYwLnksIFBmMS56KSk7XFxuICBmbG9hdCBuMDExID0gZG90KGcwMTEsIHZlYzMoUGYwLngsIFBmMS55eikpO1xcbiAgZmxvYXQgbjExMSA9IGRvdChnMTExLCBQZjEpO1xcblxcbiAgdmVjMyBmYWRlX3h5eiA9IGZhZGUoUGYwKTtcXG4gIHZlYzQgbl96ID0gbWl4KHZlYzQobjAwMCwgbjEwMCwgbjAxMCwgbjExMCksIHZlYzQobjAwMSwgbjEwMSwgbjAxMSwgbjExMSksIGZhZGVfeHl6LnopO1xcbiAgdmVjMiBuX3l6ID0gbWl4KG5fei54eSwgbl96Lnp3LCBmYWRlX3h5ei55KTtcXG4gIGZsb2F0IG5feHl6ID0gbWl4KG5feXoueCwgbl95ei55LCBmYWRlX3h5ei54KTsgXFxuICByZXR1cm4gMi4yICogbl94eXo7XFxufVxcblxcbnZlYzMgZ2V0X3BvczEoZmxvYXQgYW5ndWxvUmFkKXtcXG4gICAgLy9mbG9hdCBhbmd1bG9SYWQgPSBhX2dlbzFfcG9zX29yYml0YSphX2dlbzFfaW5jcl9hbmd1bG9SYWQrKChhX2dlbzFfaW5jcl9hbmd1bG9SYWQvMi4pKmFfZ2VvMV9pbmNyKSsoMS4qYV9nZW8xX2RpciowLjIpO1xcbiAgICBmbG9hdCB4ID0gY29zKGFuZ3Vsb1JhZCkqYV9nZW8xX3JhZGlvO1xcbiAgICBmbG9hdCB5ID0gc2luKGFuZ3Vsb1JhZCkqYV9nZW8xX3JhZGlvO1xcbiAgICBmbG9hdCB6ID0gMC4wO1xcbiAgICB2ZWMzIG5ld1BvcyA9IHZlYzMoeCwgeSwgeik7XFxuICAgIHJldHVybiBuZXdQb3M7XFxufVxcblxcbnZlYzMgZ2V0X3Bvc1Njcm9sbFNwZWVkKHZlYzMgcG9zKXtcXG4gICAgZmxvYXQgZmFjdG9yID0gbWl4KDEuMCwgMi4wLCB1U2Nyb2xsU3BlZWQpO1xcbiAgICBwb3MgPSBwb3MqZmFjdG9yO1xcbiAgICByZXR1cm4gcG9zO1xcbn1cXG5cXG5mbG9hdCBnZXRfZXNjYWxhTm9pc2UoZmxvYXQgeCwgZmxvYXQgeSwgZmxvYXQgYW1wbGl0dWRNYXBhLCBmbG9hdCBwcm9ncmVzcyl7XFxuICAgIGZsb2F0IHZhbG9yID0gY25vaXNlKHZlYzMoeC9hbXBsaXR1ZE1hcGEsIHkvYW1wbGl0dWRNYXBhLCBwcm9ncmVzcykpO1xcbiAgICB2YWxvciA9IDAuNSsodmFsb3IvMi4pO1xcbiAgICB2YWxvciAqPTIuO1xcbiAgICByZXR1cm4gdmFsb3I7XFxufVxcblxcbmZsb2F0IGdldF9lc2NhbGFPbmRhUmFkaWFsKGZsb2F0IG9yYml0YWwsIGZsb2F0IHByb2dyZXNzKXtcXG4gICAgZmxvYXQgZnJlY3VlbmNpYSA9IDAuNTsgLy8gVmFsb3JlcyBiYWpvcyBvbmRhcyBtYXMgbGFyZ2FzLCB2YWxvcmVzIGFsdG9zIG9uZGFzIG1hcyBjb3J0YXNcXG4gICAgZmxvYXQgc2VubyA9IChzaW4oKHByb2dyZXNzK29yYml0YWwpKmZyZWN1ZW5jaWEpKzEuKS8yLjtcXG5cXG4gICAgZmxvYXQgdmFsb3IgPSAwLjUrKHNlbm8qMC41KTtcXG5cXG4gICAgcmV0dXJuIHZhbG9yO1xcbn1cXG5cXG5mbG9hdCBnZXRfZXNjYWxhRWRnZShmbG9hdCBvcmJpdGFsKXtcXG4gICAgZmxvYXQgdmFsdWUgPSAxLjtcXG4gICAgZmxvYXQgb3JiaXRhbE1heCA9IDM3LjtcXG4gICAgZmxvYXQgZmFkZUxpbWl0ID0gMjIuO1xcbiAgICBmbG9hdCBmYWRlU2NhbGUgPSAxLjtcXG4gICAgZmxvYXQgcmFuZ28gPSBvcmJpdGFsTWF4IC1mYWRlTGltaXQ7XFxuICAgIGlmKG9yYml0YWwgPj0gZmFkZUxpbWl0KXtcXG4gICAgICAgIGZsb2F0IG9yYml0YWxSZWwgPSBvcmJpdGFsIC1mYWRlTGltaXQ7XFxuICAgICAgICBmbG9hdCByYXRpbyA9IG9yYml0YWxSZWwvcmFuZ287XFxuICAgICAgICBmYWRlU2NhbGUgPSBmYWRlU2NhbGUtcmF0aW87XFxuICAgIH1cXG4gICAgcmV0dXJuIGZhZGVTY2FsZTtcXG59XFxuXFxudmVjMyByYW5kb21pemVQb3NpdGlvbih2ZWMzIG9sZFBvcywgdmVjMyByYW5kb21uZXNzLCBmbG9hdCB0aW1lLCBmbG9hdCBhbXBsaXR1ZGUsIGZsb2F0IGFtb3VudCwgZmxvYXQgc3BlZWQpe1xcbiAgICB0aW1lID0gdGltZSpzcGVlZDtcXG4gICAgdmVjMyBuZXdQb3MgPSBvbGRQb3M7XFxuICAgIG5ld1Bvcy54ICs9IHNpbih0aW1lICogcmFuZG9tbmVzcy54KSAqIChhbXBsaXR1ZGUqYW1vdW50KTtcXG4gICAgbmV3UG9zLnkgKz0gY29zKHRpbWUgKiByYW5kb21uZXNzLnkpICogKGFtcGxpdHVkZSphbW91bnQpO1xcbiAgICBuZXdQb3MueiArPSBjb3ModGltZSAqIHJhbmRvbW5lc3MueikgKiAoYW1wbGl0dWRlKmFtb3VudCk7XFxuICAgIHJldHVybiBuZXdQb3M7XFxufVxcblxcbmZsb2F0IHF1aW50aWNPdXQoZmxvYXQgdCkge1xcbiAgcmV0dXJuIChwb3codCAtIDEuMCwgNS4wKSk7XFxufVxcblxcbmZsb2F0IHF1YWRyYXRpY091dChmbG9hdCB0KSB7XFxuICByZXR1cm4gLXQgKiAodCAtIDIuMCk7XFxufVxcblxcbmZsb2F0IHF1YXJ0aWNPdXQoZmxvYXQgdCkge1xcbiAgcmV0dXJuIHBvdyh0IC0gMS4wLCAzLjApICogKDEuMCAtIHQpICsgMS4wO1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIC8vIGZsb2F0IHRpbWUgPSB1VGltZSAqIDQuOyAgICBcXG5cXG4gICAgLy92ZWMzIHBvcyA9IG1peChwb3NpdGlvbiwgYV9nZW8xX3Bvc2l0aW9uLCB1UHJvZ3Jlc3MpO1xcbiAgICAvLyB2ZWMzIHBvcyA9IGFfZ2VvMl9wb3NpdGlvbjtcXG4gICAgLy92ZWMzIHBvcyA9IHBvc2l0aW9uO1xcbiAgICAvL3ZlYzMgcG9zMSA9IGdldF9wb3MxKCk7XFxuICAgIC8vcG9zMSA9IHBvczEqKHNpbigoLXVUaW1lK2FfZ2VvMV9vcmJpdGFsKSowLjUpKzIuKSowLjE7XFxuXFxuICAgIC8vZmxvYXQgc2Vub0Z4ID0gc2luKCgtdVRpbWUrYV9nZW8xX29yYml0YWwpKSowLjUqMC41O1xcbiAgICAvL2Zsb2F0IGVzY2FsYUZ4ID0gbWl4KDAuOTgsIDEuMDIsIHNlbm9GeCk7XFxuICAgIC8vcG9zMSA9IHBvczEqZXNjYWxhRng7XFxuICAgIC8vcG9zMSA9IGdldF9wb3NTY3JvbGxTcGVlZChwb3MxKTtcXG5cXG4gICAgLy92ZWMzIGVuZFBvcyA9IG1peChhX2dlbzJfcG9zaXRpb24sIGFfZ2VvM19wb3NpdGlvbiwgMC4pO1xcbiAgICAvL3ZlYzMgZW5kUG9zID0gYV9nZW8yX3Bvc2l0aW9uO1xcbiAgICAvL3ZlYzMgcG9zID0gbWl4KHBvczEsIGFfZ2VvMl9wb3NpdGlvbiwgdVByb2dyZXNzMSk7XFxuICAgIC8vcG9zID0gcmFuZG9taXplUG9zaXRpb24ocG9zLCBhX3JhbmRvbW5lc3MsIHVUaW1lLCA1LjAsIHVQcm9ncmVzczEsIDUuKTtcXG4gICAgLy8gcG9zLnggKz0gc2luKHRpbWUgKiBhX3JhbmRvbW5lc3MueCkgKjAuMDI7XFxuICAgIC8vIHBvcy55ICs9IGNvcyh0aW1lICogYV9yYW5kb21uZXNzLnkpICowLjAyO1xcbiAgICAvLyBwb3MueiArPSBjb3ModGltZSAqIGFfcmFuZG9tbmVzcy56KSAqMC4wMjtcXG4gICAgXFxuICAgIC8vIHBvcyAqPSB1U2NhbGU7XFxuICAgIC8vIHZQb3NpdGlvbiA9IHBvcztcXG5cXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIC8vIFBPU0lUSU9OOlxcbiAgICBmbG9hdCByb3RhdGlvbiA9IG1peCh1Um90YXRpb25Jbm5lciwgdVJvdGF0aW9uT3V0dGVyLCAoKGFfZ2VvMV9vcmJpdGFsKSoxLikvMzcuKTtcXG4gICAgZmxvYXQgYW5ndWxvUmFkX3RpbWUgPSAoYV9nZW8xX2FuZ3Vsb1JhZCtyb3RhdGlvbik7XFxuICAgIC8vIEdlb21ldHJpZXMgcHJlc2VudDpcXG4gICAgLy9mbG9hdCBhbmd1bG9SYWQgPSBhX2dlbzFfcG9zX29yYml0YSphX2dlbzFfaW5jcl9hbmd1bG9SYWQrKChhX2dlbzFfaW5jcl9hbmd1bG9SYWQvMi4pKmFfZ2VvMV9pbmNyKSsodVNjcm9sbFByb2dyZXNzKmFfZ2VvMV9kaXIqMi4yKTtcXG4gICAgdmVjMyBQT1NJVElPTl8xID0gZ2V0X3BvczEoYW5ndWxvUmFkX3RpbWUpO1xcbiAgICAvL3ZlYzMgUE9TSVRJT05fMSA9IHBvc2l0aW9uO1xcbiAgICB2ZWMzIFBPU0lUSU9OXzIgPSBhX2dlbzJfcG9zaXRpb247XFxuICAgIFBPU0lUSU9OXzIgPSByYW5kb21pemVQb3NpdGlvbihQT1NJVElPTl8yLCBhX3JhbmRvbW5lc3MsIHVUaW1lLCA1LjAsIHVNb3JwaGluZ1Byb2dyZXNzLCA1Lik7XFxuICAgIC8vIFogbW9kaWZpY2F0aW9uczpcXG4gICAgXFxuICAgIC8vIE9uZGFzIGRlIHNlbm86XFxuICAgIGZsb2F0IHNlbm9GeCA9IHNpbigoLXVUaW1lK2FfZ2VvMV9vcmJpdGFsKSkqMC41KjAuNTtcXG4gICAgZmxvYXQgZXNjYWxhRnggPSBtaXgoMC45OCwgMS4wMiwgc2Vub0Z4KTtcXG4gICAgLy9QT1NJVElPTl8xICo9IGVzY2FsYUZ4O1xcbiAgICAvLyBNb3JwaGluZzpcXG4gICAgZmxvYXQgY2xhbXBlZF9tb3JwaW5nUHJvZ3Jlc3MgPSBjbGFtcCgwLiwgMC45NSwgdU1vcnBoaW5nUHJvZ3Jlc3MpO1xcbiAgICBQT1NJVElPTl8xID0gbWl4KFBPU0lUSU9OXzEsIFBPU0lUSU9OXzIsIGNsYW1wZWRfbW9ycGluZ1Byb2dyZXNzKTtcXG4gICAgLy8gUmFuZG9taXplZCBwb3NpdGlvbiB3aGlsZSBpbiBQT1NJVElPTl8yXFxuICAgIFBPU0lUSU9OXzEgPSByYW5kb21pemVQb3NpdGlvbihQT1NJVElPTl8xLCBhX3JhbmRvbW5lc3MqMi4sIHVUaW1lLCA1LjAsIHVNb3JwaGluZ1Byb2dyZXNzLCAyLjUpO1xcbiAgICAvLyBFc2NhbGEgcG9yIHNjcm9sbCBkZWx0YTpcXG4gICAgLy9QT1NJVElPTl8xICo9IDEuKyh1U2Nyb2xsRGVsdGEpO1xcbiAgICAvLyBFc2NhbGFkbyBpbmNpYWw6XFxuICAgIC8vUE9TSVRJT05fMSAqPSBtaXgoNS4sIDEuLCBxdWludGljT3V0KHVJbnRyb1Byb2dyZXNzKSk7XFxuICAgIC8vUE9TSVRJT05fMSAqPSBtaXgoNS4sIDEuLCBxdWFkcmF0aWNPdXQodUludHJvUHJvZ3Jlc3MpKTtcXG4gICAgLy9QT1NJVElPTl8xICo9IG1peCgxMC4sIDEuLCBxdWFydGljT3V0KHVJbnRyb1Byb2dyZXNzKSk7XFxuICAgIFBPU0lUSU9OXzEgKj0gbWl4KDEwLiwgMS4sIHVJbnRyb1Byb2dyZXNzKTtcXG4gICAgLy8gUmVzcG9uc2l2ZSBTY2FsZTpcXG4gICAgUE9TSVRJT05fMSAqPSB1UmVzcG9uc2l2ZVNjYWxlO1xcbiAgICAvL1xcbiAgICBQT1NJVElPTl8xID0gbWl4KFBPU0lUSU9OXzEsIFBPU0lUSU9OXzIsIHVNb3JwaGluZ1Byb2dyZXNzKTtcXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyBTSVpFOlxcbiAgICBmbG9hdCBTSVpFXzEgPSA4LjtcXG4gICAgLy8gTG9zIHB1bnRvcyBzb24gbWFzIHBlcXVlw7FvcyBlbiBsb3Mgb3JiaXRhbGVzIGRlIGxhIHBlcmlmZXJpYVxcbiAgICBmbG9hdCBlc2NsYUVkZWdlID0gZ2V0X2VzY2FsYUVkZ2UoYV9nZW8xX29yYml0YWwpOyBcXG4gICAgZmxvYXQgcmFuZ28gPSAxLi1lc2NsYUVkZWdlO1xcbiAgICBTSVpFXzEgKj0gKGVzY2xhRWRlZ2UgKyAocmFuZ28qdVByb2dyZXNzMSkpO1xcbiAgICAvLyBMb3MgcHVudG9zIHNlIGVzY2FsYW4gZW4gYmFzZSBhIHVuIG1hcGEgZGUgcnVpZG9cXG4gICAgU0laRV8xICo9IG1peCgxLiwgZ2V0X2VzY2FsYU5vaXNlKFBPU0lUSU9OXzEueCwgUE9TSVRJT05fMS55LCA1MDAuLCB1UHJvZ3Jlc3MwKSwgdVByb2dyZXNzMGIpO1xcbiAgICAvLyBMb3MgcHVudG9zIHNlIGVzY2FsYW4gZW4gYmFzZSBhIG9uZGFzIGNvbmNlbnRyaWNhcyBkZSBzZW5vOlxcbiAgICBTSVpFXzEgKj0gbWl4KDEuLCBnZXRfZXNjYWxhT25kYVJhZGlhbChhX2dlbzFfb3JiaXRhbCwgLXVUaW1lKjEwLiksIHVQcm9ncmVzczRiKTtcXG4gICAgLy8gTG9zIHB1bnRvcyBzZSBlc2NhbGFuIHBvciBwdWxzb24gcmFuZG9tOlxcbiAgICBTSVpFXzEgKj0gbWl4KDEuLCAxLjUsIHZfYWN0aXZlUHVsc2VQcm9ncmVzcyk7XFxuICAgIC8vIExvcyBwdW50b3Mgc2UgZXNjYWxhbiBqdW50byBjb24gbGEgZ2VvbWV0cmlhIGNvbiBlbCBzY3JvbGxkZWx0YVxcbiAgICBTSVpFXzEgKj0gMS4rKHVTY3JvbGxEZWx0YSk7XFxuXFxuICAgIGZsb2F0IFNJWkVfMiA9IDUuOyBcXG4gICAgLy8gXFxuICAgIGZsb2F0IHpEZXB0aE5vcm0gPSAoUE9TSVRJT05fMi56KzYwMC4pLyg2MDAuKjIuKTsgLy8gZGUgLTYwMCBhIDYwMCBkZSB1biB2YWxvciBub3JtYWxpemFkbyAoc2luIGNsYW1wLCBlcyBkZWNpciBxdWUgcHVlZGUgc2VyIDwwIHkgPjEpIGRlIGxhIHBvc2ljaW9uIHpcXG4gICAgZmxvYXQgekRlcHRoQWxwaGEgPSBtaXgoMC4yLCAwLjksIHpEZXB0aE5vcm0pO1xcbiAgICBmbG9hdCB6RGVwdGhTY2FsZSA9IG1peCgwLjgsIDIuNSwgekRlcHRoTm9ybSk7XFxuICAgIGZsb2F0IHJhbmRvbVNpemUgPSBTSVpFXzIgKjAuNSsoYV9yYW5kb21uZXNzLngqMC45KTtcXG4gICAgcmFuZG9tU2l6ZSAqPSB6RGVwdGhTY2FsZTtcXG4gICAgU0laRV8yID0gbWl4KFNJWkVfMiwgcmFuZG9tU2l6ZSwgdU1vcnBoaW5nUHJvZ3Jlc3MpO1xcbiAgICBcXG4gICAgXFxuICAgIGZsb2F0IFNJWkUgPSBtaXgoU0laRV8xLCBTSVpFXzIsIHVNb3JwaGluZ1Byb2dyZXNzKTtcXG4gICAgLy8gTG9zIHB1bnRvcyBzZSBlc2NhbGFuIHNpIHNlIHJlZGltZW5zb25hIGVsIGxpZW56b1xcbiAgICBTSVpFICo9IHVSZXNwb25zaXZlU2NhbGU7XFxuICAgIFxcbiAgICBcXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyBWRVJURVhcXG4gICAgdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggUE9TSVRJT05fMSwgMS4wICk7XFxuICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxuICAgIGdsX1BvaW50U2l6ZSA9IFNJWkUqKHVDYW1hcmFEaXN0YW5jZS8tbXZQb3NpdGlvbi56KTtcXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIFxcblxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgLy8gVkFSWUlOR1M6XFxuICAgIHZfcmFuZG9tbmVzcyA9IGFfcmFuZG9tbmVzcztcXG4gICAgdl9jb2xvclN0cmVuZ3RoID0gZ2V0X2VzY2FsYU5vaXNlKFBPU0lUSU9OXzEueCwgUE9TSVRJT05fMS55LCAyMDAuLCBzaW4odVRpbWUpKTtcXG4gICAgdl9jb2xvclN0cmVuZ3RoID0gbWl4KDEuLCB2X2NvbG9yU3RyZW5ndGgsIHVNb3JwaGluZ1Byb2dyZXNzKTtcXG5cXG59XCI7IiwiZXhwb3J0IGRlZmF1bHQgXCIjZGVmaW5lIEdMU0xJRlkgMVxcbi8vIHZhcnlpbmcgdmVjMyB2UG9zaXRpb247XFxuLy8gdmFyeWluZyB2ZWMyIHZVdjtcXG5cXG52YXJ5aW5nIHZlYzMgdl9yYW5kb21uZXNzO1xcbnZhcnlpbmcgZmxvYXQgdl9jb2xvclN0cmVuZ3RoO1xcblxcbnVuaWZvcm0gdmVjMyB1Q29sb3IxO1xcbnVuaWZvcm0gdmVjMyB1Q29sb3IyO1xcbnVuaWZvcm0gdmVjMyB1Q29sb3IzO1xcblxcbnVuaWZvcm0gZmxvYXQgdVByb2dyZXNzMTtcXG51bmlmb3JtIGZsb2F0IHVQcm9ncmVzczI7XFxudW5pZm9ybSBmbG9hdCB1UHJvZ3Jlc3MzO1xcbnVuaWZvcm0gZmxvYXQgdUludHJvUHJvZ3Jlc3M7XFxuXFxudmFyeWluZyBmbG9hdCB2X2FjdGl2ZVB1bHNlO1xcbnZhcnlpbmcgZmxvYXQgdl9hY3RpdmVQdWxzZVByb2dyZXNzOyBcXG52YXJ5aW5nIGZsb2F0IHZfdGVzdDtcXG5cXG5mbG9hdCBxdWFydGljT3V0KGZsb2F0IHQpIHtcXG4gIHJldHVybiBwb3codCAtIDEuMCwgMy4wKSAqICgxLjAgLSB0KSArIDEuMDtcXG59XFxuXFxuZmxvYXQgY2lyY3VsaXphcihmbG9hdCByYWRpbyl7XFxuICAgIC8vIHJhZGlvIGVzIHVuIHZhbG9yIGVudHJlIDAgeSAxLiAwIGVzIDAgZGUgcmFkaW8geSAxIGVzIGVsIG1heGltbyBkZWwgcmFkaW8gZGVudHJvIGRlXFxuICAgIHJhZGlvID0gMS4wLSgwLjUqcmFkaW8pO1xcbiAgICBmbG9hdCByZXN1bHQgPSBkaXN0YW5jZShnbF9Qb2ludENvb3JkLCB2ZWMyKDAuNSwgMC41KSk7XFxuICAgIHJlc3VsdCA9IDEuIC1yZXN1bHQ7XFxuICAgIHJlc3VsdCA9IHBvdyhyZXN1bHQsIDEuKTtcXG4gICAgcmVzdWx0ID0gc3RlcChyYWRpbywgcmVzdWx0KTtcXG4gICAgcmV0dXJuIHJlc3VsdDtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcblxcbiAgICBmbG9hdCByYW5kb21uZXNzQ2lyID0gdl9yYW5kb21uZXNzLngqdVByb2dyZXNzMTtcXG4gICAgcmFuZG9tbmVzc0NpciA9IG1peCgxLiwgcmFuZG9tbmVzc0NpciwgdVByb2dyZXNzMSk7XFxuICAgIC8vZmxvYXQgYWxwaGEgPSBjaXJjdWxpemFyKDEuMCpyYW5kb21uZXNzQ2lyKTtcXG4gICAgZmxvYXQgYWxwaGEgPSBjaXJjdWxpemFyKDEuMCk7XFxuXFxuICAgIC8vYWxwaGEgKj0gbWl4KC0yLiwgMS4sIHF1YXJ0aWNPdXQodUludHJvUHJvZ3Jlc3MpKTtcXG4gICAgYWxwaGEgKj0gbWl4KDAuOCwgMS4sIHVJbnRyb1Byb2dyZXNzKTtcXG5cXG4gICAgdmVjMyBmaW5hbENvbG9yID0gbWl4KHVDb2xvcjIsIHVDb2xvcjEsIHZfY29sb3JTdHJlbmd0aCk7XFxuXFxuICAgIHZlYzMgY29sb3JXaGl0ZSA9IHZlYzMoMS4wLCAxLjAsIDEuMCk7XFxuICAgIHZlYzMgbWl4QWN0aXZlQ29sb3IgPSBtaXgoZmluYWxDb2xvciwgdUNvbG9yMywgdl9hY3RpdmVQdWxzZSk7XFxuXFxuICAgIHZlYzMgd2hpdGUgPSB2ZWMzKDEuLCAxLiwgMS4pO1xcblxcbiAgICBmaW5hbENvbG9yID0gIG1peChmaW5hbENvbG9yLCB3aGl0ZSwgdl9hY3RpdmVQdWxzZVByb2dyZXNzKjAuMTUpO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGZpbmFsQ29sb3IsIGFscGhhKTtcXG5cXG59XCI7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCBnc2FwIGZyb20gXCJnc2FwXCI7XG5pbXBvcnQgRWFzaW5nIGZyb20gJ2Vhc2luZy1mdW5jdGlvbnMnO1xuaW1wb3J0IFdlYkdMVXRpbHMgZnJvbSBcIi4uL1dlYkdMVXRpbHNcIjtcbmltcG9ydCBFYXNlZE91dFZhbHVlIGZyb20gJy4uL0Vhc2VkT3V0VmFsdWUnO1xuaW1wb3J0IExvYWRlZEdlb21ldHJ5IGZyb20gJy4uL0xvYWRlZEdlb21ldHJ5JztcbmltcG9ydCBIb21lNEdlb21ldHJ5IGZyb20gJy4vSG9tZTRHZW9tZXRyeSc7XG5pbXBvcnQgdmVydGV4IGZyb20gXCIuL3NoYWRlcnMvaG9tZTRfZG90c192ZXJ0ZXguZ2xzbFwiO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gXCIuL3NoYWRlcnMvaG9tZTRfZG90c19mcmFnbWVudC5nbHNsXCI7XG5cbnZhciBIb21lNERvdHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIb21lNERvdHMob2JqKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIb21lNERvdHMpO1xuXG4gICAgLy9jb25zb2xlLmxvZyhcIihIb21lNERvdHMuQ09OU1RSVUNUT1JBKSFcIilcbiAgICAvL2NvbnNvbGUubG9nKG9iailcbiAgICB0aGlzLndvcmxkR0wgPSBvYmoud29ybGRHTDsgLy8tLVxuXG4gICAgdGhpcy5zY2VuZSA9IHRoaXMud29ybGRHTC5zY2VuZTtcbiAgICB0aGlzLmNhbWVyYURpc3RhbmNlID0gdGhpcy53b3JsZEdMLmNhbWVyYURpc3RhbmNlOyAvLy0tXG5cbiAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcbiAgICB0aGlzLmdlb21ldHJ5ID0gbnVsbDtcbiAgICB0aGlzLm1lc2ggPSBudWxsO1xuICAgIHRoaXMubnVtUGFydGljbGVzID0gbnVsbDtcbiAgICB0aGlzLmFsbExvYWRlZCA9IGZhbHNlO1xuICAgIHRoaXMuY3JlYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xvY2sgPSBuZXcgVEhSRUUuQ2xvY2soKTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy5pbnRyb1RpbWUgPSAxLjI7XG4gICAgdGhpcy5yb3RhdGlvblggPSAwO1xuICAgIHRoaXMucm90YXRpb25ZID0gMDtcbiAgICB0aGlzLnJvdGF0aW9uV2FudGVkWCA9IDA7XG4gICAgdGhpcy5yb3RhdGlvbldhbnRlZFkgPSAwO1xuICAgIHRoaXMubW9ycGhpbmdQcm9ncmVzcyA9IDA7IC8vLS1cblxuICAgIHRoaXMuZWFzZWRfcm90YXRpb24gPSBuZXcgRWFzZWRPdXRWYWx1ZSgwLCAwLjA1KTtcbiAgICB0aGlzLmVhc2VkX3Njcm9sbERlbHRhID0gbmV3IEVhc2VkT3V0VmFsdWUodGhpcy53b3JsZEdMLnNldHRpbmdzLnNjcm9sbF9ub3JtYWxpemVkRGVsdGEgKiAwLjMsIDAuMDUpO1xuICAgIHRoaXMuZWFzZWRfc2Nyb2xsRGVsdGFfZmFzdCA9IG5ldyBFYXNlZE91dFZhbHVlKHRoaXMud29ybGRHTC5zZXR0aW5ncy5zY3JvbGxfbm9ybWFsaXplZERlbHRhICogMC41LCAwLjEpO1xuICAgIHRoaXMuZWFzZWRfc2Nyb2xsUHJvZ3Jlc3MgPSBuZXcgRWFzZWRPdXRWYWx1ZSh0aGlzLndvcmxkR0wuc2V0dGluZ3Muc2Nyb2xsX3Byb2dyZXNzLCAwLjA1KTsgLy8tLVxuXG4gICAgdGhpcy5fc2V0dXBfc2V0dGluZ3MoKTsgLy8tLVxuXG5cbiAgICB0aGlzLm9yYml0YWxfZ2VvbWV0cnkgPSBuZXcgSG9tZTRHZW9tZXRyeSh0aGlzLnNldHRpbmdzKTsgLy8tLVxuXG4gICAgdGhpcy5NX2dlb21ldHJ5ID0gbmV3IExvYWRlZEdlb21ldHJ5KHtcbiAgICAgIGlkOiBcIk1fZ2VvbWV0cnlcIixcbiAgICAgIGZpbGU6IFwid3AtY29udGVudC90aGVtZXMvbWlvdGljb25zdWx0aW5nL2ltZy9NLmdsYlwiLFxuICAgICAgaXNEcmFjbzogZmFsc2UsXG4gICAgICBzY2FsZTogNjAwIC8vcm90YXRpb25ZIDogLU1hdGguUEkqMC4yNVxuXG4gICAgfSwgdGhpcy5zZXR0aW5ncyk7XG4gICAgdGhpcy5NX2dlb21ldHJ5Lm9uKFwib25NZXNoTG9hZGVkXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWU0RG90cykgb25NZXNoTG9hZGVkIVwiKVxuICAgICAgX3RoaXMuX2V2YWxfYWxsTG9hZGVkKCk7XG4gICAgfSk7IC8vLS1cblxuICAgIHRoaXMucmVzaXplKCk7IC8vLS1cblxuICAgIHRoaXMuTV9nZW9tZXRyeS5pbml0KCk7XG4gIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUFVCTElDQVM6XG5cblxuICBfY3JlYXRlQ2xhc3MoSG9tZTREb3RzLCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lNERvdHMuX2NyZWF0ZSkhXCIpXG4gICAgICAvLy0tXG4gICAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICAgIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nLFxuICAgICAgICAvL2JsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAgICAgICAgLy9ibGVuZGluZzogVEhSRUUuTXVsdGlwbHlCbGVuZGluZyxcbiAgICAgICAgdmVydGV4Q29sb3JzOiB0cnVlLFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IHZlcnRleCxcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50LFxuICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICB1Q29sb3IxOiB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKFwiIzE3MGU0MVwiKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy84MDFjNjVcbiAgICAgICAgICB1Q29sb3IyOiB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKFwiIzgwMWM2NVwiKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdUNvbG9yMzoge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcihcIiM4ODAzNjRcIilcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVUaW1lOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdUNhbWFyYURpc3RhbmNlOiB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5jYW1lcmFEaXN0YW5jZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVNjcm9sbERlbHRhOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVNjcm9sbFByb2dyZXNzOiB7XG4gICAgICAgICAgICB2YWx1ZTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVJlc3BvbnNpdmVTY2FsZToge1xuICAgICAgICAgICAgdmFsdWU6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVSb3RhdGlvbjE6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Um90YXRpb24yOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVJvdGF0aW9uMzoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVSb3RhdGlvbklubmVyOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVJvdGF0aW9uT3V0dGVyOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdU1vcnBoaW5nUHJvZ3Jlc3M6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1SW50cm9Qcm9ncmVzczoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVTY3JvbGxTcGVlZDoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVQcm9ncmVzczA6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UHJvZ3Jlc3MwYjoge1xuICAgICAgICAgICAgdmFsdWU6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVQcm9ncmVzczE6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UHJvZ3Jlc3MyOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVByb2dyZXNzMzoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVQcm9ncmVzczQ6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UHJvZ3Jlc3M0Yjoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVQcm9ncmVzczU6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UHJvZ3Jlc3M2OiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVByb2dyZXNzNmI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSAvL3VTY2FsZToge3ZhbHVlOiAxfSxcbiAgICAgICAgICAvL3VTaXplOiB7dmFsdWU6IDMwICogdGhpcy5yZW5kZXJlci5nZXRQaXhlbFJhdGlvKCl9XG5cbiAgICAgICAgfVxuICAgICAgfSk7IC8vLS1cbiAgICAgIC8vY29uc29sZS5sb2codGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9wb3NpY2lvbmVzKVxuICAgICAgLy8tLVxuXG4gICAgICB0aGlzLmdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfcG9zaWNpb25lcywgMykpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9wb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9wb3NpY2lvbmVzLCAzKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX2RvdF9udW0nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfZG90X251bSwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9vcmJpdGFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX29yYml0YWwsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfcG9zX29yYml0YScsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9wb3Nfb3JiaXRhLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX2luY3JfYW5ndWxvUmFkJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX2luY3JfYW5ndWxvUmFkLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX2FuZ3Vsb1JhZCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9hbmd1bG9SYWQsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfcmFkaW8nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfcmFkaW8sIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfZGlyJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX2RpciwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9pbmNyJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX2luY3IsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfeCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV94LCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX3knLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfeSwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV96JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3osIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzJfcG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMuTV9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfcG9zaWNpb25lcywgMykpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfcmFuZG9tbmVzcycsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5NX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9yYW5kb21uZXNzLCAzKSk7XG4gICAgICB0aGlzLm1lc2ggPSBuZXcgVEhSRUUuUG9pbnRzKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgICAgdGhpcy5zY2VuZS5hZGQodGhpcy5tZXNoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25Nb3VzZVVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1vdXNlVXBkYXRlKG1vdXNlTm9ybVgsIG1vdXNlTm9ybVkpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTREb3RzLm9uTW91c2VVcGRhdGUpOiBcIittb3VzZU5vcm1YKVxuICAgICAgaWYgKHRoaXMubW9ycGhpbmdQcm9ncmVzcyA+IDApIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIipcIilcbiAgICAgICAgdGhpcy5fbW91c2VVcGRhdGVYKG1vdXNlTm9ybVgpO1xuXG4gICAgICAgIHRoaXMuX21vdXNlVXBkYXRlWShtb3VzZU5vcm1ZKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIGlmICh0aGlzLmFsbExvYWRlZCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWU0RG90cy5yZW5kZXIpIVwiKVxuICAgICAgICAvLy0tXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSB0aGlzLmNsb2NrLmdldEVsYXBzZWRUaW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW50cm9Qcm9ncmVzcyA9IFdlYkdMVXRpbHMuY2xhbXAoKHRoaXMuY2xvY2suZ2V0RWxhcHNlZFRpbWUoKSAtIHRoaXMuc3RhcnRUaW1lKSAvIHRoaXMuaW50cm9UaW1lLCAwLCAxKTtcbiAgICAgICAgaW50cm9Qcm9ncmVzcyA9IEVhc2luZy5RdWFydGljLk91dChpbnRyb1Byb2dyZXNzKTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51SW50cm9Qcm9ncmVzcy52YWx1ZSA9IGludHJvUHJvZ3Jlc3M7IC8vLS1cblxuICAgICAgICB2YXIgcm90YXRpb25FYXNlZFkgPSB0aGlzLnJvdGF0aW9uWSArICh0aGlzLnJvdGF0aW9uV2FudGVkWSAtIHRoaXMucm90YXRpb25ZKSAqIDAuMDU7XG4gICAgICAgIHRoaXMucm90YXRpb25ZID0gcm90YXRpb25FYXNlZFk7XG4gICAgICAgIHRoaXMubWVzaC5yb3RhdGlvbi55ID0gcm90YXRpb25FYXNlZFk7IC8vLS1cblxuICAgICAgICB2YXIgcm90YXRpb25FYXNlZFggPSB0aGlzLnJvdGF0aW9uWCArICh0aGlzLnJvdGF0aW9uV2FudGVkWCAtIHRoaXMucm90YXRpb25YKSAqIDAuMDU7XG4gICAgICAgIHRoaXMucm90YXRpb25YID0gcm90YXRpb25FYXNlZFg7XG4gICAgICAgIHRoaXMubWVzaC5yb3RhdGlvbi54ID0gcm90YXRpb25FYXNlZFg7IC8vLS1cblxuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVUaW1lLnZhbHVlID0gdGhpcy5jbG9jay5nZXRFbGFwc2VkVGltZSgpO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVDYW1hcmFEaXN0YW5jZS52YWx1ZSA9IHRoaXMud29ybGRHTC5jYW1lcmFEaXN0YW5jZTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51UmVzcG9uc2l2ZVNjYWxlLnZhbHVlID0gdGhpcy53b3JsZEdMLnJlc3BvbnNpdmVTY2FsZTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51U2Nyb2xsRGVsdGEudmFsdWUgPSAtdGhpcy5lYXNlZF9zY3JvbGxEZWx0YS5nZXQodGhpcy53b3JsZEdMLnNldHRpbmdzLnNjcm9sbF9ub3JtYWxpemVkRGVsdGEgKiAwLjUpO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVTY3JvbGxQcm9ncmVzcy52YWx1ZSA9IHRoaXMud29ybGRHTC5zZXR0aW5ncy5zY3JvbGxfcHJvZ3Jlc3M7XG5cbiAgICAgICAgaWYgKHRoaXMud29ybGRHTC5zZXR0aW5ncy5tb3JwaGluZ1Byb2dyZXNzIDw9IDAuNSkge1xuICAgICAgICAgIHRoaXMubW9ycGhpbmdQcm9ncmVzcyA9IDA7XG5cbiAgICAgICAgICB0aGlzLl9tb3VzZVVwZGF0ZVgoMCk7XG5cbiAgICAgICAgICB0aGlzLl9tb3VzZVVwZGF0ZVkoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tb3JwaGluZ1Byb2dyZXNzID0gKHRoaXMud29ybGRHTC5zZXR0aW5ncy5tb3JwaGluZ1Byb2dyZXNzIC0gMC41KSAqIDI7XG4gICAgICAgIH0gLy9jb25zb2xlLmxvZyhcInRoaXMubW9ycGhpbmdQcm9ncmVzczogXCIrdGhpcy5tb3JwaGluZ1Byb2dyZXNzKVxuICAgICAgICAvLy0tXG5cblxuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVNb3JwaGluZ1Byb2dyZXNzLnZhbHVlID0gdGhpcy5tb3JwaGluZ1Byb2dyZXNzO1xuICAgICAgICB2YXIgZXh0cmFTcGVlZCA9IDEgKyBNYXRoLmFicyh0aGlzLmVhc2VkX3Njcm9sbERlbHRhX2Zhc3QuZ2V0KHRoaXMud29ybGRHTC5zZXR0aW5ncy5zY3JvbGxfbm9ybWFsaXplZERlbHRhICogMC41KSAqIDEwKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5yb3RhdGlvbjEgKz0gdGhpcy5zZXR0aW5ncy5zcGVlZFJvdGF0aW9uMSAqIGV4dHJhU3BlZWQ7XG4gICAgICAgIHRoaXMuc2V0dGluZ3Mucm90YXRpb24yICs9IHRoaXMuc2V0dGluZ3Muc3BlZWRSb3RhdGlvbjIgKiBleHRyYVNwZWVkO1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJvdGF0aW9uMyArPSB0aGlzLnNldHRpbmdzLnNwZWVkUm90YXRpb24zICogZXh0cmFTcGVlZDtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Um90YXRpb24xLnZhbHVlID0gdGhpcy5zZXR0aW5ncy5yb3RhdGlvbjE7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVJvdGF0aW9uMi52YWx1ZSA9IC10aGlzLnNldHRpbmdzLnJvdGF0aW9uMjtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Um90YXRpb24zLnZhbHVlID0gdGhpcy5zZXR0aW5ncy5yb3RhdGlvbjM7XG4gICAgICAgIHRoaXMuc2V0dGluZ3Mucm90YXRpb25Jbm5lciArPSB0aGlzLnNldHRpbmdzLnNwZWVkUm90YXRpb25Jbm5lciAqIGV4dHJhU3BlZWQ7XG4gICAgICAgIHRoaXMuc2V0dGluZ3Mucm90YXRpb25PdXR0ZXIgKz0gdGhpcy5zZXR0aW5ncy5zcGVlZFJvdGF0aW9uT3V0dGVyICogZXh0cmFTcGVlZDtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Um90YXRpb25Jbm5lci52YWx1ZSA9IHRoaXMuc2V0dGluZ3Mucm90YXRpb25Jbm5lcjtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Um90YXRpb25PdXR0ZXIudmFsdWUgPSB0aGlzLnNldHRpbmdzLnJvdGF0aW9uT3V0dGVyO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVQcm9ncmVzczAudmFsdWUgPSB0aGlzLnNldHRpbmdzLnByb2dyZXNzMDtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51UHJvZ3Jlc3MwYi52YWx1ZSA9IHRoaXMuc2V0dGluZ3MucHJvZ3Jlc3MwYjtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51UHJvZ3Jlc3MxLnZhbHVlID0gdGhpcy5zZXR0aW5ncy5wcm9ncmVzczE7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVByb2dyZXNzMi52YWx1ZSA9IHRoaXMuc2V0dGluZ3MucHJvZ3Jlc3MyO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVQcm9ncmVzczMudmFsdWUgPSB0aGlzLnNldHRpbmdzLnByb2dyZXNzMztcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51UHJvZ3Jlc3M0LnZhbHVlID0gdGhpcy5zZXR0aW5ncy5wcm9ncmVzczQ7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVByb2dyZXNzNGIudmFsdWUgPSB0aGlzLnNldHRpbmdzLnByb2dyZXNzNGI7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVByb2dyZXNzNS52YWx1ZSA9IHRoaXMuc2V0dGluZ3MucHJvZ3Jlc3M1O1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVQcm9ncmVzczYudmFsdWUgPSB0aGlzLnNldHRpbmdzLnByb2dyZXNzNjtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51UHJvZ3Jlc3M2Yi52YWx1ZSA9IHRoaXMuc2V0dGluZ3MucHJvZ3Jlc3M2YjtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51U2Nyb2xsU3BlZWQudmFsdWUgPSB0aGlzLnNldHRpbmdzLnNjcm9sbFNwZWVkRmlsdGVyZWQ7IC8vLS1cblxuICAgICAgICB0aGlzLnNldHRpbmdzLnJvdGF0aW9uSW5uZXIgKz0gdGhpcy5zZXR0aW5ncy5zcGVlZFJvdGF0aW9uSW5uZXIgKiBleHRyYVNwZWVkO1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJvdGF0aW9uT3V0dGVyICs9IHRoaXMuc2V0dGluZ3Muc3BlZWRSb3RhdGlvbk91dHRlciAqIGV4dHJhU3BlZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoKSB7Ly9OQURBXG4gICAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFBSSVZBREFTOiBcblxuICB9LCB7XG4gICAga2V5OiBcIl9tb3VzZVVwZGF0ZVhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdXNlVXBkYXRlWChtb3VzZU5vcm1YKSB7XG4gICAgICB2YXIgbWF4QW5nbGVSYWQgPSBNYXRoLlBJICogMC4yNTtcbiAgICAgIHRoaXMucm90YXRpb25XYW50ZWRZID0gbWF4QW5nbGVSYWQgKiBtb3VzZU5vcm1YICogdGhpcy5tb3JwaGluZ1Byb2dyZXNzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbW91c2VVcGRhdGVZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3VzZVVwZGF0ZVkobW91c2VOb3JtWSkge1xuICAgICAgdmFyIG1heEFuZ2xlUmFkID0gTWF0aC5QSSAqIDAuMTtcbiAgICAgIHRoaXMucm90YXRpb25XYW50ZWRYID0gbWF4QW5nbGVSYWQgKiBtb3VzZU5vcm1ZICogdGhpcy5tb3JwaGluZ1Byb2dyZXNzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZXZhbF9hbGxMb2FkZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2YWxfYWxsTG9hZGVkKCkge1xuICAgICAgaWYgKHRoaXMuTV9nZW9tZXRyeS5sb2FkZWQpIHtcbiAgICAgICAgdGhpcy5hbGxMb2FkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLndvcmxkR0wuZXZhbF9zdGFydCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0dXBfc2V0dGluZ3MzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cF9zZXR0aW5nczMoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWU0RG90cy5fc2V0dXBfc2V0dGluZ3MpIVwiKVxuICAgICAgdGhpcy5zZXR0aW5ncyA9IHtcbiAgICAgICAgZmFjdG9yOiA2LFxuICAgICAgICBpbmNyX3JhZGlvOiAyNSxcbiAgICAgICAgbnVtT3JiaXRzOiAyNixcbiAgICAgICAgLy9hcnJheU9yYml0czogWzEyLCAxOSwgMjZdXG4gICAgICAgIGFycmF5T3JiaXRzOiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIDI2XSAvL2FycmF5T3JiaXRzOiBbMSwgM11cblxuICAgICAgfTtcbiAgICAgIHRoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhciA9IHRoaXMuX2dldF9hcnJheV90cmlhbmd1bGFyKHRoaXMuc2V0dGluZ3MuZmFjdG9yLCB0aGlzLnNldHRpbmdzLm51bU9yYml0cyk7XG4gICAgICB0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YSA9IHRoaXMuX2dldF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEodGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyLCB0aGlzLnNldHRpbmdzLmFycmF5T3JiaXRzKTtcbiAgICAgIHRoaXMuc2V0dGluZ3MuYXJyYXlfZG90UG9zID0gdGhpcy5fZ2V0X2FycmF5X2RvdFBvcyh0aGlzLnNldHRpbmdzLmFycmF5T3JiaXRzLCB0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXIsIHRoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhKTtcbiAgICAgIHRoaXMuc2V0dGluZ3MubnVtRG90cyA9IHRoaXMuc2V0dGluZ3MuYXJyYXlfZG90UG9zLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldHVwX3NldHRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cF9zZXR0aW5ncygpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTREb3RzLl9zZXR1cF9zZXR0aW5ncykhXCIpXG4gICAgICB2YXIgc3BlZWRCYXNlID0gMC4wMDAwNTsgLy8tLVxuXG4gICAgICB0aGlzLnNldHRpbmdzID0ge1xuICAgICAgICAvLy0tXG4gICAgICAgIHJvdGF0aW9uSW5uZXI6IDAsXG4gICAgICAgIHNwZWVkUm90YXRpb25Jbm5lcjogMzcgKiBzcGVlZEJhc2UsXG4gICAgICAgIHJvdGF0aW9uT3V0dGVyOiAwLFxuICAgICAgICBzcGVlZFJvdGF0aW9uT3V0dGVyOiAxICogc3BlZWRCYXNlLFxuICAgICAgICAvLy0tXG4gICAgICAgIGZhY3RvcjogNixcbiAgICAgICAgaW5jcl9yYWRpbzogMjUsXG4gICAgICAgIG51bU9yYml0czogMzcsXG4gICAgICAgIHB1bHNlQXJyYXk6IFtdLFxuICAgICAgICBwdWxzZU1heDogMSxcbiAgICAgICAgcHVsc2VOdW1fMDogMCxcbiAgICAgICAgcHVsc2VJbml0VGltZV8wOiAwLFxuICAgICAgICBwdWxzZVByb2dyZXNzXzA6IDAsXG4gICAgICAgIHByb2dyZXNzMDogMCxcbiAgICAgICAgcHJvZ3Jlc3MwYjogMSxcbiAgICAgICAgcHJvZ3Jlc3MxOiAwLFxuICAgICAgICBwcm9ncmVzczI6IDAsXG4gICAgICAgIHByb2dyZXNzMzogMCxcbiAgICAgICAgcHJvZ3Jlc3M0OiAwLFxuICAgICAgICBwcm9ncmVzczRiOiAxLFxuICAgICAgICBwcm9ncmVzczU6IDAsXG4gICAgICAgIHByb2dyZXNzNjogMCxcbiAgICAgICAgcHJvZ3Jlc3M2YjogMSxcbiAgICAgICAgc2Nyb2xsU3BlZWQ6IDAsXG4gICAgICAgIHNjcm9sbFNwZWVkRmlsdGVyZWQ6IDBcbiAgICAgIH07XG4gICAgICB0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXIgPSB0aGlzLl9nZXRfYXJyYXlfdHJpYW5ndWxhcih0aGlzLnNldHRpbmdzLmZhY3RvciwgdGhpcy5zZXR0aW5ncy5udW1PcmJpdHMpO1xuICAgICAgdGhpcy5zZXR0aW5ncy5udW1Eb3RzID0gdGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyW3RoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhci5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldF9hcnJheV90cmlhbmd1bGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfYXJyYXlfdHJpYW5ndWxhcihfZmFjdG9yLCBfbnVtT2JpdHMpIHtcbiAgICAgIC8vIEdlbmVyYSB1bmEgYXJyYXkgZGUgcHJvZ3Jlc2nDs24gdHJpYW5ndWxhciAoKiBmYWN0b3IpLlxuICAgICAgLy8gVW5hIHByb2dyZXNpw7NuIHRyaWFuZ3VsYXIgZXM6IDEsIDMsIDYsIDEwLCAxNSAoaHR0cHM6Ly9zaWduaWZpY2F0aXZhLm9yZy9kaWNjaW9uYXJpb3MvbnVtZXJvcy1maWd1cmFkb3MvIzp+OnRleHQ9My4xLjEuMS4tLERlZmluaWNpJUMzJUIzbixhbnRlcmlvciUyMG5vJTIwb2J0ZW5lbW9zJTIwdW5hJTIwY29uc3RhbnRlLilcbiAgICAgIHZhciBtaUFycmF5ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IF9udW1PYml0czsgaSsrKSB7XG4gICAgICAgIC8vYXJyYXlfbnVtVHJpYWd1bGFyZXMucHVzaChpKihpKzEpLzIpXG4gICAgICAgIG1pQXJyYXkucHVzaChpICogKGkgKyAxKSAvIDIgKiBfZmFjdG9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1pQXJyYXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRfYXJyYXlfZG90UG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfYXJyYXlfZG90UG9zKF9hcnJheU9yYml0cywgX2FycmF5X3RyaWFuZ3VsYXIsIF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEpIHtcbiAgICAgIHZhciBtaUFycmF5ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2FycmF5T3JiaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvcmJpdE51bSA9IF9hcnJheU9yYml0c1tpXTtcbiAgICAgICAgdmFyIGRvdHNfeF9vcmJpdCA9IF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGFbaV07XG4gICAgICAgIHZhciBkb3ROdW1fYmFzZSA9IF9hcnJheV90cmlhbmd1bGFyW19hcnJheU9yYml0c1tpXSAtIDFdOyAvLyBjb25zb2xlLmxvZyhcIm9yYml0TnVtOiBcIitvcmJpdE51bSlcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJkb3RzX3hfb3JiaXQ6IFwiK2RvdHNfeF9vcmJpdClcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJkb3ROdW1fYmFzZTogXCIrZG90TnVtX2Jhc2UpXG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb3RzX3hfb3JiaXQ7IGorKykge1xuICAgICAgICAgIG1pQXJyYXkucHVzaChkb3ROdW1fYmFzZSArIGogKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWlBcnJheTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldF9udW1Eb3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfbnVtRG90cyhfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhKSB7XG4gICAgICB2YXIgbnVtRG90cyA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIG51bURvdHMgKz0gX2FycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YVtpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bURvdHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhKF9hcnJheV90cmlhbmd1bGFyLCBfYXJyYXlPcmJpdHMpIHtcbiAgICAgIC8vIEdlbmVyYSB1bmEgYXJyYXkgYmFzYWRhIGVuIGxhIHByb2dyZXNpw7NuIHRyaWFuZ3VsYXIgKCogZmFjdG9yKS5cbiAgICAgIC8vIC4uLiBkb25kZSBzZSBpbmRpY2EgZWwgbnVtZXJvIGRlIGRvdHMgcG9yIG9yYml0YWxcbiAgICAgIC8vIFVuYSBwcm9ncmVzacOzbiB0cmlhbmd1bGFyIGVzOiAxLCAzLCA2LCAxMCwgMTUgKGh0dHBzOi8vc2lnbmlmaWNhdGl2YS5vcmcvZGljY2lvbmFyaW9zL251bWVyb3MtZmlndXJhZG9zLyM6fjp0ZXh0PTMuMS4xLjEuLSxEZWZpbmljaSVDMyVCM24sYW50ZXJpb3IlMjBubyUyMG9idGVuZW1vcyUyMHVuYSUyMGNvbnN0YW50ZS4pXG4gICAgICB2YXIgbWlBcnJheSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBfYXJyYXlPcmJpdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIC8vYXJyYXlfbnVtVHJpYWd1bGFyZXMucHVzaChpKihpKzEpLzIpXG4gICAgICAgIHZhciBudW1Eb3RzX29yYml0YV9hY3R1YWwgPSBfYXJyYXlfdHJpYW5ndWxhcltfYXJyYXlPcmJpdHNbaV1dO1xuICAgICAgICB2YXIgbnVtRG90c19vcmJpdGFfYW50ZXJpb3IgPSBfYXJyYXlfdHJpYW5ndWxhcltfYXJyYXlPcmJpdHNbaV0gLSAxXTtcbiAgICAgICAgdmFyIG51bURvdHNfb3JiaXRhID0gbnVtRG90c19vcmJpdGFfYWN0dWFsIC0gbnVtRG90c19vcmJpdGFfYW50ZXJpb3I7XG4gICAgICAgIG1pQXJyYXkucHVzaChudW1Eb3RzX29yYml0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaUFycmF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlY3ViZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlY3ViZShfc2NlbmUpIHtcbiAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgxMDAsIDEwMCwgMTAwKTtcbiAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgIGNvbG9yOiAweDAwZmYwMFxuICAgICAgfSk7XG4gICAgICB2YXIgY3ViZSA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5cbiAgICAgIF9zY2VuZS5hZGQoY3ViZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhvbWU0RG90cztcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgSG9tZTREb3RzOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLy8gRlBTLU1ldGVyOlxuLy8oZnVuY3Rpb24oKXt2YXIgc2NyaXB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO3NjcmlwdC5vbmxvYWQ9ZnVuY3Rpb24oKXt2YXIgc3RhdHM9bmV3IFN0YXRzKCk7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0cy5kb20pO3JlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKCl7c3RhdHMudXBkYXRlKCk7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApfSk7fTtzY3JpcHQuc3JjPScvL2Nkbi5qc2RlbGl2ci5uZXQvZ2gvS2V2bnovc3RhdHMuanMvYnVpbGQvc3RhdHMubWluLmpzJztkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7fSkoKVxuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IGdzYXAgZnJvbSAnZ3NhcCc7XG5pbXBvcnQgU2Nyb2xsVHJpZ2dlciBmcm9tICdnc2FwL1Njcm9sbFRyaWdnZXInO1xuaW1wb3J0IFdlYkdMVXRpbHMgZnJvbSAnLi4vV2ViR0xVdGlscyc7XG5pbXBvcnQgSG9tZTREb3RzIGZyb20gJy4vSG9tZTREb3RzJztcblxudmFyIEhvbWU0QXBwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSG9tZTRBcHAob2JqKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIb21lNEFwcCk7XG5cbiAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWU0QXBwLkNPTlNUUlVDVE9SQSkhXCIsIG9iaikgXG4gICAgdGhpcy5od19yZW5kZXJlciA9IG9iai5yZW5kZXJlcjsgLy8gUmVkZXJlci9wYWdpbmEgZGUgSGlnaFdheS4gTm8gY29uZnVuZGlyIGNvbiBlbCByZW5kZXIvcmVuZGVyZXIgZGUgVGhyZWUuanNcblxuICAgIHRoaXMuJGNvbnRhaW5lciA9IG9iai5kb21FbGVtZW50OyAvLy0tIFxuICAgIC8vdGhpcy4kaW5uZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW5uZXInKVxuICAgIC8vdGhpcy4kZm9vdGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZvb3RlcicpXG4gICAgLy8tLVxuXG4gICAgdGhpcy5SRUZfUkVTT0xVVElPTiA9IHtcbiAgICAgIHdpZHRoOiAxOTIwLFxuICAgICAgaGVpZ2h0OiA5NDdcbiAgICB9O1xuICAgIHRoaXMuUkVGX0NBTUVSQV9ESVNUQU5DRSA9IDUwMDsgLy8tLVxuXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlOyAvLy0tXG5cbiAgICB0aGlzLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0O1xuICAgIHRoaXMucmVzcG9uc2l2ZVNjYWxlO1xuICAgIHRoaXMuY2FtZXJhRGlzdGFuY2U7IC8vLS1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICBfdGhpcy5vbk1vdXNlVXBkYXRlKHNlbGYpO1xuICAgIH0sIGZhbHNlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICBfdGhpcy5vbk1vdXNlVXBkYXRlKHNlbGYpO1xuICAgIH0sIGZhbHNlKTsgLy8tLVxuXG4gICAgdGhpcy5NQUlOX0FDVElWRSA9IGZhbHNlO1xuICAgIHRoaXMuRk9PVEVSX0FDVElWRSA9IGZhbHNlOyAvLy0tXG5cbiAgICB0aGlzLm1vdXNlTm9ybSA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTsgLy8tLVxuICAgIC8vdGhpcy5yZWZSZXNvbHV0aW9uID0gMTkyMDtcbiAgICAvL3RoaXMucmVmUmVzb2x1dGlvbiA9IDQ1MDtcbiAgICAvL3RoaXMucmVzcG9uc2l2ZVNjYWxlID0gdGhpcy53aWR0aC90aGlzLnJlZlJlc29sdXRpb247XG4gICAgLy8tLVxuICAgIC8vdGhpcy5jYW1lcmFEaXN0YW5jZSA9IDUwMFxuICAgIC8vLS1cblxuICAgIHRoaXMuc2V0dGluZ3MgPSB7XG4gICAgICBzY3JvbGxfbGFzdElubmVyWTogMCxcbiAgICAgIC8vIFVsdGltYSBwb3NpY2nDs24gZGVsIGVsZW1lbnRvIGRlIHJlZmVyZW5jaWFcbiAgICAgIHNjcm9sbF9kZWx0YTogMCxcbiAgICAgIC8vIEluY3JlbWVudG8gZGUgcGl4ZWxzIGRlbCBzY3JvbGxcbiAgICAgIHNjcm9sbF9saW1pdGVkRGVsdGE6IDAsXG4gICAgICAvLyBMaW1pdGEgbG9zIHZhbG9yZXMgYSAtMjAgLT4gKzIwXG4gICAgICBzY3JvbGxfbm9ybWFsaXplZERlbHRhOiAwLFxuICAgICAgLy8gUGFzYSBlbCBkZWx0YSBhIC0xIC0+ICsxXG4gICAgICBzY3JvbGxfZmFjdG9yZERlbHRhOiAxLFxuICAgICAgLy8gVmFsb3JlcyBhYnNvbHV0b3MgZGUgMCAtPiAxXG4gICAgICBzY3JvbGxfZGlyZWN0aW9uOiAxLFxuICAgICAgLy8gRGlyZWNjaW9uIGRlbCBkZWx0YS4gMSBzaSBlc3TDoSBwYXJhZG9cbiAgICAgIHNjcm9sbF9mb290ZXJfcHJvZ3Jlc3M6IDAsXG4gICAgICBtb3JwaGluZ1Byb2dyZXNzOiAwXG4gICAgfTsgLy8tLVxuXG4gICAgdGhpcy5fdXBkYXRlX2RpbWVuc2lvbnMoKTsgLy8tLVxuICAgIC8vIFNjZW5lXG5cblxuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICB0aGlzLnNjZW5lLmJhY2tncm91bmQgPSBuZXcgVEhSRUUuQ29sb3IoMHgwMDBhMzMpOyAvLy0tXG4gICAgLy8gQ2FtZXJhXG4gICAgLy9QZXJzcGVjdGl2ZUNhbWVyYSggZm92IDogTnVtYmVyLCBhc3BlY3QgOiBOdW1iZXIsIG5lYXIgOiBOdW1iZXIsIGZhciA6IE51bWJlciApXG5cbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSgzMCwgdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0LCAwLjEsIDIwMDApO1xuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSB0aGlzLmNhbWVyYURpc3RhbmNlOyAvL2NvbnNvbGUubG9nKFwidGhpcy5jYW1lcmEuZm92OiBcIit0aGlzLmNhbWVyYS5mb3YpXG5cbiAgICB0aGlzLmNhbWVyYS5mb3YgPSAyICogTWF0aC5hdGFuKHRoaXMuaGVpZ2h0IC8gMiAvIHRoaXMuY2FtZXJhRGlzdGFuY2UpICogKDE4MCAvIE1hdGguUEkpOyAvL2NvbnNvbGUubG9nKFwidGhpcy5jYW1lcmEuZm92OiBcIit0aGlzLmNhbWVyYS5mb3YpXG4gICAgLy8tLVxuICAgIC8vIFJlbmRlcmVyXG5cbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMMVJlbmRlcmVyKHtcbiAgICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICAgIGFscGhhOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJlci5hdXRvQ2xlYXIgPSBmYWxzZTsgLy8gVmFtb3MgYSB1c2FyIDIgc2NlbmFzICh1bmEgcGFyYSBlbCBiYWNrZ3JvdW5kIHkgb3RyYSBwYXJhIGxvcyBwdW50b3MpIHF1ZSBpbXBsaWNhcsOhbiB1c2FyIDIgYWNjaW9uZXMgZGUgcmVuZGVyLiBDb24gYXV0b2NsZWFyIGZhbHNlIHBlcm1pdGltb3MgcXVlIGxhIHNlZ3VuZGEgbm8gYm9ycmUgbGEgcHJpbWVyYS5cblxuICAgIHRoaXMucmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyhNYXRoLm1pbih3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgMSkpOyAvLy0tXG5cbiAgICB0aGlzLiRjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTsgLy8tLVxuXG4gICAgdGhpcy5kb3RzID0gbmV3IEhvbWU0RG90cyh7XG4gICAgICB3b3JsZEdMOiB0aGlzXG4gICAgfSk7IC8vLS1cblxuICAgIHRoaXMuX3Jlc2l6ZSgpOyAvL3RoaXMuX3JlbmRlcigpO1xuICAgIC8vdGhpcy5faW5pdF9zY3JvbGxMaXN0ZW5lcnMoKVxuXG4gIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUFVCTElDQVM6XG5cblxuICBfY3JlYXRlQ2xhc3MoSG9tZTRBcHAsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTRBcHAuaW5pdCkhXCIpIFxuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLmV2YWxfc3RhcnQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXZhbF9zdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsX3N0YXJ0KCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lNEFwcC5ldmFsX3N0YXJ0KTogXCIrdGhpcy5pbml0aWFsaXplZCtcIjpcIit0aGlzLmRvdHMuYWxsTG9hZGVkKSBcbiAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkICYmIHRoaXMuZG90cy5hbGxMb2FkZWQpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lNEFwcC5ldmFsX3N0YXJ0KSAtLSBTVEFSVFwiKSBcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNUQVJUIVwiKVxuICAgICAgICAvLy0tXG4gICAgICAgIHRoaXMuJGlubmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmlubmVyJyk7XG4gICAgICAgIHRoaXMuJGZvb3RlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mb290ZXInKTsgLy8tLVxuXG4gICAgICAgIHRoaXMuZG90cy5jcmVhdGUoKTtcblxuICAgICAgICB0aGlzLl9yZW5kZXIoKTtcblxuICAgICAgICB0aGlzLl9pbml0X3Njcm9sbExpc3RlbmVycygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJraWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWU0QXBwLmtpbGwpIVwiKSBcbiAgICAgIHRoaXMuJGlubmVyX3RyaWdnZXIua2lsbCgpO1xuICAgICAgdGhpcy4kZm9vdGVyX3RyaWdnZXIua2lsbCgpO1xuICAgICAgZ3NhcC50aWNrZXIucmVtb3ZlKHRoaXMuX2JpbmRlZF9yZW5kZXIpO1xuICAgICAgZ3NhcC50aWNrZXIucmVtb3ZlKHRoaXMuX2JpbmRlZF9ldmFsX3Njcm9sbCk7XG4gICAgICB0aGlzLmRvdHMgPSBudWxsO1xuICAgIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB9LCB7XG4gICAga2V5OiBcIm9uUmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lMUFwcC5vblJlc2l6ZSkhXCIpXG4gICAgICB0aGlzLl9yZXNpemUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25Nb3VzZVVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1vdXNlVXBkYXRlKGUpIHtcbiAgICAgIGlmICh0aGlzLkZPT1RFUl9BQ1RJVkUpIHtcbiAgICAgICAgdGhpcy5tb3VzZU5vcm0ueCA9IGUucGFnZVggLyB0aGlzLndpZHRoICogMiAtIDE7XG4gICAgICAgIHRoaXMubW91c2VOb3JtLnkgPSBlLnBhZ2VZIC8gdGhpcy5oZWlnaHQgKiAyIC0gMTtcblxuICAgICAgICBpZiAodGhpcy5kb3RzKSB7XG4gICAgICAgICAgdGhpcy5kb3RzLm9uTW91c2VVcGRhdGUodGhpcy5tb3VzZU5vcm0ueCwgdGhpcy5tb3VzZU5vcm0ueSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUFJJVkFEQVM6XG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlX2RpbWVuc2lvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZV9kaW1lbnNpb25zKCkge1xuICAgICAgLy8gY29uc29sZS5sb2coXCIoSG9tZTJBcHBfbS5fdXBkYXRlX2RpbWVuc2lvbnMpIVwiLCB0aGlzLnJlbmRlcmVyKVxuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuJGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy4kY29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICAgIHRoaXMucmVzcG9uc2l2ZVNjYWxlID0gdGhpcy53aWR0aCAvIHRoaXMuUkVGX1JFU09MVVRJT04ud2lkdGg7XG4gICAgICB0aGlzLmNhbWVyYURpc3RhbmNlID0gdGhpcy5SRUZfQ0FNRVJBX0RJU1RBTkNFICogdGhpcy5yZXNwb25zaXZlU2NhbGU7IC8vLS1cblxuICAgICAgaWYgKHRoaXMucmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTsgLy8tLVxuXG4gICAgICAgIHRoaXMuY2FtZXJhLmFzcGVjdCA9IHRoaXMud2lkdGggLyB0aGlzLmhlaWdodDtcbiAgICAgICAgdGhpcy5jYW1lcmFEaXN0YW5jZSA9IHRoaXMuY2FtZXJhLnBvc2l0aW9uLno7XG4gICAgICAgIHRoaXMuY2FtZXJhLmZvdiA9IDIgKiBNYXRoLmF0YW4odGhpcy5oZWlnaHQgLyAyIC8gdGhpcy5jYW1lcmFEaXN0YW5jZSkgKiAoMTgwIC8gTWF0aC5QSSk7XG4gICAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgIH0gLy8tLVxuXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0X3Njcm9sbExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdF9zY3JvbGxMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGJpbmRlZF9yZW5kZXIgPSBmdW5jdGlvbiBiaW5kZWRfcmVuZGVyKCkge1xuICAgICAgICBfdGhpczIuX3JlbmRlcigpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGJpbmRlZF9ldmFsX3Njcm9sbCA9IGZ1bmN0aW9uIGJpbmRlZF9ldmFsX3Njcm9sbCgpIHtcbiAgICAgICAgX3RoaXMyLl9ldmFsX2luZXJ0aWFfc2Nyb2xsKF90aGlzMi4kaW5uZXJfdHJpZ2dlci5wcm9ncmVzcyk7XG5cbiAgICAgICAgX3RoaXMyLl9ldmFsX2Zvb3Rlcl9zY3JvbGwoX3RoaXMyLiRmb290ZXJfdHJpZ2dlci5wcm9ncmVzcyk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9iaW5kZWRfcmVuZGVyID0gYmluZGVkX3JlbmRlcjtcbiAgICAgIHRoaXMuX2JpbmRlZF9ldmFsX3Njcm9sbCA9IGJpbmRlZF9ldmFsX3Njcm9sbDtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHRoaXMuJGlubmVyX3RyaWdnZXIgPSBTY3JvbGxUcmlnZ2VyLmNyZWF0ZSh7XG4gICAgICAgIHRyaWdnZXI6IHRoaXMuJGlubmVyLFxuICAgICAgICBzdGFydDogJ3RvcC09MTAgdG9wJyxcbiAgICAgICAgZW5kOiAnYm90dG9tIGJvdHRvbScsXG4gICAgICAgIHNjcnViOiB0cnVlLFxuICAgICAgICAvLyBTY3J1YjogR2VuZXJhIGV2ZW50b3MgZW4gdW5hIGZyYW5qYSBtYXMgcXVlIGVuIHVuIHB1bnRvLlxuICAgICAgICAvLyBtYXJrZXJzOiB0cnVlLFxuICAgICAgICBvblRvZ2dsZTogZnVuY3Rpb24gb25Ub2dnbGUoc2VsZikge1xuICAgICAgICAgIGlmIChzZWxmLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiTUFJTiBBQ1RJVkVcIilcbiAgICAgICAgICAgIHRoYXQuTUFJTl9BQ1RJVkUgPSB0cnVlO1xuICAgICAgICAgICAgZ3NhcC50aWNrZXIuYWRkKGJpbmRlZF9yZW5kZXIpO1xuICAgICAgICAgICAgZ3NhcC50aWNrZXIuYWRkKGJpbmRlZF9ldmFsX3Njcm9sbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoYXQuTUFJTl9BQ1RJVkUgPSBmYWxzZTsgLy9jb25zb2xlLmxvZyhcIk1BSU4gTk9UIEFDVElWRVwiKVxuICAgICAgICAgICAgLy9nc2FwLnRpY2tlci5yZW1vdmUoYmluZGVkX3JlbmRlcikgLy8gRWwgZm9uZG8gd2ViZ2wgcGVyc2lzdGUgc2llbXByZS4gTm8gbG8gZGVzYWN0aXZhbW9zIG51bmNhLlxuXG4gICAgICAgICAgICBnc2FwLnRpY2tlci5yZW1vdmUoYmluZGVkX2V2YWxfc2Nyb2xsKTsgLy8gRWwgZm9uZG8gd2ViZ2wgcGVyc2lzdGUgc2llbXByZS4gTm8gbG8gZGVzYWN0aXZhbW9zIG51bmNhLlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLiRmb290ZXJfdHJpZ2dlciA9IFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgdHJpZ2dlcjogdGhpcy4kZm9vdGVyLFxuICAgICAgICBzdGFydDogJ3RvcCBib3R0b20nLFxuICAgICAgICBlbmQ6ICdib3R0b20rPTEwIGJvdHRvbScsXG4gICAgICAgIHNjcnViOiB0cnVlLFxuICAgICAgICAvLyBTY3J1YjogR2VuZXJhIGV2ZW50b3MgZW4gdW5hIGZyYW5qYSBtYXMgcXVlIGVuIHVuIHB1bnRvLlxuICAgICAgICAvLyBtYXJrZXJzOiB0cnVlLFxuICAgICAgICBvblRvZ2dsZTogZnVuY3Rpb24gb25Ub2dnbGUoc2VsZikge1xuICAgICAgICAgIGlmIChzZWxmLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRk9PVEVSIEFDVElWRVwiKVxuICAgICAgICAgICAgdGhhdC5GT09URVJfQUNUSVZFID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkZPT1RFUiBOT1QgQUNUSVZFXCIpXG4gICAgICAgICAgICB0aGF0LkZPT1RFUl9BQ1RJVkUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZXZhbF9pbmVydGlhX3Njcm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZhbF9pbmVydGlhX3Njcm9sbChwcm9ncmVzcykge1xuICAgICAgdmFyIGlubmVyRGF0YSA9IHRoaXMuJGlubmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIG5ld0lubmVyWSA9IGlubmVyRGF0YS55O1xuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfcHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX2RlbHRhID0gbmV3SW5uZXJZIC0gdGhpcy5zZXR0aW5ncy5zY3JvbGxfbGFzdElubmVyWTtcbiAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX2xhc3RJbm5lclkgPSBuZXdJbm5lclk7XG4gICAgICB0aGlzLnNldHRpbmdzLnNjcm9sbF9saW1pdGVkRGVsdGEgPSBXZWJHTFV0aWxzLmNsYW1wKHRoaXMuc2V0dGluZ3Muc2Nyb2xsX2RlbHRhLCAtMjAsIDIwKTsgLy8gTGltaXRhIGxvcyB2YWxvcmVzIGEgLTIwIC0+ICsyMFxuXG4gICAgICB0aGlzLnNldHRpbmdzLnNjcm9sbF9ub3JtYWxpemVkRGVsdGEgPSAodGhpcy5zZXR0aW5ncy5zY3JvbGxfbGltaXRlZERlbHRhIC8gMjApLnRvRml4ZWQoMyk7IC8vIFBhc2EgZWwgZGVsdGEgYSAtMSAtPiArMVxuXG4gICAgICB0aGlzLnNldHRpbmdzLnNjcm9sbF9mYWN0b3JkRGVsdGEgPSBNYXRoLmFicyh0aGlzLnNldHRpbmdzLnNjcm9sbF9ub3JtYWxpemVkRGVsdGEpICsgMDsgLy8gVmFsb3JlcyBhYnNvbHV0b3MgZGUgMCAtPiAxXG5cbiAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX2RpcmVjdGlvbiA9IDE7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNjcm9sbF9ub3JtYWxpemVkRGVsdGEgPCAwKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX2RpcmVjdGlvbiA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZXZhbF9mb290ZXJfc2Nyb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmFsX2Zvb3Rlcl9zY3JvbGwocHJvZ3Jlc3MpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTRBcHAuX2V2YWxfZm9vdGVyX3Njcm9sbCk6IFwiK3Byb2dyZXNzKVxuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfZm9vdGVyX3Byb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICB0aGlzLnNldHRpbmdzLm1vcnBoaW5nUHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lNERvdHMucmVzaXplKSFcIilcbiAgICAgIC8vdGhpcy53aWR0aCA9IHRoaXMuJGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgIC8vdGhpcy5oZWlnaHQgPSB0aGlzLiRjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgLy90aGlzLnJlc3BvbnNpdmVTY2FsZSA9IHRoaXMud2lkdGgvdGhpcy5yZWZSZXNvbHV0aW9uO1xuICAgICAgLy90aGlzLnJlbmRlcmVyLnNldFNpemUoIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0ICk7XG4gICAgICAvL3RoaXMuY2FtZXJhLmFzcGVjdCA9IHRoaXMud2lkdGgvdGhpcy5oZWlnaHRcbiAgICAgIC8vdGhpcy5jYW1lcmFEaXN0YW5jZSA9IHRoaXMuY2FtZXJhLnBvc2l0aW9uLnpcbiAgICAgIC8vdGhpcy5jYW1lcmEuZm92ID0gMipNYXRoLmF0YW4oKHRoaXMuaGVpZ2h0LzIpLyh0aGlzLmNhbWVyYURpc3RhbmNlKSkgKiAoMTgwL01hdGguUEkpIFxuICAgICAgLy8vLy0tXG4gICAgICAvL3RoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgIC8vLS1cbiAgICAgIHRoaXMuX3VwZGF0ZV9kaW1lbnNpb25zKCk7IC8vLS1cblxuXG4gICAgICBpZiAodGhpcy5kb3RzKSB7XG4gICAgICAgIHRoaXMuZG90cy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXIoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWU0QXBwLl9yZW5kZXIpOiBcIit0aGlzLnNldHRpbmdzLnNjcm9sbF9wcm9ncmVzcytcIjpcIit0aGlzLnNldHRpbmdzLnNjcm9sbF9mb290ZXJfcHJvZ3Jlc3MpXG4gICAgICBpZiAodGhpcy5oZWlnaHQgIT0gdGhpcy4kY29udGFpbmVyLm9mZnNldEhlaWdodCB8fCB0aGlzLndpZHRoICE9IHRoaXMuJGNvbnRhaW5lci5vZmZzZXRXaWR0aCkge1xuICAgICAgICB0aGlzLl9yZXNpemUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZG90cykge1xuICAgICAgICB0aGlzLmRvdHMucmVuZGVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTsgLy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXIuYmluZCh0aGlzKSlcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSG9tZTRBcHA7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IEhvbWU0QXBwOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuaW1wb3J0IGdzYXAgZnJvbSAnZ3NhcCc7XG5pbXBvcnQgU2Nyb2xsVHJpZ2dlciBmcm9tICdnc2FwL1Njcm9sbFRyaWdnZXInO1xuaW1wb3J0IFdlYkdMVXRpbHMgZnJvbSAnLi4vV2ViR0xVdGlscyc7XG5cbnZhciBIb21lMVNjcm9sbF9tID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSG9tZTFTY3JvbGxfbShvYmopIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSG9tZTFTY3JvbGxfbSk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhcIihIb21lMVNjcm9sbF9tLkNPTlNUUlVDVE9SQSk6IFwiLCBvYmopXG4gICAgdGhpcy5hcHAgPSBvYmouYXBwO1xuICAgIHRoaXMuJGlubmVyID0gb2JqLiRpbm5lcjsgLy8tLVxuXG4gICAgdGhpcy5sYXN0SW5uZXJZID0gMDsgLy8gVWx0aW1hIHBvc2ljacOzbiBkZWwgZWxlbWVudG8gZGUgcmVmZXJlbmNpYVxuXG4gICAgdGhpcy5kZWx0YSA9IDA7IC8vIEluY3JlbWVudG8gZGUgcGl4ZWxzIGRlbCBzY3JvbGxcblxuICAgIHRoaXMubGltaXRlZERlbHRhID0gMDsgLy8gTGltaXRhIGxvcyB2YWxvcmVzIGEgLTIwIC0+ICsyMFxuXG4gICAgdGhpcy5ub3JtYWxpemVkRGVsdGEgPSAwOyAvLyBQYXNhIGVsIGRlbHRhIGEgLTEgLT4gKzFcblxuICAgIHRoaXMuZmFjdG9yZERlbHRhID0gMTsgLy8gVmFsb3JlcyBhYnNvbHV0b3MgZGUgMCAtPiAxXG5cbiAgICB0aGlzLmRpcmVjdGlvbiA9IDE7IC8vIERpcmVjY2lvbiBkZWwgZGVsdGEuIDEgc2kgZXN0w6EgcGFyYWRvXG4gICAgLy8tLVxuXG4gICAgdGhpcy50cmlnZ2VycyA9IHt9OyAvLy0tXG5cbiAgICB0aGlzLnByb2dyZXNzID0ge307XG4gICAgdGhpcy5wcm9ncmVzcy4kaW5uZXIgPSAwOyAvLy0tXG5cbiAgICB0aGlzLl9pbml0XyRpbm5lcigpO1xuICB9IC8vLS0tLS0tLS0tLS0tXG4gIC8vIFBVQkxJQ0FTOlxuXG5cbiAgX2NyZWF0ZUNsYXNzKEhvbWUxU2Nyb2xsX20sIFt7XG4gICAga2V5OiBcImtpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgIHRoaXMudHJpZ2dlcnMuJGlubmVyLmtpbGwoKTtcbiAgICAgIGdzYXAudGlja2VyLnJlbW92ZSh0aGlzLl9iaW5kZWRfcmVuZGVyKTtcbiAgICAgIGdzYXAudGlja2VyLnJlbW92ZSh0aGlzLl9iaW5kZWRfZXZhbF9zY3JvbGwpO1xuICAgIH0gLy8tLS0tLS0tLS0tLS1cbiAgICAvLyBQUklWQURBU1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRfJGlubmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0XyRpbm5lcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBiaW5kZWRfcmVuZGVyID0gZnVuY3Rpb24gYmluZGVkX3JlbmRlcigpIHtcbiAgICAgICAgX3RoaXMuYXBwLnJlbmRlcigpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGJpbmRlZF9ldmFsX3Njcm9sbCA9IGZ1bmN0aW9uIGJpbmRlZF9ldmFsX3Njcm9sbCgpIHtcbiAgICAgICAgX3RoaXMuX3VwZGF0ZV8kaW5uZXIoX3RoaXMudHJpZ2dlcnMuJGlubmVyLnByb2dyZXNzKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2JpbmRlZF9yZW5kZXIgPSBiaW5kZWRfcmVuZGVyO1xuICAgICAgdGhpcy5fYmluZGVkX2V2YWxfc2Nyb2xsID0gYmluZGVkX2V2YWxfc2Nyb2xsOyAvLy0tXG5cbiAgICAgIHRoaXMudHJpZ2dlcnMuJGlubmVyID0gU2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xuICAgICAgICB0cmlnZ2VyOiB0aGlzLiRpbm5lcixcbiAgICAgICAgc3RhcnQ6ICd0b3AgYm90dG9tJyxcbiAgICAgICAgZW5kOiAnYm90dG9tIGJvdHRvbScsXG4gICAgICAgIHNjcnViOiB0cnVlLFxuICAgICAgICAvLyBTY3J1YjogR2VuZXJhIGV2ZW50b3MgZW4gdW5hIGZyYW5qYSBtYXMgcXVlIGVuIHVuIHB1bnRvLlxuICAgICAgICAvLyBtYXJrZXJzOiB0cnVlLFxuICAgICAgICBvblRvZ2dsZTogZnVuY3Rpb24gb25Ub2dnbGUoc2VsZikge1xuICAgICAgICAgIGlmIChzZWxmLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICBnc2FwLnRpY2tlci5hZGQoYmluZGVkX3JlbmRlcik7XG4gICAgICAgICAgICBnc2FwLnRpY2tlci5hZGQoYmluZGVkX2V2YWxfc2Nyb2xsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3NhcC50aWNrZXIucmVtb3ZlKGJpbmRlZF9yZW5kZXIpO1xuICAgICAgICAgICAgZ3NhcC50aWNrZXIucmVtb3ZlKGJpbmRlZF9ldmFsX3Njcm9sbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZV8kaW5uZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZV8kaW5uZXIocHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMucHJvZ3Jlc3MuJGlubmVyID0gcHJvZ3Jlc3M7IC8vLS1cblxuICAgICAgdmFyIGlubmVyRGF0YSA9IHRoaXMuJGlubmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIG5ld0lubmVyWSA9IGlubmVyRGF0YS55O1xuICAgICAgdGhpcy5kZWx0YSA9IG5ld0lubmVyWSAtIHRoaXMubGFzdElubmVyWTtcbiAgICAgIHRoaXMubGFzdElubmVyWSA9IG5ld0lubmVyWTtcbiAgICAgIHRoaXMubGltaXRlZERlbHRhID0gV2ViR0xVdGlscy5jbGFtcCh0aGlzLmRlbHRhLCAtMjAsIDIwKTsgLy8gTGltaXRhIGxvcyB2YWxvcmVzIGEgLTIwIC0+ICsyMFxuXG4gICAgICB0aGlzLm5vcm1hbGl6ZWREZWx0YSA9ICh0aGlzLmxpbWl0ZWREZWx0YSAvIDIwKS50b0ZpeGVkKDMpOyAvLyBQYXNhIGVsIGRlbHRhIGEgLTEgLT4gKzFcblxuICAgICAgdGhpcy5mYWN0b3JkRGVsdGEgPSBNYXRoLmFicyh0aGlzLm5vcm1hbGl6ZWREZWx0YSkgKyAwOyAvLyBWYWxvcmVzIGFic29sdXRvcyBkZSAwIC0+IDFcblxuICAgICAgdGhpcy5kaXJlY3Rpb24gPSAxO1xuXG4gICAgICBpZiAodGhpcy5ub3JtYWxpemVkRGVsdGEgPCAwKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsX2RpcmVjdGlvbiA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIb21lMVNjcm9sbF9tO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBIb21lMVNjcm9sbF9tOyIsImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhX3JhbmRvbW5lc3M7XFxuYXR0cmlidXRlIHZlYzMgYV9nZW8xX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfZ2VvMV9jb2xvcjtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9nZW8xX2FuZ3Vsb1JhZDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9nZW8xX29yYml0YWw7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9wb3Nfb3JiaXRhO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfaW5jcl9hbmd1bG9SYWQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9pbmNyO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfZGlyO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfcmFkaW87XFxuXFxudW5pZm9ybSBmbG9hdCB1Q2FtYXJhRGlzdGFuY2U7XFxudW5pZm9ybSBmbG9hdCB1VGltZTtcXG51bmlmb3JtIGZsb2F0IHVPcGVuUHJvZ3Jlc3M7XFxudW5pZm9ybSBmbG9hdCB1UmVzcG9uc2l2ZVNjYWxlO1xcblxcbnVuaWZvcm0gZmxvYXQgdVNjcm9sbERlbHRhO1xcbnVuaWZvcm0gZmxvYXQgdVJvdGF0aW9uMTtcXG51bmlmb3JtIGZsb2F0IHVSb3RhdGlvbjI7XFxudW5pZm9ybSBmbG9hdCB1Um90YXRpb24zO1xcbi8vdW5pZm9ybSBmbG9hdCB1U2NhbGU7XFxuXFxudmFyeWluZyB2ZWMzIHZfY29sb3I7XFxudmFyeWluZyBmbG9hdCB2X3B1bHNlU3RyZW5ndGhOb3JtMTtcXG52YXJ5aW5nIGZsb2F0IHZfcHVsc2VTdHJlbmd0aE5vcm0yO1xcblxcbi8vXFx0Q2xhc3NpYyBQZXJsaW4gM0QgTm9pc2UgXFxuLy9cXHRieSBTdGVmYW4gR3VzdGF2c29uXFxuLy9cXG5cXG4jZGVmaW5lIFBJIDMuMTQxNTkyNjUzOFxcbi8vI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTVcXG5cXG52ZWMzIGdldF9wb3MxKGZsb2F0IGFuZ3Vsb1JhZCl7XFxuICAgIC8vZmxvYXQgYW5ndWxvUmFkID0gYV9nZW8xX3Bvc19vcmJpdGEqYV9nZW8xX2luY3JfYW5ndWxvUmFkKygoYV9nZW8xX2luY3JfYW5ndWxvUmFkLzIuKSphX2dlbzFfaW5jcikrKDEuKmFfZ2VvMV9kaXIqMC4yKTtcXG4gICAgZmxvYXQgeCA9IGNvcyhhbmd1bG9SYWQpKmFfZ2VvMV9yYWRpbztcXG4gICAgZmxvYXQgeSA9IHNpbihhbmd1bG9SYWQpKmFfZ2VvMV9yYWRpbztcXG4gICAgZmxvYXQgeiA9IDAuMDtcXG4gICAgdmVjMyBuZXdQb3MgPSB2ZWMzKHgsIHksIHopO1xcbiAgICByZXR1cm4gbmV3UG9zO1xcbn1cXG5cXG5mbG9hdCBnZXRfb3BlblNjYWxlKCl7XFxuICAgIHJldHVybiBtaXgoMS4sIDguLCB1T3BlblByb2dyZXNzKTtcXG59XFxuXFxudmVjMyBnZXRfb3BlbkZ4KCB2ZWMzIHBvcyl7XFxuICAgIC8vZmxvYXQgb3BlblNjYWxlID0gbWl4KDEuLCA4LiwgdU9wZW5Qcm9ncmVzcyk7XFxuICAgIHZlYzMgcG9zRnggPSBwb3MqZ2V0X29wZW5TY2FsZSgpO1xcbiAgICByZXR1cm4gcG9zRng7XFxufVxcblxcbmZsb2F0IGdldF9jb3NUaW1lKGZsb2F0IHRpbWUsIGZsb2F0IHJhZGl1cyl7XFxuICAgIC8vXFxuICAgIC8vZmxvYXQgdmFsdWUgPSBzaW4odVRpbWUpKjIuKlBJO1xcbiAgICBmbG9hdCB2YWx1ZSA9IHNpbih0aW1lKSpyYWRpdXM7XFxuICAgIHJldHVybiB2YWx1ZTtcXG59XFxuXFxuZmxvYXQgZ2V0X3goZmxvYXQgYW5nbGVSYWQsIGZsb2F0IHJhZGl1cyl7XFxuICAgIHJldHVybiBjb3MoYW5nbGVSYWQpKmFfZ2VvMV9yYWRpbztcXG59XFxuXFxuZmxvYXQgZ2V0X3B1bHNlU3RyZW5ndGhOb3JtKCBmbG9hdCBkaXJlY3Rpb24pe1xcbiAgICBmbG9hdCBkb3RBZ3VsZU5vcm0gPSBhX2dlbzFfYW5ndWxvUmFkLygyLipQSSk7IC8vIFBhc2Ftb3MgZWwgYW5ndWxvIGRlbCBwdW50byBxdWUgZXN0w6EgZW4gcmFkaWFuZXMgYSB1biB2YWxvciBkZSAwIGEgMS5cXG5cXG4gICAgZmxvYXQgbW9kU3BlZWQgPSBtaXgoMS4sIDIuNSwgMTMuL2FfZ2VvMV9vcmJpdGFsKSpkaXJlY3Rpb247XFxuICAgIGZsb2F0IHJhZGlhbFNwZWVkID0gdVRpbWUqMC4wMiptb2RTcGVlZDsgLy8gTW9kaWZpY2Ftb3MgdVRpbWUgcGFyYSBkZXRlcm1pbmFyIGxhIHZlbG9jaWRhZCByYWRpYWwuXFxuXFxuICAgIGZsb2F0IHB1bHNlQW5nbGVSYWQgPSByYWRpYWxTcGVlZCooNC4qUEkpO1xcblxcbiAgICAvLyBFbCB2YWxvciBkZSBwdWxzZUFuZ2xlUmFkIGRlYmUgZXN0YXIgZW50cmUgMCB5IDJQSSAoaW5pY2lvIHkgZmluIGRlIHVuYSBjaXJjdW5mZXJlbmNpYSkuXFxuICAgIC8vIENvbW8gZGVwZW5kZSBkZSB1VGltZSBlbCB2YWxvciBzYWxkcsOhIGRlIGVzZSByYW5nbyBwcm9udG8gcG9yIGxvIHF1ZSB0b21hcmVtb3MgZWwgcmVzdG8gKG1vZHVsbyksXFxuICAgIC8vIGRlIGRpdmlkaXIgcHVsc2VBbmdsZVJhZCBwb3IgMlBJLlxcbiAgICBpZihwdWxzZUFuZ2xlUmFkID4gMi4qUEkpe1xcbiAgICAgICAgcHVsc2VBbmdsZVJhZCA9IG1vZChwdWxzZUFuZ2xlUmFkLCAoMi4qUEkpKTtcXG4gICAgfVxcbiAgICBpZihwdWxzZUFuZ2xlUmFkIDwgMC4pe1xcbiAgICAgICAgcHVsc2VBbmdsZVJhZCA9IG1vZChwdWxzZUFuZ2xlUmFkLCAoMi4qUEkpKTtcXG4gICAgfVxcblxcbiAgICBmbG9hdCBwdWxzZUFuZ2xlTm9ybSA9IHB1bHNlQW5nbGVSYWQvKDIuKlBJKTsgLy8gTm9ybWFsaXphbW9zIGVsIHZhbG9yIChkZSAwIGEgMSlcXG5cXG4gICAgZmxvYXQgZGlzdEFuZ2xlTm9ybSA9IGFicyhwdWxzZUFuZ2xlTm9ybS1kb3RBZ3VsZU5vcm0pOyAvLyBDYWxjdWxhbW9zIGxhIGRpc3RhbmNpYSByYWRpYWwgZGVsIHB1bHNvIGFsIHB1bnRvXFxuXFxuICAgIC8vIEFwYcOxYW1vcyBsYSBkaXN0YW5jaWEgZGUgdGFsIGZvcm1hIHF1ZSBubyBsZSBhZmVjdGUgZWwgcHVudG8gZGUgZGlzY29udGludWlkYWQgT1BJID0gMlBJXFxuICAgIGlmKGRpc3RBbmdsZU5vcm0gPiAwLjUpeyBcXG4gICAgICAgIGRpc3RBbmdsZU5vcm0gPSAwLjUtKGRpc3RBbmdsZU5vcm0tMC41KTtcXG4gICAgfVxcblxcbiAgICAvLyBMYSBtYXhpbWEgZGlzdGFuY2lhIGVzIGRlIG1lZGlvIGNpcmN1bG8geSBlbiB0ZXJtaW5vcyBub3JtYWxpemFkb3MgZXMgMC41XFxuICAgIC8vIENyZWFtb3MgdW5hIHZhcmlhYmxlIHF1ZSBub3JtYWxpY2UgZXNlIHZhbG9yIGVudHJlIDAgeSAxLlxcbiAgICBmbG9hdCBwdWxzZVN0cmVuZ3RoTm9ybSAgPSBkaXN0QW5nbGVOb3JtKjIuOyBcXG5cXG4gICAgZmxvYXQgcGljbyA9IDAuOTI7XFxuICAgIHBpY28gPSBtaXgocGljbyowLjk5LCBwaWNvKjEuMDEsIGFfZ2VvMV9vcmJpdGFsLzEzLik7XFxuXFxuICAgIC8vIE5vcyBpbnRlcmVzYSBzb2xvIGVsIHBpY28sIGxhIHpvbmEgcXVlIHZhIGVudHJlIDAuOTUgeSAxLlxcbiAgICAvLyBUb29kbyBsbyBxdWUgaGF5YSBwb3IgZGViYWpvIGRlIDAuOTUgbG8gcGFzYW1vcyBhIDAuOTVcXG4gICAgLy8geSBsZSByZXN0YW1vcyBlc2UgbWlzbW8gMC45NSBwYXJhIHF1ZWRhcm5vcyBjb24gZWwgcGljbyBkZSAwLjA1IGVvbCBjdWFsIGFtcGxpZmljYW1vcyB4MjAgcGFyYSBub3JtYWxpemFybG8gKGRlIDAgYSAxKS5cXG4gICAgcHVsc2VTdHJlbmd0aE5vcm0gPSAoY2xhbXAocHVsc2VTdHJlbmd0aE5vcm0sIHBpY28sIDEuKS1waWNvKSoxMC47XFxuICAgIC8vLS1cXG4gICAgcmV0dXJuIHB1bHNlU3RyZW5ndGhOb3JtO1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIC8vZmxvYXQgZGlyZWN0aW9uID0gMS47XFxuICAgIC8vaWYoYWJzKGFfZ2VvMV9vcmJpdGFsIC0gMTMuKSA8IDAuNSl7IC8vIDEzIGVzIGVsIG9yYml0YWwgZGVsIG1lZGlvXFxuICAgIC8vICAgIGRpcmVjdGlvbiA9IC0xLjtcXG4gICAgLy99XFxuXFxuICAgIC8vZmxvYXQgbG9uZ1BlcmlvZCA9IHNpbih1VGltZSk7XFxuICAgIC8vIGxvbmdQZXJpb2QgPSBjbGFtcChsb25nUGVyaW9kLCAwLiwgMS4pO1xcbiAgICAvLyBsb25nUGVyaW9kID0gMS47XFxuXFxuICAgIGZsb2F0IHB1bHNlU3RyZW5ndGhOb3JtMSA9IGdldF9wdWxzZVN0cmVuZ3RoTm9ybSgxLjUpO1xcbiAgICBmbG9hdCBwdWxzZVN0cmVuZ3RoTm9ybTIgPSBnZXRfcHVsc2VTdHJlbmd0aE5vcm0oLTEuKTtcXG5cXG4gICAgXFxuXFxuICAgIC8vIERldGVybWluYW1vcyBlbCB0YW1hw7FvIGRlbCBwdW50byB0ZW5pZW5kbyB1biBtaW5pbW8gZGUgNSB5IGFtcGxpZmljYW5kbyBlbCBtYXhpbW8gcGFyYSBxdWUgdmlzdWFsbWVudGUgc2VhIGJvbml0b1xcbiAgICAvL2Zsb2F0IHNpemUgPSA1LisocHVsc2VTdHJlbmd0aE5vcm0qMTUuKmxvbmdQZXJpb2QpO1xcbiAgICBmbG9hdCBzaXplID0gMy47XFxuICAgIHNpemUgKz0gKHB1bHNlU3RyZW5ndGhOb3JtMSo1Lik7XFxuICAgIHNpemUgKz0gKHB1bHNlU3RyZW5ndGhOb3JtMio1Lik7XFxuICAgIHNpemUgKj0gdVJlc3BvbnNpdmVTY2FsZTtcXG4gICAgc2l6ZSAqPSBnZXRfb3BlblNjYWxlKCk7XFxuXFxuICAgIGZsb2F0IGFuZ3Vsb1JhZF90aW1lID0gMC47XFxuICAgIGlmKGFicyhhX2dlbzFfb3JiaXRhbC0xMC4pIDwgMC41KXsgLy8gRGV0ZWN0YSBlbCBvcmJpdGFsIDZcXG4gICAgICAgIGFuZ3Vsb1JhZF90aW1lID0gYV9nZW8xX2FuZ3Vsb1JhZCt1Um90YXRpb24xO1xcbiAgICB9ZWxzZSBpZihhYnMoYV9nZW8xX29yYml0YWwtMTQuKSA8IDAuNSl7IC8vIERldGVjdGEgZWwgb3JiaXRhbCAxMVxcbiAgICAgICAgYW5ndWxvUmFkX3RpbWUgPSBhX2dlbzFfYW5ndWxvUmFkK3VSb3RhdGlvbjI7XFxuICAgIH1lbHNlIGlmKGFicyhhX2dlbzFfb3JiaXRhbC0xOC4pIDwgMC41KXsgLy8gRGV0ZWN0YSBlbCBvcmJpdGFsIDEzXFxuICAgICAgICBhbmd1bG9SYWRfdGltZSA9IGFfZ2VvMV9hbmd1bG9SYWQrdVJvdGF0aW9uMztcXG4gICAgfVxcbiAgICBcXG5cXG4gICAgLy9mbG9hdCByb3RhdGlvblNwZWVkID0gKGFfZ2VvMV9vcmJpdGFsLzEzLik7XFxuICAgIC8vZmxvYXQgcm90YXRpb25TcGVlZCA9ICgxMy4vYV9nZW8xX29yYml0YWwpO1xcbiAgICAvL3JvdGF0aW9uU3BlZWQgKj0gLXVfc2Nyb2xsX2ZhY3RvcmREZWx0YTtcXG4gICAgLy9mbG9hdCBhbmd1bG9SYWRfdGltZSA9IGFfZ2VvMV9hbmd1bG9SYWQrKHJvdGF0aW9uU3BlZWQqMC41KSsoZGlyZWN0aW9uKnVUaW1lKjAuMik7XFxuICAgIHZlYzMgcG9zMSA9IGdldF9wb3MxKGFuZ3Vsb1JhZF90aW1lKTtcXG4gICAgcG9zMSA9IGdldF9vcGVuRngocG9zMSk7XFxuICAgIHBvczEgPSBwb3MxICp1UmVzcG9uc2l2ZVNjYWxlO1xcbiAgICAvL3BvczEgPSBwb3MxICogKDEuKyh1X3Njcm9sbF9mYWN0b3JkRGVsdGEqMC4yKSk7XFxuICAgIC8vdmVjMyBwb3MyID0gcG9zMSoxLjA7XFxuICAgIC8vcG9zMT0gbWl4KHBvczEsIHBvczIsIHB1bHNlU3RyZW5ndGhOb3JtKTtcXG4gICAgdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zMSwgMS4wICk7IFxcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uOyAvLzwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICBnbF9Qb2ludFNpemUgPSBzaXplKih1Q2FtYXJhRGlzdGFuY2UvLW12UG9zaXRpb24ueik7IC8vPC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIC8vIFZBUllJTkdTOlxcbiAgICB2X2NvbG9yID0gYV9nZW8xX2NvbG9yOyBcXG4gICAgdl9wdWxzZVN0cmVuZ3RoTm9ybTEgPSBwdWxzZVN0cmVuZ3RoTm9ybTE7IFxcbiAgICB2X3B1bHNlU3RyZW5ndGhOb3JtMiA9IHB1bHNlU3RyZW5ndGhOb3JtMjsgXFxuXFxufVxcblxcbi8qXFxudmVjMyBnZXRfcG9zMSgpe1xcbiAgICAvL2Zsb2F0IGFuZ3Vsb1JhZCA9IGFfZ2VvMV9wb3Nfb3JiaXRhKmFfZ2VvMV9pbmNyX2FuZ3Vsb1JhZCsoKGFfZ2VvMV9pbmNyX2FuZ3Vsb1JhZC8yLikqYV9nZW8xX2luY3IpKygxLiphX2dlbzFfZGlyKjAuMik7XFxuICAgIGZsb2F0IHggPSBjb3MoYV9nZW8xX2FuZ3Vsb1JhZCkqYV9nZW8xX3JhZGlvO1xcbiAgICBmbG9hdCB5ID0gc2luKGFfZ2VvMV9hbmd1bG9SYWQpKmFfZ2VvMV9yYWRpbztcXG4gICAgZmxvYXQgeiA9IDAuMDtcXG4gICAgdmVjMyBuZXdQb3MgPSB2ZWMzKHgsIHksIHopO1xcbiAgICByZXR1cm4gbmV3UG9zO1xcbn1cXG5cXG5mbG9hdCBnZXRfY29zVGltZShmbG9hdCB0aW1lLCBmbG9hdCByYWRpdXMpe1xcbiAgICAvL1xcbiAgICAvL2Zsb2F0IHZhbHVlID0gc2luKHVUaW1lKSoyLipQSTtcXG4gICAgZmxvYXQgdmFsdWUgPSBzaW4odGltZSkqcmFkaXVzO1xcbiAgICByZXR1cm4gdmFsdWU7XFxufVxcblxcbmZsb2F0IGdldF94KGZsb2F0IGFuZ2xlUmFkLCBmbG9hdCByYWRpdXMpe1xcbiAgICByZXR1cm4gY29zKGFuZ2xlUmFkKSphX2dlbzFfcmFkaW87XFxufVxcblxcblxcblxcbnZvaWQgbWFpbigpIHtcXG5cXG4gICAgdmVjMyBwb3MxID0gZ2V0X3BvczEoKTtcXG4gICAgdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zMSwgMS4wICk7IFxcblxcbiAgICBmbG9hdCBkaXN0ID0gZGlzdGFuY2UoZ2V0X3goYV9nZW8xX2FuZ3Vsb1JhZCwgYV9nZW8xX3JhZGlvKSwgZ2V0X2Nvc1RpbWUodVRpbWUqMC4wMDUqYV9nZW8xX3JhZGlvLCBhX2dlbzFfcmFkaW8pKTtcXG4gICAgZmxvYXQgc2l6ZSA9IDIuK2FicygoKDAuMDAxKmFfZ2VvMV9yYWRpbyktZGlzdCkqMC4wMik7XFxuXFxuICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247IC8vPC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICBnbF9Qb2ludFNpemUgPSBzaXplKih1Q2FtYXJhRGlzdGFuY2UvLW12UG9zaXRpb24ueik7IC8vPC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICB2X2NvbG9yID0gYV9nZW8xX2NvbG9yOyBcXG5cXG59XFxuXFxuKi8vKlxcbnZlYzMgZ2V0X3BvczEoKXtcXG4gICAgLy9mbG9hdCBhbmd1bG9SYWQgPSBhX2dlbzFfcG9zX29yYml0YSphX2dlbzFfaW5jcl9hbmd1bG9SYWQrKChhX2dlbzFfaW5jcl9hbmd1bG9SYWQvMi4pKmFfZ2VvMV9pbmNyKSsoMS4qYV9nZW8xX2RpciowLjIpO1xcbiAgICBmbG9hdCB4ID0gY29zKGFfZ2VvMV9hbmd1bG9SYWQpKmFfZ2VvMV9yYWRpbztcXG4gICAgZmxvYXQgeSA9IHNpbihhX2dlbzFfYW5ndWxvUmFkKSphX2dlbzFfcmFkaW87XFxuICAgIGZsb2F0IHogPSAwLjA7XFxuICAgIHZlYzMgbmV3UG9zID0gdmVjMyh4LCB5LCB6KTtcXG4gICAgcmV0dXJuIG5ld1BvcztcXG59XFxuXFxuZmxvYXQgZ2V0X2Nvc1RpbWUoZmxvYXQgdGltZSwgZmxvYXQgcmFkaXVzKXtcXG4gICAgLy9cXG4gICAgLy9mbG9hdCB2YWx1ZSA9IHNpbih1VGltZSkqMi4qUEk7XFxuICAgIGZsb2F0IHZhbHVlID0gc2luKHRpbWUpKnJhZGl1cztcXG4gICAgcmV0dXJuIHZhbHVlO1xcbn1cXG5cXG5mbG9hdCBnZXRfeChmbG9hdCBhbmdsZVJhZCwgZmxvYXQgcmFkaXVzKXtcXG4gICAgcmV0dXJuIGNvcyhhbmdsZVJhZCkqYV9nZW8xX3JhZGlvO1xcbn1cXG5cXG5cXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIHZlYzMgcG9zMSA9IGdldF9wb3MxKCk7XFxuICAgIHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvczEsIDEuMCApOyBcXG5cXG4gICAgZmxvYXQgZGlzdCA9IGRpc3RhbmNlKGdldF94KGFfZ2VvMV9hbmd1bG9SYWQsIGFfZ2VvMV9yYWRpbyksIGdldF9jb3NUaW1lKHVUaW1lKjAuMDA1KmFfZ2VvMV9yYWRpbywgYV9nZW8xX3JhZGlvKSk7XFxuICAgIGZsb2F0IHNpemUgPSAyLithYnMoKCgwLjAwMSphX2dlbzFfcmFkaW8pLWRpc3QpKjAuMDIpO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uOyAvLzwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgZ2xfUG9pbnRTaXplID0gc2l6ZSoodUNhbWFyYURpc3RhbmNlLy1tdlBvc2l0aW9uLnopOyAvLzwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG4gICAgdl9jb2xvciA9IGFfZ2VvMV9jb2xvcjsgXFxuXFxufVxcblxcbiovLypcXG52ZWMzIGdldF9wb3MxKCl7XFxuICAgIC8vZmxvYXQgYW5ndWxvUmFkID0gYV9nZW8xX3Bvc19vcmJpdGEqYV9nZW8xX2luY3JfYW5ndWxvUmFkKygoYV9nZW8xX2luY3JfYW5ndWxvUmFkLzIuKSphX2dlbzFfaW5jcikrKDEuKmFfZ2VvMV9kaXIqMC4yKTtcXG4gICAgZmxvYXQgeCA9IGNvcyhhX2dlbzFfYW5ndWxvUmFkKSphX2dlbzFfcmFkaW87XFxuICAgIGZsb2F0IHkgPSBzaW4oYV9nZW8xX2FuZ3Vsb1JhZCkqYV9nZW8xX3JhZGlvO1xcbiAgICBmbG9hdCB6ID0gMC4wO1xcbiAgICB2ZWMzIG5ld1BvcyA9IHZlYzMoeCwgeSwgeik7XFxuICAgIHJldHVybiBuZXdQb3M7XFxufVxcblxcbmZsb2F0IGdldF9jb3NUaW1lKGZsb2F0IHRpbWUsIGZsb2F0IHJhZGl1cyl7XFxuICAgIC8vXFxuICAgIC8vZmxvYXQgdmFsdWUgPSBzaW4odVRpbWUpKjIuKlBJO1xcbiAgICBmbG9hdCB2YWx1ZSA9IHNpbih0aW1lKSpyYWRpdXM7XFxuICAgIHJldHVybiB2YWx1ZTtcXG59XFxuXFxuZmxvYXQgZ2V0X3goZmxvYXQgYW5nbGVSYWQsIGZsb2F0IHJhZGl1cyl7XFxuICAgIHJldHVybiBjb3MoYW5nbGVSYWQpKmFfZ2VvMV9yYWRpbztcXG59XFxuXFxuXFxuXFxudm9pZCBtYWluKCkge1xcblxcbiAgICB2ZWMzIHBvczEgPSBnZXRfcG9zMSgpO1xcbiAgICB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3MxLCAxLjAgKTsgXFxuXFxuICAgIGZsb2F0IGRpc3QgPSBkaXN0YW5jZShnZXRfeChhX2dlbzFfYW5ndWxvUmFkLCBhX2dlbzFfcmFkaW8pLCBnZXRfY29zVGltZSh1VGltZSowLjAwNSphX2dlbzFfcmFkaW8sIGFfZ2VvMV9yYWRpbykpO1xcbiAgICBmbG9hdCBzaXplID0gMi4rYWJzKCgoMC4wMDEqYV9nZW8xX3JhZGlvKS1kaXN0KSowLjAyKTtcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjsgLy88LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIGdsX1BvaW50U2l6ZSA9IHNpemUqKHVDYW1hcmFEaXN0YW5jZS8tbXZQb3NpdGlvbi56KTsgLy88LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIHZfY29sb3IgPSBhX2dlbzFfY29sb3I7IFxcblxcbn1cXG5cXG4qLy8qXFxudmVjMyBnZXRfcG9zMSgpe1xcbiAgICAvL2Zsb2F0IGFuZ3Vsb1JhZCA9IGFfZ2VvMV9wb3Nfb3JiaXRhKmFfZ2VvMV9pbmNyX2FuZ3Vsb1JhZCsoKGFfZ2VvMV9pbmNyX2FuZ3Vsb1JhZC8yLikqYV9nZW8xX2luY3IpKygxLiphX2dlbzFfZGlyKjAuMik7XFxuICAgIGZsb2F0IHggPSBjb3MoYV9nZW8xX2FuZ3Vsb1JhZCkqYV9nZW8xX3JhZGlvO1xcbiAgICBmbG9hdCB5ID0gc2luKGFfZ2VvMV9hbmd1bG9SYWQpKmFfZ2VvMV9yYWRpbztcXG4gICAgZmxvYXQgeiA9IDAuMDtcXG4gICAgdmVjMyBuZXdQb3MgPSB2ZWMzKHgsIHksIHopO1xcbiAgICByZXR1cm4gbmV3UG9zO1xcbn1cXG5cXG5mbG9hdCBnZXRfY29zVGltZShmbG9hdCB0aW1lLCBmbG9hdCByYWRpdXMpe1xcbiAgICAvL1xcbiAgICAvL2Zsb2F0IHZhbHVlID0gc2luKHVUaW1lKSoyLipQSTtcXG4gICAgZmxvYXQgdmFsdWUgPSBzaW4odGltZSkqcmFkaXVzO1xcbiAgICByZXR1cm4gdmFsdWU7XFxufVxcblxcbmZsb2F0IGdldF94KGZsb2F0IGFuZ2xlUmFkLCBmbG9hdCByYWRpdXMpe1xcbiAgICByZXR1cm4gY29zKGFuZ2xlUmFkKSphX2dlbzFfcmFkaW87XFxufVxcblxcblxcblxcbnZvaWQgbWFpbigpIHtcXG5cXG4gICAgdmVjMyBwb3MxID0gZ2V0X3BvczEoKTtcXG4gICAgdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zMSwgMS4wICk7IFxcblxcbiAgICBmbG9hdCBkaXN0ID0gZGlzdGFuY2UoZ2V0X3goYV9nZW8xX2FuZ3Vsb1JhZCwgYV9nZW8xX3JhZGlvKSwgZ2V0X2Nvc1RpbWUodVRpbWUqMC4wMDUqYV9nZW8xX3JhZGlvLCBhX2dlbzFfcmFkaW8pKTtcXG4gICAgZmxvYXQgc2l6ZSA9IDIuK2FicygoKDAuMDAxKmFfZ2VvMV9yYWRpbyktZGlzdCkqMC4wMik7XFxuXFxuICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247IC8vPC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICBnbF9Qb2ludFNpemUgPSBzaXplKih1Q2FtYXJhRGlzdGFuY2UvLW12UG9zaXRpb24ueik7IC8vPC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICB2X2NvbG9yID0gYV9nZW8xX2NvbG9yOyBcXG5cXG59XFxuXFxuKi9cIjsiLCJleHBvcnQgZGVmYXVsdCBcIiNkZWZpbmUgR0xTTElGWSAxXFxudmFyeWluZyB2ZWMzIHZfY29sb3I7XFxudmFyeWluZyBmbG9hdCB2X3B1bHNlU3RyZW5ndGhOb3JtMTtcXG52YXJ5aW5nIGZsb2F0IHZfcHVsc2VTdHJlbmd0aE5vcm0yO1xcblxcbmZsb2F0IGNpcmN1bGl6YXIoZmxvYXQgcmFkaW8pe1xcbiAgICAvLyByYWRpbyBlcyB1biB2YWxvciBlbnRyZSAwIHkgMS4gMCBlcyAwIGRlIHJhZGlvIHkgMSBlcyBlbCBtYXhpbW8gZGVsIHJhZGlvIGRlbnRybyBkZVxcbiAgICByYWRpbyA9IDEuMC0oMC41KnJhZGlvKTtcXG4gICAgZmxvYXQgcmVzdWx0ID0gZGlzdGFuY2UoZ2xfUG9pbnRDb29yZCwgdmVjMigwLjUsIDAuNSkpO1xcbiAgICByZXN1bHQgPSAxLiAtcmVzdWx0O1xcbiAgICByZXN1bHQgPSBwb3cocmVzdWx0LCAxLik7XFxuICAgIHJlc3VsdCA9IHN0ZXAocmFkaW8sIHJlc3VsdCk7XFxuICAgIHJldHVybiByZXN1bHQ7XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMyB3aGl0ZSA9IHZlYzMoMS4sIDEuLCAxLik7XFxuICAgIGZsb2F0IHB1bHNlID0gdl9wdWxzZVN0cmVuZ3RoTm9ybTErdl9wdWxzZVN0cmVuZ3RoTm9ybTI7XFxuICAgIHB1bHNlID0gY2xhbXAocHVsc2UsIDAuLCAxLik7XFxuICAgIHZlYzMgZmluYWxDb2xvciA9IHZfY29sb3I7XFxuICAgIC8vZmluYWxDb2xvciA9IG1peChmaW5hbENvbG9yLCB3aGl0ZSwgcHVsc2UqNS4pO1xcbiAgICAvL2ZpbmFsQ29sb3IgPSBtaXgoZmluYWxDb2xvciwgd2hpdGUsIDAuKTtcXG4gICAgZmxvYXQgYWxwaGEgPSBjaXJjdWxpemFyKDEuMCk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoZmluYWxDb2xvciwgYWxwaGEqMC44KTtcXG59XCI7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuLy9pbXBvcnQgKiBhcyBUSFJFRSBmcm9tIFwidGhyZWVcIlxuLy9pbXBvcnQgZ3NhcCBmcm9tIFwiZ3NhcFwiXG4vL2ltcG9ydCB7R0xURkxvYWRlciwgR0xUTG9hZGVyfSBmcm9tIFwidGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvR0xURkxvYWRlclwiXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbnZhciBIb21lMUdlb21ldHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhIb21lMUdlb21ldHJ5LCBfRXZlbnRFbWl0dGVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEhvbWUxR2VvbWV0cnkpO1xuXG4gIGZ1bmN0aW9uIEhvbWUxR2VvbWV0cnkob2JqKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhvbWUxR2VvbWV0cnkpO1xuXG4gICAgLy9jb25zb2xlLmxvZyhcIihIb21lMUdlb21ldHJ5LkNPTlNUUlVDVE9SQSkhXCIpXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTsgLy8tLVxuXG4gICAgX3RoaXMuZmFjdG9yID0gb2JqLmZhY3RvcjsgLy82XG5cbiAgICBfdGhpcy5pbmNyX3JhZGlvID0gb2JqLmluY3JfcmFkaW87IC8vMjVcblxuICAgIF90aGlzLm51bU9yYml0cyA9IG9iai5udW1PcmJpdHM7IC8vMzdcblxuICAgIF90aGlzLmFycmF5X3RyaWFuZ3VsYXIgPSBvYmouYXJyYXlfdHJpYW5ndWxhcjtcbiAgICBfdGhpcy5hcnJheV9kb3RQb3MgPSBvYmouYXJyYXlfZG90UG9zO1xuICAgIF90aGlzLm51bURvdHMgPSBvYmoubnVtRG90czsgLy8tLVxuXG4gICAgX3RoaXMuYXJyYXlDb2xvcmVzX1JHQiA9IFtdO1xuICAgIF90aGlzLmFycmF5Q29sb3Jlc19SR0JfMDEgPSBbXTtcbiAgICBfdGhpcy5jb2xvclBvcyA9IDA7XG5cbiAgICBfdGhpcy5faW5pdF9jb2xvcnMoKTsgLy8tLVxuXG5cbiAgICBfdGhpcy5hdHRyaWJ1dGVzID0ge1xuICAgICAgYV9wb3NpY2lvbmVzOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAzKSxcbiAgICAgIGFfY29sb3I6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDMpLFxuICAgICAgYV9vcmJpdGFsOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfcG9zX29yYml0YTogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX2luY3JfYW5ndWxvUmFkOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfYW5ndWxvUmFkOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfcmFkaW86IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV9kaXI6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV9pbmNyOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfeDogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX3k6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV96OiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKVxuICAgIH07IC8vLS1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMuYXJyYXlfZG90UG9zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZG90UG9zID0gX3RoaXMuYXJyYXlfZG90UG9zW2ldO1xuXG4gICAgICB2YXIgZG90ID0gX3RoaXMuX2dldF9kb3QoZG90UG9zKTtcblxuICAgICAgdmFyIGkzID0gaSAqIDM7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfcG9zaWNpb25lc1tpM10gPSBkb3QueDtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9wb3NpY2lvbmVzW2kzICsgMV0gPSBkb3QueTtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9wb3NpY2lvbmVzW2kzICsgMl0gPSBkb3QuejsgLy8tLVxuXG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfY29sb3JbaTNdID0gZG90LmNvbG9yWzBdO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX2NvbG9yW2kzICsgMV0gPSBkb3QuY29sb3JbMV07XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfY29sb3JbaTMgKyAyXSA9IGRvdC5jb2xvclsyXTsgLy8tLVxuXG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfb3JiaXRhbFtpXSA9IGRvdC5vcmJpdGFsO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3Bvc19vcmJpdGFbaV0gPSBkb3QucG9zX29yYml0YTtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9pbmNyX2FuZ3Vsb1JhZFtpXSA9IGRvdC5pbmNyX2FuZ3Vsb1JhZDtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9hbmd1bG9SYWRbaV0gPSBkb3QuYW5ndWxvUmFkO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3JhZGlvW2ldID0gZG90LnJhZGlvO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX2RpcltpXSA9IGRvdC5kaXI7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfaW5jcltpXSA9IGRvdC5pbmNyO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3hbaV0gPSBkb3QueTtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV95W2ldID0gZG90Lnk7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfeltpXSA9IGRvdC56O1xuICAgIH0gLy8tLVxuXG5cbiAgICBfdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUFJJVkFEQVNcblxuXG4gIF9jcmVhdGVDbGFzcyhIb21lMUdlb21ldHJ5LCBbe1xuICAgIGtleTogXCJfZ2V0X2RvdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0X2RvdChudW0pIHtcbiAgICAgIC8vIERldnVlbHZlIHVuIG9iamV0byBjb24gbGEgaW5mb3JtYWNpw7NuIGRlIHVuIHB1bnRvIGRlIGxhIGdlb21ldHJpYSBcIm9yYml0YWwgTUlPVElcIlxuICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgbnVtOiBudW0sXG4gICAgICAgIGNvbG9yOiB0aGlzLl9nZXRfY29sb3IoKSxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgejogMCxcbiAgICAgICAgb3JiaXRhbDogMCxcbiAgICAgICAgY29fb3JiaXRhbnRlczogMCxcbiAgICAgICAgcG9zX29yYml0YTogMCxcbiAgICAgICAgaW5jcl9hbmd1bG9SYWQ6IDAsXG4gICAgICAgIGFuZ3Vsb1JhZDogMCxcbiAgICAgICAgcmFkaW86IDBcbiAgICAgIH07IC8vLS1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdGhpcy5hcnJheV90cmlhbmd1bGFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW1TdXAgPSB0aGlzLmFycmF5X3RyaWFuZ3VsYXJbaV07IC8vY29uc29sZS5sb2coXCJsaW1TdXA6IFwiK2xpbVN1cClcblxuICAgICAgICBpZiAobnVtID4gbGltU3VwKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCIqXCIpXG4gICAgICAgICAgb2JqLm9yYml0YWwgPSBpICsgMTtcbiAgICAgICAgICBvYmouY29fb3JiaXRhbnRlcyA9IChpICsgMSkgKiB0aGlzLmZhY3RvcjtcbiAgICAgICAgICBvYmoucG9zX29yYml0YSA9IG51bSAtIGxpbVN1cCAtIDE7XG4gICAgICAgICAgb2JqLmluY3JfYW5ndWxvUmFkID0gMiAqIE1hdGguUEkgLyBvYmouY29fb3JiaXRhbnRlcztcblxuICAgICAgICAgIGlmIChvYmoub3JiaXRhbCAlIDIgPT0gMCkge1xuICAgICAgICAgICAgb2JqLmRpciA9IDE7XG4gICAgICAgICAgICBvYmouaW5jciA9IDA7XG4gICAgICAgICAgICBvYmouYW5ndWxvUmFkID0gb2JqLnBvc19vcmJpdGEgKiBvYmouaW5jcl9hbmd1bG9SYWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9iai5kaXIgPSAtMTtcbiAgICAgICAgICAgIG9iai5pbmNyID0gMTtcbiAgICAgICAgICAgIG9iai5hbmd1bG9SYWQgPSBvYmoucG9zX29yYml0YSAqIG9iai5pbmNyX2FuZ3Vsb1JhZCArIG9iai5pbmNyX2FuZ3Vsb1JhZCAvIDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JqLnJhZGlvID0gb2JqLm9yYml0YWwgKiB0aGlzLmluY3JfcmFkaW87IC8vLS1cblxuICAgICAgICAgIG9iai54ID0gTWF0aC5jb3Mob2JqLmFuZ3Vsb1JhZCkgKiBvYmoucmFkaW87XG4gICAgICAgICAgb2JqLnkgPSBNYXRoLnNpbihvYmouYW5ndWxvUmFkKSAqIG9iai5yYWRpbztcbiAgICAgICAgICBvYmoueiA9IDA7XG4gICAgICAgIH0gLy9icmVha1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRfY29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9jb2xvcigpIHtcbiAgICAgIHZhciBjb2xvcl9SR0JfMDEgPSB0aGlzLmFycmF5Q29sb3Jlc19SR0JfMDFbdGhpcy5jb2xvclBvc107XG4gICAgICB0aGlzLmNvbG9yUG9zKys7XG5cbiAgICAgIGlmICh0aGlzLmNvbG9yUG9zID4gdGhpcy5hcnJheUNvbG9yZXNfUkdCXzAxLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhpcy5jb2xvclBvcyA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xvcl9SR0JfMDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0X2NvbG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdF9jb2xvcnMoKSB7XG4gICAgICB0aGlzLmFycmF5Q29sb3Jlc19SR0IgPSBbXTtcbiAgICAgIHRoaXMuYXJyYXlDb2xvcmVzX1JHQi5wdXNoKFsyNTUsIDg3LCAxMzFdKTsgLy8gUm9zYVxuXG4gICAgICB0aGlzLmFycmF5Q29sb3Jlc19SR0IucHVzaChbODksIDIsIDJdKTtcbiAgICAgIHRoaXMuYXJyYXlDb2xvcmVzX1JHQi5wdXNoKFsxLCAzLCA0OV0pO1xuICAgICAgdGhpcy5hcnJheUNvbG9yZXNfUkdCLnB1c2goWzAsIDE2LCAxMTZdKTtcbiAgICAgIHRoaXMuYXJyYXlDb2xvcmVzX1JHQi5wdXNoKFsxNCwgMTMzLCAyNTVdKTtcbiAgICAgIHRoaXMuYXJyYXlDb2xvcmVzX1JHQl8wMSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXJyYXlDb2xvcmVzX1JHQi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29sb3JfUkdCID0gdGhpcy5hcnJheUNvbG9yZXNfUkdCW2ldO1xuICAgICAgICB2YXIgY29sb3JfUkdCXzAxID0gW2NvbG9yX1JHQlswXSAvIDI1NSwgY29sb3JfUkdCWzFdIC8gMjU1LCBjb2xvcl9SR0JbMl0gLyAyNTVdO1xuICAgICAgICB0aGlzLmFycmF5Q29sb3Jlc19SR0JfMDEucHVzaChjb2xvcl9SR0JfMDEpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIb21lMUdlb21ldHJ5O1xufShFdmVudEVtaXR0ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBIb21lMUdlb21ldHJ5OyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSBcInRocmVlXCI7IC8vaW1wb3J0IGdzYXAgZnJvbSBcImdzYXBcIlxuXG5pbXBvcnQgdmVydGV4IGZyb20gXCIuL3NoYWRlcnMvaG9tZTFfZG90c192ZXJ0ZXhfbS5nbHNsXCI7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSBcIi4vc2hhZGVycy9ob21lMV9kb3RzX2ZyYWdtZW50X20uZ2xzbFwiOyAvL2ltcG9ydCB2ZXJ0ZXhfYmcgZnJvbSBcIi4vc2hhZGVycy9ob21lMV9iYWNrZ3JvdW5kX3ZlcnRleC5nbHNsXCJcbi8vaW1wb3J0IGZyYWdtZW50X2JnIGZyb20gXCIuL3NoYWRlcnMvaG9tZTFfYmFja2dyb3VuZF9mcmFnbWVudC5nbHNsXCJcblxuaW1wb3J0IEVhc2VkT3V0VmFsdWUgZnJvbSAnLi4vRWFzZWRPdXRWYWx1ZSc7XG5pbXBvcnQgSG9tZTFHZW9tZXRyeSBmcm9tICcuL0hvbWUxR2VvbWV0cnlfbSc7XG5cbnZhciBIb21lMURvdHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIb21lMURvdHMob2JqKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhvbWUxRG90cyk7XG5cbiAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWUxRG90cy5DT05TVFJVQ1RPUkEpIVwiKVxuICAgIC8vY29uc29sZS5sb2cob2JqKVxuICAgIHRoaXMuYXBwID0gb2JqLmFwcDsgLy8tLVxuXG4gICAgdGhpcy5zY2VuZSA9IHRoaXMuYXBwLnNjZW5lO1xuICAgIHRoaXMuY2FtZXJhRGlzdGFuY2UgPSB0aGlzLmFwcC5jYW1lcmFEaXN0YW5jZTsgLy8tLVxuXG4gICAgdGhpcy5tYXRlcmlhbCA9IG51bGw7XG4gICAgdGhpcy5nZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5tZXNoID0gbnVsbDtcbiAgICB0aGlzLmNyZWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNsb2NrID0gbmV3IFRIUkVFLkNsb2NrKCk7IC8vLS1cbiAgICAvL3RoaXMuZWFzZWRfc2Nyb2xsRGVsdGFfZmFzdCA9IG5ldyBFYXNlZE91dFZhbHVlKHRoaXMuYXBwLnNjcm9sbERhdGEubm9ybWFsaXplZERlbHRhKjAuNSwgMC4xKVxuICAgIC8vLS1cblxuICAgIHRoaXMuX3NldHVwX3NldHRpbmdzKCk7IC8vLS1cblxuXG4gICAgdGhpcy5vcmJpdGFsX2dlb21ldHJ5ID0gbmV3IEhvbWUxR2VvbWV0cnkodGhpcy5zZXR0aW5ncyk7IC8vLS1cbiAgICAvL3RoaXMuX2NyZWF0ZSgpXG4gIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUFVCTElDQVM6IFxuXG5cbiAgX2NyZWF0ZUNsYXNzKEhvbWUxRG90cywgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5lYXNlZF9zY3JvbGxEZWx0YV9mYXN0ID0gbmV3IEVhc2VkT3V0VmFsdWUodGhpcy5hcHAuc2Nyb2xsRGF0YS5ub3JtYWxpemVkRGVsdGEgKiAwLjUsIDAuMSk7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZSgpO1xuICAgIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICBpZiAodGhpcy5jcmVhdGVkKSB7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVRpbWUudmFsdWUgPSB0aGlzLmNsb2NrLmdldEVsYXBzZWRUaW1lKCk7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudUNhbWFyYURpc3RhbmNlLnZhbHVlID0gdGhpcy5hcHAuY2FtZXJhRGlzdGFuY2U7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudU9wZW5Qcm9ncmVzcy52YWx1ZSA9IHRoaXMuc2V0dGluZ3Mub3BlblByb2dyZXNzO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVSZXNwb25zaXZlU2NhbGUudmFsdWUgPSB0aGlzLmFwcC5yZXNwb25zaXZlU2NhbGU7IC8vdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51X3Njcm9sbF9mYWN0b3JkRGVsdGEudmFsdWUgPSB0aGlzLmFwcC5zY3JvbGxEYXRhLmZhY3RvcmREZWx0YVxuICAgICAgICAvL3RoaXMubWF0ZXJpYWwudW5pZm9ybXMudV9zY3JvbGxfZGlyZWN0aW9uLnZhbHVlID0gdGhpcy5hcHAuc2Nyb2xsRGF0YS5kaXJlY3Rpb25cblxuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVTY3JvbGxEZWx0YS52YWx1ZSA9IC10aGlzLmVhc2VkX3Njcm9sbERlbHRhX2Zhc3QuZ2V0KHRoaXMuYXBwLnNjcm9sbERhdGEubm9ybWFsaXplZERlbHRhICogMC41KTsgLy8tLVxuXG4gICAgICAgIHZhciBleHRyYVNwZWVkID0gMSArIE1hdGguYWJzKHRoaXMuZWFzZWRfc2Nyb2xsRGVsdGFfZmFzdC5nZXQodGhpcy5hcHAuc2Nyb2xsRGF0YS5ub3JtYWxpemVkRGVsdGEgKiAwLjUpICogMTApO1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJvdGF0aW9uMSArPSB0aGlzLnNldHRpbmdzLnNwZWVkUm90YXRpb24xICogZXh0cmFTcGVlZDtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5yb3RhdGlvbjIgKz0gdGhpcy5zZXR0aW5ncy5zcGVlZFJvdGF0aW9uMiAqIGV4dHJhU3BlZWQ7XG4gICAgICAgIHRoaXMuc2V0dGluZ3Mucm90YXRpb24zICs9IHRoaXMuc2V0dGluZ3Muc3BlZWRSb3RhdGlvbjMgKiBleHRyYVNwZWVkO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVSb3RhdGlvbjEudmFsdWUgPSB0aGlzLnNldHRpbmdzLnJvdGF0aW9uMTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Um90YXRpb24yLnZhbHVlID0gLXRoaXMuc2V0dGluZ3Mucm90YXRpb24yO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVSb3RhdGlvbjMudmFsdWUgPSB0aGlzLnNldHRpbmdzLnJvdGF0aW9uMzsgLy9jb25zb2xlLmxvZyh0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVSb3RhdGlvbjEudmFsdWUpXG4gICAgICB9XG4gICAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFBVQkxJQ0FTOlxuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7Ly9jb25zb2xlLmxvZyhcIihHcmFkaWVudEJhY2tncm91bmQucmVzaXplKSFcIilcbiAgICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUFJJVkFEQVM6IFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldHVwX3NldHRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cF9zZXR0aW5ncygpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTFEb3RzLl9zZXR1cF9zZXR0aW5ncykhIVwiKVxuICAgICAgdmFyIHNwZWVkQmFzZSA9IDAuMDAyO1xuICAgICAgdGhpcy5zZXR0aW5ncyA9IHtcbiAgICAgICAgZmFjdG9yOiA2LFxuICAgICAgICAvL2luY3JfcmFkaW86IDI1LFxuICAgICAgICBpbmNyX3JhZGlvOiAxMy4yLFxuICAgICAgICBudW1PcmJpdHM6IDE5LFxuICAgICAgICAvL2FycmF5T3JiaXRzOiBbNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsICAxNywgMTgsIDE5XSxcbiAgICAgICAgYXJyYXlPcmJpdHM6IFsxMCwgMTQsIDE4XSxcbiAgICAgICAgLy9hcnJheU9yYml0czogWzEsIDMsIDQsIDVdLFxuICAgICAgICAvLyBPcnRiaXQgcm90YXRpb25cbiAgICAgICAgcm90YXRpb24xOiAwLFxuICAgICAgICBzcGVlZFJvdGF0aW9uMTogMyAqIHNwZWVkQmFzZSxcbiAgICAgICAgcm90YXRpb24yOiAyLFxuICAgICAgICBzcGVlZFJvdGF0aW9uMjogMiAqIHNwZWVkQmFzZSxcbiAgICAgICAgcm90YXRpb24zOiAwLFxuICAgICAgICBzcGVlZFJvdGF0aW9uMzogMSAqIHNwZWVkQmFzZVxuICAgICAgfTtcbiAgICAgIHRoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhciA9IHRoaXMuX2dldF9hcnJheV90cmlhbmd1bGFyKHRoaXMuc2V0dGluZ3MuZmFjdG9yLCB0aGlzLnNldHRpbmdzLm51bU9yYml0cyk7XG4gICAgICB0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YSA9IHRoaXMuX2dldF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEodGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyLCB0aGlzLnNldHRpbmdzLmFycmF5T3JiaXRzKTtcbiAgICAgIHRoaXMuc2V0dGluZ3MuYXJyYXlfZG90UG9zID0gdGhpcy5fZ2V0X2FycmF5X2RvdFBvcyh0aGlzLnNldHRpbmdzLmFycmF5T3JiaXRzLCB0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXIsIHRoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhKTtcbiAgICAgIHRoaXMuc2V0dGluZ3MubnVtRG90cyA9IHRoaXMuc2V0dGluZ3MuYXJyYXlfZG90UG9zLmxlbmd0aDtcbiAgICAgIHRoaXMuc2V0dGluZ3Mub3BlblByb2dyZXNzID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lMURvdHMuX2NyZWF0ZSkhXCIpXG4gICAgICAvLy0tXG4gICAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICAgIC8vYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcsXG4gICAgICAgIHZlcnRleENvbG9yczogdHJ1ZSxcbiAgICAgICAgdmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgdUNhbWFyYURpc3RhbmNlOiB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5hcHAuY2FtZXJhRGlzdGFuY2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVUaW1lOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy91U2NhbGU6e3ZhbHVlOiAxfSxcbiAgICAgICAgICB1T3BlblByb2dyZXNzOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVJlc3BvbnNpdmVTY2FsZToge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vdV9zY3JvbGxfZmFjdG9yZERlbHRhOiB7dmFsdWU6IDF9LFxuICAgICAgICAgIC8vdV9zY3JvbGxfZGlyZWN0aW9uOiB7dmFsdWU6IDF9LFxuICAgICAgICAgIHVTY3JvbGxEZWx0YToge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVSb3RhdGlvbjE6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Um90YXRpb24yOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVJvdGF0aW9uMzoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLy0tXG4gICAgICAvL2NvbnNvbGUubG9nKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfY29sb3IpXG4gICAgICAvLy0tXG5cbiAgICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9wb3NpY2lvbmVzLCAzKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXMsIDMpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfY29sb3IsIDMpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfb3JiaXRhbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9vcmJpdGFsLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX3Bvc19vcmJpdGEnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfcG9zX29yYml0YSwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9pbmNyX2FuZ3Vsb1JhZCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9pbmNyX2FuZ3Vsb1JhZCwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9hbmd1bG9SYWQnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfYW5ndWxvUmFkLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX3JhZGlvJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3JhZGlvLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX2RpcicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9kaXIsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfaW5jcicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9pbmNyLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX3gnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfeCwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV95JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3ksIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfeicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV96LCAxKSk7XG4gICAgICB0aGlzLm1lc2ggPSBuZXcgVEhSRUUuUG9pbnRzKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgICAgdGhpcy5zY2VuZS5hZGQodGhpcy5tZXNoKTtcbiAgICAgIHRoaXMuY3JlYXRlZCA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRfYXJyYXlfZG90UG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfYXJyYXlfZG90UG9zKF9hcnJheU9yYml0cywgX2FycmF5X3RyaWFuZ3VsYXIsIF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEpIHtcbiAgICAgIHZhciBtaUFycmF5ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2FycmF5T3JiaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvcmJpdE51bSA9IF9hcnJheU9yYml0c1tpXTtcbiAgICAgICAgdmFyIGRvdHNfeF9vcmJpdCA9IF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGFbaV07XG4gICAgICAgIHZhciBkb3ROdW1fYmFzZSA9IF9hcnJheV90cmlhbmd1bGFyW19hcnJheU9yYml0c1tpXSAtIDFdOyAvLyBjb25zb2xlLmxvZyhcIm9yYml0TnVtOiBcIitvcmJpdE51bSlcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJkb3RzX3hfb3JiaXQ6IFwiK2RvdHNfeF9vcmJpdClcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJkb3ROdW1fYmFzZTogXCIrZG90TnVtX2Jhc2UpXG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb3RzX3hfb3JiaXQ7IGorKykge1xuICAgICAgICAgIG1pQXJyYXkucHVzaChkb3ROdW1fYmFzZSArIGogKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWlBcnJheTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldF9udW1Eb3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfbnVtRG90cyhfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhKSB7XG4gICAgICB2YXIgbnVtRG90cyA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIG51bURvdHMgKz0gX2FycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YVtpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bURvdHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhKF9hcnJheV90cmlhbmd1bGFyLCBfYXJyYXlPcmJpdHMpIHtcbiAgICAgIC8vIEdlbmVyYSB1bmEgYXJyYXkgYmFzYWRhIGVuIGxhIHByb2dyZXNpw7NuIHRyaWFuZ3VsYXIgKCogZmFjdG9yKS5cbiAgICAgIC8vIC4uLiBkb25kZSBzZSBpbmRpY2EgZWwgbnVtZXJvIGRlIGRvdHMgcG9yIG9yYml0YWxcbiAgICAgIC8vIFVuYSBwcm9ncmVzacOzbiB0cmlhbmd1bGFyIGVzOiAxLCAzLCA2LCAxMCwgMTUgKGh0dHBzOi8vc2lnbmlmaWNhdGl2YS5vcmcvZGljY2lvbmFyaW9zL251bWVyb3MtZmlndXJhZG9zLyM6fjp0ZXh0PTMuMS4xLjEuLSxEZWZpbmljaSVDMyVCM24sYW50ZXJpb3IlMjBubyUyMG9idGVuZW1vcyUyMHVuYSUyMGNvbnN0YW50ZS4pXG4gICAgICB2YXIgbWlBcnJheSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBfYXJyYXlPcmJpdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIC8vYXJyYXlfbnVtVHJpYWd1bGFyZXMucHVzaChpKihpKzEpLzIpXG4gICAgICAgIHZhciBudW1Eb3RzX29yYml0YV9hY3R1YWwgPSBfYXJyYXlfdHJpYW5ndWxhcltfYXJyYXlPcmJpdHNbaV1dO1xuICAgICAgICB2YXIgbnVtRG90c19vcmJpdGFfYW50ZXJpb3IgPSBfYXJyYXlfdHJpYW5ndWxhcltfYXJyYXlPcmJpdHNbaV0gLSAxXTtcbiAgICAgICAgdmFyIG51bURvdHNfb3JiaXRhID0gbnVtRG90c19vcmJpdGFfYWN0dWFsIC0gbnVtRG90c19vcmJpdGFfYW50ZXJpb3I7XG4gICAgICAgIG1pQXJyYXkucHVzaChudW1Eb3RzX29yYml0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaUFycmF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0X2FycmF5X3RyaWFuZ3VsYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9hcnJheV90cmlhbmd1bGFyKF9mYWN0b3IsIF9udW1PYml0cykge1xuICAgICAgLy8gR2VuZXJhIHVuYSBhcnJheSBkZSBwcm9ncmVzacOzbiB0cmlhbmd1bGFyICgqIGZhY3RvcikuXG4gICAgICAvLyBVbmEgcHJvZ3Jlc2nDs24gdHJpYW5ndWxhciBlczogMSwgMywgNiwgMTAsIDE1IChodHRwczovL3NpZ25pZmljYXRpdmEub3JnL2RpY2Npb25hcmlvcy9udW1lcm9zLWZpZ3VyYWRvcy8jOn46dGV4dD0zLjEuMS4xLi0sRGVmaW5pY2klQzMlQjNuLGFudGVyaW9yJTIwbm8lMjBvYnRlbmVtb3MlMjB1bmElMjBjb25zdGFudGUuKVxuICAgICAgdmFyIG1pQXJyYXkgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gX251bU9iaXRzOyBpKyspIHtcbiAgICAgICAgLy9hcnJheV9udW1UcmlhZ3VsYXJlcy5wdXNoKGkqKGkrMSkvMilcbiAgICAgICAgbWlBcnJheS5wdXNoKGkgKiAoaSArIDEpIC8gMiAqIF9mYWN0b3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWlBcnJheTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldHVwX2d1aVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBfZ3VpKCkgey8vY29uc29sZS5sb2coXCIoSG9tZTFEb3RzLl9zZXR1cF9ndWkpIVwiKVxuICAgICAgLy8gdGhpcy5ndWkgPSBuZXcgZGF0LkdVSSgpO1xuICAgICAgLy8gdGhpcy5ndWkud2lkdGggPSA0MDBcbiAgICAgIC8vIGNvbnN0IGZvbGRlcjAgPSB0aGlzLmd1aS5hZGRGb2xkZXIoXCJPcmJpdCBzcGlubmluZ1wiKVxuICAgICAgLy8gZm9sZGVyMC5hZGQodGhpcy5zZXR0aW5ncywgXCJwcm9ncmVzczVcIiwgMCwgMTAsIDAuMDEpLm5hbWUoXCJQcm9ncmVzc1wiKVxuICAgICAgLy8gZm9sZGVyMC5vcGVuKClcbiAgICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB9XSk7XG5cbiAgcmV0dXJuIEhvbWUxRG90cztcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgSG9tZTFEb3RzOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IGdzYXAgZnJvbSAnZ3NhcCc7XG5pbXBvcnQgU2Nyb2xsVHJpZ2dlciBmcm9tICdnc2FwL1Njcm9sbFRyaWdnZXInO1xuaW1wb3J0IEhvbWUxU2Nyb2xsX20gZnJvbSAnLi9Ib21lMVNjcm9sbF9tJzsgLy8tLVxuXG5pbXBvcnQgSG9tZTFEb3RzX20gZnJvbSAnLi9Ib21lMURvdHNfbSc7XG5cbnZhciBIb21lMUFwcF9tID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSG9tZTFBcHBfbShvYmopIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSG9tZTFBcHBfbSk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhcIihIb21lMUFwcF9tLkNPTlNUUlVDVE9SQSkhIVwiLCBvYmopIFxuICAgIHRoaXMuaHdfcmVuZGVyZXIgPSBvYmoucmVuZGVyZXI7IC8vIFJlZGVyZXIvcGFnaW5hIGRlIEhpZ2hXYXkuIE5vIGNvbmZ1bmRpciBjb24gZWwgcmVuZGVyL3JlbmRlcmVyIGRlIFRocmVlLmpzXG5cbiAgICB0aGlzLiRjb250YWluZXIgPSBvYmouZG9tRWxlbWVudDsgLy8tLVxuXG4gICAgdGhpcy4kaW5uZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW5uZXInKTsgLy8tLVxuXG4gICAgdGhpcy5SRUZfUkVTT0xVVElPTiA9IHtcbiAgICAgIHdpZHRoOiA0ODAsXG4gICAgICBoZWlnaHQ6IDQ4MFxuICAgIH07XG4gICAgdGhpcy5SRUZfQ0FNRVJBX0RJU1RBTkNFID0gNTAwOyAvLy0tXG5cbiAgICB0aGlzLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0O1xuICAgIHRoaXMucmVzcG9uc2l2ZVNjYWxlO1xuICAgIHRoaXMuY2FtZXJhRGlzdGFuY2U7IC8vLS1cbiAgICAvLy0tXG4gICAgLy90aGlzLnNjcm9sbERhdGEgPSBuZXcgSG9tZTFTY3JvbGxfbSh7XG4gICAgLy8gICAgYXBwOnRoaXMsXG4gICAgLy8gICAgJGlubmVyOiB0aGlzLiRpbm5lclxuICAgIC8vfSlcbiAgICAvLy0tXG5cbiAgICB0aGlzLl91cGRhdGVfZGltZW5zaW9ucygpOyAvLy0tXG4gICAgLy8gU2NlbmVcblxuXG4gICAgdGhpcy5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpOyAvL3RoaXMuc2NlbmUuYmFja2dyb3VuZCA9IG5ldyBUSFJFRS5Db2xvciggMHgwMGZmMDAgKTtcbiAgICAvLy0tXG4gICAgLy8gY29uc29sZS5sb2coXCJ0aGlzLndpZHRoOiBcIit0aGlzLndpZHRoKVxuICAgIC8vIGNvbnNvbGUubG9nKFwidGhpcy5oZWlnaHQ6IFwiK3RoaXMuaGVpZ2h0KVxuICAgIC8vIGNvbnNvbGUubG9nKFwidGhpcy5jYW1lcmFEaXN0YW5jZTogXCIrdGhpcy5jYW1lcmFEaXN0YW5jZSlcbiAgICAvLy0tXG4gICAgLy8gQ2FtZXJhXG4gICAgLy9QZXJzcGVjdGl2ZUNhbWVyYSggZm92IDogTnVtYmVyLCBhc3BlY3QgOiBOdW1iZXIsIG5lYXIgOiBOdW1iZXIsIGZhciA6IE51bWJlciApXG5cbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSgzMCwgdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0LCAwLjEsIDIwMDApO1xuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSB0aGlzLmNhbWVyYURpc3RhbmNlO1xuICAgIHRoaXMuY2FtZXJhLmZvdiA9IDIgKiBNYXRoLmF0YW4odGhpcy5oZWlnaHQgLyAyIC8gdGhpcy5jYW1lcmFEaXN0YW5jZSkgKiAoMTgwIC8gTWF0aC5QSSk7IC8vLS1cbiAgICAvLyBSZW5kZXJlclxuICAgIC8vLS1cblxuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0wxUmVuZGVyZXIoe1xuICAgICAgYW50aWFsaWFzOiB0cnVlLFxuICAgICAgYWxwaGE6IHRydWVcbiAgICB9KTsgLy90aGlzLnJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlIC8vIFZhbW9zIGEgdXNhciAyIHNjZW5hcyAodW5hIHBhcmEgZWwgYmFja2dyb3VuZCB5IG90cmEgcGFyYSBsb3MgcHVudG9zKSBxdWUgaW1wbGljYXLDoW4gdXNhciAyIGFjY2lvbmVzIGRlIHJlbmRlci4gQ29uIGF1dG9jbGVhciBmYWxzZSBwZXJtaXRpbW9zIHF1ZSBsYSBzZWd1bmRhIG5vIGJvcnJlIGxhIHByaW1lcmEuXG5cbiAgICB0aGlzLnJlbmRlcmVyLnNldFBpeGVsUmF0aW8oTWF0aC5taW4od2luZG93LmRldmljZVBpeGVsUmF0aW8sIDEpKTsgLy90aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3JIZXgoIDB4ZmYwMDAwLCAxICk7XG4gICAgLy8tLVxuXG4gICAgdGhpcy4kY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7IC8vLS1cblxuICAgIHRoaXMuZG90cyA9IG5ldyBIb21lMURvdHNfbSh7XG4gICAgICBhcHA6IHRoaXNcbiAgICB9KTsgLy8tLVxuICAgIC8vdGhpcy5fY3JlYXRlY3ViZSh0aGlzLnNjZW5lKVxuXG4gICAgdGhpcy5fcmVzaXplKCk7IC8vdGhpcy5fcmVuZGVyKCk7XG5cbiAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQVUJMSUNBUzpcblxuXG4gIF9jcmVhdGVDbGFzcyhIb21lMUFwcF9tLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLiRpbm5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbm5lcicpO1xuICAgICAgdGhpcy5zY3JvbGxEYXRhID0gbmV3IEhvbWUxU2Nyb2xsX20oe1xuICAgICAgICBhcHA6IHRoaXMsXG4gICAgICAgICRpbm5lcjogdGhpcy4kaW5uZXJcbiAgICAgIH0pOyAvLy0tXG5cbiAgICAgIHRoaXMuZG90cy5pbml0KCk7IC8vLS1cblxuICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImtpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgIHRoaXMuc2Nyb2xsRGF0YS5raWxsKCk7XG4gICAgICB0aGlzLnNjcm9sbERhdGEgPSBudWxsO1xuICAgICAgdGhpcy5kb3RzID0gbnVsbDtcbiAgICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lMUFwcF9tLnJlbmRlcikhXCIpXG4gICAgICB0aGlzLl9yZW5kZXIoKTsgLy8gTG8gbGxhbWEgc2Nyb2xsRGF0YVxuXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWUxQXBwX20ucmVzaXplKSFcIilcbiAgICAgIHRoaXMuX3Jlc2l6ZSgpO1xuICAgIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBQUklWQURBUzpcblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVfZGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlX2RpbWVuc2lvbnMoKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIihIb21lMUFwcF9tLl91cGRhdGVfZGltZW5zaW9ucykhXCIsIHRoaXMucmVuZGVyZXIpXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy4kY29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLiRjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgdGhpcy5yZXNwb25zaXZlU2NhbGUgPSB0aGlzLndpZHRoIC8gdGhpcy5SRUZfUkVTT0xVVElPTi53aWR0aDtcbiAgICAgIHRoaXMuY2FtZXJhRGlzdGFuY2UgPSB0aGlzLlJFRl9DQU1FUkFfRElTVEFOQ0UgKiB0aGlzLnJlc3BvbnNpdmVTY2FsZTsgLy8tLVxuXG4gICAgICBpZiAodGhpcy5yZW5kZXJlcikge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpOyAvLy0tXG5cbiAgICAgICAgdGhpcy5jYW1lcmEuYXNwZWN0ID0gdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNhbWVyYURpc3RhbmNlID0gdGhpcy5jYW1lcmEucG9zaXRpb24uejtcbiAgICAgICAgdGhpcy5jYW1lcmEuZm92ID0gMiAqIE1hdGguYXRhbih0aGlzLmhlaWdodCAvIDIgLyB0aGlzLmNhbWVyYURpc3RhbmNlKSAqICgxODAgLyBNYXRoLlBJKTtcbiAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgfSAvLy0tXG5cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lMUFwcF9tLl9yZXNpemUpISFcIilcbiAgICAgIHRoaXMuX3VwZGF0ZV9kaW1lbnNpb25zKCk7IC8vLS1cblxuXG4gICAgICBpZiAodGhpcy5kb3RzKSB7Ly90aGlzLmRvdHMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lMUFwcF9tLl9yZW5kZXIpIVwiKVxuICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IHRoaXMuJGNvbnRhaW5lci5vZmZzZXRIZWlnaHQgfHwgdGhpcy53aWR0aCAhPSB0aGlzLiRjb250YWluZXIub2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRvdHMpIHtcbiAgICAgICAgdGhpcy5kb3RzLnJlbmRlcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVjdWJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVjdWJlKF9zY2VuZSkge1xuICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KDEwMCwgMTAwLCAxMDApO1xuICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgY29sb3I6IDB4ZmYwMDAwXG4gICAgICB9KTtcbiAgICAgIHZhciBjdWJlID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTsgLy9jdWJlLnBvc2l0aW9uLnNldCgxMDAsIDEwMCwgMTAwKVxuXG4gICAgICBfc2NlbmUuYWRkKGN1YmUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIb21lMUFwcF9tO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBIb21lMUFwcF9tOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuaW1wb3J0IGdzYXAgZnJvbSAnZ3NhcCc7XG5pbXBvcnQgU2Nyb2xsVHJpZ2dlciBmcm9tICdnc2FwL1Njcm9sbFRyaWdnZXInO1xuaW1wb3J0IFdlYkdMVXRpbHMgZnJvbSAnLi4vV2ViR0xVdGlscyc7XG5cbnZhciBIb21lMlNjcm9sbF9tID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSG9tZTJTY3JvbGxfbShvYmopIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSG9tZTJTY3JvbGxfbSk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhcIihIb21lMlNjcm9sbF9tLkNPTlNUUlVDVE9SQSk6IFwiLCBvYmopXG4gICAgdGhpcy5hcHAgPSBvYmouYXBwO1xuICAgIHRoaXMuJGlubmVyID0gb2JqLiRpbm5lcjsgLy8tLVxuXG4gICAgdGhpcy5sYXN0SW5uZXJZID0gMDsgLy8gVWx0aW1hIHBvc2ljacOzbiBkZWwgZWxlbWVudG8gZGUgcmVmZXJlbmNpYVxuXG4gICAgdGhpcy5kZWx0YSA9IDA7IC8vIEluY3JlbWVudG8gZGUgcGl4ZWxzIGRlbCBzY3JvbGxcblxuICAgIHRoaXMubGltaXRlZERlbHRhID0gMDsgLy8gTGltaXRhIGxvcyB2YWxvcmVzIGEgLTIwIC0+ICsyMFxuXG4gICAgdGhpcy5ub3JtYWxpemVkRGVsdGEgPSAwOyAvLyBQYXNhIGVsIGRlbHRhIGEgLTEgLT4gKzFcblxuICAgIHRoaXMuZmFjdG9yZERlbHRhID0gMTsgLy8gVmFsb3JlcyBhYnNvbHV0b3MgZGUgMCAtPiAxXG5cbiAgICB0aGlzLmRpcmVjdGlvbiA9IDE7IC8vIERpcmVjY2lvbiBkZWwgZGVsdGEuIDEgc2kgZXN0w6EgcGFyYWRvXG4gICAgLy8tLVxuXG4gICAgdGhpcy50cmlnZ2VycyA9IHt9OyAvLy0tXG5cbiAgICB0aGlzLnByb2dyZXNzID0ge307XG4gICAgdGhpcy5wcm9ncmVzcy4kaW5uZXIgPSAwOyAvLy0tXG5cbiAgICB0aGlzLl9pbml0XyRpbm5lcigpO1xuICB9IC8vLS0tLS0tLS0tLS0tXG4gIC8vIFBVQkxJQ0FTOlxuXG5cbiAgX2NyZWF0ZUNsYXNzKEhvbWUyU2Nyb2xsX20sIFt7XG4gICAga2V5OiBcImtpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgIHRoaXMudHJpZ2dlcnMuJGlubmVyLmtpbGwoKTtcbiAgICAgIGdzYXAudGlja2VyLnJlbW92ZSh0aGlzLl9iaW5kZWRfcmVuZGVyKTtcbiAgICAgIGdzYXAudGlja2VyLnJlbW92ZSh0aGlzLl9iaW5kZWRfZXZhbF9zY3JvbGwpO1xuICAgIH0gLy8tLS0tLS0tLS0tLS1cbiAgICAvLyBQUklWQURBU1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRfJGlubmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0XyRpbm5lcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBiaW5kZWRfcmVuZGVyID0gZnVuY3Rpb24gYmluZGVkX3JlbmRlcigpIHtcbiAgICAgICAgX3RoaXMuYXBwLnJlbmRlcigpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGJpbmRlZF9ldmFsX3Njcm9sbCA9IGZ1bmN0aW9uIGJpbmRlZF9ldmFsX3Njcm9sbCgpIHtcbiAgICAgICAgX3RoaXMuX3VwZGF0ZV8kaW5uZXIoX3RoaXMudHJpZ2dlcnMuJGlubmVyLnByb2dyZXNzKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2JpbmRlZF9yZW5kZXIgPSBiaW5kZWRfcmVuZGVyO1xuICAgICAgdGhpcy5fYmluZGVkX2V2YWxfc2Nyb2xsID0gYmluZGVkX2V2YWxfc2Nyb2xsOyAvLy0tXG5cbiAgICAgIHRoaXMudHJpZ2dlcnMuJGlubmVyID0gU2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xuICAgICAgICB0cmlnZ2VyOiB0aGlzLiRpbm5lcixcbiAgICAgICAgc3RhcnQ6ICd0b3AgYm90dG9tJyxcbiAgICAgICAgZW5kOiAnYm90dG9tIGJvdHRvbScsXG4gICAgICAgIHNjcnViOiB0cnVlLFxuICAgICAgICAvLyBTY3J1YjogR2VuZXJhIGV2ZW50b3MgZW4gdW5hIGZyYW5qYSBtYXMgcXVlIGVuIHVuIHB1bnRvLlxuICAgICAgICAvLyBtYXJrZXJzOiB0cnVlLFxuICAgICAgICBvblRvZ2dsZTogZnVuY3Rpb24gb25Ub2dnbGUoc2VsZikge1xuICAgICAgICAgIGlmIChzZWxmLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICBnc2FwLnRpY2tlci5hZGQoYmluZGVkX3JlbmRlcik7XG4gICAgICAgICAgICBnc2FwLnRpY2tlci5hZGQoYmluZGVkX2V2YWxfc2Nyb2xsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3NhcC50aWNrZXIucmVtb3ZlKGJpbmRlZF9yZW5kZXIpO1xuICAgICAgICAgICAgZ3NhcC50aWNrZXIucmVtb3ZlKGJpbmRlZF9ldmFsX3Njcm9sbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZV8kaW5uZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZV8kaW5uZXIocHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMucHJvZ3Jlc3MuJGlubmVyID0gcHJvZ3Jlc3M7IC8vLS1cblxuICAgICAgdmFyIGlubmVyRGF0YSA9IHRoaXMuJGlubmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIG5ld0lubmVyWSA9IGlubmVyRGF0YS55O1xuICAgICAgdGhpcy5kZWx0YSA9IG5ld0lubmVyWSAtIHRoaXMubGFzdElubmVyWTtcbiAgICAgIHRoaXMubGFzdElubmVyWSA9IG5ld0lubmVyWTtcbiAgICAgIHRoaXMubGltaXRlZERlbHRhID0gV2ViR0xVdGlscy5jbGFtcCh0aGlzLmRlbHRhLCAtMjAsIDIwKTsgLy8gTGltaXRhIGxvcyB2YWxvcmVzIGEgLTIwIC0+ICsyMFxuXG4gICAgICB0aGlzLm5vcm1hbGl6ZWREZWx0YSA9ICh0aGlzLmxpbWl0ZWREZWx0YSAvIDIwKS50b0ZpeGVkKDMpOyAvLyBQYXNhIGVsIGRlbHRhIGEgLTEgLT4gKzFcblxuICAgICAgdGhpcy5mYWN0b3JkRGVsdGEgPSBNYXRoLmFicyh0aGlzLm5vcm1hbGl6ZWREZWx0YSkgKyAwOyAvLyBWYWxvcmVzIGFic29sdXRvcyBkZSAwIC0+IDFcblxuICAgICAgdGhpcy5kaXJlY3Rpb24gPSAxO1xuXG4gICAgICBpZiAodGhpcy5ub3JtYWxpemVkRGVsdGEgPCAwKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsX2RpcmVjdGlvbiA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIb21lMlNjcm9sbF9tO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBIb21lMlNjcm9sbF9tOyIsImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhX3JhbmRvbW5lc3M7XFxuYXR0cmlidXRlIHZlYzMgYV9nZW8xX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfZ2VvMV9jb2xvcjtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9nZW8xX2FuZ3Vsb1JhZDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9nZW8xX29yYml0YWw7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9wb3Nfb3JiaXRhO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfaW5jcl9hbmd1bG9SYWQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9pbmNyO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfZGlyO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfcmFkaW87XFxuXFxudW5pZm9ybSBmbG9hdCB1Q2FtYXJhRGlzdGFuY2U7XFxudW5pZm9ybSBmbG9hdCB1VGltZTtcXG51bmlmb3JtIGZsb2F0IHVPcGVuUHJvZ3Jlc3M7XFxudW5pZm9ybSBmbG9hdCB1UmVzcG9uc2l2ZVNjYWxlO1xcblxcbnVuaWZvcm0gZmxvYXQgdVNjcm9sbERlbHRhO1xcbnVuaWZvcm0gZmxvYXQgdVJvdGF0aW9uMTtcXG51bmlmb3JtIGZsb2F0IHVSb3RhdGlvbjI7XFxudW5pZm9ybSBmbG9hdCB1Um90YXRpb24zO1xcbnVuaWZvcm0gdmVjMyB1RG90Q29sb3I7XFxuLy91bmlmb3JtIGZsb2F0IHVTY2FsZTtcXG5cXG52YXJ5aW5nIHZlYzMgdl9jb2xvcjtcXG52YXJ5aW5nIGZsb2F0IHZfcHVsc2VTdHJlbmd0aE5vcm0xO1xcbnZhcnlpbmcgZmxvYXQgdl9wdWxzZVN0cmVuZ3RoTm9ybTI7XFxuXFxuLy9cXHRDbGFzc2ljIFBlcmxpbiAzRCBOb2lzZSBcXG4vL1xcdGJ5IFN0ZWZhbiBHdXN0YXZzb25cXG4vL1xcblxcbiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM4XFxuLy8jZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NVxcblxcbnZlYzMgZ2V0X3BvczEoZmxvYXQgYW5ndWxvUmFkKXtcXG4gICAgLy9mbG9hdCBhbmd1bG9SYWQgPSBhX2dlbzFfcG9zX29yYml0YSphX2dlbzFfaW5jcl9hbmd1bG9SYWQrKChhX2dlbzFfaW5jcl9hbmd1bG9SYWQvMi4pKmFfZ2VvMV9pbmNyKSsoMS4qYV9nZW8xX2RpciowLjIpO1xcbiAgICBmbG9hdCB4ID0gY29zKGFuZ3Vsb1JhZCkqYV9nZW8xX3JhZGlvO1xcbiAgICBmbG9hdCB5ID0gc2luKGFuZ3Vsb1JhZCkqYV9nZW8xX3JhZGlvO1xcbiAgICBmbG9hdCB6ID0gMC4wO1xcbiAgICB2ZWMzIG5ld1BvcyA9IHZlYzMoeCwgeSwgeik7XFxuICAgIHJldHVybiBuZXdQb3M7XFxufVxcblxcbmZsb2F0IGdldF9vcGVuU2NhbGUoKXtcXG4gICAgcmV0dXJuIG1peCgxLiwgOC4sIHVPcGVuUHJvZ3Jlc3MpO1xcbn1cXG5cXG52ZWMzIGdldF9vcGVuRngoIHZlYzMgcG9zKXtcXG4gICAgLy9mbG9hdCBvcGVuU2NhbGUgPSBtaXgoMS4sIDguLCB1T3BlblByb2dyZXNzKTtcXG4gICAgdmVjMyBwb3NGeCA9IHBvcypnZXRfb3BlblNjYWxlKCk7XFxuICAgIHJldHVybiBwb3NGeDtcXG59XFxuXFxuZmxvYXQgZ2V0X2Nvc1RpbWUoZmxvYXQgdGltZSwgZmxvYXQgcmFkaXVzKXtcXG4gICAgLy9cXG4gICAgLy9mbG9hdCB2YWx1ZSA9IHNpbih1VGltZSkqMi4qUEk7XFxuICAgIGZsb2F0IHZhbHVlID0gc2luKHRpbWUpKnJhZGl1cztcXG4gICAgcmV0dXJuIHZhbHVlO1xcbn1cXG5cXG5mbG9hdCBnZXRfeChmbG9hdCBhbmdsZVJhZCwgZmxvYXQgcmFkaXVzKXtcXG4gICAgcmV0dXJuIGNvcyhhbmdsZVJhZCkqYV9nZW8xX3JhZGlvO1xcbn1cXG5cXG5mbG9hdCBnZXRfcHVsc2VTdHJlbmd0aE5vcm0oIGZsb2F0IGRpcmVjdGlvbil7XFxuICAgIGZsb2F0IGRvdEFndWxlTm9ybSA9IGFfZ2VvMV9hbmd1bG9SYWQvKDIuKlBJKTsgLy8gUGFzYW1vcyBlbCBhbmd1bG8gZGVsIHB1bnRvIHF1ZSBlc3TDoSBlbiByYWRpYW5lcyBhIHVuIHZhbG9yIGRlIDAgYSAxLlxcblxcbiAgICBmbG9hdCBtb2RTcGVlZCA9IG1peCgxLiwgMi41LCAxMy4vYV9nZW8xX29yYml0YWwpKmRpcmVjdGlvbjtcXG4gICAgZmxvYXQgcmFkaWFsU3BlZWQgPSB1VGltZSowLjAyKm1vZFNwZWVkOyAvLyBNb2RpZmljYW1vcyB1VGltZSBwYXJhIGRldGVybWluYXIgbGEgdmVsb2NpZGFkIHJhZGlhbC5cXG5cXG4gICAgZmxvYXQgcHVsc2VBbmdsZVJhZCA9IHJhZGlhbFNwZWVkKig0LipQSSk7XFxuXFxuICAgIC8vIEVsIHZhbG9yIGRlIHB1bHNlQW5nbGVSYWQgZGViZSBlc3RhciBlbnRyZSAwIHkgMlBJIChpbmljaW8geSBmaW4gZGUgdW5hIGNpcmN1bmZlcmVuY2lhKS5cXG4gICAgLy8gQ29tbyBkZXBlbmRlIGRlIHVUaW1lIGVsIHZhbG9yIHNhbGRyw6EgZGUgZXNlIHJhbmdvIHByb250byBwb3IgbG8gcXVlIHRvbWFyZW1vcyBlbCByZXN0byAobW9kdWxvKSxcXG4gICAgLy8gZGUgZGl2aWRpciBwdWxzZUFuZ2xlUmFkIHBvciAyUEkuXFxuICAgIGlmKHB1bHNlQW5nbGVSYWQgPiAyLipQSSl7XFxuICAgICAgICBwdWxzZUFuZ2xlUmFkID0gbW9kKHB1bHNlQW5nbGVSYWQsICgyLipQSSkpO1xcbiAgICB9XFxuICAgIGlmKHB1bHNlQW5nbGVSYWQgPCAwLil7XFxuICAgICAgICBwdWxzZUFuZ2xlUmFkID0gbW9kKHB1bHNlQW5nbGVSYWQsICgyLipQSSkpO1xcbiAgICB9XFxuXFxuICAgIGZsb2F0IHB1bHNlQW5nbGVOb3JtID0gcHVsc2VBbmdsZVJhZC8oMi4qUEkpOyAvLyBOb3JtYWxpemFtb3MgZWwgdmFsb3IgKGRlIDAgYSAxKVxcblxcbiAgICBmbG9hdCBkaXN0QW5nbGVOb3JtID0gYWJzKHB1bHNlQW5nbGVOb3JtLWRvdEFndWxlTm9ybSk7IC8vIENhbGN1bGFtb3MgbGEgZGlzdGFuY2lhIHJhZGlhbCBkZWwgcHVsc28gYWwgcHVudG9cXG5cXG4gICAgLy8gQXBhw7FhbW9zIGxhIGRpc3RhbmNpYSBkZSB0YWwgZm9ybWEgcXVlIG5vIGxlIGFmZWN0ZSBlbCBwdW50byBkZSBkaXNjb250aW51aWRhZCBPUEkgPSAyUElcXG4gICAgaWYoZGlzdEFuZ2xlTm9ybSA+IDAuNSl7IFxcbiAgICAgICAgZGlzdEFuZ2xlTm9ybSA9IDAuNS0oZGlzdEFuZ2xlTm9ybS0wLjUpO1xcbiAgICB9XFxuXFxuICAgIC8vIExhIG1heGltYSBkaXN0YW5jaWEgZXMgZGUgbWVkaW8gY2lyY3VsbyB5IGVuIHRlcm1pbm9zIG5vcm1hbGl6YWRvcyBlcyAwLjVcXG4gICAgLy8gQ3JlYW1vcyB1bmEgdmFyaWFibGUgcXVlIG5vcm1hbGljZSBlc2UgdmFsb3IgZW50cmUgMCB5IDEuXFxuICAgIGZsb2F0IHB1bHNlU3RyZW5ndGhOb3JtICA9IGRpc3RBbmdsZU5vcm0qMi47IFxcblxcbiAgICBmbG9hdCBwaWNvID0gMC45MjtcXG4gICAgcGljbyA9IG1peChwaWNvKjAuOTksIHBpY28qMS4wMSwgYV9nZW8xX29yYml0YWwvMTMuKTtcXG5cXG4gICAgLy8gTm9zIGludGVyZXNhIHNvbG8gZWwgcGljbywgbGEgem9uYSBxdWUgdmEgZW50cmUgMC45NSB5IDEuXFxuICAgIC8vIFRvb2RvIGxvIHF1ZSBoYXlhIHBvciBkZWJham8gZGUgMC45NSBsbyBwYXNhbW9zIGEgMC45NVxcbiAgICAvLyB5IGxlIHJlc3RhbW9zIGVzZSBtaXNtbyAwLjk1IHBhcmEgcXVlZGFybm9zIGNvbiBlbCBwaWNvIGRlIDAuMDUgZW9sIGN1YWwgYW1wbGlmaWNhbW9zIHgyMCBwYXJhIG5vcm1hbGl6YXJsbyAoZGUgMCBhIDEpLlxcbiAgICBwdWxzZVN0cmVuZ3RoTm9ybSA9IChjbGFtcChwdWxzZVN0cmVuZ3RoTm9ybSwgcGljbywgMS4pLXBpY28pKjEwLjtcXG4gICAgLy8tLVxcbiAgICByZXR1cm4gcHVsc2VTdHJlbmd0aE5vcm07XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG5cXG4gICAgLy9mbG9hdCBkaXJlY3Rpb24gPSAxLjtcXG4gICAgLy9pZihhYnMoYV9nZW8xX29yYml0YWwgLSAxMy4pIDwgMC41KXsgLy8gMTMgZXMgZWwgb3JiaXRhbCBkZWwgbWVkaW9cXG4gICAgLy8gICAgZGlyZWN0aW9uID0gLTEuO1xcbiAgICAvL31cXG5cXG4gICAgLy9mbG9hdCBsb25nUGVyaW9kID0gc2luKHVUaW1lKTtcXG4gICAgLy8gbG9uZ1BlcmlvZCA9IGNsYW1wKGxvbmdQZXJpb2QsIDAuLCAxLik7XFxuICAgIC8vIGxvbmdQZXJpb2QgPSAxLjtcXG5cXG4gICAgZmxvYXQgcHVsc2VTdHJlbmd0aE5vcm0xID0gZ2V0X3B1bHNlU3RyZW5ndGhOb3JtKDEuNSk7XFxuICAgIGZsb2F0IHB1bHNlU3RyZW5ndGhOb3JtMiA9IGdldF9wdWxzZVN0cmVuZ3RoTm9ybSgtMS4pO1xcblxcbiAgICBcXG5cXG4gICAgLy8gRGV0ZXJtaW5hbW9zIGVsIHRhbWHDsW8gZGVsIHB1bnRvIHRlbmllbmRvIHVuIG1pbmltbyBkZSA1IHkgYW1wbGlmaWNhbmRvIGVsIG1heGltbyBwYXJhIHF1ZSB2aXN1YWxtZW50ZSBzZWEgYm9uaXRvXFxuICAgIC8vZmxvYXQgc2l6ZSA9IDUuKyhwdWxzZVN0cmVuZ3RoTm9ybSoxNS4qbG9uZ1BlcmlvZCk7XFxuICAgIGZsb2F0IHNpemUgPSAzLjtcXG4gICAgLy9zaXplICs9IChwdWxzZVN0cmVuZ3RoTm9ybTEqNS4pO1xcbiAgICAvL3NpemUgKz0gKHB1bHNlU3RyZW5ndGhOb3JtMio1Lik7XFxuICAgIHNpemUgKj0gdVJlc3BvbnNpdmVTY2FsZTtcXG4gICAgc2l6ZSAqPSBnZXRfb3BlblNjYWxlKCk7XFxuXFxuICAgIGZsb2F0IGFuZ3Vsb1JhZF90aW1lID0gMC47XFxuICAgIGlmKGFicyhhX2dlbzFfb3JiaXRhbC04LikgPCAwLjUpeyAvLyBEZXRlY3RhIGVsIG9yYml0YWwgNlxcbiAgICAgICAgYW5ndWxvUmFkX3RpbWUgPSBhX2dlbzFfYW5ndWxvUmFkK3VSb3RhdGlvbjE7XFxuICAgIH1lbHNlIGlmKGFicyhhX2dlbzFfb3JiaXRhbC0xMy4pIDwgMC41KXsgLy8gRGV0ZWN0YSBlbCBvcmJpdGFsIDExXFxuICAgICAgICBhbmd1bG9SYWRfdGltZSA9IGFfZ2VvMV9hbmd1bG9SYWQrdVJvdGF0aW9uMjtcXG4gICAgfWVsc2UgaWYoYWJzKGFfZ2VvMV9vcmJpdGFsLTE4LikgPCAwLjUpeyAvLyBEZXRlY3RhIGVsIG9yYml0YWwgMTNcXG4gICAgICAgIGFuZ3Vsb1JhZF90aW1lID0gYV9nZW8xX2FuZ3Vsb1JhZCt1Um90YXRpb24zO1xcbiAgICB9XFxuICAgIFxcblxcbiAgICAvL2Zsb2F0IHJvdGF0aW9uU3BlZWQgPSAoYV9nZW8xX29yYml0YWwvMTMuKTtcXG4gICAgLy9mbG9hdCByb3RhdGlvblNwZWVkID0gKDEzLi9hX2dlbzFfb3JiaXRhbCk7XFxuICAgIC8vcm90YXRpb25TcGVlZCAqPSAtdV9zY3JvbGxfZmFjdG9yZERlbHRhO1xcbiAgICAvL2Zsb2F0IGFuZ3Vsb1JhZF90aW1lID0gYV9nZW8xX2FuZ3Vsb1JhZCsocm90YXRpb25TcGVlZCowLjUpKyhkaXJlY3Rpb24qdVRpbWUqMC4yKTtcXG4gICAgdmVjMyBwb3MxID0gZ2V0X3BvczEoYW5ndWxvUmFkX3RpbWUpO1xcbiAgICBwb3MxID0gZ2V0X29wZW5GeChwb3MxKTtcXG4gICAgcG9zMSA9IHBvczEgKnVSZXNwb25zaXZlU2NhbGU7XFxuICAgIC8vcG9zMSA9IHBvczEgKiAoMS4rKHVfc2Nyb2xsX2ZhY3RvcmREZWx0YSowLjIpKTtcXG4gICAgLy92ZWMzIHBvczIgPSBwb3MxKjEuMDtcXG4gICAgLy9wb3MxPSBtaXgocG9zMSwgcG9zMiwgcHVsc2VTdHJlbmd0aE5vcm0pO1xcbiAgICB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3MxLCAxLjAgKTsgXFxuXFxuICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247IC8vPC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIGdsX1BvaW50U2l6ZSA9IHNpemUqKHVDYW1hcmFEaXN0YW5jZS8tbXZQb3NpdGlvbi56KTsgLy88LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgLy8gVkFSWUlOR1M6XFxuICAgIHZfY29sb3IgPSBhX2dlbzFfY29sb3I7IFxcbiAgIC8vdl9wdWxzZVN0cmVuZ3RoTm9ybTEgPSBwdWxzZVN0cmVuZ3RoTm9ybTE7IFxcbiAgICAvL3ZfcHVsc2VTdHJlbmd0aE5vcm0yID0gcHVsc2VTdHJlbmd0aE5vcm0yOyBcXG5cXG59XFxuXFxuLypcXG52ZWMzIGdldF9wb3MxKCl7XFxuICAgIC8vZmxvYXQgYW5ndWxvUmFkID0gYV9nZW8xX3Bvc19vcmJpdGEqYV9nZW8xX2luY3JfYW5ndWxvUmFkKygoYV9nZW8xX2luY3JfYW5ndWxvUmFkLzIuKSphX2dlbzFfaW5jcikrKDEuKmFfZ2VvMV9kaXIqMC4yKTtcXG4gICAgZmxvYXQgeCA9IGNvcyhhX2dlbzFfYW5ndWxvUmFkKSphX2dlbzFfcmFkaW87XFxuICAgIGZsb2F0IHkgPSBzaW4oYV9nZW8xX2FuZ3Vsb1JhZCkqYV9nZW8xX3JhZGlvO1xcbiAgICBmbG9hdCB6ID0gMC4wO1xcbiAgICB2ZWMzIG5ld1BvcyA9IHZlYzMoeCwgeSwgeik7XFxuICAgIHJldHVybiBuZXdQb3M7XFxufVxcblxcbmZsb2F0IGdldF9jb3NUaW1lKGZsb2F0IHRpbWUsIGZsb2F0IHJhZGl1cyl7XFxuICAgIC8vXFxuICAgIC8vZmxvYXQgdmFsdWUgPSBzaW4odVRpbWUpKjIuKlBJO1xcbiAgICBmbG9hdCB2YWx1ZSA9IHNpbih0aW1lKSpyYWRpdXM7XFxuICAgIHJldHVybiB2YWx1ZTtcXG59XFxuXFxuZmxvYXQgZ2V0X3goZmxvYXQgYW5nbGVSYWQsIGZsb2F0IHJhZGl1cyl7XFxuICAgIHJldHVybiBjb3MoYW5nbGVSYWQpKmFfZ2VvMV9yYWRpbztcXG59XFxuXFxuXFxuXFxudm9pZCBtYWluKCkge1xcblxcbiAgICB2ZWMzIHBvczEgPSBnZXRfcG9zMSgpO1xcbiAgICB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3MxLCAxLjAgKTsgXFxuXFxuICAgIGZsb2F0IGRpc3QgPSBkaXN0YW5jZShnZXRfeChhX2dlbzFfYW5ndWxvUmFkLCBhX2dlbzFfcmFkaW8pLCBnZXRfY29zVGltZSh1VGltZSowLjAwNSphX2dlbzFfcmFkaW8sIGFfZ2VvMV9yYWRpbykpO1xcbiAgICBmbG9hdCBzaXplID0gMi4rYWJzKCgoMC4wMDEqYV9nZW8xX3JhZGlvKS1kaXN0KSowLjAyKTtcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjsgLy88LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIGdsX1BvaW50U2l6ZSA9IHNpemUqKHVDYW1hcmFEaXN0YW5jZS8tbXZQb3NpdGlvbi56KTsgLy88LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIHZfY29sb3IgPSBhX2dlbzFfY29sb3I7IFxcblxcbn1cXG5cXG4qLy8qXFxudmVjMyBnZXRfcG9zMSgpe1xcbiAgICAvL2Zsb2F0IGFuZ3Vsb1JhZCA9IGFfZ2VvMV9wb3Nfb3JiaXRhKmFfZ2VvMV9pbmNyX2FuZ3Vsb1JhZCsoKGFfZ2VvMV9pbmNyX2FuZ3Vsb1JhZC8yLikqYV9nZW8xX2luY3IpKygxLiphX2dlbzFfZGlyKjAuMik7XFxuICAgIGZsb2F0IHggPSBjb3MoYV9nZW8xX2FuZ3Vsb1JhZCkqYV9nZW8xX3JhZGlvO1xcbiAgICBmbG9hdCB5ID0gc2luKGFfZ2VvMV9hbmd1bG9SYWQpKmFfZ2VvMV9yYWRpbztcXG4gICAgZmxvYXQgeiA9IDAuMDtcXG4gICAgdmVjMyBuZXdQb3MgPSB2ZWMzKHgsIHksIHopO1xcbiAgICByZXR1cm4gbmV3UG9zO1xcbn1cXG5cXG5mbG9hdCBnZXRfY29zVGltZShmbG9hdCB0aW1lLCBmbG9hdCByYWRpdXMpe1xcbiAgICAvL1xcbiAgICAvL2Zsb2F0IHZhbHVlID0gc2luKHVUaW1lKSoyLipQSTtcXG4gICAgZmxvYXQgdmFsdWUgPSBzaW4odGltZSkqcmFkaXVzO1xcbiAgICByZXR1cm4gdmFsdWU7XFxufVxcblxcbmZsb2F0IGdldF94KGZsb2F0IGFuZ2xlUmFkLCBmbG9hdCByYWRpdXMpe1xcbiAgICByZXR1cm4gY29zKGFuZ2xlUmFkKSphX2dlbzFfcmFkaW87XFxufVxcblxcblxcblxcbnZvaWQgbWFpbigpIHtcXG5cXG4gICAgdmVjMyBwb3MxID0gZ2V0X3BvczEoKTtcXG4gICAgdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zMSwgMS4wICk7IFxcblxcbiAgICBmbG9hdCBkaXN0ID0gZGlzdGFuY2UoZ2V0X3goYV9nZW8xX2FuZ3Vsb1JhZCwgYV9nZW8xX3JhZGlvKSwgZ2V0X2Nvc1RpbWUodVRpbWUqMC4wMDUqYV9nZW8xX3JhZGlvLCBhX2dlbzFfcmFkaW8pKTtcXG4gICAgZmxvYXQgc2l6ZSA9IDIuK2FicygoKDAuMDAxKmFfZ2VvMV9yYWRpbyktZGlzdCkqMC4wMik7XFxuXFxuICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247IC8vPC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICBnbF9Qb2ludFNpemUgPSBzaXplKih1Q2FtYXJhRGlzdGFuY2UvLW12UG9zaXRpb24ueik7IC8vPC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICB2X2NvbG9yID0gYV9nZW8xX2NvbG9yOyBcXG5cXG59XFxuXFxuKi8vKlxcbnZlYzMgZ2V0X3BvczEoKXtcXG4gICAgLy9mbG9hdCBhbmd1bG9SYWQgPSBhX2dlbzFfcG9zX29yYml0YSphX2dlbzFfaW5jcl9hbmd1bG9SYWQrKChhX2dlbzFfaW5jcl9hbmd1bG9SYWQvMi4pKmFfZ2VvMV9pbmNyKSsoMS4qYV9nZW8xX2RpciowLjIpO1xcbiAgICBmbG9hdCB4ID0gY29zKGFfZ2VvMV9hbmd1bG9SYWQpKmFfZ2VvMV9yYWRpbztcXG4gICAgZmxvYXQgeSA9IHNpbihhX2dlbzFfYW5ndWxvUmFkKSphX2dlbzFfcmFkaW87XFxuICAgIGZsb2F0IHogPSAwLjA7XFxuICAgIHZlYzMgbmV3UG9zID0gdmVjMyh4LCB5LCB6KTtcXG4gICAgcmV0dXJuIG5ld1BvcztcXG59XFxuXFxuZmxvYXQgZ2V0X2Nvc1RpbWUoZmxvYXQgdGltZSwgZmxvYXQgcmFkaXVzKXtcXG4gICAgLy9cXG4gICAgLy9mbG9hdCB2YWx1ZSA9IHNpbih1VGltZSkqMi4qUEk7XFxuICAgIGZsb2F0IHZhbHVlID0gc2luKHRpbWUpKnJhZGl1cztcXG4gICAgcmV0dXJuIHZhbHVlO1xcbn1cXG5cXG5mbG9hdCBnZXRfeChmbG9hdCBhbmdsZVJhZCwgZmxvYXQgcmFkaXVzKXtcXG4gICAgcmV0dXJuIGNvcyhhbmdsZVJhZCkqYV9nZW8xX3JhZGlvO1xcbn1cXG5cXG5cXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIHZlYzMgcG9zMSA9IGdldF9wb3MxKCk7XFxuICAgIHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvczEsIDEuMCApOyBcXG5cXG4gICAgZmxvYXQgZGlzdCA9IGRpc3RhbmNlKGdldF94KGFfZ2VvMV9hbmd1bG9SYWQsIGFfZ2VvMV9yYWRpbyksIGdldF9jb3NUaW1lKHVUaW1lKjAuMDA1KmFfZ2VvMV9yYWRpbywgYV9nZW8xX3JhZGlvKSk7XFxuICAgIGZsb2F0IHNpemUgPSAyLithYnMoKCgwLjAwMSphX2dlbzFfcmFkaW8pLWRpc3QpKjAuMDIpO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uOyAvLzwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgZ2xfUG9pbnRTaXplID0gc2l6ZSoodUNhbWFyYURpc3RhbmNlLy1tdlBvc2l0aW9uLnopOyAvLzwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG4gICAgdl9jb2xvciA9IGFfZ2VvMV9jb2xvcjsgXFxuXFxufVxcblxcbiovLypcXG52ZWMzIGdldF9wb3MxKCl7XFxuICAgIC8vZmxvYXQgYW5ndWxvUmFkID0gYV9nZW8xX3Bvc19vcmJpdGEqYV9nZW8xX2luY3JfYW5ndWxvUmFkKygoYV9nZW8xX2luY3JfYW5ndWxvUmFkLzIuKSphX2dlbzFfaW5jcikrKDEuKmFfZ2VvMV9kaXIqMC4yKTtcXG4gICAgZmxvYXQgeCA9IGNvcyhhX2dlbzFfYW5ndWxvUmFkKSphX2dlbzFfcmFkaW87XFxuICAgIGZsb2F0IHkgPSBzaW4oYV9nZW8xX2FuZ3Vsb1JhZCkqYV9nZW8xX3JhZGlvO1xcbiAgICBmbG9hdCB6ID0gMC4wO1xcbiAgICB2ZWMzIG5ld1BvcyA9IHZlYzMoeCwgeSwgeik7XFxuICAgIHJldHVybiBuZXdQb3M7XFxufVxcblxcbmZsb2F0IGdldF9jb3NUaW1lKGZsb2F0IHRpbWUsIGZsb2F0IHJhZGl1cyl7XFxuICAgIC8vXFxuICAgIC8vZmxvYXQgdmFsdWUgPSBzaW4odVRpbWUpKjIuKlBJO1xcbiAgICBmbG9hdCB2YWx1ZSA9IHNpbih0aW1lKSpyYWRpdXM7XFxuICAgIHJldHVybiB2YWx1ZTtcXG59XFxuXFxuZmxvYXQgZ2V0X3goZmxvYXQgYW5nbGVSYWQsIGZsb2F0IHJhZGl1cyl7XFxuICAgIHJldHVybiBjb3MoYW5nbGVSYWQpKmFfZ2VvMV9yYWRpbztcXG59XFxuXFxuXFxuXFxudm9pZCBtYWluKCkge1xcblxcbiAgICB2ZWMzIHBvczEgPSBnZXRfcG9zMSgpO1xcbiAgICB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3MxLCAxLjAgKTsgXFxuXFxuICAgIGZsb2F0IGRpc3QgPSBkaXN0YW5jZShnZXRfeChhX2dlbzFfYW5ndWxvUmFkLCBhX2dlbzFfcmFkaW8pLCBnZXRfY29zVGltZSh1VGltZSowLjAwNSphX2dlbzFfcmFkaW8sIGFfZ2VvMV9yYWRpbykpO1xcbiAgICBmbG9hdCBzaXplID0gMi4rYWJzKCgoMC4wMDEqYV9nZW8xX3JhZGlvKS1kaXN0KSowLjAyKTtcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjsgLy88LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIGdsX1BvaW50U2l6ZSA9IHNpemUqKHVDYW1hcmFEaXN0YW5jZS8tbXZQb3NpdGlvbi56KTsgLy88LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIHZfY29sb3IgPSBhX2dlbzFfY29sb3I7IFxcblxcbn1cXG5cXG4qL1wiOyIsImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBHTFNMSUZZIDFcXG51bmlmb3JtIHZlYzMgdURvdENvbG9yO1xcblxcbnZhcnlpbmcgdmVjMyB2X2NvbG9yO1xcbnZhcnlpbmcgZmxvYXQgdl9wdWxzZVN0cmVuZ3RoTm9ybTE7XFxudmFyeWluZyBmbG9hdCB2X3B1bHNlU3RyZW5ndGhOb3JtMjtcXG5cXG5mbG9hdCBjaXJjdWxpemFyKGZsb2F0IHJhZGlvKXtcXG4gICAgLy8gcmFkaW8gZXMgdW4gdmFsb3IgZW50cmUgMCB5IDEuIDAgZXMgMCBkZSByYWRpbyB5IDEgZXMgZWwgbWF4aW1vIGRlbCByYWRpbyBkZW50cm8gZGVcXG4gICAgcmFkaW8gPSAxLjAtKDAuNSpyYWRpbyk7XFxuICAgIGZsb2F0IHJlc3VsdCA9IGRpc3RhbmNlKGdsX1BvaW50Q29vcmQsIHZlYzIoMC41LCAwLjUpKTtcXG4gICAgcmVzdWx0ID0gMS4gLXJlc3VsdDtcXG4gICAgcmVzdWx0ID0gcG93KHJlc3VsdCwgMS4pO1xcbiAgICByZXN1bHQgPSBzdGVwKHJhZGlvLCByZXN1bHQpO1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGZsb2F0IGFscGhhID0gY2lyY3VsaXphcigxLjApO1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVEb3RDb2xvciwgYWxwaGEpO1xcbn1cIjsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vL2ltcG9ydCAqIGFzIFRIUkVFIGZyb20gXCJ0aHJlZVwiXG4vL2ltcG9ydCBnc2FwIGZyb20gXCJnc2FwXCJcbi8vaW1wb3J0IHtHTFRGTG9hZGVyLCBHTFRMb2FkZXJ9IGZyb20gXCJ0aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9HTFRGTG9hZGVyXCJcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcblxudmFyIEhvbWUyR2VvbWV0cnlfbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoSG9tZTJHZW9tZXRyeV9tLCBfRXZlbnRFbWl0dGVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEhvbWUyR2VvbWV0cnlfbSk7XG5cbiAgZnVuY3Rpb24gSG9tZTJHZW9tZXRyeV9tKG9iaikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIb21lMkdlb21ldHJ5X20pO1xuXG4gICAgLy9jb25zb2xlLmxvZyhcIihIb21lMkdlb21ldHJ5X20uQ09OU1RSVUNUT1JBKSFcIilcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpOyAvLy0tXG5cbiAgICBfdGhpcy5mYWN0b3IgPSBvYmouZmFjdG9yOyAvLzZcblxuICAgIF90aGlzLmluY3JfcmFkaW8gPSBvYmouaW5jcl9yYWRpbzsgLy8yNVxuXG4gICAgX3RoaXMubnVtT3JiaXRzID0gb2JqLm51bU9yYml0czsgLy8zN1xuXG4gICAgX3RoaXMuYXJyYXlfdHJpYW5ndWxhciA9IG9iai5hcnJheV90cmlhbmd1bGFyO1xuICAgIF90aGlzLmFycmF5X2RvdFBvcyA9IG9iai5hcnJheV9kb3RQb3M7XG4gICAgX3RoaXMubnVtRG90cyA9IG9iai5udW1Eb3RzOyAvLy0tXG5cbiAgICBfdGhpcy5hcnJheUNvbG9yZXNfUkdCID0gW107XG4gICAgX3RoaXMuYXJyYXlDb2xvcmVzX1JHQl8wMSA9IFtdO1xuICAgIF90aGlzLmNvbG9yUG9zID0gMDtcblxuICAgIF90aGlzLl9pbml0X2NvbG9ycygpOyAvLy0tXG5cblxuICAgIF90aGlzLmF0dHJpYnV0ZXMgPSB7XG4gICAgICBhX3Bvc2ljaW9uZXM6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDMpLFxuICAgICAgYV9jb2xvcjogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMyksXG4gICAgICBhX29yYml0YWw6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV9wb3Nfb3JiaXRhOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfaW5jcl9hbmd1bG9SYWQ6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV9hbmd1bG9SYWQ6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV9yYWRpbzogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX2RpcjogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX2luY3I6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV94OiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfeTogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX3o6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpXG4gICAgfTsgLy8tLVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5hcnJheV9kb3RQb3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb3RQb3MgPSBfdGhpcy5hcnJheV9kb3RQb3NbaV07XG5cbiAgICAgIHZhciBkb3QgPSBfdGhpcy5fZ2V0X2RvdChkb3RQb3MpO1xuXG4gICAgICB2YXIgaTMgPSBpICogMztcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9wb3NpY2lvbmVzW2kzXSA9IGRvdC54O1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXNbaTMgKyAxXSA9IGRvdC55O1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXNbaTMgKyAyXSA9IGRvdC56OyAvLy0tXG5cbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9jb2xvcltpM10gPSBkb3QuY29sb3JbMF07XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfY29sb3JbaTMgKyAxXSA9IGRvdC5jb2xvclsxXTtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9jb2xvcltpMyArIDJdID0gZG90LmNvbG9yWzJdOyAvLy0tXG5cbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9vcmJpdGFsW2ldID0gZG90Lm9yYml0YWw7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfcG9zX29yYml0YVtpXSA9IGRvdC5wb3Nfb3JiaXRhO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX2luY3JfYW5ndWxvUmFkW2ldID0gZG90LmluY3JfYW5ndWxvUmFkO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX2FuZ3Vsb1JhZFtpXSA9IGRvdC5hbmd1bG9SYWQ7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfcmFkaW9baV0gPSBkb3QucmFkaW87XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfZGlyW2ldID0gZG90LmRpcjtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9pbmNyW2ldID0gZG90LmluY3I7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfeFtpXSA9IGRvdC55O1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3lbaV0gPSBkb3QueTtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV96W2ldID0gZG90Lno7XG4gICAgfSAvLy0tXG5cblxuICAgIF90aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQUklWQURBU1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEhvbWUyR2VvbWV0cnlfbSwgW3tcbiAgICBrZXk6IFwiX2dldF9kb3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9kb3QobnVtKSB7XG4gICAgICAvLyBEZXZ1ZWx2ZSB1biBvYmpldG8gY29uIGxhIGluZm9ybWFjacOzbiBkZSB1biBwdW50byBkZSBsYSBnZW9tZXRyaWEgXCJvcmJpdGFsIE1JT1RJXCJcbiAgICAgIHZhciBvYmogPSB7XG4gICAgICAgIG51bTogbnVtLFxuICAgICAgICBjb2xvcjogdGhpcy5fZ2V0X2NvbG9yKCksXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHo6IDAsXG4gICAgICAgIG9yYml0YWw6IDAsXG4gICAgICAgIGNvX29yYml0YW50ZXM6IDAsXG4gICAgICAgIHBvc19vcmJpdGE6IDAsXG4gICAgICAgIGluY3JfYW5ndWxvUmFkOiAwLFxuICAgICAgICBhbmd1bG9SYWQ6IDAsXG4gICAgICAgIHJhZGlvOiAwXG4gICAgICB9OyAvLy0tXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHRoaXMuYXJyYXlfdHJpYW5ndWxhci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGltU3VwID0gdGhpcy5hcnJheV90cmlhbmd1bGFyW2ldOyAvL2NvbnNvbGUubG9nKFwibGltU3VwOiBcIitsaW1TdXApXG5cbiAgICAgICAgaWYgKG51bSA+IGxpbVN1cCkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiKlwiKVxuICAgICAgICAgIG9iai5vcmJpdGFsID0gaSArIDE7XG4gICAgICAgICAgb2JqLmNvX29yYml0YW50ZXMgPSAoaSArIDEpICogdGhpcy5mYWN0b3I7XG4gICAgICAgICAgb2JqLnBvc19vcmJpdGEgPSBudW0gLSBsaW1TdXAgLSAxO1xuICAgICAgICAgIG9iai5pbmNyX2FuZ3Vsb1JhZCA9IDIgKiBNYXRoLlBJIC8gb2JqLmNvX29yYml0YW50ZXM7XG5cbiAgICAgICAgICBpZiAob2JqLm9yYml0YWwgJSAyID09IDApIHtcbiAgICAgICAgICAgIG9iai5kaXIgPSAxO1xuICAgICAgICAgICAgb2JqLmluY3IgPSAwO1xuICAgICAgICAgICAgb2JqLmFuZ3Vsb1JhZCA9IG9iai5wb3Nfb3JiaXRhICogb2JqLmluY3JfYW5ndWxvUmFkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmouZGlyID0gLTE7XG4gICAgICAgICAgICBvYmouaW5jciA9IDE7XG4gICAgICAgICAgICBvYmouYW5ndWxvUmFkID0gb2JqLnBvc19vcmJpdGEgKiBvYmouaW5jcl9hbmd1bG9SYWQgKyBvYmouaW5jcl9hbmd1bG9SYWQgLyAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9iai5yYWRpbyA9IG9iai5vcmJpdGFsICogdGhpcy5pbmNyX3JhZGlvOyAvLy0tXG5cbiAgICAgICAgICBvYmoueCA9IE1hdGguY29zKG9iai5hbmd1bG9SYWQpICogb2JqLnJhZGlvO1xuICAgICAgICAgIG9iai55ID0gTWF0aC5zaW4ob2JqLmFuZ3Vsb1JhZCkgKiBvYmoucmFkaW87XG4gICAgICAgICAgb2JqLnogPSAwO1xuICAgICAgICB9IC8vYnJlYWtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0X2NvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfY29sb3IoKSB7XG4gICAgICB2YXIgY29sb3JfUkdCXzAxID0gdGhpcy5hcnJheUNvbG9yZXNfUkdCXzAxW3RoaXMuY29sb3JQb3NdO1xuICAgICAgdGhpcy5jb2xvclBvcysrO1xuXG4gICAgICBpZiAodGhpcy5jb2xvclBvcyA+IHRoaXMuYXJyYXlDb2xvcmVzX1JHQl8wMS5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMuY29sb3JQb3MgPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sb3JfUkdCXzAxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdF9jb2xvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRfY29sb3JzKCkge1xuICAgICAgdGhpcy5hcnJheUNvbG9yZXNfUkdCID0gW107XG4gICAgICB0aGlzLmFycmF5Q29sb3Jlc19SR0IucHVzaChbMjU1LCA4NywgMTMxXSk7IC8vIFJvc2FcblxuICAgICAgdGhpcy5hcnJheUNvbG9yZXNfUkdCLnB1c2goWzg5LCAyLCAyXSk7XG4gICAgICB0aGlzLmFycmF5Q29sb3Jlc19SR0IucHVzaChbMSwgMywgNDldKTtcbiAgICAgIHRoaXMuYXJyYXlDb2xvcmVzX1JHQi5wdXNoKFswLCAxNiwgMTE2XSk7XG4gICAgICB0aGlzLmFycmF5Q29sb3Jlc19SR0IucHVzaChbMTQsIDEzMywgMjU1XSk7XG4gICAgICB0aGlzLmFycmF5Q29sb3Jlc19SR0JfMDEgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFycmF5Q29sb3Jlc19SR0IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbG9yX1JHQiA9IHRoaXMuYXJyYXlDb2xvcmVzX1JHQltpXTtcbiAgICAgICAgdmFyIGNvbG9yX1JHQl8wMSA9IFtjb2xvcl9SR0JbMF0gLyAyNTUsIGNvbG9yX1JHQlsxXSAvIDI1NSwgY29sb3JfUkdCWzJdIC8gMjU1XTtcbiAgICAgICAgdGhpcy5hcnJheUNvbG9yZXNfUkdCXzAxLnB1c2goY29sb3JfUkdCXzAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSG9tZTJHZW9tZXRyeV9tO1xufShFdmVudEVtaXR0ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBIb21lMkdlb21ldHJ5X207IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tIFwidGhyZWVcIjsgLy9pbXBvcnQgZ3NhcCBmcm9tIFwiZ3NhcFwiXG5cbmltcG9ydCB2ZXJ0ZXggZnJvbSBcIi4vc2hhZGVycy9ob21lMl9kb3RzX3ZlcnRleF9tLmdsc2xcIjtcbmltcG9ydCBmcmFnbWVudCBmcm9tIFwiLi9zaGFkZXJzL2hvbWUyX2RvdHNfZnJhZ21lbnRfbS5nbHNsXCI7XG5pbXBvcnQgRWFzZWRPdXRWYWx1ZSBmcm9tICcuLi9FYXNlZE91dFZhbHVlJztcbmltcG9ydCBIb21lMkdlb21ldHJ5X20gZnJvbSAnLi9Ib21lMkdlb21ldHJ5X20nO1xuXG52YXIgSG9tZTFEb3RzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSG9tZTFEb3RzKG9iaikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIb21lMURvdHMpO1xuXG4gICAgLy9jb25zb2xlLmxvZyhcIihIb21lMURvdHMuQ09OU1RSVUNUT1JBKSFcIilcbiAgICAvL2NvbnNvbGUubG9nKG9iailcbiAgICB0aGlzLmFwcCA9IG9iai5hcHA7IC8vLS1cblxuICAgIHRoaXMuc2NlbmUgPSB0aGlzLmFwcC5zY2VuZTtcbiAgICB0aGlzLmNhbWVyYURpc3RhbmNlID0gdGhpcy5hcHAuY2FtZXJhRGlzdGFuY2U7IC8vLS1cblxuICAgIHRoaXMubWF0ZXJpYWwgPSBudWxsO1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBudWxsO1xuICAgIHRoaXMubWVzaCA9IG51bGw7XG4gICAgdGhpcy5jcmVhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5jbG9jayA9IG5ldyBUSFJFRS5DbG9jaygpOyAvLy0tXG4gICAgLy90aGlzLmVhc2VkX3Njcm9sbERlbHRhX2Zhc3QgPSBuZXcgRWFzZWRPdXRWYWx1ZSh0aGlzLmFwcC5zY3JvbGxEYXRhLm5vcm1hbGl6ZWREZWx0YSowLjUsIDAuMSlcbiAgICAvLy0tXG5cbiAgICB0aGlzLl9zZXR1cF9zZXR0aW5ncygpOyAvLy0tXG5cblxuICAgIHRoaXMub3JiaXRhbF9nZW9tZXRyeSA9IG5ldyBIb21lMkdlb21ldHJ5X20odGhpcy5zZXR0aW5ncyk7IC8vLS1cbiAgICAvL3RoaXMuX2NyZWF0ZSgpXG4gIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUFVCTElDQVM6IFxuXG5cbiAgX2NyZWF0ZUNsYXNzKEhvbWUxRG90cywgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5lYXNlZF9zY3JvbGxEZWx0YV9mYXN0ID0gbmV3IEVhc2VkT3V0VmFsdWUodGhpcy5hcHAuc2Nyb2xsRGF0YS5ub3JtYWxpemVkRGVsdGEgKiAwLjUsIDAuMSk7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZSgpO1xuICAgIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICBpZiAodGhpcy5jcmVhdGVkKSB7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVRpbWUudmFsdWUgPSB0aGlzLmNsb2NrLmdldEVsYXBzZWRUaW1lKCk7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudUNhbWFyYURpc3RhbmNlLnZhbHVlID0gdGhpcy5hcHAuY2FtZXJhRGlzdGFuY2U7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudU9wZW5Qcm9ncmVzcy52YWx1ZSA9IHRoaXMuc2V0dGluZ3Mub3BlblByb2dyZXNzO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVSZXNwb25zaXZlU2NhbGUudmFsdWUgPSB0aGlzLmFwcC5yZXNwb25zaXZlU2NhbGU7IC8vdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51X3Njcm9sbF9mYWN0b3JkRGVsdGEudmFsdWUgPSB0aGlzLmFwcC5zY3JvbGxEYXRhLmZhY3RvcmREZWx0YVxuICAgICAgICAvL3RoaXMubWF0ZXJpYWwudW5pZm9ybXMudV9zY3JvbGxfZGlyZWN0aW9uLnZhbHVlID0gdGhpcy5hcHAuc2Nyb2xsRGF0YS5kaXJlY3Rpb25cblxuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVTY3JvbGxEZWx0YS52YWx1ZSA9IC10aGlzLmVhc2VkX3Njcm9sbERlbHRhX2Zhc3QuZ2V0KHRoaXMuYXBwLnNjcm9sbERhdGEubm9ybWFsaXplZERlbHRhICogMC41KTsgLy8tLVxuXG4gICAgICAgIHZhciBleHRyYVNwZWVkID0gMSArIE1hdGguYWJzKHRoaXMuZWFzZWRfc2Nyb2xsRGVsdGFfZmFzdC5nZXQodGhpcy5hcHAuc2Nyb2xsRGF0YS5ub3JtYWxpemVkRGVsdGEgKiAwLjUpICogMTApO1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJvdGF0aW9uMSArPSB0aGlzLnNldHRpbmdzLnNwZWVkUm90YXRpb24xICogZXh0cmFTcGVlZDtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5yb3RhdGlvbjIgKz0gdGhpcy5zZXR0aW5ncy5zcGVlZFJvdGF0aW9uMiAqIGV4dHJhU3BlZWQ7XG4gICAgICAgIHRoaXMuc2V0dGluZ3Mucm90YXRpb24zICs9IHRoaXMuc2V0dGluZ3Muc3BlZWRSb3RhdGlvbjMgKiBleHRyYVNwZWVkO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVSb3RhdGlvbjEudmFsdWUgPSB0aGlzLnNldHRpbmdzLnJvdGF0aW9uMTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Um90YXRpb24yLnZhbHVlID0gLXRoaXMuc2V0dGluZ3Mucm90YXRpb24yO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVSb3RhdGlvbjMudmFsdWUgPSB0aGlzLnNldHRpbmdzLnJvdGF0aW9uMzsgLy9jb25zb2xlLmxvZyh0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVSb3RhdGlvbjEudmFsdWUpXG4gICAgICB9XG4gICAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFBVQkxJQ0FTOlxuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7Ly9jb25zb2xlLmxvZyhcIihHcmFkaWVudEJhY2tncm91bmQucmVzaXplKSFcIilcbiAgICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUFJJVkFEQVM6IFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldHVwX3NldHRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cF9zZXR0aW5ncygpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTFEb3RzLl9zZXR1cF9zZXR0aW5ncykhIVwiKVxuICAgICAgdmFyIHNwZWVkQmFzZSA9IDAuMDAyO1xuICAgICAgdGhpcy5zZXR0aW5ncyA9IHtcbiAgICAgICAgZmFjdG9yOiA2LFxuICAgICAgICAvL2luY3JfcmFkaW86IDI1LFxuICAgICAgICAvL2luY3JfcmFkaW86IDEzLjIsXG4gICAgICAgIGluY3JfcmFkaW86IHRoaXMuYXBwLmluY3JfcmFkaW8sXG4gICAgICAgIG51bU9yYml0czogMTksXG4gICAgICAgIC8vYXJyYXlPcmJpdHM6IFs1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgIDE3LCAxOCwgMTldLFxuICAgICAgICBhcnJheU9yYml0czogWzgsIDEzLCAxOF0sXG4gICAgICAgIC8vYXJyYXlPcmJpdHM6IFsxLCAzLCA0LCA1XSxcbiAgICAgICAgLy8gT3J0Yml0IHJvdGF0aW9uXG4gICAgICAgIHJvdGF0aW9uMTogMCxcbiAgICAgICAgc3BlZWRSb3RhdGlvbjE6IDMgKiBzcGVlZEJhc2UsXG4gICAgICAgIHJvdGF0aW9uMjogMixcbiAgICAgICAgc3BlZWRSb3RhdGlvbjI6IDIgKiBzcGVlZEJhc2UsXG4gICAgICAgIHJvdGF0aW9uMzogMCxcbiAgICAgICAgc3BlZWRSb3RhdGlvbjM6IDEgKiBzcGVlZEJhc2VcbiAgICAgIH07XG4gICAgICB0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXIgPSB0aGlzLl9nZXRfYXJyYXlfdHJpYW5ndWxhcih0aGlzLnNldHRpbmdzLmZhY3RvciwgdGhpcy5zZXR0aW5ncy5udW1PcmJpdHMpO1xuICAgICAgdGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEgPSB0aGlzLl9nZXRfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhKHRoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhciwgdGhpcy5zZXR0aW5ncy5hcnJheU9yYml0cyk7XG4gICAgICB0aGlzLnNldHRpbmdzLmFycmF5X2RvdFBvcyA9IHRoaXMuX2dldF9hcnJheV9kb3RQb3ModGhpcy5zZXR0aW5ncy5hcnJheU9yYml0cywgdGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyLCB0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YSk7XG4gICAgICB0aGlzLnNldHRpbmdzLm51bURvdHMgPSB0aGlzLnNldHRpbmdzLmFycmF5X2RvdFBvcy5sZW5ndGg7XG4gICAgICB0aGlzLnNldHRpbmdzLm9wZW5Qcm9ncmVzcyA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTFEb3RzLl9jcmVhdGUpIVwiKVxuICAgICAgLy8tLVxuICAgICAgdGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7XG4gICAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgICAvL2JsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nLFxuICAgICAgICB2ZXJ0ZXhDb2xvcnM6IHRydWUsXG4gICAgICAgIHZlcnRleFNoYWRlcjogdmVydGV4LFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogZnJhZ21lbnQsXG4gICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIHVDYW1hcmFEaXN0YW5jZToge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMuYXBwLmNhbWVyYURpc3RhbmNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1RG90Q29sb3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmFwcC5kb3RDb2xvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVRpbWU6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICAvL3VTY2FsZTp7dmFsdWU6IDF9LFxuICAgICAgICAgIHVPcGVuUHJvZ3Jlc3M6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UmVzcG9uc2l2ZVNjYWxlOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy91X3Njcm9sbF9mYWN0b3JkRGVsdGE6IHt2YWx1ZTogMX0sXG4gICAgICAgICAgLy91X3Njcm9sbF9kaXJlY3Rpb246IHt2YWx1ZTogMX0sXG4gICAgICAgICAgdVNjcm9sbERlbHRhOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVJvdGF0aW9uMToge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVSb3RhdGlvbjI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Um90YXRpb24zOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7IC8vLS1cbiAgICAgIC8vY29uc29sZS5sb2codGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9jb2xvcilcbiAgICAgIC8vLS1cblxuICAgICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXMsIDMpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfcG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfcG9zaWNpb25lcywgMykpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9jb2xvcicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9jb2xvciwgMykpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9vcmJpdGFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX29yYml0YWwsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfcG9zX29yYml0YScsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9wb3Nfb3JiaXRhLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX2luY3JfYW5ndWxvUmFkJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX2luY3JfYW5ndWxvUmFkLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX2FuZ3Vsb1JhZCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9hbmd1bG9SYWQsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfcmFkaW8nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfcmFkaW8sIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfZGlyJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX2RpciwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9pbmNyJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX2luY3IsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfeCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV94LCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX3knLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfeSwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV96JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3osIDEpKTtcbiAgICAgIHRoaXMubWVzaCA9IG5ldyBUSFJFRS5Qb2ludHModGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCk7XG4gICAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLm1lc2gpO1xuICAgICAgdGhpcy5jcmVhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldF9hcnJheV9kb3RQb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9hcnJheV9kb3RQb3MoX2FycmF5T3JiaXRzLCBfYXJyYXlfdHJpYW5ndWxhciwgX2FycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YSkge1xuICAgICAgdmFyIG1pQXJyYXkgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYXJyYXlPcmJpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9yYml0TnVtID0gX2FycmF5T3JiaXRzW2ldO1xuICAgICAgICB2YXIgZG90c194X29yYml0ID0gX2FycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YVtpXTtcbiAgICAgICAgdmFyIGRvdE51bV9iYXNlID0gX2FycmF5X3RyaWFuZ3VsYXJbX2FycmF5T3JiaXRzW2ldIC0gMV07IC8vIGNvbnNvbGUubG9nKFwib3JiaXROdW06IFwiK29yYml0TnVtKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImRvdHNfeF9vcmJpdDogXCIrZG90c194X29yYml0KVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImRvdE51bV9iYXNlOiBcIitkb3ROdW1fYmFzZSlcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvdHNfeF9vcmJpdDsgaisrKSB7XG4gICAgICAgICAgbWlBcnJheS5wdXNoKGRvdE51bV9iYXNlICsgaiArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaUFycmF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0X251bURvdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9udW1Eb3RzKF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEpIHtcbiAgICAgIHZhciBudW1Eb3RzID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gX2FycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbnVtRG90cyArPSBfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVtRG90cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEoX2FycmF5X3RyaWFuZ3VsYXIsIF9hcnJheU9yYml0cykge1xuICAgICAgLy8gR2VuZXJhIHVuYSBhcnJheSBiYXNhZGEgZW4gbGEgcHJvZ3Jlc2nDs24gdHJpYW5ndWxhciAoKiBmYWN0b3IpLlxuICAgICAgLy8gLi4uIGRvbmRlIHNlIGluZGljYSBlbCBudW1lcm8gZGUgZG90cyBwb3Igb3JiaXRhbFxuICAgICAgLy8gVW5hIHByb2dyZXNpw7NuIHRyaWFuZ3VsYXIgZXM6IDEsIDMsIDYsIDEwLCAxNSAoaHR0cHM6Ly9zaWduaWZpY2F0aXZhLm9yZy9kaWNjaW9uYXJpb3MvbnVtZXJvcy1maWd1cmFkb3MvIzp+OnRleHQ9My4xLjEuMS4tLERlZmluaWNpJUMzJUIzbixhbnRlcmlvciUyMG5vJTIwb2J0ZW5lbW9zJTIwdW5hJTIwY29uc3RhbnRlLilcbiAgICAgIHZhciBtaUFycmF5ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IF9hcnJheU9yYml0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgLy9hcnJheV9udW1UcmlhZ3VsYXJlcy5wdXNoKGkqKGkrMSkvMilcbiAgICAgICAgdmFyIG51bURvdHNfb3JiaXRhX2FjdHVhbCA9IF9hcnJheV90cmlhbmd1bGFyW19hcnJheU9yYml0c1tpXV07XG4gICAgICAgIHZhciBudW1Eb3RzX29yYml0YV9hbnRlcmlvciA9IF9hcnJheV90cmlhbmd1bGFyW19hcnJheU9yYml0c1tpXSAtIDFdO1xuICAgICAgICB2YXIgbnVtRG90c19vcmJpdGEgPSBudW1Eb3RzX29yYml0YV9hY3R1YWwgLSBudW1Eb3RzX29yYml0YV9hbnRlcmlvcjtcbiAgICAgICAgbWlBcnJheS5wdXNoKG51bURvdHNfb3JiaXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1pQXJyYXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRfYXJyYXlfdHJpYW5ndWxhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0X2FycmF5X3RyaWFuZ3VsYXIoX2ZhY3RvciwgX251bU9iaXRzKSB7XG4gICAgICAvLyBHZW5lcmEgdW5hIGFycmF5IGRlIHByb2dyZXNpw7NuIHRyaWFuZ3VsYXIgKCogZmFjdG9yKS5cbiAgICAgIC8vIFVuYSBwcm9ncmVzacOzbiB0cmlhbmd1bGFyIGVzOiAxLCAzLCA2LCAxMCwgMTUgKGh0dHBzOi8vc2lnbmlmaWNhdGl2YS5vcmcvZGljY2lvbmFyaW9zL251bWVyb3MtZmlndXJhZG9zLyM6fjp0ZXh0PTMuMS4xLjEuLSxEZWZpbmljaSVDMyVCM24sYW50ZXJpb3IlMjBubyUyMG9idGVuZW1vcyUyMHVuYSUyMGNvbnN0YW50ZS4pXG4gICAgICB2YXIgbWlBcnJheSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBfbnVtT2JpdHM7IGkrKykge1xuICAgICAgICAvL2FycmF5X251bVRyaWFndWxhcmVzLnB1c2goaSooaSsxKS8yKVxuICAgICAgICBtaUFycmF5LnB1c2goaSAqIChpICsgMSkgLyAyICogX2ZhY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaUFycmF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0dXBfZ3VpXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cF9ndWkoKSB7Ly9jb25zb2xlLmxvZyhcIihIb21lMURvdHMuX3NldHVwX2d1aSkhXCIpXG4gICAgICAvLyB0aGlzLmd1aSA9IG5ldyBkYXQuR1VJKCk7XG4gICAgICAvLyB0aGlzLmd1aS53aWR0aCA9IDQwMFxuICAgICAgLy8gY29uc3QgZm9sZGVyMCA9IHRoaXMuZ3VpLmFkZEZvbGRlcihcIk9yYml0IHNwaW5uaW5nXCIpXG4gICAgICAvLyBmb2xkZXIwLmFkZCh0aGlzLnNldHRpbmdzLCBcInByb2dyZXNzNVwiLCAwLCAxMCwgMC4wMSkubmFtZShcIlByb2dyZXNzXCIpXG4gICAgICAvLyBmb2xkZXIwLm9wZW4oKVxuICAgIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIH1dKTtcblxuICByZXR1cm4gSG9tZTFEb3RzO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBIb21lMURvdHM7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgZ3NhcCBmcm9tICdnc2FwJztcbmltcG9ydCBTY3JvbGxUcmlnZ2VyIGZyb20gJ2dzYXAvU2Nyb2xsVHJpZ2dlcic7XG5pbXBvcnQgSG9tZTJTY3JvbGxfbSBmcm9tICcuL0hvbWUyU2Nyb2xsX20nOyAvLy0tXG5cbmltcG9ydCBIb21lMkRvdHNfbSBmcm9tICcuL0hvbWUyRG90c19tJztcblxudmFyIEhvbWUyQXBwX20gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIb21lMkFwcF9tKG9iaikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIb21lMkFwcF9tKTtcblxuICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTJBcHBfbS5DT05TVFJVQ1RPUkEpISFcIiwgb2JqKSBcbiAgICB0aGlzLmh3X3JlbmRlcmVyID0gb2JqLnJlbmRlcmVyOyAvLyBSZWRlcmVyL3BhZ2luYSBkZSBIaWdoV2F5LiBObyBjb25mdW5kaXIgY29uIGVsIHJlbmRlci9yZW5kZXJlciBkZSBUaHJlZS5qc1xuXG4gICAgdGhpcy4kY29udGFpbmVyID0gb2JqLmRvbUVsZW1lbnQ7XG4gICAgdGhpcy5kb3RDb2xvciA9IG5ldyBUSFJFRS5Db2xvcihvYmouZG90Q29sb3IpO1xuICAgIHRoaXMuaW5jcl9yYWRpbyA9IG9iai5pbmNyX3JhZGlvOyAvLy0tXG5cbiAgICB0aGlzLiRpbm5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbm5lcicpOyAvLy0tXG5cbiAgICB0aGlzLlJFRl9SRVNPTFVUSU9OID0ge1xuICAgICAgd2lkdGg6IDQ4MCxcbiAgICAgIGhlaWdodDogNDgwXG4gICAgfTtcbiAgICB0aGlzLlJFRl9DQU1FUkFfRElTVEFOQ0UgPSA1MDA7IC8vLS1cblxuICAgIHRoaXMud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy5yZXNwb25zaXZlU2NhbGU7XG4gICAgdGhpcy5jYW1lcmFEaXN0YW5jZTsgLy8tLVxuICAgIC8vLS1cbiAgICAvL3RoaXMuc2Nyb2xsRGF0YSA9IG5ldyBIb21lMlNjcm9sbF9tKHtcbiAgICAvLyAgICBhcHA6dGhpcyxcbiAgICAvLyAgICAkaW5uZXI6IHRoaXMuJGlubmVyXG4gICAgLy99KVxuICAgIC8vLS1cblxuICAgIHRoaXMuX3VwZGF0ZV9kaW1lbnNpb25zKCk7IC8vLS1cbiAgICAvLyBTY2VuZVxuXG5cbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7IC8vdGhpcy5zY2VuZS5iYWNrZ3JvdW5kID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwZmYwMCApO1xuICAgIC8vLS1cbiAgICAvLyBjb25zb2xlLmxvZyhcInRoaXMud2lkdGg6IFwiK3RoaXMud2lkdGgpXG4gICAgLy8gY29uc29sZS5sb2coXCJ0aGlzLmhlaWdodDogXCIrdGhpcy5oZWlnaHQpXG4gICAgLy8gY29uc29sZS5sb2coXCJ0aGlzLmNhbWVyYURpc3RhbmNlOiBcIit0aGlzLmNhbWVyYURpc3RhbmNlKVxuICAgIC8vLS1cbiAgICAvLyBDYW1lcmFcbiAgICAvL1BlcnNwZWN0aXZlQ2FtZXJhKCBmb3YgOiBOdW1iZXIsIGFzcGVjdCA6IE51bWJlciwgbmVhciA6IE51bWJlciwgZmFyIDogTnVtYmVyIClcblxuICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDMwLCB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQsIDAuMSwgMjAwMCk7XG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueiA9IHRoaXMuY2FtZXJhRGlzdGFuY2U7XG4gICAgdGhpcy5jYW1lcmEuZm92ID0gMiAqIE1hdGguYXRhbih0aGlzLmhlaWdodCAvIDIgLyB0aGlzLmNhbWVyYURpc3RhbmNlKSAqICgxODAgLyBNYXRoLlBJKTsgLy8tLVxuICAgIC8vIFJlbmRlcmVyXG4gICAgLy8tLVxuXG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTDFSZW5kZXJlcih7XG4gICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICBhbHBoYTogdHJ1ZVxuICAgIH0pOyAvL3RoaXMucmVuZGVyZXIuYXV0b0NsZWFyID0gZmFsc2UgLy8gVmFtb3MgYSB1c2FyIDIgc2NlbmFzICh1bmEgcGFyYSBlbCBiYWNrZ3JvdW5kIHkgb3RyYSBwYXJhIGxvcyBwdW50b3MpIHF1ZSBpbXBsaWNhcsOhbiB1c2FyIDIgYWNjaW9uZXMgZGUgcmVuZGVyLiBDb24gYXV0b2NsZWFyIGZhbHNlIHBlcm1pdGltb3MgcXVlIGxhIHNlZ3VuZGEgbm8gYm9ycmUgbGEgcHJpbWVyYS5cblxuICAgIHRoaXMucmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyhNYXRoLm1pbih3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgMSkpOyAvL3RoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvckhleCggMHhmZjAwMDAsIDEgKTtcbiAgICAvLy0tXG5cbiAgICB0aGlzLiRjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTsgLy8tLVxuXG4gICAgdGhpcy5kb3RzID0gbmV3IEhvbWUyRG90c19tKHtcbiAgICAgIGFwcDogdGhpc1xuICAgIH0pOyAvLy0tXG4gICAgLy90aGlzLl9jcmVhdGVjdWJlKHRoaXMuc2NlbmUpXG5cbiAgICB0aGlzLl9yZXNpemUoKTsgLy90aGlzLl9yZW5kZXIoKTtcblxuICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFBVQkxJQ0FTOlxuXG5cbiAgX2NyZWF0ZUNsYXNzKEhvbWUyQXBwX20sIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuJGlubmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmlubmVyJyk7XG4gICAgICB0aGlzLnNjcm9sbERhdGEgPSBuZXcgSG9tZTJTY3JvbGxfbSh7XG4gICAgICAgIGFwcDogdGhpcyxcbiAgICAgICAgJGlubmVyOiB0aGlzLiRpbm5lclxuICAgICAgfSk7IC8vLS1cblxuICAgICAgdGhpcy5kb3RzLmluaXQoKTsgLy8tLVxuXG4gICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwia2lsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgdGhpcy5zY3JvbGxEYXRhLmtpbGwoKTtcbiAgICAgIHRoaXMuc2Nyb2xsRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLmRvdHMgPSBudWxsO1xuICAgIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWUyQXBwX20ucmVuZGVyKSFcIilcbiAgICAgIHRoaXMuX3JlbmRlcigpOyAvLyBMbyBsbGFtYSBzY3JvbGxEYXRhXG5cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoSG9tZTJBcHBfbS5yZXNpemUpIVwiKVxuICAgICAgdGhpcy5fcmVzaXplKCk7XG4gICAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFBSSVZBREFTOlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZV9kaW1lbnNpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVfZGltZW5zaW9ucygpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiKEhvbWUyQXBwX20uX3VwZGF0ZV9kaW1lbnNpb25zKSFcIiwgdGhpcy5yZW5kZXJlcilcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLiRjb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuJGNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICB0aGlzLnJlc3BvbnNpdmVTY2FsZSA9IHRoaXMud2lkdGggLyB0aGlzLlJFRl9SRVNPTFVUSU9OLndpZHRoO1xuICAgICAgdGhpcy5jYW1lcmFEaXN0YW5jZSA9IHRoaXMuUkVGX0NBTUVSQV9ESVNUQU5DRSAqIHRoaXMucmVzcG9uc2l2ZVNjYWxlOyAvLy0tXG5cbiAgICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7IC8vLS1cblxuICAgICAgICB0aGlzLmNhbWVyYS5hc3BlY3QgPSB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FtZXJhRGlzdGFuY2UgPSB0aGlzLmNhbWVyYS5wb3NpdGlvbi56O1xuICAgICAgICB0aGlzLmNhbWVyYS5mb3YgPSAyICogTWF0aC5hdGFuKHRoaXMuaGVpZ2h0IC8gMiAvIHRoaXMuY2FtZXJhRGlzdGFuY2UpICogKDE4MCAvIE1hdGguUEkpO1xuICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICB9IC8vLS1cblxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNpemUoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWUyQXBwX20uX3Jlc2l6ZSkhIVwiKVxuICAgICAgdGhpcy5fdXBkYXRlX2RpbWVuc2lvbnMoKTsgLy8tLVxuXG5cbiAgICAgIGlmICh0aGlzLmRvdHMpIHsvL3RoaXMuZG90cy5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXIoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEhvbWUyQXBwX20uX3JlbmRlcikhXCIpXG4gICAgICBpZiAodGhpcy5oZWlnaHQgIT0gdGhpcy4kY29udGFpbmVyLm9mZnNldEhlaWdodCB8fCB0aGlzLndpZHRoICE9IHRoaXMuJGNvbnRhaW5lci5vZmZzZXRXaWR0aCkge1xuICAgICAgICB0aGlzLl9yZXNpemUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZG90cykge1xuICAgICAgICB0aGlzLmRvdHMucmVuZGVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZWN1YmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZWN1YmUoX3NjZW5lKSB7XG4gICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMTAwLCAxMDAsIDEwMCk7XG4gICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICBjb2xvcjogMHhmZjAwMDBcbiAgICAgIH0pO1xuICAgICAgdmFyIGN1YmUgPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpOyAvL2N1YmUucG9zaXRpb24uc2V0KDEwMCwgMTAwLCAxMDApXG5cbiAgICAgIF9zY2VuZS5hZGQoY3ViZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhvbWUyQXBwX207XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IEhvbWUyQXBwX207IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKiFcbiAqIFZlbG9jaXR5VHJhY2tlcjogMy42LjFcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgZ3NhcCxcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX3RvQXJyYXksXG4gICAgX2dldFVuaXQsXG4gICAgX2ZpcnN0LFxuICAgIF90aWNrZXIsXG4gICAgX3RpbWUxLFxuICAgIF90aW1lMixcbiAgICBfZ2V0Q2FjaGUsXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKTtcbn0sXG4gICAgX2xvb2t1cCA9IHt9LFxuICAgIF9yb3VuZCA9IGZ1bmN0aW9uIF9yb3VuZCh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwKSAvIDEwMDAwO1xufSxcbiAgICBfZ2V0SUQgPSBmdW5jdGlvbiBfZ2V0SUQodGFyZ2V0KSB7XG4gIHJldHVybiBfZ2V0Q2FjaGUodGFyZ2V0KS5pZDtcbn0sXG4gICAgX2dldEJ5VGFyZ2V0ID0gZnVuY3Rpb24gX2dldEJ5VGFyZ2V0KHRhcmdldCkge1xuICByZXR1cm4gX2xvb2t1cFtfZ2V0SUQodHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIiA/IF90b0FycmF5KHRhcmdldClbMF0gOiB0YXJnZXQpXTtcbn0sXG4gICAgX29uVGljayA9IGZ1bmN0aW9uIF9vblRpY2sodGltZSkge1xuICB2YXIgcHQgPSBfZmlyc3QsXG4gICAgICB2YWw7IC8vaWYgdGhlIGZyYW1lIHJhdGUgaXMgdG9vIGhpZ2gsIHdlIHdvbid0IGJlIGFibGUgdG8gdHJhY2sgdGhlIHZlbG9jaXR5IGFzIHdlbGwsIHNvIG9ubHkgdXBkYXRlIHRoZSB2YWx1ZXMgYWJvdXQgMjAgdGltZXMgcGVyIHNlY29uZFxuXG4gIGlmICh0aW1lIC0gX3RpbWUxID49IDAuMDUpIHtcbiAgICBfdGltZTIgPSBfdGltZTE7XG4gICAgX3RpbWUxID0gdGltZTtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgdmFsID0gcHQuZyhwdC50LCBwdC5wKTtcblxuICAgICAgaWYgKHZhbCAhPT0gcHQudjEgfHwgdGltZSAtIHB0LnQxID4gMC4yKSB7XG4gICAgICAgIC8vdXNlIGEgdGhyZXNob2xkIG9mIDAuMiBzZWNvbmRzIGZvciB6ZXJvaW5nLW91dCB2ZWxvY2l0eS4gSWYgd2Ugb25seSB1c2UgMC4wNSBhbmQgdGhpbmdzIHVwZGF0ZSBzbGlnaHRseSBzbG93ZXIsIGxpa2Ugc29tZSBBbmRyb2lkIGRldmljZXMgZGlzcGF0Y2ggXCJ0b3VjaG1vdmVcIiBldmVudHMgc2x1Z2dpc2hseSBzbyAyIG9yIDMgdGlja3Mgb2YgdGhlIGdzYXAudGlja2VyIG1heSBlbGFwc2UgaW5iZXR3ZWVuLCB0aHVzIGl0IG1heSBhcHBlYXIgbGlrZSB0aGUgb2JqZWN0IGlzIG5vdCBtb3ZpbmcgYnV0IGl0IGFjdHVhbGx5IGlzIGJ1dCBpdCdzIG5vdCB1cGRhdGluZyBhcyBmcmVxdWVudGx5LiBBIHRocmVzaG9sZCBvZiAwLjIgc2Vjb25kcyBzZWVtcyB0byBiZSBhIGdvb2QgYmFsYW5jZS4gV2Ugd2FudCB0byB1cGRhdGUgdGhpbmdzIGZyZXF1ZW50bHkgKDAuMDUgc2Vjb25kcykgd2hlbiB0aGV5J3JlIG1vdmluZyBzbyB0aGF0IHdlIGNhbiByZXNwb25kIHRvIGZhc3QgbW90aW9ucyBhY2N1cmF0ZWx5LCBidXQgd2Ugd2FudCB0byBiZSBtb3JlIHJlc2lzdGFudCB0byBnbyBiYWNrIHRvIGEgemVybyB2ZWxvY2l0eS5cbiAgICAgICAgcHQudjIgPSBwdC52MTtcbiAgICAgICAgcHQudjEgPSB2YWw7XG4gICAgICAgIHB0LnQyID0gcHQudDE7XG4gICAgICAgIHB0LnQxID0gdGltZTtcbiAgICAgIH1cblxuICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICB9XG4gIH1cbn0sXG4gICAgX3R5cGVzID0ge1xuICBkZWc6IDM2MCxcbiAgcmFkOiBNYXRoLlBJICogMlxufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoKSB7XG4gIGdzYXAgPSBfZ2V0R1NBUCgpO1xuXG4gIGlmIChnc2FwKSB7XG4gICAgX3RvQXJyYXkgPSBnc2FwLnV0aWxzLnRvQXJyYXk7XG4gICAgX2dldFVuaXQgPSBnc2FwLnV0aWxzLmdldFVuaXQ7XG4gICAgX2dldENhY2hlID0gZ3NhcC5jb3JlLmdldENhY2hlO1xuICAgIF90aWNrZXIgPSBnc2FwLnRpY2tlcjtcbiAgICBfY29yZUluaXR0ZWQgPSAxO1xuICB9XG59O1xuXG52YXIgUHJvcFRyYWNrZXIgPSBmdW5jdGlvbiBQcm9wVHJhY2tlcih0YXJnZXQsIHByb3BlcnR5LCB0eXBlLCBuZXh0KSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9wVHJhY2tlcik7XG5cbiAgdGhpcy50ID0gdGFyZ2V0O1xuICB0aGlzLnAgPSBwcm9wZXJ0eTtcbiAgdGhpcy5nID0gdGFyZ2V0Ll9nc2FwLmdldDtcbiAgdGhpcy5yQ2FwID0gX3R5cGVzW3R5cGUgfHwgX2dldFVuaXQodGhpcy5nKHRhcmdldCwgcHJvcGVydHkpKV07IC8vcm90YXRpb25hbCBjYXAgKGZvciBkZWdyZWVzLCBcImRlZ1wiLCBpdCdzIDM2MCBhbmQgZm9yIHJhZGlhbnMsIFwicmFkXCIsIGl0J3MgTWF0aC5QSSAqIDIpXG5cbiAgdGhpcy52MSA9IHRoaXMudjIgPSAwO1xuICB0aGlzLnQxID0gdGhpcy50MiA9IF90aWNrZXIudGltZTtcblxuICBpZiAobmV4dCkge1xuICAgIHRoaXMuX25leHQgPSBuZXh0O1xuICAgIG5leHQuX3ByZXYgPSB0aGlzO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIFZlbG9jaXR5VHJhY2tlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZlbG9jaXR5VHJhY2tlcih0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZlbG9jaXR5VHJhY2tlcik7XG5cbiAgICBpZiAoIV9jb3JlSW5pdHRlZCkge1xuICAgICAgX2luaXRDb3JlKCk7XG4gICAgfVxuXG4gICAgdGhpcy50YXJnZXQgPSBfdG9BcnJheSh0YXJnZXQpWzBdO1xuICAgIF9sb29rdXBbX2dldElEKHRoaXMudGFyZ2V0KV0gPSB0aGlzO1xuICAgIHRoaXMuX3Byb3BzID0ge307XG4gICAgcHJvcGVydHkgJiYgdGhpcy5hZGQocHJvcGVydHkpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFZlbG9jaXR5VHJhY2tlciwgW3tcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChwcm9wZXJ0eSwgc2tpcFJlY2VudFRpY2spIHtcbiAgICAgIHZhciBwdCA9IHRoaXMuX3Byb3BzW3Byb3BlcnR5XSB8fCBjb25zb2xlLndhcm4oXCJOb3QgdHJhY2tpbmcgXCIgKyBwcm9wZXJ0eSArIFwiIHZlbG9jaXR5LlwiKSxcbiAgICAgICAgICB2YWwsXG4gICAgICAgICAgZGlmLFxuICAgICAgICAgIHJvdGF0aW9uQ2FwO1xuICAgICAgdmFsID0gcGFyc2VGbG9hdChza2lwUmVjZW50VGljayA/IHB0LnYxIDogcHQuZyhwdC50LCBwdC5wKSk7XG4gICAgICBkaWYgPSB2YWwgLSBwYXJzZUZsb2F0KHB0LnYyKTtcbiAgICAgIHJvdGF0aW9uQ2FwID0gcHQuckNhcDtcblxuICAgICAgaWYgKHJvdGF0aW9uQ2FwKSB7XG4gICAgICAgIC8vcm90YXRpb25hbCB2YWx1ZXMgbmVlZCBzcGVjaWFsIGludGVycHJldGF0aW9uIHNvIHRoYXQgaWYsIGZvciBleGFtcGxlLCB0aGV5IGdvIGZyb20gMTc5IHRvIC0xNzggZGVncmVlcyBpdCBpcyBpbnRlcnByZXRlZCBhcyBhIGNoYW5nZSBvZiAzIGluc3RlYWQgb2YgLTM1Ny5cbiAgICAgICAgZGlmID0gZGlmICUgcm90YXRpb25DYXA7XG5cbiAgICAgICAgaWYgKGRpZiAhPT0gZGlmICUgKHJvdGF0aW9uQ2FwIC8gMikpIHtcbiAgICAgICAgICBkaWYgPSBkaWYgPCAwID8gZGlmICsgcm90YXRpb25DYXAgOiBkaWYgLSByb3RhdGlvbkNhcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3JvdW5kKGRpZiAvICgoc2tpcFJlY2VudFRpY2sgPyBwdC50MSA6IF90aWNrZXIudGltZSkgLSBwdC50MikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxsKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9LFxuICAgICAgICAgIHByb3BzID0gdGhpcy5fcHJvcHMsXG4gICAgICAgICAgcDtcblxuICAgICAgZm9yIChwIGluIHByb3BzKSB7XG4gICAgICAgIHJlc3VsdFtwXSA9IHRoaXMuZ2V0KHApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1RyYWNraW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVHJhY2tpbmcocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzLl9wcm9wcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChwcm9wZXJ0eSwgdHlwZSkge1xuICAgICAgaWYgKCEocHJvcGVydHkgaW4gdGhpcy5fcHJvcHMpKSB7XG4gICAgICAgIGlmICghX2ZpcnN0KSB7XG4gICAgICAgICAgX3RpY2tlci5hZGQoX29uVGljayk7XG5cbiAgICAgICAgICBfdGltZTEgPSBfdGltZTIgPSBfdGlja2VyLnRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBfZmlyc3QgPSB0aGlzLl9wcm9wc1twcm9wZXJ0eV0gPSBuZXcgUHJvcFRyYWNrZXIodGhpcy50YXJnZXQsIHByb3BlcnR5LCB0eXBlLCBfZmlyc3QpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKHByb3BlcnR5KSB7XG4gICAgICB2YXIgcHQgPSB0aGlzLl9wcm9wc1twcm9wZXJ0eV0sXG4gICAgICAgICAgcHJldixcbiAgICAgICAgICBuZXh0O1xuXG4gICAgICBpZiAocHQpIHtcbiAgICAgICAgcHJldiA9IHB0Ll9wcmV2O1xuICAgICAgICBuZXh0ID0gcHQuX25leHQ7XG5cbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICBwcmV2Ll9uZXh0ID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgbmV4dC5fcHJldiA9IHByZXY7XG4gICAgICAgIH0gZWxzZSBpZiAoX2ZpcnN0ID09PSBwdCkge1xuICAgICAgICAgIF90aWNrZXIucmVtb3ZlKF9vblRpY2spO1xuXG4gICAgICAgICAgX2ZpcnN0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9wcm9wc1twcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImtpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbChzaGFsbG93KSB7XG4gICAgICBmb3IgKHZhciBwIGluIHRoaXMuX3Byb3BzKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKHApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNoYWxsb3cpIHtcbiAgICAgICAgZGVsZXRlIF9sb29rdXBbX2dldElEKHRoaXMudGFyZ2V0KV07XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicmVnaXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIoY29yZSkge1xuICAgICAgZ3NhcCA9IGNvcmU7XG5cbiAgICAgIF9pbml0Q29yZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFjayh0YXJnZXRzLCBwcm9wZXJ0aWVzLCB0eXBlcykge1xuICAgICAgaWYgKCFfY29yZUluaXR0ZWQpIHtcbiAgICAgICAgX2luaXRDb3JlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICB0YXJncyA9IF90b0FycmF5KHRhcmdldHMpLFxuICAgICAgICAgIGEgPSBwcm9wZXJ0aWVzLnNwbGl0KFwiLFwiKSxcbiAgICAgICAgICB0ID0gKHR5cGVzIHx8IFwiXCIpLnNwbGl0KFwiLFwiKSxcbiAgICAgICAgICBpID0gdGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIHRyYWNrZXIsXG4gICAgICAgICAgajtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB0cmFja2VyID0gX2dldEJ5VGFyZ2V0KHRhcmdzW2ldKSB8fCBuZXcgVmVsb2NpdHlUcmFja2VyKHRhcmdzW2ldKTtcbiAgICAgICAgaiA9IGEubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICB0cmFja2VyLmFkZChhW2pdLCB0W2pdIHx8IHRbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2godHJhY2tlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVudHJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW50cmFjayh0YXJnZXRzLCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgcHJvcHMgPSAocHJvcGVydGllcyB8fCBcIlwiKS5zcGxpdChcIixcIik7XG5cbiAgICAgIF90b0FycmF5KHRhcmdldHMpLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICB2YXIgdHJhY2tlciA9IF9nZXRCeVRhcmdldCh0YXJnZXQpO1xuXG4gICAgICAgIGlmICh0cmFja2VyKSB7XG4gICAgICAgICAgaWYgKCFwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRyYWNrZXIua2lsbCgxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJhY2tlci5yZW1vdmUocCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1RyYWNraW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVHJhY2tpbmcodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIHRyYWNrZXIgPSBfZ2V0QnlUYXJnZXQodGFyZ2V0KTtcblxuICAgICAgcmV0dXJuIHRyYWNrZXIgJiYgdHJhY2tlci5pc1RyYWNraW5nKHByb3BlcnR5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmVsb2NpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmVsb2NpdHkodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIHRyYWNrZXIgPSBfZ2V0QnlUYXJnZXQodGFyZ2V0KTtcblxuICAgICAgcmV0dXJuICF0cmFja2VyIHx8ICF0cmFja2VyLmlzVHJhY2tpbmcocHJvcGVydHkpID8gY29uc29sZS53YXJuKFwiTm90IHRyYWNraW5nIHZlbG9jaXR5IG9mIFwiICsgcHJvcGVydHkpIDogdHJhY2tlci5nZXQocHJvcGVydHkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWZWxvY2l0eVRyYWNrZXI7XG59KCk7XG5WZWxvY2l0eVRyYWNrZXIuZ2V0QnlUYXJnZXQgPSBfZ2V0QnlUYXJnZXQ7XG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oVmVsb2NpdHlUcmFja2VyKTtcbmV4cG9ydCB7IFZlbG9jaXR5VHJhY2tlciBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4vKiFcbiAqIEluZXJ0aWFQbHVnaW4gMy42LjFcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyBWZWxvY2l0eVRyYWNrZXIgfSBmcm9tIFwiLi4vdXRpbHMvVmVsb2NpdHlUcmFja2VyLmpzXCI7XG5cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfcGFyc2VFYXNlLFxuICAgIF90b0FycmF5LFxuICAgIF9wb3dlcjMsXG4gICAgX2NvbmZpZyxcbiAgICBfZ2V0VW5pdCxcbiAgICBQcm9wVHdlZW4sXG4gICAgX2dldENhY2hlLFxuICAgIF9jaGVja1BvaW50UmF0aW8sXG4gICAgX2NsYW1wLFxuICAgIF9wcm9jZXNzaW5nVmFycyxcbiAgICBfZ2V0VHJhY2tlciA9IFZlbG9jaXR5VHJhY2tlci5nZXRCeVRhcmdldCxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59LFxuICAgIF9pc051bWJlciA9IGZ1bmN0aW9uIF9pc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufSxcbiAgICBfaXNPYmplY3QgPSBmdW5jdGlvbiBfaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIF90eXBlb2YodmFsdWUpID09PSBcIm9iamVjdFwiO1xufSxcbiAgICBfaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn0sXG4gICAgX2JvbnVzVmFsaWRhdGVkID0gMSxcbiAgICAvLzxuYW1lPkluZXJ0aWFQbHVnaW48L25hbWU+XG5faXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgX2VtcHR5RnVuYyA9IGZ1bmN0aW9uIF9lbXB0eUZ1bmMocCkge1xuICByZXR1cm4gcDtcbn0sXG4gICAgX2JpZ051bSA9IDFlMTAsXG4gICAgX3RpbnlOdW0gPSAxIC8gX2JpZ051bSxcbiAgICBfY2hlY2tQb2ludCA9IDAuMDUsXG4gICAgX3JvdW5kID0gZnVuY3Rpb24gX3JvdW5kKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDApIC8gMTAwMDA7XG59LFxuICAgIF9leHRlbmQgPSBmdW5jdGlvbiBfZXh0ZW5kKG9iaiwgZGVmYXVsdHMsIGV4Y2x1ZGUpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIGlmICghKHAgaW4gb2JqKSAmJiBwICE9PSBleGNsdWRlKSB7XG4gICAgICBvYmpbcF0gPSBkZWZhdWx0c1twXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfZGVlcENsb25lID0gZnVuY3Rpb24gX2RlZXBDbG9uZShvYmopIHtcbiAgdmFyIGNvcHkgPSB7fSxcbiAgICAgIHAsXG4gICAgICB2O1xuXG4gIGZvciAocCBpbiBvYmopIHtcbiAgICBjb3B5W3BdID0gX2lzT2JqZWN0KHYgPSBvYmpbcF0pID8gX2RlZXBDbG9uZSh2KSA6IHY7XG4gIH1cblxuICByZXR1cm4gY29weTtcbn0sXG4gICAgX2dldENsb3Nlc3QgPSBmdW5jdGlvbiBfZ2V0Q2xvc2VzdChuLCB2YWx1ZXMsIG1heCwgbWluLCByYWRpdXMpIHtcbiAgdmFyIGkgPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgY2xvc2VzdCA9IDAsXG4gICAgICBhYnNEaWYgPSBfYmlnTnVtLFxuICAgICAgdmFsLFxuICAgICAgZGlmLFxuICAgICAgcCxcbiAgICAgIGRpc3Q7XG5cbiAgaWYgKF9pc09iamVjdChuKSkge1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHZhbHVlc1tpXTtcbiAgICAgIGRpZiA9IDA7XG5cbiAgICAgIGZvciAocCBpbiBuKSB7XG4gICAgICAgIGRpc3QgPSB2YWxbcF0gLSBuW3BdO1xuICAgICAgICBkaWYgKz0gZGlzdCAqIGRpc3Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWYgPCBhYnNEaWYpIHtcbiAgICAgICAgY2xvc2VzdCA9IGk7XG4gICAgICAgIGFic0RpZiA9IGRpZjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoKHJhZGl1cyB8fCBfYmlnTnVtKSA8IF9iaWdOdW0gJiYgcmFkaXVzIDwgTWF0aC5zcXJ0KGFic0RpZikpIHtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSB2YWx1ZXNbaV07XG4gICAgICBkaWYgPSB2YWwgLSBuO1xuXG4gICAgICBpZiAoZGlmIDwgMCkge1xuICAgICAgICBkaWYgPSAtZGlmO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlmIDwgYWJzRGlmICYmIHZhbCA+PSBtaW4gJiYgdmFsIDw9IG1heCkge1xuICAgICAgICBjbG9zZXN0ID0gaTtcbiAgICAgICAgYWJzRGlmID0gZGlmO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZXNbY2xvc2VzdF07XG59LFxuICAgIF9wYXJzZUVuZCA9IGZ1bmN0aW9uIF9wYXJzZUVuZChjdXJQcm9wLCBlbmQsIG1heCwgbWluLCBuYW1lLCByYWRpdXMpIHtcbiAgaWYgKGN1clByb3AuZW5kID09PSBcImF1dG9cIikge1xuICAgIHJldHVybiBjdXJQcm9wO1xuICB9XG5cbiAgdmFyIGVuZFZhciA9IGN1clByb3AuZW5kLFxuICAgICAgYWRqdXN0ZWRFbmQsXG4gICAgICBwO1xuICBtYXggPSBpc05hTihtYXgpID8gX2JpZ051bSA6IG1heDtcbiAgbWluID0gaXNOYU4obWluKSA/IC1fYmlnTnVtIDogbWluO1xuXG4gIGlmIChfaXNPYmplY3QoZW5kKSkge1xuICAgIC8vZm9yIG9iamVjdHMsIGxpa2Uge3gsIHl9IHdoZXJlIHRoZXkncmUgbGlua2VkIGFuZCB3ZSBtdXN0IHBhc3MgYW4gb2JqZWN0IHRvIHRoZSBmdW5jdGlvbiBvciBmaW5kIHRoZSBjbG9zZXN0IHZhbHVlIGluIGFuIGFycmF5LlxuICAgIGFkanVzdGVkRW5kID0gZW5kLmNhbGN1bGF0ZWQgPyBlbmQgOiAoX2lzRnVuY3Rpb24oZW5kVmFyKSA/IGVuZFZhcihlbmQpIDogX2dldENsb3Nlc3QoZW5kLCBlbmRWYXIsIG1heCwgbWluLCByYWRpdXMpKSB8fCBlbmQ7XG5cbiAgICBpZiAoIWVuZC5jYWxjdWxhdGVkKSB7XG4gICAgICBmb3IgKHAgaW4gYWRqdXN0ZWRFbmQpIHtcbiAgICAgICAgZW5kW3BdID0gYWRqdXN0ZWRFbmRbcF07XG4gICAgICB9XG5cbiAgICAgIGVuZC5jYWxjdWxhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBhZGp1c3RlZEVuZCA9IGFkanVzdGVkRW5kW25hbWVdO1xuICB9IGVsc2Uge1xuICAgIGFkanVzdGVkRW5kID0gX2lzRnVuY3Rpb24oZW5kVmFyKSA/IGVuZFZhcihlbmQpIDogX2lzQXJyYXkoZW5kVmFyKSA/IF9nZXRDbG9zZXN0KGVuZCwgZW5kVmFyLCBtYXgsIG1pbiwgcmFkaXVzKSA6IHBhcnNlRmxvYXQoZW5kVmFyKTtcbiAgfVxuXG4gIGlmIChhZGp1c3RlZEVuZCA+IG1heCkge1xuICAgIGFkanVzdGVkRW5kID0gbWF4O1xuICB9IGVsc2UgaWYgKGFkanVzdGVkRW5kIDwgbWluKSB7XG4gICAgYWRqdXN0ZWRFbmQgPSBtaW47XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1heDogYWRqdXN0ZWRFbmQsXG4gICAgbWluOiBhZGp1c3RlZEVuZCxcbiAgICB1bml0RmFjdG9yOiBjdXJQcm9wLnVuaXRGYWN0b3JcbiAgfTtcbn0sXG4gICAgX2dldE51bU9yRGVmYXVsdCA9IGZ1bmN0aW9uIF9nZXROdW1PckRlZmF1bHQodmFycywgcHJvcGVydHksIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gaXNOYU4odmFyc1twcm9wZXJ0eV0pID8gZGVmYXVsdFZhbHVlIDogK3ZhcnNbcHJvcGVydHldO1xufSxcbiAgICBfY2FsY3VsYXRlQ2hhbmdlID0gZnVuY3Rpb24gX2NhbGN1bGF0ZUNoYW5nZSh2ZWxvY2l0eSwgZHVyYXRpb24pIHtcbiAgcmV0dXJuIGR1cmF0aW9uICogX2NoZWNrUG9pbnQgKiB2ZWxvY2l0eSAvIF9jaGVja1BvaW50UmF0aW87XG59LFxuICAgIF9jYWxjdWxhdGVEdXJhdGlvbiA9IGZ1bmN0aW9uIF9jYWxjdWxhdGVEdXJhdGlvbihzdGFydCwgZW5kLCB2ZWxvY2l0eSkge1xuICByZXR1cm4gTWF0aC5hYnMoKGVuZCAtIHN0YXJ0KSAqIF9jaGVja1BvaW50UmF0aW8gLyB2ZWxvY2l0eSAvIF9jaGVja1BvaW50KTtcbn0sXG4gICAgX3Jlc2VydmVkUHJvcHMgPSB7XG4gIHJlc2lzdGFuY2U6IDEsXG4gIGNoZWNrcG9pbnQ6IDEsXG4gIHByZXZlbnRPdmVyc2hvb3Q6IDEsXG4gIGxpbmtlZFByb3BzOiAxLFxuICByYWRpdXM6IDEsXG4gIGR1cmF0aW9uOiAxXG59LFxuICAgIF9wcm9jZXNzTGlua2VkUHJvcHMgPSBmdW5jdGlvbiBfcHJvY2Vzc0xpbmtlZFByb3BzKHRhcmdldCwgdmFycywgZ2V0VmFsLCByZXNpc3RhbmNlKSB7XG4gIGlmICh2YXJzLmxpbmtlZFByb3BzKSB7XG4gICAgLy93aGVuIHRoZXJlIGFyZSBsaW5rZWRQcm9wcyAodHlwaWNhbGx5IFwieCx5XCIgd2hlcmUgc25hcHBpbmcgaGFzIHRvIGZhY3RvciBpbiBtdWx0aXBsZSBwcm9wZXJ0aWVzLCB3ZSBtdXN0IGZpcnN0IHBvcHVsYXRlIGFuIG9iamVjdCB3aXRoIGFsbCBvZiB0aG9zZSBlbmQgdmFsdWVzLCB0aGVuIGZlZWQgaXQgdG8gdGhlIGZ1bmN0aW9uIHRoYXQgbWFrZSBhbnkgbmVjZXNzYXJ5IGFsdGVyYXRpb25zLiBTbyB0aGUgcG9pbnQgb2YgdGhpcyBmaXJzdCBsb29wIGlzIHRvIHNpbXBseSBidWlsZCBhbiBvYmplY3QgKGxpa2Uge3g6MTAwLCB5OjIwNC41fSkgZm9yIGZlZWRpbmcgaW50byB0aGF0IGZ1bmN0aW9uIHdoaWNoIHdlJ2xsIGRvIGxhdGVyIGluIHRoZSBcInJlYWxcIiBsb29wLlxuICAgIHZhciBsaW5rZWRQcm9wTmFtZXMgPSB2YXJzLmxpbmtlZFByb3BzLnNwbGl0KFwiLFwiKSxcbiAgICAgICAgbGlua2VkUHJvcHMgPSB7fSxcbiAgICAgICAgaSxcbiAgICAgICAgcCxcbiAgICAgICAgY3VyUHJvcCxcbiAgICAgICAgY3VyVmVsb2NpdHksXG4gICAgICAgIHRyYWNrZXIsXG4gICAgICAgIGN1ckR1cmF0aW9uO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxpbmtlZFByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgcCA9IGxpbmtlZFByb3BOYW1lc1tpXTtcbiAgICAgIGN1clByb3AgPSB2YXJzW3BdO1xuXG4gICAgICBpZiAoY3VyUHJvcCkge1xuICAgICAgICBpZiAoX2lzTnVtYmVyKGN1clByb3AudmVsb2NpdHkpKSB7XG4gICAgICAgICAgY3VyVmVsb2NpdHkgPSBjdXJQcm9wLnZlbG9jaXR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYWNrZXIgPSB0cmFja2VyIHx8IF9nZXRUcmFja2VyKHRhcmdldCk7XG4gICAgICAgICAgY3VyVmVsb2NpdHkgPSB0cmFja2VyICYmIHRyYWNrZXIuaXNUcmFja2luZyhwKSA/IHRyYWNrZXIuZ2V0KHApIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1ckR1cmF0aW9uID0gTWF0aC5hYnMoY3VyVmVsb2NpdHkgLyBfZ2V0TnVtT3JEZWZhdWx0KGN1clByb3AsIFwicmVzaXN0YW5jZVwiLCByZXNpc3RhbmNlKSk7XG4gICAgICAgIGxpbmtlZFByb3BzW3BdID0gcGFyc2VGbG9hdChnZXRWYWwodGFyZ2V0LCBwKSkgKyBfY2FsY3VsYXRlQ2hhbmdlKGN1clZlbG9jaXR5LCBjdXJEdXJhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmtlZFByb3BzO1xuICB9XG59LFxuICAgIF9jYWxjdWxhdGVUd2VlbkR1cmF0aW9uID0gZnVuY3Rpb24gX2NhbGN1bGF0ZVR3ZWVuRHVyYXRpb24odGFyZ2V0LCB2YXJzKSB7XG4gIHZhciBtYXhEdXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTA7XG4gIHZhciBtaW5EdXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMC4yO1xuICB2YXIgb3ZlcnNob290VG9sZXJhbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAxO1xuICB2YXIgcmVjb3JkRW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAwO1xuICBfaXNTdHJpbmcodGFyZ2V0KSAmJiAodGFyZ2V0ID0gX3RvQXJyYXkodGFyZ2V0KVswXSk7XG5cbiAgaWYgKCF0YXJnZXQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBkdXJhdGlvbiA9IDAsXG4gICAgICBjbGlwcGVkRHVyYXRpb24gPSBfYmlnTnVtLFxuICAgICAgaW5lcnRpYVZhcnMgPSB2YXJzLmluZXJ0aWEgfHwgdmFycyxcbiAgICAgIGdldFZhbCA9IF9nZXRDYWNoZSh0YXJnZXQpLmdldCxcbiAgICAgIHJlc2lzdGFuY2UgPSBfZ2V0TnVtT3JEZWZhdWx0KGluZXJ0aWFWYXJzLCBcInJlc2lzdGFuY2VcIiwgX2NvbmZpZy5yZXNpc3RhbmNlKSxcbiAgICAgIHAsXG4gICAgICBjdXJQcm9wLFxuICAgICAgY3VyRHVyYXRpb24sXG4gICAgICBjdXJWZWxvY2l0eSxcbiAgICAgIGN1clZhbCxcbiAgICAgIGVuZCxcbiAgICAgIGN1ckNsaXBwZWREdXJhdGlvbixcbiAgICAgIHRyYWNrZXIsXG4gICAgICB1bml0RmFjdG9yLFxuICAgICAgbGlua2VkUHJvcHM7IC8vd2hlbiB0aGVyZSBhcmUgbGlua2VkUHJvcHMgKHR5cGljYWxseSBcIngseVwiIHdoZXJlIHNuYXBwaW5nIGhhcyB0byBmYWN0b3IgaW4gbXVsdGlwbGUgcHJvcGVydGllcywgd2UgbXVzdCBmaXJzdCBwb3B1bGF0ZSBhbiBvYmplY3Qgd2l0aCBhbGwgb2YgdGhvc2UgZW5kIHZhbHVlcywgdGhlbiBmZWVkIGl0IHRvIHRoZSBmdW5jdGlvbiB0aGF0IG1ha2UgYW55IG5lY2Vzc2FyeSBhbHRlcmF0aW9ucy4gU28gdGhlIHBvaW50IG9mIHRoaXMgZmlyc3QgbG9vcCBpcyB0byBzaW1wbHkgYnVpbGQgYW4gb2JqZWN0IChsaWtlIHt4OjEwMCwgeToyMDQuNX0pIGZvciBmZWVkaW5nIGludG8gdGhhdCBmdW5jdGlvbiB3aGljaCB3ZSdsbCBkbyBsYXRlciBpbiB0aGUgXCJyZWFsXCIgbG9vcC5cblxuXG4gIGxpbmtlZFByb3BzID0gX3Byb2Nlc3NMaW5rZWRQcm9wcyh0YXJnZXQsIGluZXJ0aWFWYXJzLCBnZXRWYWwsIHJlc2lzdGFuY2UpO1xuXG4gIGZvciAocCBpbiBpbmVydGlhVmFycykge1xuICAgIGlmICghX3Jlc2VydmVkUHJvcHNbcF0pIHtcbiAgICAgIGN1clByb3AgPSBpbmVydGlhVmFyc1twXTtcblxuICAgICAgaWYgKCFfaXNPYmplY3QoY3VyUHJvcCkpIHtcbiAgICAgICAgdHJhY2tlciA9IHRyYWNrZXIgfHwgX2dldFRyYWNrZXIodGFyZ2V0KTtcblxuICAgICAgICBpZiAodHJhY2tlciAmJiB0cmFja2VyLmlzVHJhY2tpbmcocCkpIHtcbiAgICAgICAgICBjdXJQcm9wID0gX2lzTnVtYmVyKGN1clByb3ApID8ge1xuICAgICAgICAgICAgdmVsb2NpdHk6IGN1clByb3BcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgdmVsb2NpdHk6IHRyYWNrZXIuZ2V0KHApXG4gICAgICAgICAgfTsgLy9pZiB3ZSdyZSB0cmFja2luZyB0aGlzIHByb3BlcnR5LCB3ZSBzaG91bGQgdXNlIHRoZSB0cmFja2luZyB2ZWxvY2l0eSBhbmQgdGhlbiB1c2UgdGhlIG51bWVyaWMgdmFsdWUgdGhhdCB3YXMgcGFzc2VkIGluIGFzIHRoZSBtaW4gYW5kIG1heCBzbyB0aGF0IGl0IHR3ZWVucyBleGFjdGx5IHRoZXJlLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1clZlbG9jaXR5ID0gK2N1clByb3AgfHwgMDtcbiAgICAgICAgICBjdXJEdXJhdGlvbiA9IE1hdGguYWJzKGN1clZlbG9jaXR5IC8gcmVzaXN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKF9pc09iamVjdChjdXJQcm9wKSkge1xuICAgICAgICBpZiAoX2lzTnVtYmVyKGN1clByb3AudmVsb2NpdHkpKSB7XG4gICAgICAgICAgY3VyVmVsb2NpdHkgPSBjdXJQcm9wLnZlbG9jaXR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYWNrZXIgPSB0cmFja2VyIHx8IF9nZXRUcmFja2VyKHRhcmdldCk7XG4gICAgICAgICAgY3VyVmVsb2NpdHkgPSB0cmFja2VyICYmIHRyYWNrZXIuaXNUcmFja2luZyhwKSA/IHRyYWNrZXIuZ2V0KHApIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1ckR1cmF0aW9uID0gX2NsYW1wKG1pbkR1cmF0aW9uLCBtYXhEdXJhdGlvbiwgTWF0aC5hYnMoY3VyVmVsb2NpdHkgLyBfZ2V0TnVtT3JEZWZhdWx0KGN1clByb3AsIFwicmVzaXN0YW5jZVwiLCByZXNpc3RhbmNlKSkpO1xuICAgICAgICBjdXJWYWwgPSBwYXJzZUZsb2F0KGdldFZhbCh0YXJnZXQsIHApKSB8fCAwO1xuICAgICAgICBlbmQgPSBjdXJWYWwgKyBfY2FsY3VsYXRlQ2hhbmdlKGN1clZlbG9jaXR5LCBjdXJEdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKFwiZW5kXCIgaW4gY3VyUHJvcCkge1xuICAgICAgICAgIGN1clByb3AgPSBfcGFyc2VFbmQoY3VyUHJvcCwgbGlua2VkUHJvcHMgJiYgcCBpbiBsaW5rZWRQcm9wcyA/IGxpbmtlZFByb3BzIDogZW5kLCBjdXJQcm9wLm1heCwgY3VyUHJvcC5taW4sIHAsIGluZXJ0aWFWYXJzLnJhZGl1cyk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkRW5kKSB7XG4gICAgICAgICAgICBfcHJvY2Vzc2luZ1ZhcnMgPT09IHZhcnMgJiYgKF9wcm9jZXNzaW5nVmFycyA9IGluZXJ0aWFWYXJzID0gX2RlZXBDbG9uZSh2YXJzKSk7XG4gICAgICAgICAgICBpbmVydGlhVmFyc1twXSA9IF9leHRlbmQoY3VyUHJvcCwgaW5lcnRpYVZhcnNbcF0sIFwiZW5kXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcIm1heFwiIGluIGN1clByb3AgJiYgZW5kID4gK2N1clByb3AubWF4ICsgX3RpbnlOdW0pIHtcbiAgICAgICAgICB1bml0RmFjdG9yID0gY3VyUHJvcC51bml0RmFjdG9yIHx8IF9jb25maWcudW5pdEZhY3RvcnNbcF0gfHwgMTsgLy9zb21lIHZhbHVlcyBhcmUgbWVhc3VyZWQgaW4gc3BlY2lhbCB1bml0cyBsaWtlIHJhZGlhbnMgaW4gd2hpY2ggY2FzZSBvdXIgdGhyZXNob2xkcyBuZWVkIHRvIGJlIGFkanVzdGVkIGFjY29yZGluZ2x5LlxuICAgICAgICAgIC8vaWYgdGhlIHZhbHVlIGlzIGFscmVhZHkgZXhjZWVkaW5nIHRoZSBtYXggb3IgdGhlIHZlbG9jaXR5IGlzIHRvbyBsb3csIHRoZSBkdXJhdGlvbiBjYW4gZW5kIHVwIGJlaW5nIHVuY29tZm9ydGFibHkgbG9uZyBidXQgaW4gbW9zdCBzaXR1YXRpb25zLCB1c2VycyB3YW50IHRoZSBzbmFwcGluZyB0byBvY2N1ciByZWxhdGl2ZWx5IHF1aWNrbHkgKDAuNzUgc2Vjb25kcyksIHNvIHdlIGltcGxlbWVudCBhIGNhcCBoZXJlIHRvIG1ha2UgdGhpbmdzIG1vcmUgaW50dWl0aXZlLiBJZiB0aGUgbWF4IGFuZCBtaW4gbWF0Y2gsIGl0IG1lYW5zIHdlJ3JlIGFuaW1hdGluZyB0byBhIHBhcnRpY3VsYXIgdmFsdWUgYW5kIHdlIGRvbid0IHdhbnQgdG8gc2hvcnRlbiB0aGUgdGltZSB1bmxlc3MgdGhlIHZlbG9jaXR5IGlzIHJlYWxseSBzbG93LiBFeGFtcGxlOiBhIHJvdGF0aW9uIHdoZXJlIHRoZSBzdGFydCBhbmQgbmF0dXJhbCBlbmQgdmFsdWUgYXJlIGxlc3MgdGhhbiB0aGUgc25hcHBpbmcgc3BvdCwgYnV0IHRoZSBuYXR1cmFsIGVuZCBpcyBwcmV0dHkgY2xvc2UgdG8gdGhlIHNuYXAuXG5cbiAgICAgICAgICBjdXJDbGlwcGVkRHVyYXRpb24gPSBjdXJWYWwgPiBjdXJQcm9wLm1heCAmJiBjdXJQcm9wLm1pbiAhPT0gY3VyUHJvcC5tYXggfHwgY3VyVmVsb2NpdHkgKiB1bml0RmFjdG9yID4gLTE1ICYmIGN1clZlbG9jaXR5ICogdW5pdEZhY3RvciA8IDQ1ID8gbWluRHVyYXRpb24gKyAobWF4RHVyYXRpb24gLSBtaW5EdXJhdGlvbikgKiAwLjEgOiBfY2FsY3VsYXRlRHVyYXRpb24oY3VyVmFsLCBjdXJQcm9wLm1heCwgY3VyVmVsb2NpdHkpO1xuXG4gICAgICAgICAgaWYgKGN1ckNsaXBwZWREdXJhdGlvbiArIG92ZXJzaG9vdFRvbGVyYW5jZSA8IGNsaXBwZWREdXJhdGlvbikge1xuICAgICAgICAgICAgY2xpcHBlZER1cmF0aW9uID0gY3VyQ2xpcHBlZER1cmF0aW9uICsgb3ZlcnNob290VG9sZXJhbmNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcIm1pblwiIGluIGN1clByb3AgJiYgZW5kIDwgK2N1clByb3AubWluIC0gX3RpbnlOdW0pIHtcbiAgICAgICAgICB1bml0RmFjdG9yID0gY3VyUHJvcC51bml0RmFjdG9yIHx8IF9jb25maWcudW5pdEZhY3RvcnNbcF0gfHwgMTsgLy9zb21lIHZhbHVlcyBhcmUgbWVhc3VyZWQgaW4gc3BlY2lhbCB1bml0cyBsaWtlIHJhZGlhbnMgaW4gd2hpY2ggY2FzZSBvdXIgdGhyZXNob2xkcyBuZWVkIHRvIGJlIGFkanVzdGVkIGFjY29yZGluZ2x5LlxuICAgICAgICAgIC8vaWYgdGhlIHZhbHVlIGlzIGFscmVhZHkgZXhjZWVkaW5nIHRoZSBtaW4gb3IgaWYgdGhlIHZlbG9jaXR5IGlzIHRvbyBsb3csIHRoZSBkdXJhdGlvbiBjYW4gZW5kIHVwIGJlaW5nIHVuY29tZm9ydGFibHkgbG9uZyBidXQgaW4gbW9zdCBzaXR1YXRpb25zLCB1c2VycyB3YW50IHRoZSBzbmFwcGluZyB0byBvY2N1ciByZWxhdGl2ZWx5IHF1aWNrbHkgKDAuNzUgc2Vjb25kcyksIHNvIHdlIGltcGxlbWVudCBhIGNhcCBoZXJlIHRvIG1ha2UgdGhpbmdzIG1vcmUgaW50dWl0aXZlLlxuXG4gICAgICAgICAgY3VyQ2xpcHBlZER1cmF0aW9uID0gY3VyVmFsIDwgY3VyUHJvcC5taW4gJiYgY3VyUHJvcC5taW4gIT09IGN1clByb3AubWF4IHx8IGN1clZlbG9jaXR5ICogdW5pdEZhY3RvciA+IC00NSAmJiBjdXJWZWxvY2l0eSAqIHVuaXRGYWN0b3IgPCAxNSA/IG1pbkR1cmF0aW9uICsgKG1heER1cmF0aW9uIC0gbWluRHVyYXRpb24pICogMC4xIDogX2NhbGN1bGF0ZUR1cmF0aW9uKGN1clZhbCwgY3VyUHJvcC5taW4sIGN1clZlbG9jaXR5KTtcblxuICAgICAgICAgIGlmIChjdXJDbGlwcGVkRHVyYXRpb24gKyBvdmVyc2hvb3RUb2xlcmFuY2UgPCBjbGlwcGVkRHVyYXRpb24pIHtcbiAgICAgICAgICAgIGNsaXBwZWREdXJhdGlvbiA9IGN1ckNsaXBwZWREdXJhdGlvbiArIG92ZXJzaG9vdFRvbGVyYW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdXJDbGlwcGVkRHVyYXRpb24gPiBkdXJhdGlvbiAmJiAoZHVyYXRpb24gPSBjdXJDbGlwcGVkRHVyYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBjdXJEdXJhdGlvbiA+IGR1cmF0aW9uICYmIChkdXJhdGlvbiA9IGN1ckR1cmF0aW9uKTtcbiAgICB9XG4gIH1cblxuICBkdXJhdGlvbiA+IGNsaXBwZWREdXJhdGlvbiAmJiAoZHVyYXRpb24gPSBjbGlwcGVkRHVyYXRpb24pO1xuICByZXR1cm4gZHVyYXRpb24gPiBtYXhEdXJhdGlvbiA/IG1heER1cmF0aW9uIDogZHVyYXRpb24gPCBtaW5EdXJhdGlvbiA/IG1pbkR1cmF0aW9uIDogZHVyYXRpb247XG59LFxuICAgIF9pbml0Q29yZSA9IGZ1bmN0aW9uIF9pbml0Q29yZSgpIHtcbiAgZ3NhcCA9IF9nZXRHU0FQKCk7XG5cbiAgaWYgKGdzYXApIHtcbiAgICBfcGFyc2VFYXNlID0gZ3NhcC5wYXJzZUVhc2U7XG4gICAgX3RvQXJyYXkgPSBnc2FwLnV0aWxzLnRvQXJyYXk7XG4gICAgX2dldFVuaXQgPSBnc2FwLnV0aWxzLmdldFVuaXQ7XG4gICAgX2dldENhY2hlID0gZ3NhcC5jb3JlLmdldENhY2hlO1xuICAgIF9jbGFtcCA9IGdzYXAudXRpbHMuY2xhbXA7XG4gICAgX3Bvd2VyMyA9IF9wYXJzZUVhc2UoXCJwb3dlcjNcIik7XG4gICAgX2NoZWNrUG9pbnRSYXRpbyA9IF9wb3dlcjMoMC4wNSk7XG4gICAgUHJvcFR3ZWVuID0gZ3NhcC5jb3JlLlByb3BUd2VlbjtcbiAgICBnc2FwLmNvbmZpZyh7XG4gICAgICByZXNpc3RhbmNlOiAxMDAsXG4gICAgICB1bml0RmFjdG9yczoge1xuICAgICAgICB0aW1lOiAxMDAwLFxuICAgICAgICB0b3RhbFRpbWU6IDEwMDAsXG4gICAgICAgIHByb2dyZXNzOiAxMDAwLFxuICAgICAgICB0b3RhbFByb2dyZXNzOiAxMDAwXG4gICAgICB9XG4gICAgfSk7XG4gICAgX2NvbmZpZyA9IGdzYXAuY29uZmlnKCk7XG4gICAgZ3NhcC5yZWdpc3RlclBsdWdpbihWZWxvY2l0eVRyYWNrZXIpO1xuICAgIF9jb3JlSW5pdHRlZCA9IDE7XG4gIH1cbn07XG5cbmV4cG9ydCB2YXIgSW5lcnRpYVBsdWdpbiA9IHtcbiAgdmVyc2lvbjogXCIzLjYuMVwiLFxuICBuYW1lOiBcImluZXJ0aWFcIixcbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUpIHtcbiAgICBnc2FwID0gY29yZTtcblxuICAgIF9pbml0Q29yZSgpO1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgX2NvcmVJbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuXG4gICAgdmFyIHRyYWNrZXIgPSBfZ2V0VHJhY2tlcih0YXJnZXQpO1xuXG4gICAgaWYgKHZhcnMgPT09IFwiYXV0b1wiKSB7XG4gICAgICBpZiAoIXRyYWNrZXIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiTm8gaW5lcnRpYSB0cmFja2luZyBvbiBcIiArIHRhcmdldCArIFwiLiBJbmVydGlhUGx1Z2luLnRyYWNrKHRhcmdldCkgZmlyc3QuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhcnMgPSB0cmFja2VyLmdldEFsbCgpO1xuICAgIH1cblxuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMudHdlZW4gPSB0d2VlbjtcbiAgICBfcHJvY2Vzc2luZ1ZhcnMgPSB2YXJzOyAvLyBnZXRzIHN3YXBwZWQgaW5zaWRlIF9jYWxjdWxhdGVUd2VlbkR1cmF0aW9uKCkgaWYgdGhlcmUncyBhIGZ1bmN0aW9uLWJhc2VkIHZhbHVlIGVuY291bnRlcmVkICh0byBhdm9pZCBkb3VibGUtY2FsbGluZyBpdClcblxuICAgIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgICAgICAgZ2V0VmFsID0gY2FjaGUuZ2V0LFxuICAgICAgICBkdXIgPSB2YXJzLmR1cmF0aW9uLFxuICAgICAgICBkdXJJc09iaiA9IF9pc09iamVjdChkdXIpLFxuICAgICAgICBwcmV2ZW50T3ZlcnNob290ID0gdmFycy5wcmV2ZW50T3ZlcnNob290IHx8IGR1cklzT2JqICYmIGR1ci5vdmVyc2hvb3QgPT09IDAsXG4gICAgICAgIHJlc2lzdGFuY2UgPSBfZ2V0TnVtT3JEZWZhdWx0KHZhcnMsIFwicmVzaXN0YW5jZVwiLCBfY29uZmlnLnJlc2lzdGFuY2UpLFxuICAgICAgICBkdXJhdGlvbiA9IF9pc051bWJlcihkdXIpID8gZHVyIDogX2NhbGN1bGF0ZVR3ZWVuRHVyYXRpb24odGFyZ2V0LCB2YXJzLCBkdXJJc09iaiAmJiBkdXIubWF4IHx8IDEwLCBkdXJJc09iaiAmJiBkdXIubWluIHx8IDAuMiwgZHVySXNPYmogJiYgXCJvdmVyc2hvb3RcIiBpbiBkdXIgPyArZHVyLm92ZXJzaG9vdCA6IHByZXZlbnRPdmVyc2hvb3QgPyAwIDogMSwgdHJ1ZSksXG4gICAgICAgIHAsXG4gICAgICAgIGN1clByb3AsXG4gICAgICAgIGN1clZhbCxcbiAgICAgICAgdW5pdCxcbiAgICAgICAgdmVsb2NpdHksXG4gICAgICAgIGNoYW5nZTEsXG4gICAgICAgIGVuZCxcbiAgICAgICAgY2hhbmdlMixcbiAgICAgICAgbGlua2VkUHJvcHM7XG5cbiAgICB2YXJzID0gX3Byb2Nlc3NpbmdWYXJzO1xuICAgIF9wcm9jZXNzaW5nVmFycyA9IDA7IC8vd2hlbiB0aGVyZSBhcmUgbGlua2VkUHJvcHMgKHR5cGljYWxseSBcIngseVwiIHdoZXJlIHNuYXBwaW5nIGhhcyB0byBmYWN0b3IgaW4gbXVsdGlwbGUgcHJvcGVydGllcywgd2UgbXVzdCBmaXJzdCBwb3B1bGF0ZSBhbiBvYmplY3Qgd2l0aCBhbGwgb2YgdGhvc2UgZW5kIHZhbHVlcywgdGhlbiBmZWVkIGl0IHRvIHRoZSBmdW5jdGlvbiB0aGF0IG1ha2UgYW55IG5lY2Vzc2FyeSBhbHRlcmF0aW9ucy4gU28gdGhlIHBvaW50IG9mIHRoaXMgZmlyc3QgbG9vcCBpcyB0byBzaW1wbHkgYnVpbGQgYW4gb2JqZWN0IChsaWtlIHt4OjEwMCwgeToyMDQuNX0pIGZvciBmZWVkaW5nIGludG8gdGhhdCBmdW5jdGlvbiB3aGljaCB3ZSdsbCBkbyBsYXRlciBpbiB0aGUgXCJyZWFsXCIgbG9vcC5cblxuICAgIGxpbmtlZFByb3BzID0gX3Byb2Nlc3NMaW5rZWRQcm9wcyh0YXJnZXQsIHZhcnMsIGdldFZhbCwgcmVzaXN0YW5jZSk7XG5cbiAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgaWYgKCFfcmVzZXJ2ZWRQcm9wc1twXSkge1xuICAgICAgICBjdXJQcm9wID0gdmFyc1twXTtcbiAgICAgICAgX2lzRnVuY3Rpb24oY3VyUHJvcCkgJiYgKGN1clByb3AgPSBjdXJQcm9wKGluZGV4LCB0YXJnZXQsIHRhcmdldHMpKTtcblxuICAgICAgICBpZiAoX2lzTnVtYmVyKGN1clByb3ApKSB7XG4gICAgICAgICAgdmVsb2NpdHkgPSBjdXJQcm9wO1xuICAgICAgICB9IGVsc2UgaWYgKF9pc09iamVjdChjdXJQcm9wKSAmJiAhaXNOYU4oY3VyUHJvcC52ZWxvY2l0eSkpIHtcbiAgICAgICAgICB2ZWxvY2l0eSA9ICtjdXJQcm9wLnZlbG9jaXR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0cmFja2VyICYmIHRyYWNrZXIuaXNUcmFja2luZyhwKSkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSB0cmFja2VyLmdldChwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRVJST1I6IE5vIHZlbG9jaXR5IHdhcyBkZWZpbmVkIGZvciBcIiArIHRhcmdldCArIFwiIHByb3BlcnR5OiBcIiArIHApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZTEgPSBfY2FsY3VsYXRlQ2hhbmdlKHZlbG9jaXR5LCBkdXJhdGlvbik7XG4gICAgICAgIGNoYW5nZTIgPSAwO1xuICAgICAgICBjdXJWYWwgPSBnZXRWYWwodGFyZ2V0LCBwKTtcbiAgICAgICAgdW5pdCA9IF9nZXRVbml0KGN1clZhbCk7XG4gICAgICAgIGN1clZhbCA9IHBhcnNlRmxvYXQoY3VyVmFsKTtcblxuICAgICAgICBpZiAoX2lzT2JqZWN0KGN1clByb3ApKSB7XG4gICAgICAgICAgZW5kID0gY3VyVmFsICsgY2hhbmdlMTtcblxuICAgICAgICAgIGlmIChcImVuZFwiIGluIGN1clByb3ApIHtcbiAgICAgICAgICAgIGN1clByb3AgPSBfcGFyc2VFbmQoY3VyUHJvcCwgbGlua2VkUHJvcHMgJiYgcCBpbiBsaW5rZWRQcm9wcyA/IGxpbmtlZFByb3BzIDogZW5kLCBjdXJQcm9wLm1heCwgY3VyUHJvcC5taW4sIHAsIHZhcnMucmFkaXVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXCJtYXhcIiBpbiBjdXJQcm9wICYmICtjdXJQcm9wLm1heCA8IGVuZCkge1xuICAgICAgICAgICAgaWYgKHByZXZlbnRPdmVyc2hvb3QgfHwgY3VyUHJvcC5wcmV2ZW50T3ZlcnNob290KSB7XG4gICAgICAgICAgICAgIGNoYW5nZTEgPSBjdXJQcm9wLm1heCAtIGN1clZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoYW5nZTIgPSBjdXJQcm9wLm1heCAtIGN1clZhbCAtIGNoYW5nZTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChcIm1pblwiIGluIGN1clByb3AgJiYgK2N1clByb3AubWluID4gZW5kKSB7XG4gICAgICAgICAgICBpZiAocHJldmVudE92ZXJzaG9vdCB8fCBjdXJQcm9wLnByZXZlbnRPdmVyc2hvb3QpIHtcbiAgICAgICAgICAgICAgY2hhbmdlMSA9IGN1clByb3AubWluIC0gY3VyVmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hhbmdlMiA9IGN1clByb3AubWluIC0gY3VyVmFsIC0gY2hhbmdlMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wcm9wcy5wdXNoKHApO1xuXG4gICAgICAgIHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LCBwLCBjdXJWYWwsIDAsIF9lbXB0eUZ1bmMsIDAsIGNhY2hlLnNldCh0YXJnZXQsIHAsIHRoaXMpKTtcbiAgICAgICAgdGhpcy5fcHQudSA9IHVuaXQgfHwgMDtcbiAgICAgICAgdGhpcy5fcHQuYzEgPSBjaGFuZ2UxO1xuICAgICAgICB0aGlzLl9wdC5jMiA9IGNoYW5nZTI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHdlZW4uZHVyYXRpb24oZHVyYXRpb24pO1xuICAgIHJldHVybiBfYm9udXNWYWxpZGF0ZWQ7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHJhdGlvLCBkYXRhKSB7XG4gICAgdmFyIHB0ID0gZGF0YS5fcHQ7XG4gICAgcmF0aW8gPSBfcG93ZXIzKGRhdGEudHdlZW4uX3RpbWUgLyBkYXRhLnR3ZWVuLl9kdXIpO1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBwdC5zZXQocHQudCwgcHQucCwgX3JvdW5kKHB0LnMgKyBwdC5jMSAqIHJhdGlvICsgcHQuYzIgKiByYXRpbyAqIHJhdGlvKSArIHB0LnUsIHB0LmQsIHJhdGlvKTtcbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuICB9XG59O1xuXCJ0cmFjayx1bnRyYWNrLGlzVHJhY2tpbmcsZ2V0VmVsb2NpdHksZ2V0QnlUYXJnZXRcIi5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gSW5lcnRpYVBsdWdpbltuYW1lXSA9IFZlbG9jaXR5VHJhY2tlcltuYW1lXTtcbn0pO1xuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKEluZXJ0aWFQbHVnaW4pO1xuZXhwb3J0IHsgSW5lcnRpYVBsdWdpbiBhcyBkZWZhdWx0LCBWZWxvY2l0eVRyYWNrZXIgfTsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8vIEdTQVAgTGlicmFyeVxuaW1wb3J0IHsgZ3NhcCB9IGZyb20gJ2dzYXAnO1xuaW1wb3J0IHsgRHJhZ2dhYmxlIH0gZnJvbSAnZ3NhcC9EcmFnZ2FibGUnO1xuaW1wb3J0IEluZXJ0aWFQbHVnaW4gZnJvbSAnLi9JbmVydGlhUGx1Z2luJztcbmdzYXAucmVnaXN0ZXJQbHVnaW4oRHJhZ2dhYmxlLCBJbmVydGlhUGx1Z2luKTsgLy8gQXBwXG5cbmltcG9ydCBhcHBDb3JlIGZyb20gJy4uL2FwcC9hcHBDb3JlJztcbmltcG9ydCBhcHBTdG9yZSBmcm9tICcuLi9hcHAvYXBwU3RvcmUnO1xuaW1wb3J0IGFwcFVpIGZyb20gJy4uL2FwcC9hcHBVaSc7IC8vIFV0aWxpdGllc1xuXG5pbXBvcnQgRG9tRXZlbnRzIGZyb20gJy4vZG9tRXZlbnRzJztcblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307IC8vZXNsaW50LWRpc2FibGUtbGluZVxuXG5cbnZhciBfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIF9kZWZhdWx0KG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgLy8gU3RvcmVcbiAgICB0aGlzLmFwcFN0b3JlID0gYXBwU3RvcmU7IC8vIEFwcCByZWZlcmVuY2VzXG4gICAgLy8gdGhpcy5hcHBDb3JlID0gbmV3IGFwcENvcmUoKTtcbiAgICAvLyB0aGlzLmFwcFVpID0gbmV3IGFwcFVpKCk7XG4gICAgLy8gSG9vayBmdW5jdGlvbnNcblxuICAgIHRoaXMuX29uU3RhcnQgPSBvcHRpb25zLm9uU3RhcnQgfHwgbm9vcDtcbiAgICB0aGlzLl9vblJhZiA9IG9wdGlvbnMub25SYWYgfHwgbm9vcDtcbiAgICB0aGlzLl9vbkNsaWNrID0gb3B0aW9ucy5vbkNsaWNrIHx8IG5vb3A7XG4gICAgdGhpcy5fb25QcmVzcyA9IG9wdGlvbnMub25QcmVzcyB8fCBub29wO1xuICAgIHRoaXMuX29uUmVsZWFzZSA9IG9wdGlvbnMub25SZWxlYXNlIHx8IG5vb3A7XG4gICAgdGhpcy5fb25SZWxlYXNlQ29tcGxldGUgPSBvcHRpb25zLm9uUmVsZWFzZUNvbXBsZXRlIHx8IG5vb3A7XG4gICAgdGhpcy5fb25JdGVtRW50ZXIgPSBvcHRpb25zLm9uSXRlbUVudGVyIHx8IG5vb3A7XG4gICAgdGhpcy5fb25JdGVtTGVhdmUgPSBvcHRpb25zLm9uSXRlbUxlYXZlIHx8IG5vb3A7XG4gICAgdGhpcy5fb25JdGVtQ2xpY2sgPSBvcHRpb25zLm9uSXRlbUNsaWNrIHx8IG5vb3A7XG4gICAgdGhpcy5kb21FdmVudHMgPSBuZXcgRG9tRXZlbnRzKCk7XG4gICAgdGhpcy4kZWwgPSBvcHRpb25zLmVsO1xuICAgIHRoaXMuJHNsaWRlciA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5zbGlkZXInKTtcbiAgICB0aGlzLiRzbGlkZXJJbm5lciA9IHRoaXMuJHNsaWRlci5xdWVyeVNlbGVjdG9yKCcuc2xpZGVyX19pbm5lcicpO1xuICAgIHRoaXMuJHNsaWRlckl0ZW1zID0gdGhpcy4kc2xpZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zbGlkZXJfX2l0ZW0nKTtcbiAgICB0aGlzLiRwcm94eSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGluaXQ6IGZhbHNlLFxuICAgICAgYm91bmRzOiBudWxsLFxuICAgICAgaW5uZXJCb3VuZHM6IG51bGwsXG4gICAgICBzbmFwOiB0eXBlb2Ygb3B0aW9ucy5zbmFwICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuc25hcCA6IGZhbHNlLFxuICAgICAgc25hcFRvOiB0eXBlb2Ygb3B0aW9ucy5zbmFwVG8gIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5zbmFwVG8gOiAnY2VudGVyJyxcbiAgICAgIHNuYXBQb2ludHM6IFtdLFxuICAgICAgc25hcHBpbmc6IGZhbHNlLFxuICAgICAgbGl2ZVBvc2l0aW9uOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LFxuICAgICAgZG90czogb3B0aW9ucy5kb3RzLFxuICAgICAgcGVyY2VudDogMCxcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgcHJvZ3Jlc3NPcmlnaW46IDBcbiAgICB9O1xuICAgIHRoaXMuaXNEZXNrdG9wID0gd2luZG93LmlubmVyV2lkdGggPj0gMTAyNDtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGlzVG91Y2hEZXZpY2UgPSBmdW5jdGlvbiBpc1RvdWNoRGV2aWNlKCkge1xuICAgICAgICByZXR1cm4gJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAgfHwgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgPiAwO1xuICAgICAgfTtcblxuICAgICAgdmFyIF9pc1RvdWNoRGV2aWNlID0gaXNUb3VjaERldmljZSgpO1xuXG4gICAgICB2YXIgbGVycCA9IGZ1bmN0aW9uIGxlcnAodmFsdWUxLCB2YWx1ZTIsIGFtb3VudCkge1xuICAgICAgICBhbW91bnQgPSBhbW91bnQgPCAwID8gMCA6IGFtb3VudDtcbiAgICAgICAgYW1vdW50ID0gYW1vdW50ID4gMSA/IDEgOiBhbW91bnQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTEgKyAodmFsdWUyIC0gdmFsdWUxKSAqIGFtb3VudDtcbiAgICAgIH07XG5cbiAgICAgIHZhciByQUYgPSBmdW5jdGlvbiByQUYoKSB7XG4gICAgICAgIF90aGlzLm9wdGlvbnMucGVyY2VudCA9IF90aGlzLmRyYWdnYWJsZVswXS54IC8gX3RoaXMuZHJhZ2dhYmxlWzBdLm1pblg7XG4gICAgICAgIF90aGlzLm9wdGlvbnMucHJvZ3Jlc3MgPSBfdGhpcy5kcmFnZ2FibGVbMF0ueCAvIChfdGhpcy5kcmFnZ2FibGVbMF0ubWluWCAtIF90aGlzLiRzbGlkZXIub2Zmc2V0V2lkdGggfHwgMSk7XG5cbiAgICAgICAgaWYgKCFfaXNUb3VjaERldmljZSkge1xuICAgICAgICAgIF90aGlzLm9wdGlvbnMubGl2ZVBvc2l0aW9uLnggPSBsZXJwKF90aGlzLm9wdGlvbnMubGl2ZVBvc2l0aW9uLngsIF90aGlzLm9wdGlvbnMucG9zaXRpb24ueCwgMC4xKTtcbiAgICAgICAgICBnc2FwLnNldChfdGhpcy4kc2xpZGVySW5uZXIsIHtcbiAgICAgICAgICAgIHg6IF90aGlzLm9wdGlvbnMubGl2ZVBvc2l0aW9uLnhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLl9vblJhZihfdGhpcy5vcHRpb25zLnBlcmNlbnQsIF90aGlzLm9wdGlvbnMucHJvZ3Jlc3MsIF90aGlzLm9wdGlvbnMucHJvZ3Jlc3NPcmlnaW4pO1xuICAgICAgfTtcblxuICAgICAgdmFyIHJBRlRvdWNoZWQgPSBmdW5jdGlvbiByQUZUb3VjaGVkKCkge1xuICAgICAgICBfdGhpcy5vcHRpb25zLnBlcmNlbnQgPSBfdGhpcy5kcmFnZ2FibGVbMF0ueCAvIF90aGlzLmRyYWdnYWJsZVswXS5taW5YO1xuICAgICAgICBfdGhpcy5vcHRpb25zLnByb2dyZXNzID0gX3RoaXMuZHJhZ2dhYmxlWzBdLnggLyAoX3RoaXMuZHJhZ2dhYmxlWzBdLm1pblggLSBfdGhpcy4kc2xpZGVyLm9mZnNldFdpZHRoIHx8IDEpO1xuXG4gICAgICAgIF90aGlzLl9vblJhZihfdGhpcy5vcHRpb25zLnBlcmNlbnQsIF90aGlzLm9wdGlvbnMucHJvZ3Jlc3MsIF90aGlzLm9wdGlvbnMucHJvZ3Jlc3NPcmlnaW4pO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5vcHRpb25zLmJvdW5kcyA9IHRoaXMuJHNsaWRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRoaXMub3B0aW9ucy5pbm5lckJvdW5kcyA9IHRoaXMuJHNsaWRlcklubmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKE1hdGgucm91bmQodGhpcy5vcHRpb25zLmlubmVyQm91bmRzLndpZHRoKSA8PSBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5ib3VuZHMud2lkdGgpKSB0aGlzLiRzbGlkZXIuY2xhc3NMaXN0LnJlbW92ZSgnc2xpZGVyLS1pbml0aWFsaXplZCcpO2Vsc2UgdGhpcy4kc2xpZGVyLmNsYXNzTGlzdC5hZGQoJ3NsaWRlci0taW5pdGlhbGl6ZWQnKTtcblxuICAgICAgaWYgKCFfaXNUb3VjaERldmljZSkge1xuICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IERyYWdnYWJsZS5jcmVhdGUodGhpcy4kcHJveHksIHtcbiAgICAgICAgICB0eXBlOiAneCcsXG4gICAgICAgICAgdHJpZ2dlcjogdGhpcy4kc2xpZGVySW5uZXIsXG4gICAgICAgICAgYm91bmRzOiB7XG4gICAgICAgICAgICBtYXhYOiAwLFxuICAgICAgICAgICAgbWluWDogLSh0aGlzLm9wdGlvbnMuaW5uZXJCb3VuZHMud2lkdGggLSB0aGlzLm9wdGlvbnMuYm91bmRzLndpZHRoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhyb3dQcm9wczogdHJ1ZSxcbiAgICAgICAgICBlZGdlUmVzaXN0YW5jZTogMC45NSxcbiAgICAgICAgICBkcmFnUmVzaXN0YW5jZTogMCxcbiAgICAgICAgICBzbmFwOiB0aGlzLm9wdGlvbnMuc25hcCA/IHtcbiAgICAgICAgICAgIHg6IHRoaXMub3B0aW9ucy5zbmFwUG9pbnRzXG4gICAgICAgICAgfSA6IGZhbHNlLFxuICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICAgICAgICBfdGhpcy5fb25DbGljaygpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25QcmVzczogZnVuY3Rpb24gb25QcmVzcygpIHtcbiAgICAgICAgICAgIF90aGlzLl9vblByZXNzKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblJlbGVhc2U6IGZ1bmN0aW9uIG9uUmVsZWFzZSgpIHtcbiAgICAgICAgICAgIF90aGlzLl9vblJlbGVhc2UoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRHJhZ1N0YXJ0OiBmdW5jdGlvbiBvbkRyYWdTdGFydCgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5raWxsUmFmKTtcbiAgICAgICAgICAgIGdzYXAudGlja2VyLmFkZChyQUYpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25EcmFnOiBmdW5jdGlvbiBvbkRyYWcoKSB7XG4gICAgICAgICAgICBfdGhpcy5vcHRpb25zLnBvc2l0aW9uLnggPSBfdGhpcy5kcmFnZ2FibGVbMF0ueDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uVGhyb3dVcGRhdGU6IGZ1bmN0aW9uIG9uVGhyb3dVcGRhdGUoKSB7XG4gICAgICAgICAgICBfdGhpcy5vcHRpb25zLnBvc2l0aW9uLnggPSBfdGhpcy5kcmFnZ2FibGVbMF0ueDtcblxuICAgICAgICAgICAgX3RoaXMudXBkYXRlRG90cygpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25UaHJvd0NvbXBsZXRlOiBmdW5jdGlvbiBvblRocm93Q29tcGxldGUoKSB7XG4gICAgICAgICAgICBfdGhpcy5fb25SZWxlYXNlQ29tcGxldGUoKTtcblxuICAgICAgICAgICAgX3RoaXMua2lsbFJhZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBnc2FwLnRpY2tlci5yZW1vdmUockFGKTtcbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IERyYWdnYWJsZS5jcmVhdGUodGhpcy4kc2xpZGVySW5uZXIsIHtcbiAgICAgICAgICB0eXBlOiAneCcsXG4gICAgICAgICAgYm91bmRzOiB7XG4gICAgICAgICAgICBtYXhYOiAwLFxuICAgICAgICAgICAgbWluWDogLSh0aGlzLm9wdGlvbnMuaW5uZXJCb3VuZHMud2lkdGggLSB0aGlzLm9wdGlvbnMuYm91bmRzLndpZHRoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhyb3dQcm9wczogdHJ1ZSxcbiAgICAgICAgICBlZGdlUmVzaXN0YW5jZTogMC44LFxuICAgICAgICAgIGRyYWdSZXNpc3RhbmNlOiAwLFxuICAgICAgICAgIHNuYXA6IHRoaXMub3B0aW9ucy5zbmFwID8ge1xuICAgICAgICAgICAgeDogdGhpcy5vcHRpb25zLnNuYXBQb2ludHNcbiAgICAgICAgICB9IDogZmFsc2UsXG4gICAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgICAgICAgIF90aGlzLl9vbkNsaWNrKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblByZXNzOiBmdW5jdGlvbiBvblByZXNzKCkge1xuICAgICAgICAgICAgX3RoaXMuX29uUHJlc3MoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uUmVsZWFzZTogZnVuY3Rpb24gb25SZWxlYXNlKCkge1xuICAgICAgICAgICAgX3RoaXMuX29uUmVsZWFzZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25EcmFnOiBmdW5jdGlvbiBvbkRyYWcoKSB7XG4gICAgICAgICAgICByQUZUb3VjaGVkKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblRocm93VXBkYXRlOiBmdW5jdGlvbiBvblRocm93VXBkYXRlKCkge1xuICAgICAgICAgICAgckFGVG91Y2hlZCgpOyAvLyB0aGlzLnVwZGF0ZURvdHMoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uVGhyb3dDb21wbGV0ZTogZnVuY3Rpb24gb25UaHJvd0NvbXBsZXRlKCkge1xuICAgICAgICAgICAgX3RoaXMuX29uUmVsZWFzZUNvbXBsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zLnBlcmNlbnQgPSB0aGlzLmRyYWdnYWJsZVswXS54IC8gdGhpcy5kcmFnZ2FibGVbMF0ubWluWDtcbiAgICAgIHRoaXMub3B0aW9ucy5wcm9ncmVzc09yaWdpbiA9IC0odGhpcy5vcHRpb25zLmJvdW5kcy53aWR0aCAvICh0aGlzLmRyYWdnYWJsZVswXS5taW5YIC0gdGhpcy5vcHRpb25zLmJvdW5kcy53aWR0aCkpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJHNsaWRlckl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRzLmFkZCh0aGlzLiRzbGlkZXJJdGVtc1tpXSwgJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoZSwgYSwgZWwpIHtcbiAgICAgICAgICBfdGhpcy5fb25JdGVtRW50ZXIoZSwgYSwgZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kb21FdmVudHMuYWRkKHRoaXMuJHNsaWRlckl0ZW1zW2ldLCAnbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChlLCBhLCBlbCkge1xuICAgICAgICAgIF90aGlzLl9vbkl0ZW1MZWF2ZShlLCBhLCBlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRvbUV2ZW50cy5hZGQodGhpcy4kc2xpZGVySXRlbXNbaV0sICdjbGljaycsIGZ1bmN0aW9uIChlLCBhLCBlbCkge1xuICAgICAgICAgIF90aGlzLl9vbkl0ZW1DbGljayhlLCBhLCBlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV9pc1RvdWNoRGV2aWNlKSByQUYoKTtlbHNlIHJBRlRvdWNoZWQoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG90cykgdGhpcy5jcmVhdGVEb3RzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZURvdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRG90cygpIHtcbiAgICAgIHRoaXMuJHNsaWRlckRvdHMgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuc2xpZGVyX19kb3RzJyk7XG5cbiAgICAgIGlmICh0aGlzLiRzbGlkZXJEb3RzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kc2xpZGVySXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLiRkb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0aGlzLiRkb3QuY2xhc3NOYW1lID0gJ2RvdHNfX2l0ZW0nO1xuICAgICAgICAgIHRoaXMuJHNsaWRlckRvdHMuYXBwZW5kQ2hpbGQodGhpcy4kZG90KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGRvdHMgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKCcuZG90c19faXRlbScpO1xuICAgICAgICB0aGlzLiRkb3RzWzBdLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVEb3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURvdHMoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNuYXAgJiYgdGhpcy5vcHRpb25zLmRvdHMgJiYgIXRoaXMuaXNEZXNrdG9wKSB7XG4gICAgICAgIHRoaXMuJHNsaWRlckRvdHMuY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGUuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZ29hbCA9IHRoaXMuZHJhZ2dhYmxlWzBdLng7XG4gICAgICAgIHZhciBjbG9zZXN0ID0gdGhpcy5vcHRpb25zLnNuYXBQb2ludHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGN1cnIgLSBnb2FsKSA8IE1hdGguYWJzKHByZXYgLSBnb2FsKSA/IGN1cnIgOiBwcmV2O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5vcHRpb25zLnNuYXBQb2ludHMuaW5kZXhPZihjbG9zZXN0KTtcbiAgICAgICAgdGhpcy4kZG90c1tpbmRleF0uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEJvdW5kc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRCb3VuZHMoKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuYm91bmRzID0gdGhpcy4kc2xpZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGhpcy5vcHRpb25zLmlubmVyQm91bmRzID0gdGhpcy4kc2xpZGVySW5uZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0aGlzLm9wdGlvbnMucGVyY2VudCA9IHRoaXMuZHJhZ2dhYmxlWzBdLnggLyB0aGlzLmRyYWdnYWJsZVswXS5taW5YO1xuICAgICAgdGhpcy5vcHRpb25zLnByb2dyZXNzT3JpZ2luID0gLSh0aGlzLm9wdGlvbnMuYm91bmRzLndpZHRoIC8gKHRoaXMuZHJhZ2dhYmxlWzBdLm1pblggLSB0aGlzLm9wdGlvbnMuYm91bmRzLndpZHRoKSk7XG4gICAgICB2YXIgbWluWCA9IC0odGhpcy5vcHRpb25zLmlubmVyQm91bmRzLndpZHRoIC0gdGhpcy5vcHRpb25zLmJvdW5kcy53aWR0aCk7XG4gICAgICB0aGlzLm9wdGlvbnMucG9zaXRpb24ueCA9IG1pblggKiB0aGlzLm9wdGlvbnMucGVyY2VudDtcbiAgICAgIHRoaXMub3B0aW9ucy5saXZlUG9zaXRpb24ueCA9IG1pblggKiB0aGlzLm9wdGlvbnMucGVyY2VudDtcbiAgICAgIGdzYXAuc2V0KHRoaXMuJHByb3h5LCB7XG4gICAgICAgIHg6IG1pblggKiB0aGlzLm9wdGlvbnMucGVyY2VudFxuICAgICAgfSk7XG4gICAgICBnc2FwLnNldCh0aGlzLiRzbGlkZXJJbm5lciwge1xuICAgICAgICB4OiBtaW5YICogdGhpcy5vcHRpb25zLnBlcmNlbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICB0aGlzLmRyYWdnYWJsZVswXS5hcHBseUJvdW5kcyh7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIG1pblg6IC0odGhpcy5vcHRpb25zLmlubmVyQm91bmRzLndpZHRoIC0gdGhpcy5vcHRpb25zLmJvdW5kcy53aWR0aCksXG4gICAgICAgIG1heFg6IDBcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kcmFnZ2FibGVbMF0udXBkYXRlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFNuYXBQb2ludHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U25hcFBvaW50cygpIHtcbiAgICAgIGlmIChNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5pbm5lckJvdW5kcy53aWR0aCkgPD0gTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMuYm91bmRzLndpZHRoKSkgdGhpcy4kc2xpZGVyLmNsYXNzTGlzdC5yZW1vdmUoJ3NsaWRlci0taW5pdGlhbGl6ZWQnKTtlbHNlIHRoaXMuJHNsaWRlci5jbGFzc0xpc3QuYWRkKCdzbGlkZXItLWluaXRpYWxpemVkJyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc25hcCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc25hcFBvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLm9wdGlvbnMuc25hcFBvaW50cy5wdXNoKHRoaXMuZHJhZ2dhYmxlWzBdLm1heFgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy4kc2xpZGVySXRlbXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbmFwVG8gPT09ICdjZW50ZXInKSB0aGlzLm9wdGlvbnMuc25hcFBvaW50cy5wdXNoKC10aGlzLiRzbGlkZXJJdGVtc1tpXS5vZmZzZXRMZWZ0ICsgdGhpcy5vcHRpb25zLmJvdW5kcy53aWR0aCAvIDIgLSB0aGlzLiRzbGlkZXJJdGVtc1tpXS5vZmZzZXRXaWR0aCAvIDIpO2Vsc2UgaWYgKHRoaXMub3B0aW9ucy5zbmFwVG8gPT09ICdsZWZ0JykgdGhpcy5vcHRpb25zLnNuYXBQb2ludHMucHVzaCgtdGhpcy4kc2xpZGVySXRlbXNbaV0ub2Zmc2V0TGVmdCk7ZWxzZSBpZiAodGhpcy5vcHRpb25zLnNuYXBUbyA9PT0gJ3JpZ2h0JykgdGhpcy5vcHRpb25zLnNuYXBQb2ludHMucHVzaCgtdGhpcy4kc2xpZGVySXRlbXNbaV0ub2Zmc2V0TGVmdCArIHRoaXMub3B0aW9ucy5ib3VuZHMud2lkdGggLSB0aGlzLiRzbGlkZXJJdGVtc1tpXS5vZmZzZXRXaWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wdGlvbnMuc25hcFBvaW50cy5wdXNoKHRoaXMuZHJhZ2dhYmxlWzBdLm1pblgpO1xuICAgICAgICB0aGlzLmRyYWdnYWJsZVswXS52YXJzLnNuYXAueCA9IHRoaXMub3B0aW9ucy5zbmFwUG9pbnRzO1xuICAgICAgICB0aGlzLmRyYWdnYWJsZVswXS51cGRhdGUodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrU3RhdHVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrU3RhdHVzKCkge1xuICAgICAgaWYgKE1hdGgucm91bmQodGhpcy5vcHRpb25zLmlubmVyQm91bmRzLndpZHRoKSA8PSBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5ib3VuZHMud2lkdGgpKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlWzBdLmRpc2FibGUoKTtcbiAgICAgICAgZ3NhcC5zZXQodGhpcy4kc2xpZGVySW5uZXIsIHtcbiAgICAgICAgICB4OiAwXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kcmFnZ2FibGVbMF0uZW5hYmxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZURpcmVjdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlyZWN0aW9ucygpIHsvLyBpZiAodGhpcy5nZXREaXJlY3Rpb24oJ3ZlbG9jaXR5JykgPT09ICdsZWZ0JylcbiAgICAgIC8vIHtcbiAgICAgIC8vIH1cbiAgICAgIC8vIGVsc2Uge1xuICAgICAgLy8gfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgdGhpcy5zZXRCb3VuZHMoKTtcbiAgICAgIHRoaXMuc2V0U25hcFBvaW50cygpO1xuICAgICAgdGhpcy51cGRhdGVEb3RzKCk7XG4gICAgICB0aGlzLmNoZWNrU3RhdHVzKCk7XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5kcmFnZ2FibGVbMF0ua2lsbCgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oKTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLy8gR1NBUCBMaWJyYXJ5XG5pbXBvcnQgeyBnc2FwIH0gZnJvbSAnZ3NhcCc7XG5pbXBvcnQgU3BsaXRUZXh0IGZyb20gJy4uL2NsYXNzZXMvc3BsaXRUZXh0JzsgLy8gQXBwXG5cbmltcG9ydCBhcHBTdG9yZSBmcm9tICcuLi9hcHAvYXBwU3RvcmUnO1xuaW1wb3J0IGFwcENvcmUgZnJvbSAnLi4vYXBwL2FwcENvcmUnO1xuaW1wb3J0IGFwcFVpIGZyb20gJy4uL2FwcC9hcHBVaSc7IC8vIFV0aWxpdGllc1xuXG5pbXBvcnQgRG9tRXZlbnRzIGZyb20gJy4uL2NsYXNzZXMvZG9tRXZlbnRzJztcbmltcG9ydCB7IFJlZEZvcm1hdCB9IGZyb20gJ3RocmVlJztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG52YXIgX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfZGVmYXVsdChvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIC8vIFN0b3JlXG4gICAgdGhpcy5hcHBTdG9yZSA9IGFwcFN0b3JlOyAvLyBBcHAgcmVmZXJlbmNlc1xuXG4gICAgdGhpcy5hcHBVaSA9IG5ldyBhcHBVaSgpO1xuICAgIHRoaXMuYXBwQ29yZSA9IG5ldyBhcHBDb3JlKCk7XG4gICAgdGhpcy5kb21FdmVudHMgPSBuZXcgRG9tRXZlbnRzKCk7XG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIHRoaXMuX3NsaWRlciA9IHtcbiAgICAgIHRhcmdldDogb3B0aW9ucy50YXJnZXQsXG4gICAgICBjdXJyZW50OiAwLFxuICAgICAgdG90YWw6IDAsXG4gICAgICBkaXJlY3Rpb246ICduZXh0JyxcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgcHJldjogMCxcbiAgICAgIG5leHQ6IDAsXG4gICAgICBkaXI6IDEsXG4gICAgICBuYXZpZ2F0aW9uUHJvZ3Jlc3MxOiAwLFxuICAgICAgbmF2aWdhdGlvblByb2dyZXNzMjogMCxcbiAgICAgIGR1cmF0aW9uOiAxLjIsXG4gICAgICBkZWxheTogdHlwZW9mIG9wdGlvbnMuZGVsYXkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5kZWxheSA6IDQsXG4gICAgICBlYXNlOiAnZXhwby5pbk91dCcsXG4gICAgICBhbmltYXRpbmc6IHRydWUsXG4gICAgICB0bEFuaW1hdGlvbjogbnVsbCxcbiAgICAgIGF1dG9wbGF5OiB0eXBlb2Ygb3B0aW9ucy5hdXRvcGxheSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmF1dG9wbGF5IDogdHJ1ZSxcbiAgICAgIGF1dG9wbGF5U3BlZWQ6IHR5cGVvZiBvcHRpb25zLmF1dG9wbGF5U3BlZWQgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5hdXRvcGxheVNwZWVkIDogNCxcbiAgICAgIGF1dG9wbGF5UHJvZ3Jlc3M6IDAsXG4gICAgICBhdXRvcGxheUNvbnRyb2xsZXI6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuc2VsZWN0b3JzKCk7XG4gICAgdGhpcy5pbml0KCk7XG4gICAgdGhpcy5ldmVudHMoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwic2VsZWN0b3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdG9ycygpIHtcbiAgICAgIC8vIFNlbGVjdG9yc1xuICAgICAgdGhpcy4kc2xpZGVyID0gdGhpcy5fc2xpZGVyLnRhcmdldDtcbiAgICAgIHRoaXMuJHNsaWRlcklubmVyID0gdGhpcy4kc2xpZGVyLnF1ZXJ5U2VsZWN0b3IoJy5zbGlkZXJfX2lubmVyJyk7XG4gICAgICB0aGlzLiRzbGlkZXJJdGVtcyA9IHRoaXMuJHNsaWRlcklubmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zbGlkZXJfX2l0ZW0nKTtcbiAgICAgIHRoaXMuJHNsaWRlck5hdmlnYXRpb24gPSB0aGlzLiRzbGlkZXIucXVlcnlTZWxlY3RvckFsbCgnLnNsaWRlcl9fbmF2aWdhdGlvbicpO1xuICAgICAgdGhpcy4kc2xpZGVyTmF2aWdhdGlvblByZXYgPSB0aGlzLiRzbGlkZXIucXVlcnlTZWxlY3RvcignLnNsaWRlcl9fbmF2aWdhdGlvbi0tcHJldicpO1xuICAgICAgdGhpcy4kc2xpZGVyTmF2aWdhdGlvbk5leHQgPSB0aGlzLiRzbGlkZXIucXVlcnlTZWxlY3RvcignLnNsaWRlcl9fbmF2aWdhdGlvbi0tbmV4dCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5kb21FdmVudHMuYWRkKHRoaXMuJHNsaWRlck5hdmlnYXRpb25QcmV2LCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgICBnc2FwLnRvKF90aGlzLiRzbGlkZXJOYXZpZ2F0aW9uUHJldi5jaGlsZHJlblswXSwge1xuICAgICAgICAgICAgY2xpcFBhdGg6ICdjaXJjbGUoMTAlIGF0IDUwJSA1MCUpJyxcbiAgICAgICAgICAgIHdlYmtpdENsaXBQYXRoOiAnY2lyY2xlKDEwJSBhdCA1MCUgNTAlKScsXG4gICAgICAgICAgICBkdXJhdGlvbjogMixcbiAgICAgICAgICAgIGVhc2U6ICdleHBvLm91dCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnc2FwLnNldChfdGhpcy4kc2xpZGVyTmF2aWdhdGlvblByZXYsIHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgICAgIGdzYXAuZGVsYXllZENhbGwoMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGdzYXAuc2V0KF90aGlzLiRzbGlkZXJOYXZpZ2F0aW9uUHJldiwge1xuICAgICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ2luaXRpYWwnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMudXBkYXRlTmF2aWdhdGlvbigncHJldicpO1xuXG4gICAgICAgIF90aGlzLmNvbnRyb2xsQXV0b3BsYXkoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kb21FdmVudHMuYWRkKHRoaXMuJHNsaWRlck5hdmlnYXRpb25OZXh0LCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgICBnc2FwLnRvKF90aGlzLiRzbGlkZXJOYXZpZ2F0aW9uTmV4dC5jaGlsZHJlblswXSwge1xuICAgICAgICAgICAgY2xpcFBhdGg6ICdjaXJjbGUoMTAlIGF0IDUwJSA1MCUpJyxcbiAgICAgICAgICAgIHdlYmtpdENsaXBQYXRoOiAnY2lyY2xlKDEwJSBhdCA1MCUgNTAlKScsXG4gICAgICAgICAgICBkdXJhdGlvbjogMixcbiAgICAgICAgICAgIGVhc2U6ICdleHBvLm91dCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnc2FwLnNldChfdGhpcy4kc2xpZGVyTmF2aWdhdGlvbk5leHQsIHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgICAgIGdzYXAuZGVsYXllZENhbGwoMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGdzYXAuc2V0KF90aGlzLiRzbGlkZXJOYXZpZ2F0aW9uTmV4dCwge1xuICAgICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ2luaXRpYWwnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMudXBkYXRlTmF2aWdhdGlvbignbmV4dCcpO1xuXG4gICAgICAgIF90aGlzLmNvbnRyb2xsQXV0b3BsYXkoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRzbGlkZXJOYXZpZ2F0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5kb21FdmVudHMuYWRkKHRoaXMuJHNsaWRlck5hdmlnYXRpb25baV0sICdtb3VzZWVudGVyJywgZnVuY3Rpb24gKGEsIGUsIGVsKSB7XG4gICAgICAgICAgICBfdGhpcy5lbnRlck5hdmlnYXRpb24oYSwgZSwgZWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZG9tRXZlbnRzLmFkZCh0aGlzLiRzbGlkZXJOYXZpZ2F0aW9uW2ldLCAnbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChhLCBlLCBlbCkge1xuICAgICAgICAgICAgX3RoaXMubGVhdmVOYXZpZ2F0aW9uKGEsIGUsIGVsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJHNsaWRlckxpbmtzID0gdGhpcy4kc2xpZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5saW5rJyk7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuJHNsaWRlckxpbmtzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIHRoaXMuZG9tRXZlbnRzLmFkZCh0aGlzLiRzbGlkZXJMaW5rc1tfaV0sICdtb3VzZWVudGVyJywgZnVuY3Rpb24gKGEsIGUsIGVsKSB7XG4gICAgICAgICAgICBnc2FwLnRvKGVsLnF1ZXJ5U2VsZWN0b3IoJy51bmRlcmxpbmUnKSwge1xuICAgICAgICAgICAgICBzY2FsZVg6IDAsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjYsXG4gICAgICAgICAgICAgIGVhc2U6ICdleHBvLmluT3V0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5kb21FdmVudHMuYWRkKHRoaXMuJHNsaWRlckxpbmtzW19pXSwgJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoYSwgZSwgZWwpIHtcbiAgICAgICAgICAgIGdzYXAudG8oZWwucXVlcnlTZWxlY3RvcignLnVuZGVybGluZScpLCB7XG4gICAgICAgICAgICAgIHNjYWxlWDogMSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDAuNixcbiAgICAgICAgICAgICAgZWFzZTogJ2V4cG8uaW5PdXQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gU2V0IHRvdGFsIGNvdW50XG4gICAgICB0aGlzLl9zbGlkZXIudG90YWwgPSB0aGlzLiRzbGlkZXJJdGVtcy5sZW5ndGg7IC8vIFNldCBhbGwgc2xpZGVzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kc2xpZGVySXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLyogSXRlbXMgKi9cbiAgICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSBnc2FwLnNldCh0aGlzLiRzbGlkZXJJdGVtc1tpXSwge1xuICAgICAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0pO1xuICAgICAgICAvKiBUZXh0cyAqL1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3XG5cbiAgICAgICAgbmV3IFNwbGl0VGV4dCh0aGlzLiRzbGlkZXJJdGVtc1tpXS5xdWVyeVNlbGVjdG9yKCcudGl0bGUnKSwge1xuICAgICAgICAgIHR5cGU6ICdsaW5lcyB3b3JkcycsXG4gICAgICAgICAgbGluZXNDbGFzczogJ2xpbmUgbGluZS0tKysnLFxuICAgICAgICAgIHdvcmRzQ2xhc3M6ICd3b3JkIHdvcmQtLSsrJ1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuJHNsaWRlckl0ZW1zW2ldLnF1ZXJ5U2VsZWN0b3JBbGwoJy50aXRsZSAud29yZCcpLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZ3NhcC5zZXQodGhpcy4kc2xpZGVySXRlbXNbaV0ucXVlcnlTZWxlY3RvckFsbCgnLnRpdGxlIC53b3JkJylbal0sIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgICAgIHk6ICcxMDAlJyxcbiAgICAgICAgICAgIHJvdGF0aW9uOiAnM2RlZydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdzYXAuc2V0KHRoaXMuJHNsaWRlckl0ZW1zW2ldLnF1ZXJ5U2VsZWN0b3IoJy5saW5rJyksIHtcbiAgICAgICAgICBvcGFjaXR5OiAwLjAwMDFcbiAgICAgICAgfSk7XG4gICAgICAgIC8qIEJhY2tncm91bmRzICovXG5cbiAgICAgICAgaWYgKCF0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkgZ3NhcC5zZXQodGhpcy4kc2xpZGVySXRlbXNbaV0ucXVlcnlTZWxlY3RvcignLmJhY2tncm91bmQnKSwge1xuICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gU2V0IGN1cnJlbnQgc2xpZGVcblxuICAgICAgLyogSXRlbXMgKi9cblxuXG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIGdzYXAuc2V0KHRoaXMuJHNsaWRlckl0ZW1zWzBdLCB7XG4gICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgIH0pO1xuICAgICAgLyogVGV4dHMgKi9cblxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdGhpcy4kc2xpZGVySXRlbXNbMF0ucXVlcnlTZWxlY3RvckFsbCgnLnRpdGxlIC53b3JkJykubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICBnc2FwLnRvKHRoaXMuJHNsaWRlckl0ZW1zWzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJy50aXRsZSAud29yZCcpW19pMl0sIHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIHk6ICcwJScsXG4gICAgICAgICAgcm90YXRpb246ICcwZGVnJyxcbiAgICAgICAgICBlYXNlOiB0aGlzLl9zbGlkZXIuZWFzZSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5fc2xpZGVyLmR1cmF0aW9uLFxuICAgICAgICAgIGRlbGF5OiAwLjMgKyBfaTIgKiAwLjAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBnc2FwLnNldCh0aGlzLiRzbGlkZXJJdGVtc1swXS5xdWVyeVNlbGVjdG9yKCcubGluaycpLCB7XG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICAgIH0pO1xuICAgICAgLyogQmFja2dyb3VuZHMgKi9cblxuICAgICAgaWYgKCF0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkgZ3NhcC5zZXQodGhpcy4kc2xpZGVySXRlbXNbMF0ucXVlcnlTZWxlY3RvcignLmJhY2tncm91bmQnKSwge1xuICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB7XG4gICAgICAgIC8vIEdldCBiYWNrZ3JvdW5kcyB1cmxcbiAgICAgICAgdmFyIHByZXZVcmwgPSB0aGlzLiRzbGlkZXJJdGVtc1t0aGlzLiRzbGlkZXJJdGVtcy5sZW5ndGggLSAxXS5xdWVyeVNlbGVjdG9yKCcuYmFja2dyb3VuZCcpLmNoaWxkcmVuWzBdLnN0eWxlLmJhY2tncm91bmRJbWFnZS5zdWJzdHJpbmcoNSwgdGhpcy4kc2xpZGVySXRlbXNbdGhpcy4kc2xpZGVySXRlbXMubGVuZ3RoIC0gMV0ucXVlcnlTZWxlY3RvcignLmJhY2tncm91bmQnKS5jaGlsZHJlblswXS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UubGVuZ3RoIC0gMik7XG4gICAgICAgIHZhciBuZXh0VXJsID0gdGhpcy4kc2xpZGVySXRlbXNbMV0ucXVlcnlTZWxlY3RvcignLmJhY2tncm91bmQnKS5jaGlsZHJlblswXS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2Uuc3Vic3RyaW5nKDUsIHRoaXMuJHNsaWRlckl0ZW1zWzFdLnF1ZXJ5U2VsZWN0b3IoJy5iYWNrZ3JvdW5kJykuY2hpbGRyZW5bMF0uc3R5bGUuYmFja2dyb3VuZEltYWdlLmxlbmd0aCAtIDIpOyAvLyBTZXQgbmF2aWdhdGlvbiBiYWNrZ3JvdW5kcyB1cmxcblxuICAgICAgICBnc2FwLnNldCh0aGlzLiRzbGlkZXJOYXZpZ2F0aW9uUHJldi5xdWVyeVNlbGVjdG9yKCcuYmFja2dyb3VuZCcpLmNoaWxkcmVuWzBdLCB7XG4gICAgICAgICAgYmFja2dyb3VuZEltYWdlOiAndXJsKCcgKyBwcmV2VXJsICsgJyknXG4gICAgICAgIH0pO1xuICAgICAgICBnc2FwLnNldCh0aGlzLiRzbGlkZXJOYXZpZ2F0aW9uTmV4dC5xdWVyeVNlbGVjdG9yKCcuYmFja2dyb3VuZCcpLmNoaWxkcmVuWzBdLCB7XG4gICAgICAgICAgYmFja2dyb3VuZEltYWdlOiAndXJsKCcgKyBuZXh0VXJsICsgJyknXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBnc2FwLmRlbGF5ZWRDYWxsKHRoaXMuX3NsaWRlci5hdXRvcGxheVNwZWVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5hdXRvcGxheSgpO1xuXG4gICAgICAgIF90aGlzMi5fc2xpZGVyLmFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRyb2xsQXV0b3BsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udHJvbGxBdXRvcGxheSgpIHtcbiAgICAgIGlmICh0aGlzLl9zbGlkZXIuYXV0b3BsYXkpIHJldHVybjtcbiAgICAgIHRoaXMuX3NsaWRlci5hdXRvcGxheSA9IHRydWU7XG4gICAgICB0aGlzLmF1dG9wbGF5KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF1dG9wbGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF1dG9wbGF5KCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIC8vIFRpbWVsaW5lIFNsaWRlciBzY3JvbGxcbiAgICAgIGlmICh0aGlzLl9zbGlkZXIuYXV0b3BsYXkpIHtcbiAgICAgICAgdGhpcy5fc2xpZGVyLmF1dG9wbGF5Q29udHJvbGxlciA9IGdzYXAudGltZWxpbmUoe1xuICAgICAgICAgIHBhdXNlZDogZmFsc2UsXG4gICAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLl9zbGlkZXIuYXV0b3BsYXlTcGVlZCxcbiAgICAgICAgICAgIGVhc2U6ICdub25lJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAgIF90aGlzMy5jaGFuZ2UoJ25leHQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3NsaWRlci5hdXRvcGxheUNvbnRyb2xsZXIuZnJvbVRvKHRoaXMuX3NsaWRlciwge1xuICAgICAgICAgIGF1dG9wbGF5UHJvZ3Jlc3M6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF1dG9wbGF5UHJvZ3Jlc3M6IDFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF1dG9wbGF5UGF1c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXV0b3BsYXlQYXVzZSgpIHtcbiAgICAgIGlmICh0aGlzLl9zbGlkZXIuYXV0b3BsYXlDb250cm9sbGVyKSB0aGlzLl9zbGlkZXIuYXV0b3BsYXlDb250cm9sbGVyLnBhdXNlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF1dG9wbGF5UGxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdXRvcGxheVBsYXkoKSB7XG4gICAgICBpZiAodGhpcy5fc2xpZGVyLmF1dG9wbGF5Q29udHJvbGxlcikgdGhpcy5fc2xpZGVyLmF1dG9wbGF5Q29udHJvbGxlci5wbGF5KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZU5hdmlnYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTmF2aWdhdGlvbihkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9zbGlkZXIuYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5fc2xpZGVyLmFuaW1hdGluZykgcmV0dXJuO1xuICAgICAgdGhpcy5uYXZpZ2F0aW9uKGRpcmVjdGlvbik7XG5cbiAgICAgIGlmICh0aGlzLl9zbGlkZXIuYXV0b3BsYXkpIHtcbiAgICAgICAgdGhpcy5fc2xpZGVyLmF1dG9wbGF5Q29udHJvbGxlci5wYXVzZSgpO1xuXG4gICAgICAgIGdzYXAuZnJvbVRvKHRoaXMuX3NsaWRlciwge1xuICAgICAgICAgIG5hdmlnYXRpb25Qcm9ncmVzczE6IHRoaXMuX3NsaWRlci5uYXZpZ2F0aW9uUHJvZ3Jlc3MxLFxuICAgICAgICAgIG5hdmlnYXRpb25Qcm9ncmVzczI6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hdmlnYXRpb25Qcm9ncmVzczE6IDEsXG4gICAgICAgICAgbmF2aWdhdGlvblByb2dyZXNzMjogMSxcbiAgICAgICAgICBkdXJhdGlvbjogMSxcbiAgICAgICAgICBlYXNlOiB0aGlzLl9zbGlkZXIuZWFzZSxcbiAgICAgICAgICBkZWxheTogMCxcbiAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgICAgX3RoaXM0Ll9zbGlkZXIuYXV0b3BsYXlDb250cm9sbGVyLnJlc3RhcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbnRlck5hdmlnYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW50ZXJOYXZpZ2F0aW9uKGEsIGUsIGVsKSB7XG4gICAgICBnc2FwLnRvKGVsLmNoaWxkcmVuWzBdLCB7XG4gICAgICAgIGNsaXBQYXRoOiAnY2lyY2xlKDQ1JSBhdCA1MCUgNTAlKScsXG4gICAgICAgIHdlYmtpdENsaXBQYXRoOiAnY2lyY2xlKDQ1JSBhdCA1MCUgNTAlKScsXG4gICAgICAgIGR1cmF0aW9uOiAyLFxuICAgICAgICBlYXNlOiAnZXhwby5vdXQnXG4gICAgICB9KTtcbiAgICAgIGdzYXAudG8oZWwuY2hpbGRyZW5bMV0sIHtcbiAgICAgICAgc2NhbGU6IDAuOSxcbiAgICAgICAgZHVyYXRpb246IDIsXG4gICAgICAgIGVhc2U6ICdleHBvLm91dCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZWF2ZU5hdmlnYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVhdmVOYXZpZ2F0aW9uKGEsIGUsIGVsKSB7XG4gICAgICBnc2FwLnRvKGVsLmNoaWxkcmVuWzBdLCB7XG4gICAgICAgIGNsaXBQYXRoOiAnY2lyY2xlKDEwJSBhdCA1MCUgNTAlKScsXG4gICAgICAgIHdlYmtpdENsaXBQYXRoOiAnY2lyY2xlKDEwJSBhdCA1MCUgNTAlKScsXG4gICAgICAgIGR1cmF0aW9uOiAyLFxuICAgICAgICBlYXNlOiAnZXhwby5vdXQnXG4gICAgICB9KTtcbiAgICAgIGdzYXAudG8oZWwuY2hpbGRyZW5bMV0sIHtcbiAgICAgICAgc2NhbGU6IDEsXG4gICAgICAgIGR1cmF0aW9uOiAyLFxuICAgICAgICBlYXNlOiAnZXhwby5vdXQnXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoYW5nZShkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9zbGlkZXIuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgdGhpcy5fc2xpZGVyLm5leHQgPSAodGhpcy5fc2xpZGVyLmN1cnJlbnQgKyAxKSAlIHRoaXMuX3NsaWRlci50b3RhbDtcbiAgICAgIHRoaXMuX3NsaWRlci5wcmV2ID0gdGhpcy5fc2xpZGVyLmN1cnJlbnQgPT09IC0xID8gdGhpcy5fc2xpZGVyLnRvdGFsIC0gMSA6IHRoaXMuX3NsaWRlci5jdXJyZW50O1xuICAgICAgdGhpcy5fc2xpZGVyLmN1cnJlbnQgPSB0aGlzLl9zbGlkZXIubmV4dDtcblxuICAgICAgaWYgKHRoaXMuX3NsaWRlci5hdXRvcGxheSkge1xuICAgICAgICB0aGlzLl9zbGlkZXIuYXV0b3BsYXlDb250cm9sbGVyLnBhdXNlKCk7XG5cbiAgICAgICAgZ3NhcC5kZWxheWVkQ2FsbCh0aGlzLl9zbGlkZXIuYXV0b3BsYXlTcGVlZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNS5fc2xpZGVyLmF1dG9wbGF5Q29udHJvbGxlci5yZXN0YXJ0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBTbGlkZXIgYW5pbWF0aW9uXG5cblxuICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB0aGlzLmFuaW1hdGlvbih0aGlzLl9zbGlkZXIuZGlyZWN0aW9uKTtlbHNlIHRoaXMuYW5pbWF0aW9uTW9iaWxlKHRoaXMuX3NsaWRlci5kaXJlY3Rpb24pOyAvLyBXZWJHTFxuXG4gICAgICB0aGlzLmVtaXR0ZXIuZW1pdCgnb25TbGlkZXJDaGFuZ2UnLCB7XG4gICAgICAgIGRpcmVjdGlvbjogdGhpcy5fc2xpZGVyLmRpcmVjdGlvbixcbiAgICAgICAgZHVyYXRpb246IHRoaXMuX3NsaWRlci5kdXJhdGlvbixcbiAgICAgICAgYWN0aW9uOiAnY2hhbmdlJyxcbiAgICAgICAgY29sb3I6IHRoaXMuJHNsaWRlckl0ZW1zW3RoaXMuX3NsaWRlci5uZXh0XS5kYXRhc2V0LmNvbG9yXG4gICAgICB9KTsgLy8gUmVzZXQgYW5pbWF0aW9uIHZhcnNcblxuICAgICAgZ3NhcC5kZWxheWVkQ2FsbCh0aGlzLl9zbGlkZXIuYXV0b3BsYXlTcGVlZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczUuX3NsaWRlci5jdXJyZW50ID0gX3RoaXM1Ll9zbGlkZXIubmV4dDtcbiAgICAgICAgX3RoaXM1Ll9zbGlkZXIuYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmF2aWdhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuYXZpZ2F0aW9uKGRpcmVjdGlvbikge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX3NsaWRlci5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG5cbiAgICAgIGlmICh0aGlzLl9zbGlkZXIuZGlyZWN0aW9uID09PSAnbmV4dCcpIHtcbiAgICAgICAgdGhpcy5fc2xpZGVyLm5leHQgPSAodGhpcy5fc2xpZGVyLmN1cnJlbnQgKyAxKSAlIHRoaXMuX3NsaWRlci50b3RhbDtcbiAgICAgICAgdGhpcy5fc2xpZGVyLnByZXYgPSB0aGlzLl9zbGlkZXIuY3VycmVudCA9PT0gLTEgPyB0aGlzLl9zbGlkZXIudG90YWwgLSAxIDogdGhpcy5fc2xpZGVyLmN1cnJlbnQ7XG4gICAgICAgIHRoaXMuX3NsaWRlci5kaXIgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2xpZGVyLm5leHQgPSB0aGlzLl9zbGlkZXIuY3VycmVudCA9PT0gMCA/IHRoaXMuX3NsaWRlci50b3RhbCAtIDEgOiB0aGlzLl9zbGlkZXIuY3VycmVudCAtIDE7XG4gICAgICAgIHRoaXMuX3NsaWRlci5wcmV2ID0gdGhpcy5fc2xpZGVyLmN1cnJlbnQgPT09IC0xID8gdGhpcy5fc2xpZGVyLnRvdGFsIC0gMSA6IHRoaXMuX3NsaWRlci5jdXJyZW50O1xuICAgICAgICB0aGlzLl9zbGlkZXIuZGlyID0gLTE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NsaWRlci5jdXJyZW50ID0gdGhpcy5fc2xpZGVyLm5leHQ7XG5cbiAgICAgIGlmICh0aGlzLl9zbGlkZXIuYXV0b3BsYXkpIHtcbiAgICAgICAgdGhpcy5fc2xpZGVyLmF1dG9wbGF5Q29udHJvbGxlci5wYXVzZSgpO1xuXG4gICAgICAgIGdzYXAuZGVsYXllZENhbGwodGhpcy5fc2xpZGVyLmR1cmF0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM2Ll9zbGlkZXIuYXV0b3BsYXlDb250cm9sbGVyLnJlc3RhcnQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFNsaWRlciBhbmltYXRpb25cblxuXG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHRoaXMuYW5pbWF0aW9uKHRoaXMuX3NsaWRlci5kaXJlY3Rpb24pO2Vsc2UgdGhpcy5hbmltYXRpb25Nb2JpbGUodGhpcy5fc2xpZGVyLmRpcmVjdGlvbik7IC8vIFdlYkdMXG5cbiAgICAgIHRoaXMuZW1pdHRlci5lbWl0KCdvblNsaWRlckNoYW5nZScsIHtcbiAgICAgICAgZGlyZWN0aW9uOiB0aGlzLl9zbGlkZXIuZGlyZWN0aW9uLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5fc2xpZGVyLmR1cmF0aW9uLFxuICAgICAgICBhY3Rpb246ICduYXZpZ2F0aW9uJyxcbiAgICAgICAgY29sb3I6IHRoaXMuJHNsaWRlckl0ZW1zW3RoaXMuX3NsaWRlci5uZXh0XS5kYXRhc2V0LmNvbG9yXG4gICAgICB9KTsgLy8gUmVzZXQgYW5pbWF0aW9uIHZhcnNcblxuICAgICAgZ3NhcC5kZWxheWVkQ2FsbCh0aGlzLl9zbGlkZXIuZHVyYXRpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM2Ll9zbGlkZXIuY3VycmVudCA9IF90aGlzNi5fc2xpZGVyLm5leHQ7XG4gICAgICAgIF90aGlzNi5fc2xpZGVyLmFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRpb24oZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgLy8gU2V0IG5leHQgc2xpZGVcblxuICAgICAgLyogSXRlbXMgKi9cbiAgICAgIGdzYXAuc2V0KHRoaXMuJHNsaWRlckl0ZW1zW3RoaXMuX3NsaWRlci5uZXh0XSwge1xuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICBjbGlwUGF0aDogJ2NpcmNsZSg1MCUgYXQgNTAlIDUwJSknLFxuICAgICAgICB3ZWJraXRDbGlwUGF0aDogJ2NpcmNsZSg1MCUgYXQgNTAlIDUwJSknLFxuICAgICAgICBvcGFjaXR5OiAwLjAwMDFcbiAgICAgIH0pO1xuICAgICAgLyogVGV4dHMgKi9cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRzbGlkZXJJdGVtc1t0aGlzLl9zbGlkZXIubmV4dF0ucXVlcnlTZWxlY3RvckFsbCgnLnRpdGxlIC53b3JkJykubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3NhcC5zZXQodGhpcy4kc2xpZGVySXRlbXNbdGhpcy5fc2xpZGVyLm5leHRdLnF1ZXJ5U2VsZWN0b3JBbGwoJy50aXRsZSAud29yZCcpW2ldLCB7XG4gICAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICAgIHk6ICcxMDAlJyxcbiAgICAgICAgICByb3RhdGlvbjogJzNkZWcnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyogQmFja2dyb3VuZHMgKi9cblxuXG4gICAgICBnc2FwLnNldCh0aGlzLiRzbGlkZXJJdGVtc1t0aGlzLl9zbGlkZXIubmV4dF0ucXVlcnlTZWxlY3RvcignLmJhY2tncm91bmQnKS5jaGlsZHJlblswXSwge1xuICAgICAgICBzY2FsZTogMS4yXG4gICAgICB9KTsgLy8gR2V0IGJhY2tncm91bmRzIHVybFxuXG4gICAgICB0aGlzLnByZXZVcmwgPSB0aGlzLiRzbGlkZXJJdGVtc1t0aGlzLl9zbGlkZXIucHJldl0ucXVlcnlTZWxlY3RvcignLmJhY2tncm91bmQnKS5jaGlsZHJlblswXS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2Uuc3Vic3RyaW5nKDUsIHRoaXMuJHNsaWRlckl0ZW1zW3RoaXMuX3NsaWRlci5wcmV2XS5xdWVyeVNlbGVjdG9yKCcuYmFja2dyb3VuZCcpLmNoaWxkcmVuWzBdLnN0eWxlLmJhY2tncm91bmRJbWFnZS5sZW5ndGggLSAyKTtcbiAgICAgIHRoaXMubmV4dFVybCA9IHRoaXMuJHNsaWRlckl0ZW1zW3RoaXMuX3NsaWRlci5uZXh0ID09PSB0aGlzLl9zbGlkZXIudG90YWwgLSAxID8gMCA6IHRoaXMuX3NsaWRlci5uZXh0ICsgMV0ucXVlcnlTZWxlY3RvcignLmJhY2tncm91bmQnKS5jaGlsZHJlblswXS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2Uuc3Vic3RyaW5nKDUsIHRoaXMuJHNsaWRlckl0ZW1zW3RoaXMuX3NsaWRlci5uZXh0ID09PSB0aGlzLl9zbGlkZXIudG90YWwgLSAxID8gMCA6IHRoaXMuX3NsaWRlci5uZXh0ICsgMV0ucXVlcnlTZWxlY3RvcignLmJhY2tncm91bmQnKS5jaGlsZHJlblswXS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UubGVuZ3RoIC0gMik7IC8vIGNvbnNvbGUubG9nKGRpcmVjdGlvbiA9PT0gJ3ByZXYnICYmIHRoaXMuX3NsaWRlci5wcmV2ICE9PSAwLCB0aGlzLl9zbGlkZXIucHJldiA9PT0gMCk7XG4gICAgICAvLyBjb25zb2xlLmxvZygnUHJldjogJyArIHRoaXMuX3NsaWRlci5wcmV2LCAnTmV4dDogJyArIHRoaXMuX3NsaWRlci5uZXh0KTtcbiAgICAgIC8vIEFuaW1hdGUgb3V0IGN1cnJlbnQgc2xpZGVcblxuICAgICAgLyogSXRlbXMgKi9cblxuICAgICAgZ3NhcC50byh0aGlzLiRzbGlkZXJJdGVtc1t0aGlzLl9zbGlkZXIucHJldl0sIHtcbiAgICAgICAgY2xpcFBhdGg6ICdjaXJjbGUoMTAlIGF0IDUwJSA1MCUpJyxcbiAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICB3ZWJraXRDbGlwUGF0aDogJ2NpcmNsZSgxMCUgYXQgNTAlIDUwJSknLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5fc2xpZGVyLmR1cmF0aW9uLFxuICAgICAgICBlYXNlOiB0aGlzLl9zbGlkZXIuZWFzZVxuICAgICAgfSk7XG4gICAgICBnc2FwLnRvKHRoaXMuJHNsaWRlckl0ZW1zW3RoaXMuX3NsaWRlci5uZXh0XSwge1xuICAgICAgICBjbGlwUGF0aDogJ2NpcmNsZSgxMCUgYXQgNTAlIDUwJSknLFxuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICB3ZWJraXRDbGlwUGF0aDogJ2NpcmNsZSgxMCUgYXQgNTAlIDUwJSknLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5fc2xpZGVyLmR1cmF0aW9uLFxuICAgICAgICBlYXNlOiB0aGlzLl9zbGlkZXIuZWFzZVxuICAgICAgfSk7XG4gICAgICAvKiBUZXh0cyAqL1xuXG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCB0aGlzLiRzbGlkZXJJdGVtc1t0aGlzLl9zbGlkZXIucHJldl0ucXVlcnlTZWxlY3RvckFsbCgnLnRpdGxlIC53b3JkJykubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICBnc2FwLnRvKHRoaXMuJHNsaWRlckl0ZW1zW3RoaXMuX3NsaWRlci5wcmV2XS5xdWVyeVNlbGVjdG9yQWxsKCcudGl0bGUgLndvcmQnKVtfaTNdLCB7XG4gICAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICAgIHk6ICctMTAwJScsXG4gICAgICAgICAgcm90YXRpb246ICctM2RlZycsXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuX3NsaWRlci5kdXJhdGlvbixcbiAgICAgICAgICBlYXNlOiB0aGlzLl9zbGlkZXIuZWFzZSxcbiAgICAgICAgICBkZWxheTogX2kzICogMC4wMSxcbiAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgICAgZ3NhcC5zZXQoX3RoaXM3LiRzbGlkZXJJdGVtc1tfdGhpczcuX3NsaWRlci5wcmV2XSwge1xuICAgICAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGdzYXAudG8odGhpcy4kc2xpZGVySXRlbXNbdGhpcy5fc2xpZGVyLnByZXZdLnF1ZXJ5U2VsZWN0b3IoJy5saW5rJyksIHtcbiAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5fc2xpZGVyLmR1cmF0aW9uLFxuICAgICAgICBlYXNlOiB0aGlzLl9zbGlkZXIuZWFzZVxuICAgICAgfSk7XG4gICAgICAvKiBBcnJvd3MgKi9cblxuICAgICAgZ3NhcC5zZXQodGhpcy4kc2xpZGVyTmF2aWdhdGlvblByZXYucXVlcnlTZWxlY3RvcignLmJhY2tncm91bmQnKS5jaGlsZHJlblswXSwge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6ICd1cmwoJyArIHRoaXMucHJldlVybCArICcpJ1xuICAgICAgfSk7XG4gICAgICBnc2FwLnNldCh0aGlzLiRzbGlkZXJOYXZpZ2F0aW9uTmV4dC5xdWVyeVNlbGVjdG9yKCcuYmFja2dyb3VuZCcpLmNoaWxkcmVuWzBdLCB7XG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogJ3VybCgnICsgdGhpcy5uZXh0VXJsICsgJyknXG4gICAgICB9KTsgLy8gQW5pbWF0ZSBpbiBuZXh0IHNsaWRlXG5cbiAgICAgIC8qIEl0ZW1zICovXG5cbiAgICAgIGdzYXAudG8odGhpcy4kc2xpZGVySXRlbXNbdGhpcy5fc2xpZGVyLm5leHRdLCB7XG4gICAgICAgIGNsaXBQYXRoOiAnY2lyY2xlKDUwJSBhdCA1MCUgNTAlKScsXG4gICAgICAgIHdlYmtpdENsaXBQYXRoOiAnY2lyY2xlKDUwJSBhdCA1MCUgNTAlKScsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLl9zbGlkZXIuZHVyYXRpb24sXG4gICAgICAgIGVhc2U6IHRoaXMuX3NsaWRlci5lYXNlLFxuICAgICAgICBkZWxheTogdGhpcy5fc2xpZGVyLmR1cmF0aW9uXG4gICAgICB9KTtcbiAgICAgIC8qIFRleHRzICovXG5cbiAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHRoaXMuJHNsaWRlckl0ZW1zW3RoaXMuX3NsaWRlci5uZXh0XS5xdWVyeVNlbGVjdG9yQWxsKCcudGl0bGUgLndvcmQnKS5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgIGdzYXAudG8odGhpcy4kc2xpZGVySXRlbXNbdGhpcy5fc2xpZGVyLm5leHRdLnF1ZXJ5U2VsZWN0b3JBbGwoJy50aXRsZSAud29yZCcpW19pNF0sIHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIHk6ICcwJScsXG4gICAgICAgICAgcm90YXRpb246ICcwZGVnJyxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5fc2xpZGVyLmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2U6IHRoaXMuX3NsaWRlci5lYXNlLFxuICAgICAgICAgIGRlbGF5OiB0aGlzLl9zbGlkZXIuZHVyYXRpb24gKyBfaTQgKiAwLjAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBnc2FwLnRvKHRoaXMuJHNsaWRlckl0ZW1zW3RoaXMuX3NsaWRlci5uZXh0XS5xdWVyeVNlbGVjdG9yKCcubGluaycpLCB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLl9zbGlkZXIuZHVyYXRpb24sXG4gICAgICAgIGVhc2U6IHRoaXMuX3NsaWRlci5lYXNlLFxuICAgICAgICBkZWxheTogdGhpcy5fc2xpZGVyLmR1cmF0aW9uXG4gICAgICB9KTtcbiAgICAgIC8qIEJhY2tncm91bmRzICovXG5cbiAgICAgIGdzYXAudG8odGhpcy4kc2xpZGVySXRlbXNbdGhpcy5fc2xpZGVyLm5leHRdLnF1ZXJ5U2VsZWN0b3IoJy5iYWNrZ3JvdW5kJykuY2hpbGRyZW5bMF0sIHtcbiAgICAgICAgc2NhbGU6IDEsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLl9zbGlkZXIuZHVyYXRpb24gKiA2LFxuICAgICAgICBlYXNlOiAnZXhwby5vdXQnLFxuICAgICAgICBkZWxheTogdGhpcy5fc2xpZGVyLmR1cmF0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0aW9uTW9iaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGlvbk1vYmlsZShkaXJlY3Rpb24pIHtcbiAgICAgIC8vIFNldCBuZXh0IHNsaWRlXG5cbiAgICAgIC8qIFRleHRzICovXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJHNsaWRlckl0ZW1zW3RoaXMuX3NsaWRlci5uZXh0XS5xdWVyeVNlbGVjdG9yQWxsKCcudGl0bGUgLndvcmQnKS5sZW5ndGg7IGkrKykge1xuICAgICAgICBnc2FwLnNldCh0aGlzLiRzbGlkZXJJdGVtc1t0aGlzLl9zbGlkZXIubmV4dF0ucXVlcnlTZWxlY3RvckFsbCgnLnRpdGxlIC53b3JkJylbaV0sIHtcbiAgICAgICAgICBvcGFjaXR5OiAwLjAwMDEsXG4gICAgICAgICAgeTogJzEwMCUnLFxuICAgICAgICAgIHJvdGF0aW9uOiAnM2RlZydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKiBCYWNrZ3JvdW5kcyAqL1xuXG5cbiAgICAgIGdzYXAuc2V0KHRoaXMuJHNsaWRlckl0ZW1zW3RoaXMuX3NsaWRlci5uZXh0XS5xdWVyeVNlbGVjdG9yKCcuYmFja2dyb3VuZCcpLCB7XG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgIHg6ICcxMDAlJ1xuICAgICAgfSk7XG4gICAgICBnc2FwLnNldCh0aGlzLiRzbGlkZXJJdGVtc1t0aGlzLl9zbGlkZXIubmV4dF0ucXVlcnlTZWxlY3RvcignLmJhY2tncm91bmQnKS5jaGlsZHJlblswXSwge1xuICAgICAgICB4OiAnMCUnXG4gICAgICB9KTsgLy8gQW5pbWF0ZSBvdXQgY3VycmVudCBzbGlkZVxuXG4gICAgICAvKiBUZXh0cyAqL1xuXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCB0aGlzLiRzbGlkZXJJdGVtc1t0aGlzLl9zbGlkZXIucHJldl0ucXVlcnlTZWxlY3RvckFsbCgnLnRpdGxlIC53b3JkJykubGVuZ3RoOyBfaTUrKykge1xuICAgICAgICBnc2FwLnRvKHRoaXMuJHNsaWRlckl0ZW1zW3RoaXMuX3NsaWRlci5wcmV2XS5xdWVyeVNlbGVjdG9yQWxsKCcudGl0bGUgLndvcmQnKVtfaTVdLCB7XG4gICAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICAgIHk6ICctMTAwJScsXG4gICAgICAgICAgcm90YXRpb246ICctM2RlZycsXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuX3NsaWRlci5kdXJhdGlvbixcbiAgICAgICAgICBlYXNlOiB0aGlzLl9zbGlkZXIuZWFzZSxcbiAgICAgICAgICBkZWxheTogX2k1ICogMC4wMVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZ3NhcC50byh0aGlzLiRzbGlkZXJJdGVtc1t0aGlzLl9zbGlkZXIucHJldl0ucXVlcnlTZWxlY3RvcignLmxpbmsnKSwge1xuICAgICAgICBvcGFjaXR5OiAwLjAwMDEsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLl9zbGlkZXIuZHVyYXRpb24sXG4gICAgICAgIGVhc2U6IHRoaXMuX3NsaWRlci5lYXNlXG4gICAgICB9KTtcbiAgICAgIC8qIEJhY2tncm91bmRzICovXG5cbiAgICAgIGdzYXAuZnJvbVRvKHRoaXMuJHNsaWRlckl0ZW1zW3RoaXMuX3NsaWRlci5wcmV2XS5xdWVyeVNlbGVjdG9yKCcuYmFja2dyb3VuZCcpLCB7XG4gICAgICAgIHg6ICcwJSdcbiAgICAgIH0sIHtcbiAgICAgICAgeDogJy0xMDAlJyxcbiAgICAgICAgZWFzZTogdGhpcy5fc2xpZGVyLmVhc2UsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLl9zbGlkZXIuZHVyYXRpb24sXG4gICAgICAgIGRlbGF5OiB0aGlzLl9zbGlkZXIuZHVyYXRpb25cbiAgICAgIH0pO1xuICAgICAgZ3NhcC5mcm9tVG8odGhpcy4kc2xpZGVySXRlbXNbdGhpcy5fc2xpZGVyLnByZXZdLnF1ZXJ5U2VsZWN0b3IoJy5iYWNrZ3JvdW5kJykuY2hpbGRyZW5bMF0sIHtcbiAgICAgICAgeDogJzAlJ1xuICAgICAgfSwge1xuICAgICAgICB4OiAnMTAwJScsXG4gICAgICAgIGVhc2U6IHRoaXMuX3NsaWRlci5lYXNlLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5fc2xpZGVyLmR1cmF0aW9uLFxuICAgICAgICBkZWxheTogdGhpcy5fc2xpZGVyLmR1cmF0aW9uXG4gICAgICB9KTsgLy8gQW5pbWF0ZSBpbiBuZXh0IHNsaWRlXG5cbiAgICAgIC8qIFRleHRzICovXG5cbiAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IHRoaXMuJHNsaWRlckl0ZW1zW3RoaXMuX3NsaWRlci5uZXh0XS5xdWVyeVNlbGVjdG9yQWxsKCcudGl0bGUgLndvcmQnKS5sZW5ndGg7IF9pNisrKSB7XG4gICAgICAgIGdzYXAudG8odGhpcy4kc2xpZGVySXRlbXNbdGhpcy5fc2xpZGVyLm5leHRdLnF1ZXJ5U2VsZWN0b3JBbGwoJy50aXRsZSAud29yZCcpW19pNl0sIHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIHk6ICcwJScsXG4gICAgICAgICAgcm90YXRpb246ICcwZGVnJyxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5fc2xpZGVyLmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2U6IHRoaXMuX3NsaWRlci5lYXNlLFxuICAgICAgICAgIGRlbGF5OiB0aGlzLl9zbGlkZXIuZHVyYXRpb24gKyBfaTYgKiAwLjAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBnc2FwLnRvKHRoaXMuJHNsaWRlckl0ZW1zW3RoaXMuX3NsaWRlci5uZXh0XS5xdWVyeVNlbGVjdG9yKCcubGluaycpLCB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLl9zbGlkZXIuZHVyYXRpb24sXG4gICAgICAgIGVhc2U6IHRoaXMuX3NsaWRlci5lYXNlLFxuICAgICAgICBkZWxheTogdGhpcy5fc2xpZGVyLmR1cmF0aW9uXG4gICAgICB9KTtcbiAgICAgIC8qIEJhY2tncm91bmRzICovXG5cbiAgICAgIGdzYXAuZnJvbVRvKHRoaXMuJHNsaWRlckl0ZW1zW3RoaXMuX3NsaWRlci5uZXh0XS5xdWVyeVNlbGVjdG9yKCcuYmFja2dyb3VuZCcpLCB7XG4gICAgICAgIHg6ICcxMDAlJ1xuICAgICAgfSwge1xuICAgICAgICB4OiAnMCUnLFxuICAgICAgICBlYXNlOiB0aGlzLl9zbGlkZXIuZWFzZSxcbiAgICAgICAgZHVyYXRpb246IHRoaXMuX3NsaWRlci5kdXJhdGlvbixcbiAgICAgICAgZGVsYXk6IHRoaXMuX3NsaWRlci5kdXJhdGlvbiAvIDJcbiAgICAgIH0pO1xuICAgICAgZ3NhcC5mcm9tVG8odGhpcy4kc2xpZGVySXRlbXNbdGhpcy5fc2xpZGVyLm5leHRdLnF1ZXJ5U2VsZWN0b3IoJy5iYWNrZ3JvdW5kJykuY2hpbGRyZW5bMF0sIHtcbiAgICAgICAgeDogJy0xMDAlJ1xuICAgICAgfSwge1xuICAgICAgICB4OiAnMCUnLFxuICAgICAgICBlYXNlOiB0aGlzLl9zbGlkZXIuZWFzZSxcbiAgICAgICAgZHVyYXRpb246IHRoaXMuX3NsaWRlci5kdXJhdGlvbixcbiAgICAgICAgZGVsYXk6IHRoaXMuX3NsaWRlci5kdXJhdGlvbiAvIDJcbiAgICAgIH0pO1xuICAgICAgZ3NhcC5mcm9tVG8odGhpcy4kc2xpZGVySXRlbXNbdGhpcy5fc2xpZGVyLm5leHRdLnF1ZXJ5U2VsZWN0b3IoJy5iYWNrZ3JvdW5kJykuY2hpbGRyZW5bMF0sIHtcbiAgICAgICAgc2NhbGU6IDEuMVxuICAgICAgfSwge1xuICAgICAgICBzY2FsZTogMSxcbiAgICAgICAgZHVyYXRpb246IDQsXG4gICAgICAgIGVhc2U6ICdleHBvLm91dCcsXG4gICAgICAgIGRlbGF5OiB0aGlzLl9zbGlkZXIuZHVyYXRpb24gLyAyXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMuX3NsaWRlci5hdXRvcGxheUNvbnRyb2xsZXIpIHRoaXMuX3NsaWRlci5hdXRvcGxheUNvbnRyb2xsZXIucGF1c2UoKTtcbiAgICAgIGlmICh0aGlzLmRvbUV2ZW50cykgdGhpcy5kb21FdmVudHMuZGVzdHJveSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oKTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8vIEdTQVAgTGlicmFyeVxuaW1wb3J0IGdzYXAgZnJvbSAnZ3NhcCc7XG5pbXBvcnQgU3BsaXRUZXh0IGZyb20gJy4uL2NsYXNzZXMvc3BsaXRUZXh0JztcbmltcG9ydCBTY3JvbGxUcmlnZ2VyIGZyb20gJ2dzYXAvU2Nyb2xsVHJpZ2dlcic7XG5nc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpO1xuaW1wb3J0IERyYXdTVkdQbHVnaW4gZnJvbSAnLi4vY2xhc3Nlcy9EcmF3U1ZHUGx1Z2luLm1pbic7XG5nc2FwLnJlZ2lzdGVyUGx1Z2luKERyYXdTVkdQbHVnaW4pOyAvLyBJbXBvcnQgUmVuZGVyZXJcblxuaW1wb3J0IFJlbmRlcmVyIGZyb20gJy4vcmVuZGVyZXIuanMnOyAvLyBXZWJnbFxuXG5pbXBvcnQgSG9tZTFBcHAgZnJvbSAnLi4vd2ViZ2wvaG9tZTEvSG9tZTFBcHAnO1xuaW1wb3J0IEhvbWUyQXBwIGZyb20gJy4uL3dlYmdsL2hvbWUyL0hvbWUyQXBwJztcbmltcG9ydCBIb21lM0FwcCBmcm9tICcuLi93ZWJnbC9ob21lMy9Ib21lM0FwcCc7XG5pbXBvcnQgSG9tZTRBcHAgZnJvbSAnLi4vd2ViZ2wvaG9tZTQvSG9tZTRBcHAnO1xuaW1wb3J0IEhvbWUxQXBwX20gZnJvbSAnLi4vd2ViZ2wvaG9tZTFfbS9Ib21lMUFwcF9tJztcbmltcG9ydCBIb21lMkFwcF9tIGZyb20gJy4uL3dlYmdsL2hvbWUyX20vSG9tZTJBcHBfbSc7IC8vIFV0aWxpdGllc1xuXG5pbXBvcnQgRG9tRXZlbnRzIGZyb20gJy4uL2NsYXNzZXMvZG9tRXZlbnRzJztcbmltcG9ydCBTdXBlclNjcm9sbGVyIGZyb20gJy4uL2NsYXNzZXMvc3VwZXJTY3JvbGxlcic7XG5pbXBvcnQgU3VwZXJEcmFnZ2FibGUgZnJvbSAnLi4vY2xhc3Nlcy9zdXBlckRyYWdnYWJsZSc7XG5pbXBvcnQgU2xpZGVyU29sdXRpb25zIGZyb20gJy4uL2NvbXBvbmVudHMvc2xpZGVyU29sdXRpb25zJztcblxudmFyIFJlbmRlcmVySG9tZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlbmRlcmVyKSB7XG4gIF9pbmhlcml0cyhSZW5kZXJlckhvbWUsIF9SZW5kZXJlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihSZW5kZXJlckhvbWUpO1xuXG4gIGZ1bmN0aW9uIFJlbmRlcmVySG9tZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVuZGVyZXJIb21lKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZW5kZXJlckhvbWUsIFt7XG4gICAga2V5OiBcInNlbGVjdG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RvcnMoKSB7XG4gICAgICAvLyBTZWN0aW9uc1xuICAgICAgdGhpcy4kaGVybyA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5ob21lX19oZXJvJyk7XG4gICAgICB0aGlzLiRkYXRhID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmhvbWVfX2RhdGEnKTtcbiAgICAgIHRoaXMuJHNlcnZpY2VzID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmhvbWVfX3NlcnZpY2VzJyk7XG4gICAgICB0aGlzLiRzb2x1dGlvbnMgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuaG9tZV9fc29sdXRpb25zJyk7XG4gICAgICB0aGlzLiR0ZWNobm9sb2d5ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmhvbWVfX3RlY2hub2xvZ3knKTtcbiAgICAgIHRoaXMuJHBsYXRmb3JtcyA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5ob21lX19wbGF0Zm9ybXMnKTtcbiAgICAgIHRoaXMuJGNsaWVudHMgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuaG9tZV9fY2xpZW50cycpOyAvLyBWaWRlb1xuXG4gICAgICB0aGlzLiR2aWRlbyA9IHRoaXMuJGhlcm8ucXVlcnlTZWxlY3RvcignLmhlcm9fX3ZpZGVvJyk7XG4gICAgICBpZiAodGhpcy4kdmlkZW8pIHRoaXMuJHZpZGVvRWwgPSB0aGlzLiR2aWRlby5xdWVyeVNlbGVjdG9yKCcudmlkZW8nKTsgLy8gQ2FudmFzXG5cbiAgICAgIHRoaXMuJGNhbnZhc0hvbWUxID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignI3dlYmdsX2hvbWUxJyk7XG4gICAgICB0aGlzLiRjYW52YXNIb21lMiA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJyN3ZWJnbF9ob21lMicpO1xuICAgICAgdGhpcy4kY2FudmFzSG9tZTMgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcjd2ViZ2xfaG9tZTMnKTtcbiAgICAgIHRoaXMuJGNhbnZhc0hvbWU0ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignI3dlYmdsX2hvbWU0Jyk7XG4gICAgICB0aGlzLiRjYW52YXNIb21lMV9tID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignI3dlYmdsX2hvbWUxX20nKTtcbiAgICAgIHRoaXMuJGNhbnZhc0hvbWUyYV9tID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignI3dlYmdsX2hvbWUyYV9tJyk7XG4gICAgICB0aGlzLiRjYW52YXNIb21lMmJfbSA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJyN3ZWJnbF9ob21lMmJfbScpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkge1xuICAgICAgICBpZiAodGhpcy4kc2VydmljZXMpIHtcbiAgICAgICAgICB0aGlzLiRzZXJ2aWNlc0J1dHRvbnMgPSB0aGlzLiRzZXJ2aWNlcy5xdWVyeVNlbGVjdG9yQWxsKCcuaWNvbi0tcGx1cycpO1xuXG4gICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICAgICAgX3RoaXMuZG9tRXZlbnRzLmFkZChfdGhpcy4kc2VydmljZXNCdXR0b25zW2ldLCAnY2xpY2snLCBmdW5jdGlvbiAoYSwgZSwgZWwpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLmFwcFVpLmlzQW5pbWF0aW5nKSBfdGhpcy5jbG9zZVNlcnZpY2VzTW9iaWxlKGEsIGUsIGVsLCBpKTtlbHNlIF90aGlzLm9wZW5TZXJ2aWNlc01vYmlsZShhLCBlLCBlbCwgaSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRzZXJ2aWNlc0J1dHRvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIF9sb29wKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLiRoZXJvKSB7XG4gICAgICAgICAgdGhpcy4kaGVyb0NpcmNsZSA9IHRoaXMuJGhlcm8ucXVlcnlTZWxlY3RvcignLmNpcmNsZScpO1xuICAgICAgICAgIHRoaXMuZG9tRXZlbnRzLmFkZCh0aGlzLiRoZXJvQ2lyY2xlLCAnY2xpY2snLCBmdW5jdGlvbiAoYSwgZSwgZWwpIHtcbiAgICAgICAgICAgIF90aGlzLm9wZW5Gb3JtKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVsb2FkKCkge1xuICAgICAgdmFyIF9tYWluID0gW107XG4gICAgICB2YXIgX3NlY29uZGFyeSA9IFtdOyAvLyBpZih0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCAmJiB0aGlzLiR2aWRlb0VsKVxuICAgICAgLy8ge1xuICAgICAgLy8gICAgIGNvbnN0IHZpZGVvVXJsID0gdGhpcy4kdmlkZW9FbC5xdWVyeVNlbGVjdG9yKCd2aWRlbyBzb3VyY2UnKS5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgLy8gICAgIF9tYWluLnB1c2godmlkZW9VcmwpO1xuICAgICAgLy8gfVxuXG4gICAgICB0aGlzLnByZWxvYWRJdGVtcyA9IHtcbiAgICAgICAgbWFpbjogX21haW4sXG4gICAgICAgIHNlY29uZGFyeTogX3NlY29uZGFyeVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmVmb3JlRW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlRW50ZXIoKSB7XG4gICAgICB0aGlzLnNldEVudGVyQW5pbWF0aW9uKCk7XG5cbiAgICAgIGlmICh0aGlzLiRwbGF0Zm9ybXMpIHtcbiAgICAgICAgdGhpcy4kcGxhdGZvcm1zVGl0bGUgPSB0aGlzLiRwbGF0Zm9ybXMucXVlcnlTZWxlY3RvcignLnRpdGxlLS1zbWFsbCcpO1xuXG4gICAgICAgIGlmICh0aGlzLiRwbGF0Zm9ybXNUaXRsZSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcbiAgICAgICAgICBuZXcgU3BsaXRUZXh0KHRoaXMuJHBsYXRmb3Jtc1RpdGxlLCB7XG4gICAgICAgICAgICB0eXBlOiAnbGluZXMgd29yZHMnLFxuICAgICAgICAgICAgbGluZXNDbGFzczogJ2xpbmUgbGluZS0tKysnLFxuICAgICAgICAgICAgd29yZHNDbGFzczogJ3dvcmQgd29yZC0tKysnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHdvcmRzID0gdGhpcy4kcGxhdGZvcm1zVGl0bGUucXVlcnlTZWxlY3RvckFsbCgnLndvcmQnKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdzYXAuc2V0KHdvcmRzW2ldLCB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgICAgICAgeTogJzEwMCUnLFxuICAgICAgICAgICAgICByb3RhdGlvblg6ICczZGVnJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB0aGlzLiRwbGF0Zm9ybXNUaXRsZS5xdWVyeVNlbGVjdG9yKCdzdHJvbmcnKS5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsICc8c3BhbiBjbGFzcz1cInN0cm9rZVwiPjwvc3Bhbj4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy4kc2VydmljZXMgJiYgIXRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB7XG4gICAgICAgIHRoaXMuJHNlcnZpY2VzSXRlbSA9IHRoaXMuJHNlcnZpY2VzLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zZXJ2aWNlc19faXRlbS0tbW9iaWxlJyk7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuJHNlcnZpY2VzSXRlbS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB0aGlzLiRzZXJ2aWNlc0luZm8gPSB0aGlzLiRzZXJ2aWNlc0l0ZW1bX2ldLnF1ZXJ5U2VsZWN0b3IoJy5pbmZvJyk7XG4gICAgICAgICAgdmFyIF9oZWlnaHQgPSB0aGlzLiRzZXJ2aWNlc0luZm8ucXVlcnlTZWxlY3RvcignLmNvbHVtbnMnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG5cbiAgICAgICAgICB2YXIgX21vdmVtZW50ID0gX2hlaWdodCAtIHdpbmRvdy5pbm5lcldpZHRoICogMC4xO1xuXG4gICAgICAgICAgZ3NhcC5zZXQodGhpcy4kc2VydmljZXNJbmZvLCB7XG4gICAgICAgICAgICB5OiBfbW92ZW1lbnQgKyAncHgnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gV2ViR0xcblxuXG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgdGhpcy5ob21lMSA9IG5ldyBIb21lMUFwcCh7XG4gICAgICAgICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgICAgICAgZG9tRWxlbWVudDogdGhpcy4kY2FudmFzSG9tZTFcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaG9tZTIgPSBuZXcgSG9tZTJBcHAoe1xuICAgICAgICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgICAgICAgIGRvbUVsZW1lbnQ6IHRoaXMuJGNhbnZhc0hvbWUyXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhvbWUzID0gbmV3IEhvbWUzQXBwKHtcbiAgICAgICAgICByZW5kZXJlcjogdGhpcyxcbiAgICAgICAgICBkb21FbGVtZW50OiB0aGlzLiRjYW52YXNIb21lMyAvLyBzbGlkZXJSZWY6IHRoaXMuX3NvbHV0aW9uc1NsaWRlclxuXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhvbWU0ID0gbmV3IEhvbWU0QXBwKHtcbiAgICAgICAgICByZW5kZXJlcjogdGhpcyxcbiAgICAgICAgICBkb21FbGVtZW50OiB0aGlzLiRjYW52YXNIb21lNFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaG9tZTFfbSA9IG5ldyBIb21lMUFwcF9tKHtcbiAgICAgICAgICByZW5kZXJlcjogdGhpcyxcbiAgICAgICAgICBkb21FbGVtZW50OiB0aGlzLiRjYW52YXNIb21lMV9tXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhvbWUyYV9tID0gbmV3IEhvbWUyQXBwX20oe1xuICAgICAgICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgICAgICAgIGRvbUVsZW1lbnQ6IHRoaXMuJGNhbnZhc0hvbWUyYV9tLFxuICAgICAgICAgIGRvdENvbG9yOiAnI2U4NDM3MScsXG4gICAgICAgICAgaW5jcl9yYWRpbzogMTMuMlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ob21lMmJfbSA9IG5ldyBIb21lMkFwcF9tKHtcbiAgICAgICAgICByZW5kZXJlcjogdGhpcyxcbiAgICAgICAgICBkb21FbGVtZW50OiB0aGlzLiRjYW52YXNIb21lMmJfbSxcbiAgICAgICAgICBkb3RDb2xvcjogJyMwMDdFRkYnLFxuICAgICAgICAgIGluY3JfcmFkaW86IDEzLjJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEVudGVyQW5pbWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEVudGVyQW5pbWF0aW9uKCkge1xuICAgICAgLy8gU2V0IEVudGVyIEFuaW1hdGlvblxuICAgICAgaWYgKHRoaXMuJGhlcm8pIHtcbiAgICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB7XG4gICAgICAgICAgLy8gU2VsZWN0b3JzXG4gICAgICAgICAgdGhpcy4kdGl0bGVIZXJvID0gdGhpcy4kaGVyby5xdWVyeVNlbGVjdG9yKCdoMScpO1xuICAgICAgICAgIHRoaXMuJHN1YlRpdGxlSGVybyA9IHRoaXMuJGhlcm8ucXVlcnlTZWxlY3RvcignaDInKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ld1xuXG4gICAgICAgICAgbmV3IFNwbGl0VGV4dCh0aGlzLiR0aXRsZUhlcm8sIHtcbiAgICAgICAgICAgIHR5cGU6ICdsaW5lcyB3b3JkcycsXG4gICAgICAgICAgICBsaW5lc0NsYXNzOiAnbGluZSBsaW5lLS0rKycsXG4gICAgICAgICAgICB3b3Jkc0NsYXNzOiAnd29yZCB3b3JkLS0rKydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgdGl0bGVXb3JkcyA9IHRoaXMuJHRpdGxlSGVyby5xdWVyeVNlbGVjdG9yQWxsKCcud29yZCcpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aXRsZVdvcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBnc2FwLnNldCh0aXRsZVdvcmRzW2pdLCB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgICAgICAgeTogJzEwMCUnLFxuICAgICAgICAgICAgICByb3RhdGlvblg6ICczZGVnJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3XG5cblxuICAgICAgICAgIG5ldyBTcGxpdFRleHQodGhpcy4kc3ViVGl0bGVIZXJvLCB7XG4gICAgICAgICAgICB0eXBlOiAnbGluZXMgd29yZHMnLFxuICAgICAgICAgICAgbGluZXNDbGFzczogJ2xpbmUgbGluZS0tKysnLFxuICAgICAgICAgICAgd29yZHNDbGFzczogJ3dvcmQgd29yZC0tKysnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHN1YnRpdGxlV29yZHMgPSB0aGlzLiRzdWJUaXRsZUhlcm8ucXVlcnlTZWxlY3RvckFsbCgnLndvcmQnKTtcblxuICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBzdWJ0aXRsZVdvcmRzLmxlbmd0aDsgX2orKykge1xuICAgICAgICAgICAgZ3NhcC5zZXQoc3VidGl0bGVXb3Jkc1tfal0sIHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICAgICAgICB5OiAnMTAwJScsXG4gICAgICAgICAgICAgIHJvdGF0aW9uWDogJzNkZWcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnc2FwLnNldCh0aGlzLiR2aWRlbywge1xuICAgICAgICAgICAgeTogJy01MHZoJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGdzYXAuc2V0KHRoaXMuJHZpZGVvRWwsIHtcbiAgICAgICAgICAgIGNsaXBQYXRoOiAnY2lyY2xlKDAlIGF0IDUwJSA1MCUpJyxcbiAgICAgICAgICAgIHdlYmtpdENsaXBQYXRoOiAnY2lyY2xlKDAlIGF0IDUwJSA1MCUpJ1xuICAgICAgICAgIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3XG5cbiAgICAgICAgICBuZXcgU3BsaXRUZXh0KHRoaXMuJHZpZGVvRWwucXVlcnlTZWxlY3RvcignLm1lZ2F0aXRsZScpLCB7XG4gICAgICAgICAgICB0eXBlOiAnbGluZXMgd29yZHMgY2hhcnMnLFxuICAgICAgICAgICAgbGluZXNDbGFzczogJ2xpbmUgbGluZS0tKysnLFxuICAgICAgICAgICAgd29yZHNDbGFzczogJ3dvcmQgd29yZC0tKysnLFxuICAgICAgICAgICAgY2hhcnNDbGFzczogJ2NoYXIgY2hhci0tKysnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGNoYXJzID0gdGhpcy4kdmlkZW9FbC5xdWVyeVNlbGVjdG9yKCcubWVnYXRpdGxlJykucXVlcnlTZWxlY3RvckFsbCgnLmNoYXInKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdzYXAuc2V0KGNoYXJzW2ldLCB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVudGVyKCkge1xuICAgICAgLy8gU2hvdyBoZWFkZXJcbiAgICAgIGlmICghdGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHRoaXMuYXBwVWkuc2hvd0hlYWRlcigpOyAvLyBTdGFydCBmdW5jdGlvbnNcblxuICAgICAgdGhpcy5pbml0KCk7IC8vIERpc2FibGUgc2Nyb2xsXG5cbiAgICAgIGlmICh0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkgdGhpcy5hcHBTdG9yZS5jdXJyZW50U2VjdGlvbi5zdXBlclNjcm9sbGVyLl9zY3JvbGwuZW5hYmxlID0gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuaW5pdEhvbWVUaXRsZXMoKTtcbiAgICAgIHRoaXMuaW5pdFNvbHV0aW9uc1NsaWRlcigpO1xuICAgICAgdGhpcy5pbml0VGVjaG5vbG9neUNhcmRzKCk7XG4gICAgICB0aGlzLmluaXRQbGF0Zm9ybXNEcmFnZ2FibGUoKTtcblxuICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB7XG4gICAgICAgIHRoaXMuaW5pdERhdGEoKTtcbiAgICAgICAgdGhpcy5pbml0U29sdXRpb25zRmVhdXR1cmVzKCk7XG4gICAgICAgIHRoaXMuaW5pdFBhcmFsbGF4Q2FyZHMoKTsgLy8gV2ViR0xcblxuICAgICAgICB0aGlzLmhvbWUxLmluaXQoKTtcbiAgICAgICAgdGhpcy5ob21lMi5pbml0KCk7XG4gICAgICAgIHRoaXMuaG9tZTMuaW5pdCh7XG4gICAgICAgICAgc2xpZGVyUmVmOiB0aGlzLl9zb2x1dGlvbnNTbGlkZXJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaG9tZTQuaW5pdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbml0RGF0YURyYWdnYWJsZU1vYmlsZSgpO1xuICAgICAgICB0aGlzLmluaXRTb2x1dGlvbnNEcmFnZ2FibGVNb2JpbGUoKTsgLy8gV2ViR0xcblxuICAgICAgICB0aGlzLmhvbWUxX20uaW5pdCgpO1xuICAgICAgICB0aGlzLmhvbWUyYV9tLmluaXQoKTtcbiAgICAgICAgdGhpcy5ob21lMmJfbS5pbml0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRFbnRlckFuaW1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0RW50ZXJBbmltYXRpb24oKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gRmFsbFxuICAgICAgZ3NhcC50byh0aGlzLiR2aWRlbywge1xuICAgICAgICB5OiAnMHZoJyxcbiAgICAgICAgZHVyYXRpb246IDEuNixcbiAgICAgICAgZWFzZTogJ2V4cG8uaW5PdXQnLFxuICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgIF90aGlzMi5pbml0VmlkZW9QaW4oKTtcblxuICAgICAgICAgIF90aGlzMi5pbml0VGVjaG5vbG9neVBpbigpO1xuXG4gICAgICAgICAgX3RoaXMyLmFwcFVpLnNob3dIZWFkZXIoKTtcblxuICAgICAgICAgIF90aGlzMi5hcHBTdG9yZS5jdXJyZW50U2VjdGlvbi5zdXBlclNjcm9sbGVyLl9zY3JvbGwuZW5hYmxlID0gdHJ1ZTsgLy8gU2hvdyBjb29raWVzXG5cbiAgICAgICAgICBpZiAoX3RoaXMyLmFwcFVpLiRjb29raWVzICYmIF90aGlzMi5hcHBTdG9yZS5pc0Rlc2t0b3ApIGdzYXAudG8oX3RoaXMyLmFwcFVpLiRjb29raWVzLCB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgZHVyYXRpb246IDEsXG4gICAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIENpcmNsZVxuXG4gICAgICBnc2FwLnRvKHRoaXMuJHZpZGVvRWwsIHtcbiAgICAgICAgY2xpcFBhdGg6ICdjaXJjbGUoMTAlIGF0IDUwJSA1MCUpJyxcbiAgICAgICAgd2Via2l0Q2xpcFBhdGg6ICdjaXJjbGUoMTAlIGF0IDUwJSA1MCUpJyxcbiAgICAgICAgZHVyYXRpb246IDEuNixcbiAgICAgICAgZWFzZTogJ2V4cG8uaW5PdXQnXG4gICAgICB9KTsgLy8gVGV4dFxuXG4gICAgICB2YXIgdGl0bGVXb3JkcyA9IHRoaXMuJHRpdGxlSGVyby5xdWVyeVNlbGVjdG9yQWxsKCcud29yZCcpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRpdGxlV29yZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZ3NhcC50byh0aXRsZVdvcmRzW2pdLCB7XG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICB5OiAnMCUnLFxuICAgICAgICAgIHJvdGF0aW9uWDogJzBkZWcnLFxuICAgICAgICAgIGVhc2U6ICdleHBvLm91dCcsXG4gICAgICAgICAgZHVyYXRpb246IDEuNCxcbiAgICAgICAgICBkZWxheTogMC45ICsgaiAqIDAuMDJcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdWJ0aXRsZVdvcmRzID0gdGhpcy4kc3ViVGl0bGVIZXJvLnF1ZXJ5U2VsZWN0b3JBbGwoJy53b3JkJyk7XG5cbiAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IHN1YnRpdGxlV29yZHMubGVuZ3RoOyBfajIrKykge1xuICAgICAgICBnc2FwLnRvKHN1YnRpdGxlV29yZHNbX2oyXSwge1xuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgeTogJzAlJyxcbiAgICAgICAgICByb3RhdGlvblg6ICcwZGVnJyxcbiAgICAgICAgICBlYXNlOiAnZXhwby5vdXQnLFxuICAgICAgICAgIGR1cmF0aW9uOiAxLjQsXG4gICAgICAgICAgZGVsYXk6IDAuOSArIF9qMiAqIDAuMDJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRWaWRlb1BpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0VmlkZW9QaW4oKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuJHZpZGVvRWwpIHtcbiAgICAgICAgLy8gU2V0IGFuaW1hdGlvblxuICAgICAgICBnc2FwLnNldCh0aGlzLiR2aWRlb0VsLCB7XG4gICAgICAgICAgeTogJzB2aCdcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmFwcFN0b3JlLmNsaWVudC5icm93c2VyID09PSAnY2hyb21lJykgZ3NhcC5zZXQodGhpcy4kdmlkZW9FbC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpLCB7XG4gICAgICAgICAgd2lkdGg6ICcxMjAlJ1xuICAgICAgICB9KTtlbHNlIGdzYXAuc2V0KHRoaXMuJHZpZGVvRWwucXVlcnlTZWxlY3RvcigndmlkZW8nKSwge1xuICAgICAgICAgIHNjYWxlOiAxLjFcbiAgICAgICAgfSk7XG4gICAgICAgIGdzYXAuc2V0KHRoaXMuJHZpZGVvRWwucXVlcnlTZWxlY3RvcignLnZpZGVvX19vdmVybGF5JyksIHtcbiAgICAgICAgICBvcGFjaXR5OiAwLjhcbiAgICAgICAgfSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcblxuICAgICAgICBuZXcgU3BsaXRUZXh0KHRoaXMuJHZpZGVvRWwucXVlcnlTZWxlY3RvcignLnRpdGxlJyksIHtcbiAgICAgICAgICB0eXBlOiAnbGluZXMgd29yZHMnLFxuICAgICAgICAgIGxpbmVzQ2xhc3M6ICdsaW5lIGxpbmUtLSsrJyxcbiAgICAgICAgICB3b3Jkc0NsYXNzOiAnd29yZCB3b3JkLS0rKydcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB3b3JkcyA9IHRoaXMuJHZpZGVvRWwucXVlcnlTZWxlY3RvcignLnRpdGxlJykucXVlcnlTZWxlY3RvckFsbCgnLndvcmQnKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZ3NhcC5zZXQod29yZHNbaV0sIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgICAgIHk6ICcxMDAlJyxcbiAgICAgICAgICAgIHJvdGF0aW9uOiAnM2RlZydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBTdGFydCB2aWRlbyB0aW1lbGluZVxuXG5cbiAgICAgICAgdGhpcy5fdmlkZW9UaW1lbGluZSA9IGdzYXAudGltZWxpbmUoe1xuICAgICAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgICBlYXNlOiAnbm9uZScsXG4gICAgICAgICAgICBkdXJhdGlvbjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2Nyb2xsVHJpZ2dlcjoge1xuICAgICAgICAgICAgdHJpZ2dlcjogdGhpcy4kdmlkZW8sXG4gICAgICAgICAgICBzdGFydDogJ3RvcCB0b3AnLFxuICAgICAgICAgICAgZW5kOiAnYm90dG9tIGJvdHRvbScsXG4gICAgICAgICAgICBzY3J1YjogdHJ1ZSxcbiAgICAgICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShzZWxmKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpczMuaG9tZTEpIF90aGlzMy5ob21lMS5vblVwZGF0ZU9wZW5Qcm9ncmVzcyhzZWxmLnByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBBbmltYXRlIGluL291dFxuXG4gICAgICAgIHRoaXMuX3ZpZGVvVGltZWxpbmUudG8odGhpcy4kdmlkZW9FbCwge1xuICAgICAgICAgIHk6ICcyMDB2aCcsXG4gICAgICAgICAgZHVyYXRpb246IDFcbiAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgdGhpcy5fdmlkZW9UaW1lbGluZS50byh0aGlzLiR2aWRlb0VsLCB7XG4gICAgICAgICAgY2xpcFBhdGg6ICdjaXJjbGUoNzUlIGF0IDUwJSA1MCUpJyxcbiAgICAgICAgICB3ZWJraXRDbGlwUGF0aDogJ2NpcmNsZSg3NSUgYXQgNTAlIDUwJSknLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLjVcbiAgICAgICAgfSwgMCk7IC8vIFNjYWxlIHZpZGVvXG5cblxuICAgICAgICBpZiAodGhpcy5hcHBTdG9yZS5jbGllbnQuYnJvd3NlciA9PT0gJ2Nocm9tZScpIHRoaXMuX3ZpZGVvVGltZWxpbmUudG8odGhpcy4kdmlkZW9FbC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpLCB7XG4gICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBkdXJhdGlvbjogMC4zNVxuICAgICAgICB9LCAwLjE1KTtlbHNlIHRoaXMuX3ZpZGVvVGltZWxpbmUudG8odGhpcy4kdmlkZW9FbC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpLCB7XG4gICAgICAgICAgc2NhbGU6IDEsXG4gICAgICAgICAgZHVyYXRpb246IDAuMzVcbiAgICAgICAgfSwgMC4xNSk7XG4gICAgICAgIGlmICh0aGlzLmFwcFN0b3JlLmNsaWVudC5icm93c2VyID09PSAnc2FmYXJpJykgdGhpcy5fdmlkZW9UaW1lbGluZS50byh0aGlzLiR2aWRlb0VsLnF1ZXJ5U2VsZWN0b3IoJy52aWRlb19fb3ZlcmxheScpLCB7XG4gICAgICAgICAgb3BhY2l0eTogMC4yLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLjM1XG4gICAgICAgIH0sIDAuMTUpO2Vsc2UgdGhpcy5fdmlkZW9UaW1lbGluZS50byh0aGlzLiR2aWRlb0VsLnF1ZXJ5U2VsZWN0b3IoJy52aWRlb19fb3ZlcmxheScpLCB7XG4gICAgICAgICAgb3BhY2l0eTogMC40LFxuICAgICAgICAgIGR1cmF0aW9uOiAwLjM1XG4gICAgICAgIH0sIDAuMTUpO1xuICAgICAgICB2YXIgY2hhcnMgPSB0aGlzLiR2aWRlb0VsLnF1ZXJ5U2VsZWN0b3IoJy5tZWdhdGl0bGUnKS5xdWVyeVNlbGVjdG9yQWxsKCcuY2hhcicpO1xuXG4gICAgICAgIHRoaXMuX3ZpZGVvVGltZWxpbmUudG8oY2hhcnMsIHtcbiAgICAgICAgICBvcGFjaXR5OiAwLjEsXG4gICAgICAgICAgc3RhZ2dlcjogMC4zNSAvIGNoYXJzLmxlbmd0aCxcbiAgICAgICAgICBkdXJhdGlvbjogMC4zNSAvIGNoYXJzLmxlbmd0aFxuICAgICAgICB9LCAwLjE1KTtcblxuICAgICAgICB0aGlzLl92aWRlb1RpbWVsaW5lLnRvKGNoYXJzLCB7XG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICBzdGFnZ2VyOiAwLjY1IC8gY2hhcnMubGVuZ3RoLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLjY1IC8gY2hhcnMubGVuZ3RoXG4gICAgICAgIH0sIDAuMzUpO1xuXG4gICAgICAgIHZhciB0aXRsZVdvcmRzID0gdGhpcy4kdmlkZW9FbC5xdWVyeVNlbGVjdG9yKCcudGl0bGUnKS5xdWVyeVNlbGVjdG9yQWxsKCcud29yZCcpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGl0bGVXb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRoaXMuX3ZpZGVvVGltZWxpbmUudG8odGl0bGVXb3Jkc1tqXSwge1xuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIHk6ICcwJScsXG4gICAgICAgICAgICByb3RhdGlvbjogJzBkZWcnLFxuICAgICAgICAgICAgZHVyYXRpb246IDAuNzUgLyB0aXRsZVdvcmRzLmxlbmd0aFxuICAgICAgICAgIH0sIDAuNzUgKyBqICogMC4wMSk7XG4gICAgICAgIH0gLy8gV2ViR0xcblxuXG4gICAgICAgIHRoaXMuX2NhbnZhc1BpbiA9IFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgICB0cmlnZ2VyOiB0aGlzLiRoZXJvLFxuICAgICAgICAgIHN0YXJ0OiAndG9wIHRvcCcsXG4gICAgICAgICAgZW5kOiAnYm90dG9tIGJvdHRvbScsXG4gICAgICAgICAgc2NydWI6IHRydWUsXG4gICAgICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKHNlbGYpIHtcbiAgICAgICAgICAgIC8vIE1ldGVtb3MgZWwgY2FsY3VsbyBkZW50cm8gZGUgb25VcGRhdGUgcG9ycXVlIHNpbm8gZmFsbGEgYWwgaGFjZXIgcmVzaXplXG4gICAgICAgICAgICB2YXIgX29mZnNldDIgPSBfdGhpczMuJGhlcm8ub2Zmc2V0SGVpZ2h0IC0gX3RoaXMzLiRjYW52YXNIb21lMS5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICAgIGdzYXAuc2V0KF90aGlzMy4kY2FudmFzSG9tZTEsIHtcbiAgICAgICAgICAgICAgeTogX29mZnNldDIgKiBzZWxmLnByb2dyZXNzICsgJ3B4J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZm9vdGVyQ2FudmFzUGluID0gU2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xuICAgICAgICAgIHRyaWdnZXI6IHRoaXMuJGZvb3RlcixcbiAgICAgICAgICBzdGFydDogJ3RvcCBib3R0b20nLFxuICAgICAgICAgIGVuZDogJ2JvdHRvbSBib3R0b20nLFxuICAgICAgICAgIHNjcnViOiB0cnVlLFxuICAgICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShzZWxmKSB7XG4gICAgICAgICAgICB2YXIgcG9zWSA9IC1fdGhpczMuJGNhbnZhc0hvbWU0Lm9mZnNldEhlaWdodCArIF90aGlzMy4kY2FudmFzSG9tZTQub2Zmc2V0SGVpZ2h0ICogMiAqIHNlbGYucHJvZ3Jlc3M7XG4gICAgICAgICAgICBnc2FwLnNldChfdGhpczMuJGNhbnZhc0hvbWU0LCB7XG4gICAgICAgICAgICAgIHk6IHBvc1kgKyAncHgnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0SG9tZVRpdGxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0SG9tZVRpdGxlcygpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy4kcGxhdGZvcm1zVGl0bGUpIHtcbiAgICAgICAgU2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xuICAgICAgICAgIHN0YXJ0OiAndG9wIGJvdHRvbScsXG4gICAgICAgICAgdHJpZ2dlcjogdGhpcy4kcGxhdGZvcm1zVGl0bGUsXG4gICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICBvbkVudGVyOiBmdW5jdGlvbiBvbkVudGVyKCkge1xuICAgICAgICAgICAgdmFyIHdvcmRzID0gX3RoaXM0LiRwbGF0Zm9ybXNUaXRsZS5xdWVyeVNlbGVjdG9yQWxsKCcud29yZCcpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGdzYXAudG8od29yZHNbaV0sIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHk6ICcwJScsXG4gICAgICAgICAgICAgICAgcm90YXRpb25YOiAnMGRlZycsXG4gICAgICAgICAgICAgICAgZWFzZTogJ2V4cG8uaW5PdXQnLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxLjIsXG4gICAgICAgICAgICAgICAgZGVsYXk6IDAuMiArIGkgKiAwLjAxXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoX3RoaXM0LmFwcFN0b3JlLmlzRGVza3RvcCkge1xuICAgICAgICAgICAgICB2YXIgJHN0cm9rZSA9IF90aGlzNC4kcGxhdGZvcm1zVGl0bGUucXVlcnlTZWxlY3RvcignLnN0cm9rZScpO1xuXG4gICAgICAgICAgICAgIGdzYXAudG8oJHN0cm9rZSwge1xuICAgICAgICAgICAgICAgIHNjYWxlWDogMSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMS4yLFxuICAgICAgICAgICAgICAgIGVhc2U6ICdleHBvLmluT3V0JyxcbiAgICAgICAgICAgICAgICBkZWxheTogMC41XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXREYXRhKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIC8vIFNlbGVjdG9yc1xuICAgICAgdGhpcy4kZGF0YUxpbmVzID0gdGhpcy4kZGF0YS5xdWVyeVNlbGVjdG9yQWxsKCcuZGF0YWxpbmUnKTtcbiAgICAgIHRoaXMuJGRhdGFJdGVtcyA9IHRoaXMuJGRhdGEucXVlcnlTZWxlY3RvckFsbCgnLmNvbHVtbnNfX2l0ZW0nKTsgLy8gY29uc3QgX3BhZGRpbmcgPSB3aW5kb3cuaW5uZXJXaWR0aCAqIDAuMztcbiAgICAgIC8vIFNldCBhbmltYXRpb25cblxuICAgICAgZ3NhcC5zZXQodGhpcy4kZGF0YUxpbmVzLCB7XG4gICAgICAgIGRyYXdTVkc6IDBcbiAgICAgIH0pO1xuICAgICAgZ3NhcC5zZXQodGhpcy4kZGF0YUl0ZW1zLCB7XG4gICAgICAgIG9wYWNpdHk6IDAuMDAwMVxuICAgICAgfSk7IC8vIENyZWF0ZSBsaW5lcyB0cmlnZ2VyXG5cbiAgICAgIHRoaXMuX2RhdGFUaW1lbGluZSA9IGdzYXAudGltZWxpbmUoe1xuICAgICAgICBkZWZhdWx0czoge1xuICAgICAgICAgIGVhc2U6ICdub25lJyxcbiAgICAgICAgICBkdXJhdGlvbjogMVxuICAgICAgICB9LFxuICAgICAgICBzY3JvbGxUcmlnZ2VyOiB7XG4gICAgICAgICAgdHJpZ2dlcjogdGhpcy4kZGF0YSxcbiAgICAgICAgICBzdGFydDogJ3RvcCA3MCUnLFxuICAgICAgICAgIGVuZDogJzgwJSBib3R0b20nLFxuICAgICAgICAgIHNjcnViOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBMaW5lcyBpbi9vdXQgYW5pbWF0aW9uXG5cbiAgICAgIHRoaXMuX2RhdGFUaW1lbGluZS50byh0aGlzLiRkYXRhTGluZXNbMF0sIHtcbiAgICAgICAgZHJhd1NWRzogJzEwMCUnLFxuICAgICAgICBkdXJhdGlvbjogMC41XG4gICAgICB9LCAwKTtcblxuICAgICAgdGhpcy5fZGF0YVRpbWVsaW5lLnRvKHRoaXMuJGRhdGFMaW5lc1sxXSwge1xuICAgICAgICBkcmF3U1ZHOiAnMTAwJScsXG4gICAgICAgIGR1cmF0aW9uOiAwLjVcbiAgICAgIH0sIDAuNSk7XG5cbiAgICAgIHRoaXMuX2RhdGFUaW1lbGluZS50byh0aGlzLiRkYXRhTGluZXNbMl0sIHtcbiAgICAgICAgZHJhd1NWRzogJzEwMCUnLFxuICAgICAgICBkdXJhdGlvbjogMC4zNVxuICAgICAgfSwgMSk7IC8vIEZpcnN0IGltYWdlIHRyaWdnZXIgYW5kIGFuaW1hdGlvblxuXG5cbiAgICAgIFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgdHJpZ2dlcjogdGhpcy4kZGF0YUxpbmVzWzBdLFxuICAgICAgICBzdGFydDogJ3RvcCA3MCUnLFxuICAgICAgICBlbmQ6ICdib3R0b20gYm90dG9tJyxcbiAgICAgICAgc2NydWI6IHRydWUsXG4gICAgICAgIG9uRW50ZXI6IGZ1bmN0aW9uIG9uRW50ZXIoKSB7XG4gICAgICAgICAgZ3NhcC50byhfdGhpczUuJGRhdGFJdGVtc1swXSwge1xuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FbnRlckJhY2s6IGZ1bmN0aW9uIG9uRW50ZXJCYWNrKCkge1xuICAgICAgICAgIGdzYXAudG8oX3RoaXM1LiRkYXRhSXRlbXNbMF0sIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIFNlY29uZCBpbWFnZSB0cmlnZ2VyIGFuZCBhbmltYXRpb25cblxuICAgICAgU2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xuICAgICAgICB0cmlnZ2VyOiB0aGlzLiRkYXRhTGluZXNbMV0sXG4gICAgICAgIHN0YXJ0OiAndG9wIDU1JScsXG4gICAgICAgIGVuZDogJ2JvdHRvbSBib3R0b20nLFxuICAgICAgICBzY3J1YjogdHJ1ZSxcbiAgICAgICAgb25FbnRlcjogZnVuY3Rpb24gb25FbnRlcigpIHtcbiAgICAgICAgICBnc2FwLnRvKF90aGlzNS4kZGF0YUl0ZW1zWzFdLCB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgZHVyYXRpb246IDAuNCxcbiAgICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkVudGVyQmFjazogZnVuY3Rpb24gb25FbnRlckJhY2soKSB7XG4gICAgICAgICAgZ3NhcC50byhfdGhpczUuJGRhdGFJdGVtc1sxXSwge1xuICAgICAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICAgICAgZHVyYXRpb246IDAuNCxcbiAgICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gVGhpcmQgaW1hZ2UgdHJpZ2dlciBhbmQgYW5pbWF0aW9uXG5cbiAgICAgIFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgdHJpZ2dlcjogdGhpcy4kZGF0YUxpbmVzWzJdLFxuICAgICAgICBzdGFydDogJ3RvcCA0OCUnLFxuICAgICAgICBlbmQ6ICdib3R0b20gYm90dG9tJyxcbiAgICAgICAgc2NydWI6IHRydWUsXG4gICAgICAgIG9uRW50ZXI6IGZ1bmN0aW9uIG9uRW50ZXIoKSB7XG4gICAgICAgICAgZ3NhcC50byhfdGhpczUuJGRhdGFJdGVtc1syXSwge1xuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FbnRlckJhY2s6IGZ1bmN0aW9uIG9uRW50ZXJCYWNrKCkge1xuICAgICAgICAgIGdzYXAudG8oX3RoaXM1LiRkYXRhSXRlbXNbMl0sIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXREYXRhRHJhZ2dhYmxlTW9iaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXREYXRhRHJhZ2dhYmxlTW9iaWxlKCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIC8vIFNlbGVjdG9yc1xuICAgICAgdGhpcy4kZGF0YVNsaWRlciA9IHRoaXMuJGRhdGEucXVlcnlTZWxlY3RvcignLnNsaWRlcicpO1xuICAgICAgdGhpcy4kZGF0YVNsaWRlckl0ZW1zID0gdGhpcy4kZGF0YVNsaWRlci5xdWVyeVNlbGVjdG9yQWxsKCcuc2xpZGVyX19pdGVtJyk7XG4gICAgICB0aGlzLiRkYXRhU2xpZGVyUHJvZ3Jlc3MgPSB0aGlzLiRkYXRhU2xpZGVyLnF1ZXJ5U2VsZWN0b3IoJy5zbGlkZXJfX3Byb2dyZXNzJyk7IC8vIENvbXBhcmUgaXRlbXMgaGVpZ2h0XG5cbiAgICAgIHRoaXMuX21heEhlaWdodCA9IDA7XG4gICAgICB0aGlzLl9hcnJheUl0ZW1zID0gQXJyYXkuZnJvbSh0aGlzLiRkYXRhU2xpZGVySXRlbXMpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2FycmF5SXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9lbGVtZW50SGVpZ2h0ID0gdGhpcy5fYXJyYXlJdGVtc1tpXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKF9lbGVtZW50SGVpZ2h0ID4gdGhpcy5fbWF4SGVpZ2h0KSB0aGlzLl9tYXhIZWlnaHQgPSBfZWxlbWVudEhlaWdodDtcbiAgICAgIH0gLy8gQXV0byBoZWlnaHRcblxuXG4gICAgICB0aGlzLiRkYXRhU2xpZGVyLnN0eWxlLmhlaWdodCA9IHRoaXMuX21heEhlaWdodCArIDQwICsgJ3B4JzsgLy8gQ3JlYXRlIGRyYWdnYWJsZVxuXG4gICAgICB0aGlzLl9kYXRhRHJhZ2dhYmxlID0gbmV3IFN1cGVyRHJhZ2dhYmxlKHtcbiAgICAgICAgZWw6IHRoaXMuJGRhdGEsXG4gICAgICAgIHNuYXA6IGZhbHNlLFxuICAgICAgICBzbmFwVG86ICdjZW50ZXInLFxuICAgICAgICBkb3RzOiBmYWxzZSxcbiAgICAgICAgb25SYWY6IGZ1bmN0aW9uIG9uUmFmKHBlcmNlbnQsIHByb2dyZXNzLCBwcm9ncmVzc09yaWdpbikge1xuICAgICAgICAgIGdzYXAudG8oX3RoaXM2LiRkYXRhU2xpZGVyUHJvZ3Jlc3MuY2hpbGRyZW5bMF0sIHtcbiAgICAgICAgICAgIHNjYWxlWDogcHJvZ3Jlc3NPcmlnaW4gKyBwcm9ncmVzc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3BlblNlcnZpY2VzTW9iaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5TZXJ2aWNlc01vYmlsZShhLCBlLCBlbCwgaW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLmFwcFVpLmlzQW5pbWF0aW5nKSByZXR1cm47XG4gICAgICB0aGlzLmFwcFVpLmlzQW5pbWF0aW5nID0gdHJ1ZTsgLy8gU2VsZWN0b3JzXG5cbiAgICAgIHRoaXMuJHNlcnZpY2VzSW5mbyA9IHRoaXMuJHNlcnZpY2VzSXRlbVtpbmRleF0ucXVlcnlTZWxlY3RvcignLmluZm8nKTtcbiAgICAgIHRoaXMuJHNlcnZpY2VzVGV4dCA9IHRoaXMuJHNlcnZpY2VzSXRlbVtpbmRleF0ucXVlcnlTZWxlY3RvcignLmNvbHVtbnMnKTsgLy8gQW5pbWF0ZSBpblxuXG4gICAgICBnc2FwLnRvKHRoaXMuJHNlcnZpY2VzSW5mbywge1xuICAgICAgICB5OiAnMHB4JyxcbiAgICAgICAgZHVyYXRpb246IDAuNixcbiAgICAgICAgZWFzZTogJ2V4cG8ub3V0J1xuICAgICAgfSk7XG4gICAgICBnc2FwLnRvKHRoaXMuJHNlcnZpY2VzVGV4dCwge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBkdXJhdGlvbjogMC42LFxuICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVNlcnZpY2VzTW9iaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlU2VydmljZXNNb2JpbGUoYSwgZSwgZWwsIGluZGV4KSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgLy8gU2VsZWN0b3JzXG4gICAgICB0aGlzLiRzZXJ2aWNlc0luZm8gPSB0aGlzLiRzZXJ2aWNlc0l0ZW1baW5kZXhdLnF1ZXJ5U2VsZWN0b3IoJy5pbmZvJyk7XG4gICAgICB0aGlzLiRzZXJ2aWNlc1RleHQgPSB0aGlzLiRzZXJ2aWNlc0l0ZW1baW5kZXhdLnF1ZXJ5U2VsZWN0b3IoJy5jb2x1bW5zJyk7XG4gICAgICB2YXIgX2hlaWdodCA9IHRoaXMuJHNlcnZpY2VzSW5mby5xdWVyeVNlbGVjdG9yKCcuY29sdW1ucycpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcblxuICAgICAgdmFyIF9tb3ZlbWVudCA9IF9oZWlnaHQgLSB3aW5kb3cuaW5uZXJXaWR0aCAqIDAuMTtcblxuICAgICAgZ3NhcC50byh0aGlzLiRzZXJ2aWNlc0luZm8sIHtcbiAgICAgICAgeTogX21vdmVtZW50ICsgJ3B4JyxcbiAgICAgICAgZHVyYXRpb246IDAuNixcbiAgICAgICAgZWFzZTogJ2V4cG8ub3V0J1xuICAgICAgfSk7XG4gICAgICBnc2FwLnRvKHRoaXMuJHNlcnZpY2VzVGV4dCwge1xuICAgICAgICBvcGFjaXR5OiAwLjAwMDEsXG4gICAgICAgIGR1cmF0aW9uOiAwLjYsXG4gICAgICAgIGVhc2U6ICdwb3dlcjIub3V0JyxcbiAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICBfdGhpczcuYXBwVWkuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRTb2x1dGlvbnNGZWF1dHVyZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFNvbHV0aW9uc0ZlYXV0dXJlcygpIHtcbiAgICAgIHRoaXMuJHNvbHV0aW9uc0ZlYXR1cmVzID0gdGhpcy4kc29sdXRpb25zLnF1ZXJ5U2VsZWN0b3IoJy5mZWF0dXJlcycpO1xuICAgICAgdGhpcy4kc29sdXRpb25zRmVhdHVyZXNJdGVtcyA9IHRoaXMuJHNvbHV0aW9uc0ZlYXR1cmVzLnF1ZXJ5U2VsZWN0b3JBbGwoJy5mZWF0dXJlc19faXRlbScpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJHNvbHV0aW9uc0ZlYXR1cmVzSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3NhcC5zZXQodGhpcy4kc29sdXRpb25zRmVhdHVyZXNJdGVtc1tpXSwge1xuICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZmVhdHVyZXNUcmlnZ2VyID0gZ3NhcC50aW1lbGluZSh7XG4gICAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgZHVyYXRpb246IDIsXG4gICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnXG4gICAgICAgIH0sXG4gICAgICAgIHNjcm9sbFRyaWdnZXI6IHtcbiAgICAgICAgICB0cmlnZ2VyOiB0aGlzLiRzb2x1dGlvbnNGZWF0dXJlcyxcbiAgICAgICAgICBzdGFydDogJ3RvcCA4MCUnLFxuICAgICAgICAgIGVuZDogJ2JvdHRvbSA3MCUnLFxuICAgICAgICAgIHNjcnViOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9mZWF0dXJlc1RyaWdnZXIudG8odGhpcy4kc29sdXRpb25zRmVhdHVyZXNJdGVtc1swXSwge1xuICAgICAgICBvcGFjaXR5OiAxXG4gICAgICB9LCAwLjI1KTtcblxuICAgICAgdGhpcy5fZmVhdHVyZXNUcmlnZ2VyLnRvKHRoaXMuJHNvbHV0aW9uc0ZlYXR1cmVzSXRlbXNbMV0sIHtcbiAgICAgICAgb3BhY2l0eTogMVxuICAgICAgfSwgMC41KTtcblxuICAgICAgdGhpcy5fZmVhdHVyZXNUcmlnZ2VyLnRvKHRoaXMuJHNvbHV0aW9uc0ZlYXR1cmVzSXRlbXNbMl0sIHtcbiAgICAgICAgb3BhY2l0eTogMVxuICAgICAgfSwgMC43NSk7XG5cbiAgICAgIHRoaXMuX2ZlYXR1cmVzVHJpZ2dlci50byh0aGlzLiRzb2x1dGlvbnNGZWF0dXJlc0l0ZW1zWzNdLCB7XG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICAgIH0sIDEpO1xuXG4gICAgICB0aGlzLl9mZWF0dXJlc1RyaWdnZXIudG8odGhpcy4kc29sdXRpb25zRmVhdHVyZXNJdGVtc1s0XSwge1xuICAgICAgICBvcGFjaXR5OiAxXG4gICAgICB9LCAxLjI1KTtcblxuICAgICAgdGhpcy5fZmVhdHVyZXNUcmlnZ2VyLnRvKHRoaXMuJHNvbHV0aW9uc0ZlYXR1cmVzSXRlbXNbNV0sIHtcbiAgICAgICAgb3BhY2l0eTogMVxuICAgICAgfSwgMS41KTtcblxuICAgICAgdGhpcy5fZmVhdHVyZXNUcmlnZ2VyLnRvKHRoaXMuJHNvbHV0aW9uc0ZlYXR1cmVzSXRlbXNbNl0sIHtcbiAgICAgICAgb3BhY2l0eTogMVxuICAgICAgfSwgMS43NSk7XG5cbiAgICAgIHRoaXMuX2ZlYXR1cmVzVHJpZ2dlci50byh0aGlzLiRzb2x1dGlvbnNGZWF0dXJlc0l0ZW1zWzddLCB7XG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICAgIH0sIDIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0U29sdXRpb25zU2xpZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRTb2x1dGlvbnNTbGlkZXIoKSB7XG4gICAgICB0aGlzLl9zb2x1dGlvbnNTbGlkZXIgPSBuZXcgU2xpZGVyU29sdXRpb25zKHtcbiAgICAgICAgZWw6IHRoaXMuJHNvbHV0aW9ucyxcbiAgICAgICAgdGFyZ2V0OiB0aGlzLiRzb2x1dGlvbnMucXVlcnlTZWxlY3RvcignLnNsaWRlci0tc29sdXRpb25zJyksXG4gICAgICAgIGF1dG9wbGF5OiB0cnVlLFxuICAgICAgICBhdXRvcGxheVNwZWVkOiAzLFxuICAgICAgICBkdXJhdGlvbjogMS4yXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFNvbHV0aW9uc0RyYWdnYWJsZU1vYmlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0U29sdXRpb25zRHJhZ2dhYmxlTW9iaWxlKCkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJHNvbHV0aW9uc0RyYWdnYWJsZSA9IHRoaXMuJHNvbHV0aW9ucy5xdWVyeVNlbGVjdG9yKCcuc2xpZGVyLS1kcmFnZ2FibGUnKTtcbiAgICAgIHRoaXMuJHNvbHV0aW9uc0RyYWdnYWJsZVByb2dyZXNzID0gdGhpcy4kc29sdXRpb25zRHJhZ2dhYmxlLnF1ZXJ5U2VsZWN0b3IoJy5zbGlkZXJfX3Byb2dyZXNzJyk7XG4gICAgICB0aGlzLl9zb2x1dGlvbnNEcmFnZ2FibGUgPSBuZXcgU3VwZXJEcmFnZ2FibGUoe1xuICAgICAgICBlbDogdGhpcy4kc29sdXRpb25zLFxuICAgICAgICBzbmFwOiBmYWxzZSxcbiAgICAgICAgc25hcFRvOiAnY2VudGVyJyxcbiAgICAgICAgZG90czogZmFsc2UsXG4gICAgICAgIG9uUmFmOiBmdW5jdGlvbiBvblJhZihwZXJjZW50LCBwcm9ncmVzcywgcHJvZ3Jlc3NPcmlnaW4pIHtcbiAgICAgICAgICBnc2FwLnRvKF90aGlzOC4kc29sdXRpb25zRHJhZ2dhYmxlUHJvZ3Jlc3MuY2hpbGRyZW5bMF0sIHtcbiAgICAgICAgICAgIHNjYWxlWDogcHJvZ3Jlc3NPcmlnaW4gKyBwcm9ncmVzc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFBhcmFsbGF4Q2FyZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFBhcmFsbGF4Q2FyZHMoKSB7XG4gICAgICB0aGlzLiR0ZWNobm9sb2d5Q2FyZHMgPSB0aGlzLiR0ZWNobm9sb2d5LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXJkJyk7XG4gICAgICB2YXIgcGFyYWxsYXhDYXJkcyA9IGdzYXAudGltZWxpbmUoe1xuICAgICAgICBkZWZhdWx0czoge1xuICAgICAgICAgIGR1cmF0aW9uOiAxLFxuICAgICAgICAgIGVhc2U6ICdub25lJ1xuICAgICAgICB9LFxuICAgICAgICBzY3JvbGxUcmlnZ2VyOiB7XG4gICAgICAgICAgdHJpZ2dlcjogdGhpcy4kdGVjaG5vbG9neS5xdWVyeVNlbGVjdG9yKCcuY29udGFpbmVyLS1sYXJnZScpLFxuICAgICAgICAgIHN0YXJ0OiAndG9wIGJvdHRvbScsXG4gICAgICAgICAgZW5kOiB0aGlzLiR0ZWNobm9sb2d5LnF1ZXJ5U2VsZWN0b3IoJy5jb250YWluZXItLWxhcmdlJykub2Zmc2V0SGVpZ2h0ICsgd2luZG93LmlubmVyV2lkdGggKiAwLjEgKyAnIHRvcCcsXG4gICAgICAgICAgc2NydWI6IHRydWUsXG4gICAgICAgICAgbWFya2VyczogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIFNldFxuXG4gICAgICBwYXJhbGxheENhcmRzLnNldChbdGhpcy4kdGVjaG5vbG9neUNhcmRzWzBdXSwge1xuICAgICAgICB5OiAnMHZ3J1xuICAgICAgfSwgMCk7XG4gICAgICBwYXJhbGxheENhcmRzLnNldChbdGhpcy4kdGVjaG5vbG9neUNhcmRzWzFdXSwge1xuICAgICAgICB5OiAnMi41dncnXG4gICAgICB9LCAwKTtcbiAgICAgIHBhcmFsbGF4Q2FyZHMuc2V0KFt0aGlzLiR0ZWNobm9sb2d5Q2FyZHNbMl1dLCB7XG4gICAgICAgIHk6ICcwdncnXG4gICAgICB9LCAwKTtcbiAgICAgIHBhcmFsbGF4Q2FyZHMuc2V0KFt0aGlzLiR0ZWNobm9sb2d5Q2FyZHNbM11dLCB7XG4gICAgICAgIHk6ICcyLjV2dydcbiAgICAgIH0sIDApOyAvLyBBbmltYXRpb25cblxuICAgICAgcGFyYWxsYXhDYXJkcy50byhbdGhpcy4kdGVjaG5vbG9neUNhcmRzWzBdXSwge1xuICAgICAgICB5OiAnMi41dncnXG4gICAgICB9LCAwKTtcbiAgICAgIHBhcmFsbGF4Q2FyZHMudG8oW3RoaXMuJHRlY2hub2xvZ3lDYXJkc1sxXV0sIHtcbiAgICAgICAgeTogJzB2dydcbiAgICAgIH0sIDApO1xuICAgICAgcGFyYWxsYXhDYXJkcy50byhbdGhpcy4kdGVjaG5vbG9neUNhcmRzWzJdXSwge1xuICAgICAgICB5OiAnMi41dncnXG4gICAgICB9LCAwKTtcbiAgICAgIHBhcmFsbGF4Q2FyZHMudG8oW3RoaXMuJHRlY2hub2xvZ3lDYXJkc1szXV0sIHtcbiAgICAgICAgeTogJzB2dydcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0VGVjaG5vbG9neUNhcmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRUZWNobm9sb2d5Q2FyZHMoKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgLy8gU2VsZWN0b3JzXG4gICAgICB0aGlzLiR0ZWNobm9sb2d5Q2FyZHMgPSB0aGlzLiR0ZWNobm9sb2d5LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXJkJyk7XG5cbiAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoaSkge1xuICAgICAgICBpZiAoX3RoaXM5LmFwcFN0b3JlLmlzRGVza3RvcCkge1xuICAgICAgICAgIF90aGlzOS5kb21FdmVudHMuYWRkKF90aGlzOS4kdGVjaG5vbG9neUNhcmRzW2ldLCAnbW91c2VlbnRlcicsIGZ1bmN0aW9uIChhLCBlLCBlbCkge1xuICAgICAgICAgICAgaWYgKGVsLnF1ZXJ5U2VsZWN0b3IoJy5pbmZvJykpIHtcbiAgICAgICAgICAgICAgZ3NhcC5raWxsVHdlZW5zT2YoZWwucXVlcnlTZWxlY3RvcignLmluZm8nKSk7XG4gICAgICAgICAgICAgIGdzYXAuc2V0KGVsLnF1ZXJ5U2VsZWN0b3IoJy5pbmZvJyksIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGdzYXAudG8oZWwucXVlcnlTZWxlY3RvcignLmluZm8nKSwge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDAuNixcbiAgICAgICAgICAgICAgICBlYXNlOiAnZXhwby5vdXQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIF90aGlzOS5kb21FdmVudHMuYWRkKF90aGlzOS4kdGVjaG5vbG9neUNhcmRzW2ldLCAnbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChhLCBlLCBlbCkge1xuICAgICAgICAgICAgaWYgKGVsLnF1ZXJ5U2VsZWN0b3IoJy5pbmZvJykpIHtcbiAgICAgICAgICAgICAgZ3NhcC5raWxsVHdlZW5zT2YoZWwucXVlcnlTZWxlY3RvcignLmluZm8nKSk7XG4gICAgICAgICAgICAgIGdzYXAudG8oZWwucXVlcnlTZWxlY3RvcignLmluZm8nKSwge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMC42LFxuICAgICAgICAgICAgICAgIGVhc2U6ICdleHBvLm91dCcsXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICAgIGdzYXAuc2V0KGVsLnF1ZXJ5U2VsZWN0b3IoJy5pbmZvJyksIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPcGVuIGFuZCBjbG9zZSBpbmZvXG4gICAgICAgICAgaWYgKF90aGlzOS4kdGVjaG5vbG9neUNhcmRzW2ldLnF1ZXJ5U2VsZWN0b3IoJy5pY29uJykpIHtcbiAgICAgICAgICAgIF90aGlzOS5kb21FdmVudHMuYWRkKF90aGlzOS4kdGVjaG5vbG9neUNhcmRzW2ldLnF1ZXJ5U2VsZWN0b3IoJy5pY29uJyksICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGdzYXAuc2V0KF90aGlzOS4kdGVjaG5vbG9neUNhcmRzW2ldLnF1ZXJ5U2VsZWN0b3IoJy5pbmZvJyksIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGdzYXAudG8oX3RoaXM5LiR0ZWNobm9sb2d5Q2FyZHNbaV0ucXVlcnlTZWxlY3RvcignLmluZm8nKSwge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDAuOCxcbiAgICAgICAgICAgICAgICBlYXNlOiAnZXhwby5vdXQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChfdGhpczkuJHRlY2hub2xvZ3lDYXJkc1tpXS5xdWVyeVNlbGVjdG9yKCcuY2xvc2VyJykpIHtcbiAgICAgICAgICAgICAgX3RoaXM5LmRvbUV2ZW50cy5hZGQoX3RoaXM5LiR0ZWNobm9sb2d5Q2FyZHNbaV0ucXVlcnlTZWxlY3RvcignLmNsb3NlcicpLCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGdzYXAudG8oX3RoaXM5LiR0ZWNobm9sb2d5Q2FyZHNbaV0ucXVlcnlTZWxlY3RvcignLmluZm8nKSwge1xuICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDAuOCxcbiAgICAgICAgICAgICAgICAgIGVhc2U6ICdleHBvLm91dCcsXG4gICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgICAgICAgICAgICBnc2FwLnNldChfdGhpczkuJHRlY2hub2xvZ3lDYXJkc1tpXS5xdWVyeVNlbGVjdG9yKCcuaW5mbycpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFNlbGVjdG9yc1xuXG5cbiAgICAgICAgICBfdGhpczkuJHRlY2hub2xvZ3lTbGlkZXIgPSBfdGhpczkuJHRlY2hub2xvZ3kucXVlcnlTZWxlY3RvcignLnNsaWRlcicpO1xuICAgICAgICAgIF90aGlzOS5fdGVjaG5vbG9neURyYWdnYWJsZSA9IG5ldyBTdXBlckRyYWdnYWJsZSh7XG4gICAgICAgICAgICBlbDogX3RoaXM5LiR0ZWNobm9sb2d5LFxuICAgICAgICAgICAgc25hcDogZmFsc2UsXG4gICAgICAgICAgICBzbmFwVG86ICdjZW50ZXInLFxuICAgICAgICAgICAgZG90czogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiR0ZWNobm9sb2d5Q2FyZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX2xvb3AyKGkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0VGVjaG5vbG9neVBpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0VGVjaG5vbG9neVBpbigpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgdGhpcy4kdGVjaG5vbG9neVdvcmRzID0gdGhpcy4kdGVjaG5vbG9neS5xdWVyeVNlbGVjdG9yKCcud29yZHMnKTtcbiAgICAgIHRoaXMuJHRlY2hub2xvZ3lXb3Jkc0lubmVyID0gdGhpcy4kdGVjaG5vbG9neVdvcmRzLnF1ZXJ5U2VsZWN0b3IoJy53b3Jkc19faW5uZXInKTtcbiAgICAgIHRoaXMuJHRlY2hub2xvZ3lXb3Jkc0dyYWRpZW50ID0gdGhpcy4kdGVjaG5vbG9neVdvcmRzLnF1ZXJ5U2VsZWN0b3IoJy53b3Jkc19fZ3JhZGllbnQnKTtcbiAgICAgIHRoaXMuJHRlY2hub2xvZ3lMYWJlbCA9IHRoaXMuJHRlY2hub2xvZ3kucXVlcnlTZWxlY3RvcignLmxhYmVsLS0xJyk7XG5cbiAgICAgIHZhciBfb2Zmc2V0ID0gdGhpcy4kdGVjaG5vbG9neVdvcmRzSW5uZXIub2Zmc2V0SGVpZ2h0IC0gdGhpcy4kdGVjaG5vbG9neVdvcmRzR3JhZGllbnQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICB0aGlzLl90ZWNobm9sb2d5UGluID0gU2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xuICAgICAgICB0cmlnZ2VyOiB0aGlzLiR0ZWNobm9sb2d5V29yZHMsXG4gICAgICAgIHN0YXJ0OiAndG9wIHRvcCcsXG4gICAgICAgIGVuZDogJ2JvdHRvbSBib3R0b20nLFxuICAgICAgICBzY3J1YjogdHJ1ZSxcbiAgICAgICAgbWFya2VyczogZmFsc2UsXG4gICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShzZWxmKSB7XG4gICAgICAgICAgZ3NhcC5zZXQoX3RoaXMxMC4kdGVjaG5vbG9neUxhYmVsLCB7XG4gICAgICAgICAgICB5OiBfb2Zmc2V0ICogc2VsZi5wcm9ncmVzcyArICdweCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBnc2FwLnNldChfdGhpczEwLiR0ZWNobm9sb2d5V29yZHNHcmFkaWVudCwge1xuICAgICAgICAgICAgeTogX29mZnNldCAqIHNlbGYucHJvZ3Jlc3MgKyAncHgnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRW50ZXI6IGZ1bmN0aW9uIG9uRW50ZXIoKSB7XG4gICAgICAgICAgZ3NhcC50byhfdGhpczEwLiR0ZWNobm9sb2d5V29yZHNHcmFkaWVudCwge1xuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FbnRlckJhY2s6IGZ1bmN0aW9uIG9uRW50ZXJCYWNrKCkge1xuICAgICAgICAgIGdzYXAudG8oX3RoaXMxMC4kdGVjaG5vbG9neVdvcmRzR3JhZGllbnQsIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICBkdXJhdGlvbjogMC40LFxuICAgICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0UGxhdGZvcm1zRHJhZ2dhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRQbGF0Zm9ybXNEcmFnZ2FibGUoKSB7XG4gICAgICAvLyBTZWxlY3RvcnNcbiAgICAgIHRoaXMuJHBsYXRmb3Jtc1NsaWRlciA9IHRoaXMuJHBsYXRmb3Jtcy5xdWVyeVNlbGVjdG9yKCcuc2xpZGVyJyk7XG4gICAgICB0aGlzLiRwbGF0Zm9ybXNTbGlkZXJJdGVtcyA9IHRoaXMuJHBsYXRmb3Jtc1NsaWRlci5xdWVyeVNlbGVjdG9yQWxsKCcuc2xpZGVyX19pdGVtJyk7XG5cbiAgICAgIGlmICh0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkge1xuICAgICAgICBpZiAodGhpcy4kcGxhdGZvcm1zU2xpZGVySXRlbXMubGVuZ3RoID4gNCkge1xuICAgICAgICAgIHRoaXMuX3BsYXRmb3Jtc0RyYWdnYWJsZSA9IG5ldyBTdXBlckRyYWdnYWJsZSh7XG4gICAgICAgICAgICBlbDogdGhpcy4kcGxhdGZvcm1zLFxuICAgICAgICAgICAgc25hcDogZmFsc2UsXG4gICAgICAgICAgICBzbmFwVG86ICdjZW50ZXInLFxuICAgICAgICAgICAgZG90czogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1zRHJhZ2dhYmxlID0gbmV3IFN1cGVyRHJhZ2dhYmxlKHtcbiAgICAgICAgICBlbDogdGhpcy4kcGxhdGZvcm1zLFxuICAgICAgICAgIHNuYXA6IGZhbHNlLFxuICAgICAgICAgIHNuYXBUbzogJ2NlbnRlcicsXG4gICAgICAgICAgZG90czogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhZigpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICB9LCB7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgaWYgKHRoaXMuX3BsYXRmb3Jtc0RyYWdnYWJsZSkgdGhpcy5fcGxhdGZvcm1zRHJhZ2dhYmxlLnJlc2l6ZSgpO1xuXG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgaWYgKHRoaXMuaG9tZTEpIHRoaXMuaG9tZTEub25SZXNpemUoKTtcbiAgICAgICAgaWYgKHRoaXMuaG9tZTIpIHRoaXMuaG9tZTIub25SZXNpemUoKTtcbiAgICAgICAgaWYgKHRoaXMuaG9tZTMpIHRoaXMuaG9tZTMub25SZXNpemUoKTtcbiAgICAgICAgaWYgKHRoaXMuaG9tZTQpIHRoaXMuaG9tZTQub25SZXNpemUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhRHJhZ2dhYmxlKSB0aGlzLl9kYXRhRHJhZ2dhYmxlLnJlc2l6ZSgpO1xuICAgICAgICBpZiAodGhpcy5fc29sdXRpb25zRHJhZ2dhYmxlKSB0aGlzLl9zb2x1dGlvbnNEcmFnZ2FibGUucmVzaXplKCk7XG4gICAgICAgIGlmICh0aGlzLl90ZWNobm9sb2d5RHJhZ2dhYmxlKSB0aGlzLl90ZWNobm9sb2d5RHJhZ2dhYmxlLnJlc2l6ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZWF2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZWF2ZSgpIHtcbiAgICAgIGlmICh0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkge1xuICAgICAgICB0aGlzLmhvbWUxLmtpbGwoKTtcbiAgICAgICAgdGhpcy5ob21lMSA9IG51bGw7XG4gICAgICAgIHRoaXMuaG9tZTIua2lsbCgpO1xuICAgICAgICB0aGlzLmhvbWUyID0gbnVsbDtcbiAgICAgICAgdGhpcy5ob21lMy5raWxsKCk7XG4gICAgICAgIHRoaXMuaG9tZTMgPSBudWxsO1xuICAgICAgICB0aGlzLmhvbWU0LmtpbGwoKTtcbiAgICAgICAgdGhpcy5ob21lNCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhvbWUxX20ua2lsbCgpO1xuICAgICAgICB0aGlzLmhvbWUxX20gPSBudWxsO1xuICAgICAgICB0aGlzLmhvbWUyYV9tLmtpbGwoKTtcbiAgICAgICAgdGhpcy5ob21lMmFfbSA9IG51bGw7XG4gICAgICAgIHRoaXMuaG9tZTJiX20ua2lsbCgpO1xuICAgICAgICB0aGlzLmhvbWUyYl9tID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVuZGVyZXJIb21lO1xufShSZW5kZXJlcik7IC8vIERvbid0IGZvcmdldCB0byBleHBvcnQgeW91ciByZW5kZXJlclxuXG5cbmV4cG9ydCBkZWZhdWx0IFJlbmRlcmVySG9tZTsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8vaW1wb3J0ICogYXMgVEhSRUUgZnJvbSBcInRocmVlXCJcbmltcG9ydCBnc2FwIGZyb20gXCJnc2FwXCI7XG5pbXBvcnQgRWFzaW5nIGZyb20gJ2Vhc2luZy1mdW5jdGlvbnMnO1xuXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbnZhciBFdmVudFByb2Nlc3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudFByb2Nlc3Mob2JqKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV2ZW50UHJvY2Vzcyk7XG5cbiAgICAvL2NvbnNvbGUubG9nKFwiKEV2ZW50UHJvY2Vzcy5DT05TVFJVQ1RPUkEpOiBcIiwgb2JqKVxuICAgIHRoaXMudGltZVNlYyA9IG9iai50aW1lU2VjIHx8IDE7IC8vLS1cblxuICAgIHRoaXMucHJvY2Vzc1RpbWVTZWMgPSBudWxsO1xuICAgIHRoaXMucmVmVGltZVNlYyA9IG51bGw7XG4gICAgdGhpcy5wcm9jZXNzID0gMDtcbiAgICB0aGlzLnQgPSAwO1xuICAgIHRoaXMudGlja2VyID0gbnVsbDsgLy8tLVxuXG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IGV2ZW50cy5FdmVudEVtaXR0ZXIoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFdmVudFByb2Nlc3MsIFt7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KGVhc2luZ0Z1bmMsIHBhdXNlU2Vjcykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy9jb25zb2xlLmxvZyhcIihFdmVudFByb2Nlc3Muc3RhcnQpOiBcIiwgcGF1c2VTZWNzKVxuICAgICAgaWYgKHBhdXNlU2VjcyA9PSAwKSB7XG4gICAgICAgIHRoaXMuZWFzaW5nRnVuYyA9IGVhc2luZ0Z1bmMgfHwgRWFzaW5nLkxpbmVhci5Ob25lOyAvLy0tXG5cbiAgICAgICAgZ3NhcC50aWNrZXIucmVtb3ZlKHRoaXMub25UaWNrKTsgLy9jb25zb2xlLmxvZyh0aGlzLmVhc2luZ0Z1bmMpXG5cbiAgICAgICAgdGhpcy5vblRpY2sgPSB0aGlzLl91cGRhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZUaW1lU2VjID0gdGhpcy5fZ2V0X3RpY2tlclRpbWUoKTtcbiAgICAgICAgZ3NhcC50aWNrZXIuYWRkKHRoaXMub25UaWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vdGhpcy5iaW5kZWRfc3RhcnQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcylcbiAgICAgICAgZ3NhcC5kZWxheWVkQ2FsbChwYXVzZVNlY3MsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuc3RhcnQoZWFzaW5nRnVuYywgMCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRfcHJvY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRfcHJvY2VzcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3M7XG4gICAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0X3RpY2tlclRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF90aWNrZXJUaW1lKCkge1xuICAgICAgcmV0dXJuIGdzYXAudGlja2VyLnRpbWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZSgpIHtcbiAgICAgIHZhciB0aWNrZXJUaW1lID0gdGhpcy5fZ2V0X3RpY2tlclRpbWUoKTtcblxuICAgICAgdGhpcy5wcm9jZXNzVGltZVNlYyA9IHRpY2tlclRpbWUgLSB0aGlzLnJlZlRpbWVTZWM7XG5cbiAgICAgIGlmICh0aGlzLnByb2Nlc3NUaW1lU2VjID49IHRoaXMudGltZVNlYykge1xuICAgICAgICB0aGlzLnByb2Nlc3NUaW1lU2VjID0gdGhpcy50aW1lU2VjO1xuICAgICAgICBnc2FwLnRpY2tlci5yZW1vdmUodGhpcy5vblRpY2spOyAvLy0tXG5cbiAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJvblByb2Nlc3NFbmRcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudCA9IHRoaXMucHJvY2Vzc1RpbWVTZWMgLyB0aGlzLnRpbWVTZWM7XG4gICAgICB0aGlzLnByb2Nlc3MgPSB0aGlzLmVhc2luZ0Z1bmModGhpcy50KTsgLy9jb25zb2xlLmxvZyhcInQ6IFwiK3RoaXMudCtcIiAtIHByb2Nlc3M6IFwiK3RoaXMucHJvY2VzcylcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRXZlbnRQcm9jZXNzO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBFdmVudFByb2Nlc3M7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuLy9pbXBvcnQgKiBhcyBUSFJFRSBmcm9tIFwidGhyZWVcIlxuLy9pbXBvcnQgZ3NhcCBmcm9tIFwiZ3NhcFwiXG4vL2ltcG9ydCB7R0xURkxvYWRlciwgR0xUTG9hZGVyfSBmcm9tIFwidGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvR0xURkxvYWRlclwiXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbnZhciBTb2x1dGlvbnMxR2VvbWV0cnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKFNvbHV0aW9uczFHZW9tZXRyeSwgX0V2ZW50RW1pdHRlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihTb2x1dGlvbnMxR2VvbWV0cnkpO1xuXG4gIGZ1bmN0aW9uIFNvbHV0aW9uczFHZW9tZXRyeShvYmopIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU29sdXRpb25zMUdlb21ldHJ5KTtcblxuICAgIC8vY29uc29sZS5sb2coXCIoU29sdXRpb25zMUdlb21ldHJ5LkNPTlNUUlVDVE9SQSk6IFwiLCBvYmopXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTsgLy8tLVxuXG4gICAgX3RoaXMuZmFjdG9yID0gb2JqLmZhY3RvcjsgLy82XG5cbiAgICBfdGhpcy5pbmNyX3JhZGlvID0gb2JqLmluY3JfcmFkaW87IC8vMjVcblxuICAgIF90aGlzLm51bU9yYml0cyA9IG9iai5udW1PcmJpdHM7IC8vMzdcblxuICAgIF90aGlzLmFycmF5X3RyaWFuZ3VsYXIgPSBvYmouYXJyYXlfdHJpYW5ndWxhcjtcbiAgICBfdGhpcy5udW1Eb3RzID0gb2JqLm51bURvdHM7IC8vLS1cblxuICAgIF90aGlzLmF0dHJpYnV0ZXMgPSB7XG4gICAgICBhX3Bvc2ljaW9uZXM6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDMpLFxuICAgICAgYV9kb3RfbnVtOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfb3JiaXRhbDogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX3Bvc19vcmJpdGE6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV9pbmNyX2FuZ3Vsb1JhZDogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX2FuZ3Vsb1JhZDogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX3JhZGlvOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfZGlyOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfaW5jcjogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX3g6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV95OiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfejogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX2RvdEZhY3RvcjogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSlcbiAgICB9OyAvLy0tXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLm51bURvdHM7IGkrKykge1xuICAgICAgdmFyIGRvdCA9IF90aGlzLl9nZXRfZG90KGkpO1xuXG4gICAgICB2YXIgaTMgPSBpICogMztcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9wb3NpY2lvbmVzW2kzXSA9IGRvdC54O1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXNbaTMgKyAxXSA9IGRvdC55O1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXNbaTMgKyAyXSA9IGRvdC56OyAvLy0tXG5cbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9kb3RfbnVtW2ldID0gaTtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9vcmJpdGFsW2ldID0gZG90Lm9yYml0YWw7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfcG9zX29yYml0YVtpXSA9IGRvdC5wb3Nfb3JiaXRhO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX2luY3JfYW5ndWxvUmFkW2ldID0gZG90LmluY3JfYW5ndWxvUmFkO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX2FuZ3Vsb1JhZFtpXSA9IGRvdC5hbmd1bG9SYWQ7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfcmFkaW9baV0gPSBkb3QucmFkaW87XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfZGlyW2ldID0gZG90LmRpcjtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9pbmNyW2ldID0gZG90LmluY3I7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfeFtpXSA9IGRvdC55O1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3lbaV0gPSBkb3QueTtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV96W2ldID0gZG90Lno7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfZG90RmFjdG9yW2ldID0gaSAvIF90aGlzLm51bURvdHM7IC8vIEVsIHB1bnRvIG1hcyBpbnRlcmlvciB0aWVuZSAxIHkgZWwgbWFzIGV4dGVyaW9yIHRpZW5lIDBcbiAgICB9IC8vLS1cblxuXG4gICAgX3RoaXMubG9hZGVkID0gZmFsc2U7IC8vY29uc29sZS5sb2codGhpcy5hdHRyaWJ1dGVzLmFfZG90X251bSlcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTb2x1dGlvbnMxR2VvbWV0cnksIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoU29sdXRpb25zMUdlb21ldHJ5LmluaXQpIVwiKVxuICAgICAgLy8tLVxuICAgICAgLy8tLVxuICAgICAgdGhpcy5lbWl0KFwib25NZXNoTG9hZGVkXCIsIHtcbiAgICAgICAgcmVmOiB0aGlzXG4gICAgICB9KTtcbiAgICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUFJJVkFEQVNcblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRfZG90XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfZG90KG51bSkge1xuICAgICAgLy8gRGV2dWVsdmUgdW4gb2JqZXRvIGNvbiBsYSBpbmZvcm1hY2nDrW4gZGUgdW4gcHVudG8gZGUgbGEgZ2VvbWV0cmlhIFwib3JiaXRhbCBNSU9USVwiXG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICBudW06IG51bSxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgejogMCxcbiAgICAgICAgb3JiaXRhbDogMCxcbiAgICAgICAgY29fb3JiaXRhbnRlczogMCxcbiAgICAgICAgcG9zX29yYml0YTogMCxcbiAgICAgICAgaW5jcl9hbmd1bG9SYWQ6IDAsXG4gICAgICAgIGFuZ3Vsb1JhZDogMCxcbiAgICAgICAgcmFkaW86IDBcbiAgICAgIH07IC8vLS1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdGhpcy5hcnJheV90cmlhbmd1bGFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW1TdXAgPSB0aGlzLmFycmF5X3RyaWFuZ3VsYXJbaV07IC8vY29uc29sZS5sb2coXCJsaW1TdXA6IFwiK2xpbVN1cClcblxuICAgICAgICBpZiAobnVtID4gbGltU3VwKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCIqXCIpXG4gICAgICAgICAgb2JqLm9yYml0YWwgPSBpICsgMTtcbiAgICAgICAgICBvYmouY29fb3JiaXRhbnRlcyA9IChpICsgMSkgKiB0aGlzLmZhY3RvcjtcbiAgICAgICAgICBvYmoucG9zX29yYml0YSA9IG51bSAtIGxpbVN1cCAtIDE7XG4gICAgICAgICAgb2JqLmluY3JfYW5ndWxvUmFkID0gMiAqIE1hdGguUEkgLyBvYmouY29fb3JiaXRhbnRlcztcblxuICAgICAgICAgIGlmIChvYmoub3JiaXRhbCAlIDIgPT0gMCkge1xuICAgICAgICAgICAgb2JqLmRpciA9IDE7XG4gICAgICAgICAgICBvYmouaW5jciA9IDA7XG4gICAgICAgICAgICBvYmouYW5ndWxvUmFkID0gb2JqLnBvc19vcmJpdGEgKiBvYmouaW5jcl9hbmd1bG9SYWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9iai5kaXIgPSAtMTtcbiAgICAgICAgICAgIG9iai5pbmNyID0gMTtcbiAgICAgICAgICAgIG9iai5hbmd1bG9SYWQgPSBvYmoucG9zX29yYml0YSAqIG9iai5pbmNyX2FuZ3Vsb1JhZCArIG9iai5pbmNyX2FuZ3Vsb1JhZCAvIDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JqLnJhZGlvID0gb2JqLm9yYml0YWwgKiB0aGlzLmluY3JfcmFkaW87IC8vLS1cblxuICAgICAgICAgIG9iai54ID0gTWF0aC5jb3Mob2JqLmFuZ3Vsb1JhZCkgKiBvYmoucmFkaW87XG4gICAgICAgICAgb2JqLnkgPSBNYXRoLnNpbihvYmouYW5ndWxvUmFkKSAqIG9iai5yYWRpbztcbiAgICAgICAgICBvYmoueiA9IDA7XG4gICAgICAgIH0gLy9icmVha1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNvbHV0aW9uczFHZW9tZXRyeTtcbn0oRXZlbnRFbWl0dGVyKTtcblxuZXhwb3J0IGRlZmF1bHQgU29sdXRpb25zMUdlb21ldHJ5OyIsImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhX3JhbmRvbW5lc3M7XFxuYXR0cmlidXRlIHZlYzMgYV9nZW8xX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfZG90X251bTtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9nZW8xX29yYml0YWw7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9wb3Nfb3JiaXRhO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfaW5jcl9hbmd1bG9SYWQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9hbmd1bG9SYWQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9pbmNyO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfZGlyO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfcmFkaW87XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9kb3RGYWN0b3I7XFxuXFxuYXR0cmlidXRlIHZlYzMgYV9nZW8yX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfZ2VvM19wb3NpdGlvbjtcXG5cXG51bmlmb3JtIGZsb2F0IHVUaW1lO1xcbnVuaWZvcm0gZmxvYXQgdUNhbWFyYURpc3RhbmNlO1xcbnVuaWZvcm0gZmxvYXQgdVNjcm9sbFNwZWVkO1xcbnVuaWZvcm0gZmxvYXQgdVNjYWxlO1xcbnVuaWZvcm0gZmxvYXQgdVJlc3BvbnNpdmVTY2FsZTtcXG51bmlmb3JtIGZsb2F0IHVTY3JvbGxEZWx0YTtcXG51bmlmb3JtIGZsb2F0IHVTY3JvbGxQcm9ncmVzcztcXG51bmlmb3JtIGZsb2F0IHVNb3JwaGluZ1Byb2dyZXNzO1xcbnVuaWZvcm0gZmxvYXQgdUludHJvUHJvZ3Jlc3M7XFxudW5pZm9ybSBmbG9hdCB1VHJhbnNpdGlvblByb2dyZXNzO1xcbnVuaWZvcm0gZmxvYXQgdVdpZHRoO1xcbnVuaWZvcm0gZmxvYXQgdUhlaWdodDtcXG5cXG51bmlmb3JtIGZsb2F0IHVSb3RhdGlvbjE7XFxudW5pZm9ybSBmbG9hdCB1Um90YXRpb24yO1xcbnVuaWZvcm0gZmxvYXQgdVJvdGF0aW9uMztcXG51bmlmb3JtIGZsb2F0IHVSb3RhdGlvbklubmVyO1xcbnVuaWZvcm0gZmxvYXQgdVJvdGF0aW9uT3V0dGVyO1xcblxcbi8vIHZhcnlpbmcgdmVjMyB2UG9zaXRpb247XFxuLy92YXJ5aW5nIHZlYzIgdlV2O1xcbnZhcnlpbmcgdmVjMyB2X3JhbmRvbW5lc3M7XFxudmFyeWluZyBmbG9hdCB2X2NvbG9yU3RyZW5ndGg7XFxuXFxudmFyeWluZyBmbG9hdCB2X2FscGhhOyAvLyBFcyBlbCBhbHBoYSBkZSBsb3MgcHVudG9zIGRldGVybWluYWRvIHNvYnJlIHNpIGVzdGFuIGVuIG9yYml0YWxlcyBvY3VsdG9zIG8gdmlzaWJsZXNcXG52YXJ5aW5nIGZsb2F0IHZfYWN0aXZlUHVsc2U7XFxudmFyeWluZyBmbG9hdCB2X2FjdGl2ZVB1bHNlUHJvZ3Jlc3M7XFxudmFyeWluZyBmbG9hdCB2X3Rlc3Q7XFxuXFxuI2RlZmluZSBQSSAzLjE0MTU5MjY1MzhcXG4vLyNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1XFxuXFxuLy9cXHRDbGFzc2ljIFBlcmxpbiAzRCBOb2lzZSBcXG4vL1xcdGJ5IFN0ZWZhbiBHdXN0YXZzb25cXG4vL1xcbnZlYzQgcGVybXV0ZSh2ZWM0IHgpe3JldHVybiBtb2QoKCh4KjM0LjApKzEuMCkqeCwgMjg5LjApO31cXG52ZWM0IHRheWxvckludlNxcnQodmVjNCByKXtyZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO31cXG52ZWMzIGZhZGUodmVjMyB0KSB7cmV0dXJuIHQqdCp0Kih0Kih0KjYuMC0xNS4wKSsxMC4wKTt9XFxuXFxuZmxvYXQgY25vaXNlKHZlYzMgUCl7XFxuICB2ZWMzIFBpMCA9IGZsb29yKFApOyAvLyBJbnRlZ2VyIHBhcnQgZm9yIGluZGV4aW5nXFxuICB2ZWMzIFBpMSA9IFBpMCArIHZlYzMoMS4wKTsgLy8gSW50ZWdlciBwYXJ0ICsgMVxcbiAgUGkwID0gbW9kKFBpMCwgMjg5LjApO1xcbiAgUGkxID0gbW9kKFBpMSwgMjg5LjApO1xcbiAgdmVjMyBQZjAgPSBmcmFjdChQKTsgLy8gRnJhY3Rpb25hbCBwYXJ0IGZvciBpbnRlcnBvbGF0aW9uXFxuICB2ZWMzIFBmMSA9IFBmMCAtIHZlYzMoMS4wKTsgLy8gRnJhY3Rpb25hbCBwYXJ0IC0gMS4wXFxuICB2ZWM0IGl4ID0gdmVjNChQaTAueCwgUGkxLngsIFBpMC54LCBQaTEueCk7XFxuICB2ZWM0IGl5ID0gdmVjNChQaTAueXksIFBpMS55eSk7XFxuICB2ZWM0IGl6MCA9IFBpMC56enp6O1xcbiAgdmVjNCBpejEgPSBQaTEuenp6ejtcXG5cXG4gIHZlYzQgaXh5ID0gcGVybXV0ZShwZXJtdXRlKGl4KSArIGl5KTtcXG4gIHZlYzQgaXh5MCA9IHBlcm11dGUoaXh5ICsgaXowKTtcXG4gIHZlYzQgaXh5MSA9IHBlcm11dGUoaXh5ICsgaXoxKTtcXG5cXG4gIHZlYzQgZ3gwID0gaXh5MCAvIDcuMDtcXG4gIHZlYzQgZ3kwID0gZnJhY3QoZmxvb3IoZ3gwKSAvIDcuMCkgLSAwLjU7XFxuICBneDAgPSBmcmFjdChneDApO1xcbiAgdmVjNCBnejAgPSB2ZWM0KDAuNSkgLSBhYnMoZ3gwKSAtIGFicyhneTApO1xcbiAgdmVjNCBzejAgPSBzdGVwKGd6MCwgdmVjNCgwLjApKTtcXG4gIGd4MCAtPSBzejAgKiAoc3RlcCgwLjAsIGd4MCkgLSAwLjUpO1xcbiAgZ3kwIC09IHN6MCAqIChzdGVwKDAuMCwgZ3kwKSAtIDAuNSk7XFxuXFxuICB2ZWM0IGd4MSA9IGl4eTEgLyA3LjA7XFxuICB2ZWM0IGd5MSA9IGZyYWN0KGZsb29yKGd4MSkgLyA3LjApIC0gMC41O1xcbiAgZ3gxID0gZnJhY3QoZ3gxKTtcXG4gIHZlYzQgZ3oxID0gdmVjNCgwLjUpIC0gYWJzKGd4MSkgLSBhYnMoZ3kxKTtcXG4gIHZlYzQgc3oxID0gc3RlcChnejEsIHZlYzQoMC4wKSk7XFxuICBneDEgLT0gc3oxICogKHN0ZXAoMC4wLCBneDEpIC0gMC41KTtcXG4gIGd5MSAtPSBzejEgKiAoc3RlcCgwLjAsIGd5MSkgLSAwLjUpO1xcblxcbiAgdmVjMyBnMDAwID0gdmVjMyhneDAueCxneTAueCxnejAueCk7XFxuICB2ZWMzIGcxMDAgPSB2ZWMzKGd4MC55LGd5MC55LGd6MC55KTtcXG4gIHZlYzMgZzAxMCA9IHZlYzMoZ3gwLnosZ3kwLnosZ3owLnopO1xcbiAgdmVjMyBnMTEwID0gdmVjMyhneDAudyxneTAudyxnejAudyk7XFxuICB2ZWMzIGcwMDEgPSB2ZWMzKGd4MS54LGd5MS54LGd6MS54KTtcXG4gIHZlYzMgZzEwMSA9IHZlYzMoZ3gxLnksZ3kxLnksZ3oxLnkpO1xcbiAgdmVjMyBnMDExID0gdmVjMyhneDEueixneTEueixnejEueik7XFxuICB2ZWMzIGcxMTEgPSB2ZWMzKGd4MS53LGd5MS53LGd6MS53KTtcXG5cXG4gIHZlYzQgbm9ybTAgPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KGcwMDAsIGcwMDApLCBkb3QoZzAxMCwgZzAxMCksIGRvdChnMTAwLCBnMTAwKSwgZG90KGcxMTAsIGcxMTApKSk7XFxuICBnMDAwICo9IG5vcm0wLng7XFxuICBnMDEwICo9IG5vcm0wLnk7XFxuICBnMTAwICo9IG5vcm0wLno7XFxuICBnMTEwICo9IG5vcm0wLnc7XFxuICB2ZWM0IG5vcm0xID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChnMDAxLCBnMDAxKSwgZG90KGcwMTEsIGcwMTEpLCBkb3QoZzEwMSwgZzEwMSksIGRvdChnMTExLCBnMTExKSkpO1xcbiAgZzAwMSAqPSBub3JtMS54O1xcbiAgZzAxMSAqPSBub3JtMS55O1xcbiAgZzEwMSAqPSBub3JtMS56O1xcbiAgZzExMSAqPSBub3JtMS53O1xcblxcbiAgZmxvYXQgbjAwMCA9IGRvdChnMDAwLCBQZjApO1xcbiAgZmxvYXQgbjEwMCA9IGRvdChnMTAwLCB2ZWMzKFBmMS54LCBQZjAueXopKTtcXG4gIGZsb2F0IG4wMTAgPSBkb3QoZzAxMCwgdmVjMyhQZjAueCwgUGYxLnksIFBmMC56KSk7XFxuICBmbG9hdCBuMTEwID0gZG90KGcxMTAsIHZlYzMoUGYxLnh5LCBQZjAueikpO1xcbiAgZmxvYXQgbjAwMSA9IGRvdChnMDAxLCB2ZWMzKFBmMC54eSwgUGYxLnopKTtcXG4gIGZsb2F0IG4xMDEgPSBkb3QoZzEwMSwgdmVjMyhQZjEueCwgUGYwLnksIFBmMS56KSk7XFxuICBmbG9hdCBuMDExID0gZG90KGcwMTEsIHZlYzMoUGYwLngsIFBmMS55eikpO1xcbiAgZmxvYXQgbjExMSA9IGRvdChnMTExLCBQZjEpO1xcblxcbiAgdmVjMyBmYWRlX3h5eiA9IGZhZGUoUGYwKTtcXG4gIHZlYzQgbl96ID0gbWl4KHZlYzQobjAwMCwgbjEwMCwgbjAxMCwgbjExMCksIHZlYzQobjAwMSwgbjEwMSwgbjAxMSwgbjExMSksIGZhZGVfeHl6LnopO1xcbiAgdmVjMiBuX3l6ID0gbWl4KG5fei54eSwgbl96Lnp3LCBmYWRlX3h5ei55KTtcXG4gIGZsb2F0IG5feHl6ID0gbWl4KG5feXoueCwgbl95ei55LCBmYWRlX3h5ei54KTsgXFxuICByZXR1cm4gMi4yICogbl94eXo7XFxufVxcblxcbnZlYzMgZ2V0X3BvczEoZmxvYXQgYW5ndWxvUmFkKXtcXG4gICAgLy9mbG9hdCBhbmd1bG9SYWQgPSBhX2dlbzFfcG9zX29yYml0YSphX2dlbzFfaW5jcl9hbmd1bG9SYWQrKChhX2dlbzFfaW5jcl9hbmd1bG9SYWQvMi4pKmFfZ2VvMV9pbmNyKSsoMS4qYV9nZW8xX2RpciowLjIpO1xcbiAgICBmbG9hdCB4ID0gY29zKGFuZ3Vsb1JhZCkqYV9nZW8xX3JhZGlvO1xcbiAgICBmbG9hdCB5ID0gc2luKGFuZ3Vsb1JhZCkqYV9nZW8xX3JhZGlvO1xcbiAgICBmbG9hdCB6ID0gMC4wO1xcbiAgICB2ZWMzIG5ld1BvcyA9IHZlYzMoeCwgeSwgeik7XFxuICAgIHJldHVybiBuZXdQb3M7XFxufVxcblxcbnZlYzMgZ2V0X3Bvc1Njcm9sbFNwZWVkKHZlYzMgcG9zKXtcXG4gICAgZmxvYXQgZmFjdG9yID0gbWl4KDEuMCwgMi4wLCB1U2Nyb2xsU3BlZWQpO1xcbiAgICBwb3MgPSBwb3MqZmFjdG9yO1xcbiAgICByZXR1cm4gcG9zO1xcbn1cXG5cXG5mbG9hdCBnZXRfZXNjYWxhTm9pc2UoZmxvYXQgeCwgZmxvYXQgeSwgZmxvYXQgYW1wbGl0dWRNYXBhLCBmbG9hdCBwcm9ncmVzcyl7XFxuICAgIGZsb2F0IHZhbG9yID0gY25vaXNlKHZlYzMoeC9hbXBsaXR1ZE1hcGEsIHkvYW1wbGl0dWRNYXBhLCBwcm9ncmVzcykpO1xcbiAgICB2YWxvciA9IDAuNSsodmFsb3IvMi4pO1xcbiAgICB2YWxvciAqPTIuO1xcbiAgICByZXR1cm4gdmFsb3I7XFxufVxcblxcbmZsb2F0IGdldF9lc2NhbGFPbmRhUmFkaWFsKGZsb2F0IG9yYml0YWwsIGZsb2F0IHByb2dyZXNzKXtcXG4gICAgZmxvYXQgZnJlY3VlbmNpYSA9IDAuNTsgLy8gVmFsb3JlcyBiYWpvcyBvbmRhcyBtYXMgbGFyZ2FzLCB2YWxvcmVzIGFsdG9zIG9uZGFzIG1hcyBjb3J0YXNcXG4gICAgZmxvYXQgc2VubyA9IChzaW4oKHByb2dyZXNzK29yYml0YWwpKmZyZWN1ZW5jaWEpKzEuKS8yLjtcXG5cXG4gICAgZmxvYXQgdmFsb3IgPSAwLjUrKHNlbm8qMC41KTtcXG5cXG4gICAgcmV0dXJuIHZhbG9yO1xcbn1cXG5cXG5mbG9hdCBnZXRfZXNjYWxhRWRnZShmbG9hdCBvcmJpdGFsKXtcXG4gICAgZmxvYXQgdmFsdWUgPSAxLjtcXG4gICAgZmxvYXQgb3JiaXRhbE1heCA9IDM3LjtcXG4gICAgZmxvYXQgZmFkZUxpbWl0ID0gMjIuO1xcbiAgICBmbG9hdCBmYWRlU2NhbGUgPSAxLjtcXG4gICAgZmxvYXQgcmFuZ28gPSBvcmJpdGFsTWF4IC1mYWRlTGltaXQ7XFxuICAgIGlmKG9yYml0YWwgPj0gZmFkZUxpbWl0KXtcXG4gICAgICAgIGZsb2F0IG9yYml0YWxSZWwgPSBvcmJpdGFsIC1mYWRlTGltaXQ7XFxuICAgICAgICBmbG9hdCByYXRpbyA9IG9yYml0YWxSZWwvcmFuZ287XFxuICAgICAgICBmYWRlU2NhbGUgPSBmYWRlU2NhbGUtcmF0aW87XFxuICAgIH1cXG4gICAgcmV0dXJuIGZhZGVTY2FsZTtcXG59XFxuXFxudmVjMyByYW5kb21pemVQb3NpdGlvbih2ZWMzIG9sZFBvcywgdmVjMyByYW5kb21uZXNzLCBmbG9hdCB0aW1lLCBmbG9hdCBhbXBsaXR1ZGUsIGZsb2F0IGFtb3VudCwgZmxvYXQgc3BlZWQpe1xcbiAgICB0aW1lID0gdGltZSpzcGVlZDtcXG4gICAgdmVjMyBuZXdQb3MgPSBvbGRQb3M7XFxuICAgIG5ld1Bvcy54ICs9IHNpbih0aW1lICogcmFuZG9tbmVzcy54KSAqIChhbXBsaXR1ZGUqYW1vdW50KTtcXG4gICAgbmV3UG9zLnkgKz0gY29zKHRpbWUgKiByYW5kb21uZXNzLnkpICogKGFtcGxpdHVkZSphbW91bnQpO1xcbiAgICBuZXdQb3MueiArPSBjb3ModGltZSAqIHJhbmRvbW5lc3MueikgKiAoYW1wbGl0dWRlKmFtb3VudCk7XFxuICAgIHJldHVybiBuZXdQb3M7XFxufVxcblxcbmZsb2F0IHF1aW50aWNPdXQoZmxvYXQgdCkge1xcbiAgcmV0dXJuIChwb3codCAtIDEuMCwgNS4wKSk7XFxufVxcblxcbmZsb2F0IHF1YWRyYXRpY091dChmbG9hdCB0KSB7XFxuICByZXR1cm4gLXQgKiAodCAtIDIuMCk7XFxufVxcblxcbmZsb2F0IHF1YXJ0aWNPdXQoZmxvYXQgdCkge1xcbiAgcmV0dXJuIHBvdyh0IC0gMS4wLCAzLjApICogKDEuMCAtIHQpICsgMS4wO1xcbn1cXG5cXG5mbG9hdCBjdWJpY0luKGZsb2F0IHQpIHtcXG4gIHJldHVybiB0ICogdCAqIHQ7XFxufVxcbmZsb2F0IGN1YmljT3V0KGZsb2F0IHQpIHtcXG4gIGZsb2F0IGYgPSB0IC0gMS4wO1xcbiAgcmV0dXJuIGYgKiBmICogZiArIDEuMDtcXG59XFxuXFxubWF0NCByb3RhdGlvbk1hdHJpeCh2ZWMzIGF4aXMsIGZsb2F0IGFuZ2xlKSB7XFxuICAgIGF4aXMgPSBub3JtYWxpemUoYXhpcyk7XFxuICAgIGZsb2F0IHMgPSBzaW4oYW5nbGUpO1xcbiAgICBmbG9hdCBjID0gY29zKGFuZ2xlKTtcXG4gICAgZmxvYXQgb2MgPSAxLjAgLSBjO1xcbiAgICBcXG4gICAgcmV0dXJuIG1hdDQob2MgKiBheGlzLnggKiBheGlzLnggKyBjLCAgICAgICAgICAgb2MgKiBheGlzLnggKiBheGlzLnkgLSBheGlzLnogKiBzLCAgb2MgKiBheGlzLnogKiBheGlzLnggKyBheGlzLnkgKiBzLCAgMC4wLFxcbiAgICAgICAgICAgICAgICBvYyAqIGF4aXMueCAqIGF4aXMueSArIGF4aXMueiAqIHMsICBvYyAqIGF4aXMueSAqIGF4aXMueSArIGMsICAgICAgICAgICBvYyAqIGF4aXMueSAqIGF4aXMueiAtIGF4aXMueCAqIHMsICAwLjAsXFxuICAgICAgICAgICAgICAgIG9jICogYXhpcy56ICogYXhpcy54IC0gYXhpcy55ICogcywgIG9jICogYXhpcy55ICogYXhpcy56ICsgYXhpcy54ICogcywgIG9jICogYXhpcy56ICogYXhpcy56ICsgYywgICAgICAgICAgIDAuMCxcXG4gICAgICAgICAgICAgICAgMC4wLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMC4wLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMC4wLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMS4wKTtcXG59XFxuXFxudmVjMyByb3RhdGUodmVjMyB2LCB2ZWMzIGF4aXMsIGZsb2F0IGFuZ2xlKSB7XFxuXFx0bWF0NCBtID0gcm90YXRpb25NYXRyaXgoYXhpcywgYW5nbGUpO1xcblxcdHJldHVybiAobSAqIHZlYzQodiwgMS4wKSkueHl6O1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyBERUNMQVJBVElPTlM6XFxuICAgIC8vZmxvYXQgdHdlbnRpZXRoWCA9ICh1V2lkdGgvMjAuKTtcXG4gICAgZmxvYXQgdHdlbnRpZXRoWCA9ICgxOTIwLi8yMC4pOyAvLzE5MjAuIGVzIGVsIHRoaXMuUkVGX1JFU09MVVRJT04ud2lkdGhcXG4gICAgZmxvYXQgYW5ndWxvUmFkX3RpbWUgPSBhX2dlbzFfYW5ndWxvUmFkO1xcblxcbiAgICB2ZWMzIFBPU0lUSU9OX09SSUdJTkFMO1xcbiAgICB2ZWMzIFBPU0lUSU9OXzE7XFxuICAgIHZlYzMgUE9TSVRJT05fMUI7XFxuICAgIHZlYzMgUE9TSVRJT05fMjtcXG5cXG4gICAgZmxvYXQgU0laRV8xID0gMC4wO1xcbiAgICBmbG9hdCBTSVpFXzIgPSA1LjA7XFxuXFxuICAgIHZfYWxwaGEgPSAwLjA1O1xcblxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgLy8gU09SVElOR1xcbiAgICAvL2Zsb2F0IHJvdGF0aW9uMV81ID0gbWl4KHVSb3RhdGlvbjEsIHVSb3RhdGlvbjMsIDAuNSk7XFxuICAgIGZsb2F0IGhhcmREb3RTcGVlZEZhY3RvciA9IDIwMC47XFxuICAgIGZsb2F0IHNvZnREb3RTcGVlZEZhY3RvciA9IDM2LjtcXG4gICAgZmxvYXQgcm90YXRpb241ID0gbWl4KHVSb3RhdGlvbklubmVyLCB1Um90YXRpb25PdXR0ZXIsICgoYV9nZW8xX29yYml0YWwpKjAuNSkvc29mdERvdFNwZWVkRmFjdG9yKTtcXG4gICAgZmxvYXQgcm90YXRpb24xMCA9IG1peCh1Um90YXRpb25Jbm5lciwgdVJvdGF0aW9uT3V0dGVyLCAoKGFfZ2VvMV9vcmJpdGFsKSowLjUpL3NvZnREb3RTcGVlZEZhY3Rvcik7XFxuICAgIGZsb2F0IHJvdGF0aW9uMTUgPSBtaXgodVJvdGF0aW9uSW5uZXIsIHVSb3RhdGlvbk91dHRlciwgKChhX2dlbzFfb3JiaXRhbCkqMC41KS9zb2Z0RG90U3BlZWRGYWN0b3IpO1xcblxcbiAgICB2ZWMzIHJhbmQgPSB2ZWMzKGFfcmFuZG9tbmVzcy54KjEuLCAtYV9yYW5kb21uZXNzLnkqMS4sIGFfcmFuZG9tbmVzcy56KjEuKTtcXG5cXG4gICAgaWYoYWJzKGFfZ2VvMV9vcmJpdGFsLTUuKSA8IDAuNSl7IC8vIERldGVjdGEgZWwgb3JiaXRhbCA1XFxuICAgICAgICBhbmd1bG9SYWRfdGltZSA9IChhX2dlbzFfYW5ndWxvUmFkK3JvdGF0aW9uNSk7XFxuICAgICAgICBTSVpFXzEgPSAzLjA7XFxuICAgICAgICB2X2FscGhhID0gMS4wO1xcbiAgICAgICAgcmFuZCA9IHZlYzMoMC4sIC0xLiwgMC4pO1xcblxcbiAgICB9ZWxzZSBpZihhYnMoYV9nZW8xX29yYml0YWwtMTAuKSA8IDAuNSl7IC8vIERldGVjdGEgZWwgb3JiaXRhbCAxMFxcbiAgICAgICAgYW5ndWxvUmFkX3RpbWUgPSAtKGFfZ2VvMV9hbmd1bG9SYWQrcm90YXRpb24xMCk7XFxuICAgICAgICBTSVpFXzEgPSAzLjA7XFxuICAgICAgICB2X2FscGhhID0gMS4wO1xcbiAgICAgICAgcmFuZCA9IHZlYzMoMC4sIC0xLiwgMC4pO1xcblxcbiAgICB9ZWxzZSBpZihhYnMoYV9nZW8xX29yYml0YWwtMTUuKSA8IDAuNSl7IC8vIERldGVjdGEgZWwgb3JiaXRhbCAxNVxcbiAgICAgICAgYW5ndWxvUmFkX3RpbWUgPSBhX2dlbzFfYW5ndWxvUmFkK3JvdGF0aW9uMTU7XFxuICAgICAgICBTSVpFXzEgPSAzLjA7XFxuICAgICAgICB2X2FscGhhID0gMS4wO1xcbiAgICAgICAgcmFuZCA9IHZlYzMoMC4sIC0xLiwgMC4pO1xcbiAgICB9ZWxzZXtcXG4gICAgICAgIGZsb2F0IGZpbHRlcmVkT3JiaXRhbCA9IGNsYW1wKGFfZ2VvMV9vcmJpdGFsLCAwLiwgMjAuKTtcXG4gICAgICAgIGFuZ3Vsb1JhZF90aW1lID0gIGFfZ2VvMV9hbmd1bG9SYWQgKyBtaXgodVJvdGF0aW9uSW5uZXIsIHVSb3RhdGlvbk91dHRlciwgYV9nZW8xX29yYml0YWwvc29mdERvdFNwZWVkRmFjdG9yKTtcXG4gICAgICAgIC8vYW5ndWxvUmFkX3RpbWUgPSBhX2dlbzFfYW5ndWxvUmFkK3JvdGF0aW9uMTU7XFxuICAgICAgICAvL1NJWkVfMSA9IDEwLjAgKiB1VHJhbnNpdGlvblByb2dyZXNzO1xcbiAgICAgICAgLy9TSVpFXzEgPSAyLjA7XFxuICAgICAgICBTSVpFXzEgPSBtaXgoMi4sIDEwLiwgdVRyYW5zaXRpb25Qcm9ncmVzcyk7XFxuICAgICAgICAvL3ZfYWxwaGEgPSAwLjA1OyAvLyAqIHVUcmFuc2l0aW9uUHJvZ3Jlc3M7XFxuICAgICAgICAvL3ZfYWxwaGEgPSAwLjEwOy8vKnVUcmFuc2l0aW9uUHJvZ3Jlc3M7XFxuICAgICAgICB2X2FscGhhID0gbWl4KDAuMDcsIDAuMTAsIHVUcmFuc2l0aW9uUHJvZ3Jlc3MpO1xcblxcbiAgICB9XFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyBQT1NJVElPTjpcXG4gICAgLy8gR2VvbWV0cmllcyBwcmVzZW50ZXM6XFxuICAgIC8vLS1cXG5cXG4gICAgLy9mbG9hdCBhbmd1bG9SYWQgPSBhX2dlbzFfcG9zX29yYml0YSphX2dlbzFfaW5jcl9hbmd1bG9SYWQrKChhX2dlbzFfaW5jcl9hbmd1bG9SYWQvMi4pKmFfZ2VvMV9pbmNyKSsodVNjcm9sbFByb2dyZXNzKmFfZ2VvMV9kaXIqMi4yKTtcXG4gICAgUE9TSVRJT05fT1JJR0lOQUwgPSBnZXRfcG9zMShhbmd1bG9SYWRfdGltZSk7XFxuICAgIFBPU0lUSU9OXzEgPSBQT1NJVElPTl9PUklHSU5BTDtcXG4gICAgLy9QT1NJVElPTl8xID0gcm90YXRlKFBPU0lUSU9OXzEsIHZlYzMoMC4sIC0xLCAwLiksIDAuNSpQSSk7XFxuICAgIFBPU0lUSU9OXzEueCArPSAtdHdlbnRpZXRoWCoyLjtcXG5cXG4gICAgUE9TSVRJT05fMUIgPSBQT1NJVElPTl9PUklHSU5BTDtcXG4gICAgUE9TSVRJT05fMUIgKj0gMS47XFxuICAgIFBPU0lUSU9OXzFCLnggKz0gdHdlbnRpZXRoWCoxMC47IFxcblxcbiAgICAvLyBmbG9hdCBvcmJpdGFsRmFjdG9yID0gYV9nZW8xX29yYml0YWwvMzcuO1xcbiAgICAvLyBmbG9hdCBmb28gPSBtaXgoMS4sIDEwLiwgb3JiaXRhbEZhY3Rvcik7XFxuICAgIC8vIGZsb2F0IGVhc2UgPSBjdWJpY091dCh1VHJhbnNpdGlvblByb2dyZXNzKmZvbyk7XFxuICAgIC8vIGVhc2UgPSBjbGFtcChlYXNlLCAwLiwgMS4pO1xcbiAgICBQT1NJVElPTl8xID0gbWl4KFBPU0lUSU9OXzEsIFBPU0lUSU9OXzFCLCB1VHJhbnNpdGlvblByb2dyZXNzKTtcXG5cXG4gICAgZmxvYXQgYW5nbGUgPSBtaXgoLVBJLCAwLiwgdVRyYW5zaXRpb25Qcm9ncmVzcyk7XFxuICAgIFBPU0lUSU9OXzEgPSByb3RhdGUoUE9TSVRJT05fMSwgcmFuZCwgYW5nbGUpO1xcblxcbiAgICBQT1NJVElPTl8yID0gYV9nZW8yX3Bvc2l0aW9uO1xcbiAgICBQT1NJVElPTl8yID0gcmFuZG9taXplUG9zaXRpb24oUE9TSVRJT05fMiwgYV9yYW5kb21uZXNzLCB1VGltZSwgNS4wLCB1TW9ycGhpbmdQcm9ncmVzcywgNS4pO1xcbiAgICAvLyBaIG1vZGlmaWNhdGlvbnM6XFxuXFxuICAgIC8vIFNvbG9cXG4gICAgXFxuICAgIC8vIE9uZGFzIGRlIHNlbm86XFxuICAgIC8vZmxvYXQgc2Vub0Z4ID0gc2luKCgtdVRpbWUrYV9nZW8xX29yYml0YWwpKSowLjUqMC41O1xcbiAgICAvL2Zsb2F0IGVzY2FsYUZ4ID0gbWl4KDAuOTgsIDEuMDIsIHNlbm9GeCk7XFxuICAgIC8vUE9TSVRJT05fMSAqPSBlc2NhbGFGeDtcXG4gICAgLy8gTW9ycGhpbmc6XFxuICAgIGZsb2F0IGNsYW1wZWRfbW9ycGluZ1Byb2dyZXNzID0gY2xhbXAoMC4sIDAuOTUsIHVNb3JwaGluZ1Byb2dyZXNzKTtcXG4gICAgUE9TSVRJT05fMSA9IG1peChQT1NJVElPTl8xLCBQT1NJVElPTl8yLCBjbGFtcGVkX21vcnBpbmdQcm9ncmVzcyk7XFxuICAgIC8vIFJhbmRvbWl6ZWQgcG9zaXRpb24gd2hpbGUgaW4gUE9TSVRJT05fMlxcbiAgICBQT1NJVElPTl8xID0gcmFuZG9taXplUG9zaXRpb24oUE9TSVRJT05fMSwgYV9yYW5kb21uZXNzKjIuLCB1VGltZSwgNS4wLCB1TW9ycGhpbmdQcm9ncmVzcywgMi41KTtcXG4gICAgLy8gRXNjYWxhIHBvciBzY3JvbGwgZGVsdGE6XFxuICAgIC8vUE9TSVRJT05fMSAqPSAxLisodVNjcm9sbERlbHRhKjAuMik7XFxuICAgIC8vIEVzY2FsYWRvIGluY2lhbDpcXG4gICAgLy9QT1NJVElPTl8xICo9IG1peCg1LiwgMS4sIHF1aW50aWNPdXQodUludHJvUHJvZ3Jlc3MpKTtcXG4gICAgLy9QT1NJVElPTl8xICo9IG1peCg1LiwgMS4sIHF1YWRyYXRpY091dCh1SW50cm9Qcm9ncmVzcykpO1xcbiAgICAvL2Zsb2F0IGNsYW1wZWRfdUludHJvUHJvZ3Jlc3M7XFxuICAgIC8vIGNsYW1wZWRfdUludHJvUHJvZ3Jlc3MgPSB1SW50cm9Qcm9ncmVzcztcXG4gICAgLy9jbGFtcGVkX3VJbnRyb1Byb2dyZXNzID0gY2xhbXAodUludHJvUHJvZ3Jlc3MsIDAuLCAxLik7XFxuICAgIC8vUE9TSVRJT05fMSAqPSBtaXgoNS4sIDEuLCBxdWFydGljT3V0KGNsYW1wZWRfdUludHJvUHJvZ3Jlc3MpKTtcXG4gICAgUE9TSVRJT05fMSAqPSBtaXgoNS4sIDEuLCB1SW50cm9Qcm9ncmVzcyk7XFxuICAgIC8vIFJlc3BvbnNpdmUgU2NhbGU6XFxuICAgIFBPU0lUSU9OXzEgKj0gdVJlc3BvbnNpdmVTY2FsZTtcXG4gICAgLy9cXG4gICAgUE9TSVRJT05fMSA9IG1peChQT1NJVElPTl8xLCBQT1NJVElPTl8yLCB1TW9ycGhpbmdQcm9ncmVzcyk7XFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgLy8gU0laRTpcXG4gICAgXFxuXFxuICAgIC8vIFNvbG8gc2UgdmVuIGxvcyBvYml0YWxlcyA1LCAxMCB5IDE1XFxuXFxuICAgIC8vIExvcyBwdW50b3Mgc29uIG1hcyBwZXF1ZcOxb3MgZW4gbG9zIG9yYml0YWxlcyBkZSBsYSBwZXJpZmVyaWFcXG4gICAgZmxvYXQgZXNjbGFFZGVnZSA9IGdldF9lc2NhbGFFZGdlKGFfZ2VvMV9vcmJpdGFsKTsgXFxuICAgIGZsb2F0IHJhbmdvID0gMS4tZXNjbGFFZGVnZTtcXG4gICAgU0laRV8xICo9IChlc2NsYUVkZWdlICsgKHJhbmdvKjAuMCkpO1xcbiAgICAvLyBMb3MgcHVudG9zIHNlIGVzY2FsYW4gZW4gYmFzZSBhIHVuIG1hcGEgZGUgcnVpZG9cXG4gICAgLy9TSVpFXzEgKj0gbWl4KDEuLCBnZXRfZXNjYWxhTm9pc2UoUE9TSVRJT05fMS54LCBQT1NJVElPTl8xLnksIDUwMC4sIHVQcm9ncmVzczApLCB1UHJvZ3Jlc3MwYik7XFxuICAgIC8vU0laRV8xICo9IG1peCgxLiwgZ2V0X2VzY2FsYU5vaXNlKFBPU0lUSU9OXzEueCwgUE9TSVRJT05fMS55LCA1MDAuLCAxLjApLCAxLjApO1xcbiAgICAvLyBMb3MgcHVudG9zIHNlIGVzY2FsYW4gZW4gYmFzZSBhIG9uZGFzIGNvbmNlbnRyaWNhcyBkZSBzZW5vOlxcbiAgICAvL1NJWkVfMSAqPSBtaXgoMS4sIGdldF9lc2NhbGFPbmRhUmFkaWFsKGFfZ2VvMV9vcmJpdGFsLCAtdVRpbWUqMTAuKSwgdVByb2dyZXNzNGIpO1xcbiAgICAvL1NJWkVfMSAqPSBtaXgoMS4sIGdldF9lc2NhbGFPbmRhUmFkaWFsKGFfZ2VvMV9vcmJpdGFsLCAtdVRpbWUqMTAuKSwgMS4wKTtcXG4gICAgLy8gTG9zIHB1bnRvcyBzZSBlc2NhbGFuIHBvciBwdWxzb24gcmFuZG9tOlxcbiAgICAvL1NJWkVfMSAqPSBtaXgoMS4sIDEuNSwgdl9hY3RpdmVQdWxzZVByb2dyZXNzKTtcXG4gICAgLy8gTG9zIHB1bnRvcyBzZSBlc2NhbGFuIGp1bnRvIGNvbiBsYSBnZW9tZXRyaWEgY29uIGVsIHNjcm9sbGRlbHRhXFxuICAgIC8vU0laRV8xICo9IDEuKyh1U2Nyb2xsRGVsdGEpO1xcblxcbiAgICBcXG5cXG4gICAgXFxuICAgIC8vIFxcbiAgICBmbG9hdCB6RGVwdGhOb3JtID0gKFBPU0lUSU9OXzIueis2MDAuKS8oNjAwLioyLik7IC8vIGRlIC02MDAgYSA2MDAgZGUgdW4gdmFsb3Igbm9ybWFsaXphZG8gKHNpbiBjbGFtcCwgZXMgZGVjaXIgcXVlIHB1ZWRlIHNlciA8MCB5ID4xKSBkZSBsYSBwb3NpY2lvbiB6XFxuICAgIGZsb2F0IHpEZXB0aEFscGhhID0gbWl4KDAuMiwgMC45LCB6RGVwdGhOb3JtKTtcXG4gICAgZmxvYXQgekRlcHRoU2NhbGUgPSBtaXgoMC44LCAyLjUsIHpEZXB0aE5vcm0pO1xcbiAgICBmbG9hdCByYW5kb21TaXplID0gU0laRV8yICowLjUrKGFfcmFuZG9tbmVzcy54KjAuOSk7XFxuICAgIHJhbmRvbVNpemUgKj0gekRlcHRoU2NhbGU7XFxuICAgIFNJWkVfMiA9IG1peChTSVpFXzIsIHJhbmRvbVNpemUsIHVNb3JwaGluZ1Byb2dyZXNzKTtcXG4gICAgXFxuICAgIFxcbiAgICBmbG9hdCBTSVpFID0gbWl4KFNJWkVfMSwgU0laRV8yLCB1TW9ycGhpbmdQcm9ncmVzcyk7XFxuICAgIC8vIExvcyBwdW50b3Mgc2UgZXNjYWxhbiBzaSBzZSByZWRpbWVuc29uYSBlbCBsaWVuem9cXG4gICAgU0laRSAqPSB1UmVzcG9uc2l2ZVNjYWxlO1xcbiAgICBcXG4gICAgXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgLy8gVkVSVEVYXFxuICAgIHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIFBPU0lUSU9OXzEsIDEuMCApO1xcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcbiAgICBnbF9Qb2ludFNpemUgPSBTSVpFKih1Q2FtYXJhRGlzdGFuY2UvLW12UG9zaXRpb24ueik7XFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICBcXG5cXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIC8vIFZBUllJTkdTOlxcbiAgICB2X3JhbmRvbW5lc3MgPSBhX3JhbmRvbW5lc3M7XFxuICAgIHZfY29sb3JTdHJlbmd0aCA9IGdldF9lc2NhbGFOb2lzZShQT1NJVElPTl8xLngsIFBPU0lUSU9OXzEueSwgMjAwLiwgc2luKHVUaW1lKSk7XFxuICAgIHZfY29sb3JTdHJlbmd0aCA9IG1peCgxLiwgdl9jb2xvclN0cmVuZ3RoLCB1TW9ycGhpbmdQcm9ncmVzcyk7XFxuXFxufVwiOyIsImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBHTFNMSUZZIDFcXG51bmlmb3JtIHZlYzMgdUNvbG9yMTtcXG51bmlmb3JtIHZlYzMgdUNvbG9yMjtcXG51bmlmb3JtIHZlYzMgdUNvbG9ySGVybztcXG51bmlmb3JtIGZsb2F0IHVJbnRyb1Byb2dyZXNzO1xcbnVuaWZvcm0gZmxvYXQgdU1vcnBoaW5nUHJvZ3Jlc3M7XFxuXFxudmFyeWluZyBmbG9hdCB2X2FscGhhOyAvLyBFcyBlbCBhbHBoYSBkZSBsb3MgcHVudG9zIGRldGVybWluYWRvIHNvYnJlIHNpIGVzdGFuIGVuIG9yYml0YWxlcyBvY3VsdG9zIG8gdmlzaWJsZXNcXG52YXJ5aW5nIGZsb2F0IHZfY29sb3JTdHJlbmd0aDtcXG5cXG5mbG9hdCBjaXJjdWxpemFyKGZsb2F0IHJhZGlvKXtcXG4gICAgLy8gcmFkaW8gZXMgdW4gdmFsb3IgZW50cmUgMCB5IDEuIDAgZXMgMCBkZSByYWRpbyB5IDEgZXMgZWwgbWF4aW1vIGRlbCByYWRpbyBkZW50cm8gZGVcXG4gICAgcmFkaW8gPSAxLjAtKDAuNSpyYWRpbyk7XFxuICAgIGZsb2F0IHJlc3VsdCA9IGRpc3RhbmNlKGdsX1BvaW50Q29vcmQsIHZlYzIoMC41LCAwLjUpKTtcXG4gICAgcmVzdWx0ID0gMS4gLXJlc3VsdDtcXG4gICAgcmVzdWx0ID0gcG93KHJlc3VsdCwgMS4pO1xcbiAgICByZXN1bHQgPSBzdGVwKHJhZGlvLCByZXN1bHQpO1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyBDT0xPUjpcXG4gICAgLy8gQ2FsY3VsYW1vcyBlbCBjb2xvciBlbiBsYSBwYXJ0ZSBmb290ZXIgKGN1YW5kbyBmb3JtYSBsYSBNIGRlbCBsb2dvKVxcbiAgICB2ZWMzIENPTE9SX0ZPT1RFUiA9IG1peCh1Q29sb3IyLCB1Q29sb3IxLCB2X2NvbG9yU3RyZW5ndGgpO1xcbiAgICAvLyBFbiBmdW5jacOzbiBkZWwgbW9ycGhpblBycGdyZXNzIGNhbGN1bGFtb3MgZWwgY29sb3IgZGUgZXNlIG1vbWVudG9cXG4gICAgdmVjMyBDT0xPUiA9IG1peCh1Q29sb3JIZXJvLCBDT0xPUl9GT09URVIsIHVNb3JwaGluZ1Byb2dyZXNzKTtcXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyBBTFBIQTpcXG4gICAgLy8gQ3JlYW1vcyBsYSBmb3JtYSBjaXJjdWxhcjpcXG4gICAgZmxvYXQgQUxQSEEgPSBjaXJjdWxpemFyKDEuMCk7XFxuICAgIEFMUEhBICo9ICBtaXgodl9hbHBoYSwgMS4sIHVNb3JwaGluZ1Byb2dyZXNzKTtcXG4gICAgLy8gRW4gbGEgaW50cm8gcGFzYSBkZSB0cmFuc3BhcmVudGEgYSBjb3Jww7NyZW9cXG4gICAgLy9BTFBIQSA9IG1peCgwLiwgQUxQSEEsIHVJbnRyb1Byb2dyZXNzKTtcXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoQ09MT1IsIEFMUEhBKTtcXG5cXG59XCI7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCBnc2FwIGZyb20gXCJnc2FwXCI7XG5pbXBvcnQgRWFzaW5nIGZyb20gJ2Vhc2luZy1mdW5jdGlvbnMnO1xuaW1wb3J0IEV2ZW50UHJvZ3Jlc3MgZnJvbSBcIi4uL0V2ZW50UHJvZ3Jlc3NcIjtcbmltcG9ydCBFdmVudFByb2Nlc3MgZnJvbSBcIi4uL0V2ZW50UHJvY2Vzc1wiO1xuaW1wb3J0IFdlYkdMVXRpbHMgZnJvbSBcIi4uL1dlYkdMVXRpbHNcIjtcbmltcG9ydCBFYXNlZE91dFZhbHVlIGZyb20gJy4uL0Vhc2VkT3V0VmFsdWUnO1xuaW1wb3J0IExvYWRlZEdlb21ldHJ5IGZyb20gJy4uL0xvYWRlZEdlb21ldHJ5JztcbmltcG9ydCBTb2x1dGlvbnMxR2VvbWV0cnkgZnJvbSAnLi9Tb2x1dGlvbnMxR2VvbWV0cnknO1xuaW1wb3J0IHZlcnRleCBmcm9tIFwiLi9zaGFkZXJzL3NvbHV0aW9uczFfZG90c192ZXJ0ZXguZ2xzbFwiO1xuaW1wb3J0IGZyYWdtZW50IGZyb20gXCIuL3NoYWRlcnMvc29sdXRpb25zMV9kb3RzX2ZyYWdtZW50Lmdsc2xcIjtcblxudmFyIFNvbHV0aW9uczFEb3RzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU29sdXRpb25zMURvdHMob2JqKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTb2x1dGlvbnMxRG90cyk7XG5cbiAgICAvL2NvbnNvbGUubG9nKFwiKFNvbHV0aW9uczFEb3RzLkNPTlNUUlVDVE9SQSkhXCIpXG4gICAgLy9jb25zb2xlLmxvZyhvYmopXG4gICAgdGhpcy53b3JsZEdMID0gb2JqLndvcmxkR0w7IC8vLS1cblxuICAgIHRoaXMuc2NlbmUgPSB0aGlzLndvcmxkR0wuc2NlbmU7XG4gICAgdGhpcy5jYW1lcmFEaXN0YW5jZSA9IHRoaXMud29ybGRHTC5jYW1lcmFEaXN0YW5jZTsgLy8tLVxuXG4gICAgdGhpcy5tYXRlcmlhbCA9IG51bGw7XG4gICAgdGhpcy5nZW9tZXRyeSA9IG51bGw7XG4gICAgdGhpcy5tZXNoID0gbnVsbDtcbiAgICB0aGlzLm51bVBhcnRpY2xlcyA9IG51bGw7XG4gICAgdGhpcy5hbGxMb2FkZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNyZWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNsb2NrID0gbmV3IFRIUkVFLkNsb2NrKCk7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgIHRoaXMuaW50cm9UaW1lID0gMTtcbiAgICB0aGlzLnJvdGF0aW9uWCA9IDA7XG4gICAgdGhpcy5yb3RhdGlvblkgPSAwO1xuICAgIHRoaXMucm90YXRpb25XYW50ZWRYID0gMDtcbiAgICB0aGlzLnJvdGF0aW9uV2FudGVkWSA9IDA7XG4gICAgdGhpcy5tb3JwaGluZ1Byb2dyZXNzID0gMDsgLy8tLVxuXG4gICAgdGhpcy50cmFuc2l0aW9uUHJvZ3Jlc3MgPSAwOyAvLy0tXG5cbiAgICB0aGlzLmV2ZW50UHJvZ3Jlc3NfaW50cm8gPSBuZXcgRXZlbnRQcm9ncmVzcygpO1xuICAgIHRoaXMuaGVyb190cmFuc2l0aW9uX2RvbmUgPSBmYWxzZTsgLy8tLVxuXG4gICAgdGhpcy5lYXNlZF9yb3RhdGlvbiA9IG5ldyBFYXNlZE91dFZhbHVlKDAsIDAuMDUpO1xuICAgIHRoaXMuZWFzZWRfc2Nyb2xsRGVsdGEgPSBuZXcgRWFzZWRPdXRWYWx1ZSh0aGlzLndvcmxkR0wuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSAqIDAuMywgMC4wNSk7XG4gICAgdGhpcy5lYXNlZF9zY3JvbGxEZWx0YV9mYXN0ID0gbmV3IEVhc2VkT3V0VmFsdWUodGhpcy53b3JsZEdMLnNldHRpbmdzLnNjcm9sbF9ub3JtYWxpemVkRGVsdGEgKiAwLjUsIDAuMSk7XG4gICAgdGhpcy5lYXNlZF9zY3JvbGxQcm9ncmVzcyA9IG5ldyBFYXNlZE91dFZhbHVlKHRoaXMud29ybGRHTC5zZXR0aW5ncy5zY3JvbGxfcHJvZ3Jlc3MsIDAuMDUpOyAvLy0tXG5cbiAgICB0aGlzLl9zZXR1cF9zZXR0aW5ncygpOyAvLy0tXG5cblxuICAgIHRoaXMub3JiaXRhbF9nZW9tZXRyeSA9IG5ldyBTb2x1dGlvbnMxR2VvbWV0cnkodGhpcy5zZXR0aW5ncyk7IC8vLS1cblxuICAgIHRoaXMuTV9nZW9tZXRyeSA9IG5ldyBMb2FkZWRHZW9tZXRyeSh7XG4gICAgICBpZDogXCJNX2dlb21ldHJ5XCIsXG4gICAgICBmaWxlOiBcIndwLWNvbnRlbnQvdGhlbWVzL21pb3RpY29uc3VsdGluZy9pbWcvTS5nbGJcIixcbiAgICAgIGlzRHJhY286IGZhbHNlLFxuICAgICAgc2NhbGU6IDYwMCAvL3JvdGF0aW9uWSA6IC1NYXRoLlBJKjAuMjVcblxuICAgIH0sIHRoaXMuc2V0dGluZ3MpO1xuICAgIHRoaXMuTV9nZW9tZXRyeS5vbihcIm9uTWVzaExvYWRlZFwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgX3RoaXMuX2V2YWxfYWxsTG9hZGVkKCk7XG4gICAgfSk7IC8vLS1cblxuICAgIHRoaXMucmVzaXplKCk7IC8vLS1cblxuICAgIHRoaXMuTV9nZW9tZXRyeS5pbml0KCk7XG4gIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUFVCTElDQVM6IFxuXG5cbiAgX2NyZWF0ZUNsYXNzKFNvbHV0aW9uczFEb3RzLCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihTb2x1dGlvbnMxRG90cy5fY3JlYXRlKSFcIilcbiAgICAgIC8vLS1cbiAgICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgICAgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcsXG4gICAgICAgIC8vYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICAgICAgICAvL2JsZW5kaW5nOiBUSFJFRS5NdWx0aXBseUJsZW5kaW5nLFxuICAgICAgICB2ZXJ0ZXhDb2xvcnM6IHRydWUsXG4gICAgICAgIHZlcnRleFNoYWRlcjogdmVydGV4LFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogZnJhZ21lbnQsXG4gICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIHVDb2xvcjE6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoXCIjMTcwZTQxXCIpXG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLzgwMWM2NVxuICAgICAgICAgIHVDb2xvcjI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoXCIjODAxYzY1XCIpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Q29sb3JIZXJvOiB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKHRoaXMud29ybGRHTC5kb3RDb2xvcilcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVUaW1lOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdUNhbWFyYURpc3RhbmNlOiB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5jYW1lcmFEaXN0YW5jZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVdpZHRoOiB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy53b3JsZEdMLndpZHRoXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1SGVpZ2h0OiB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy53b3JsZEdMLmhlaWdodFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVNjcm9sbERlbHRhOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVNjcm9sbFByb2dyZXNzOiB7XG4gICAgICAgICAgICB2YWx1ZTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVJlc3BvbnNpdmVTY2FsZToge1xuICAgICAgICAgICAgdmFsdWU6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVSb3RhdGlvbjE6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Um90YXRpb24yOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVJvdGF0aW9uMzoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVSb3RhdGlvbklubmVyOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVJvdGF0aW9uT3V0dGVyOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdU1vcnBoaW5nUHJvZ3Jlc3M6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1SW50cm9Qcm9ncmVzczoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVUcmFuc2l0aW9uUHJvZ3Jlc3M6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTsgLy8tLVxuICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXMpXG4gICAgICAvLy0tXG5cbiAgICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9wb3NpY2lvbmVzLCAzKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXMsIDMpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfZG90X251bScsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9kb3RfbnVtLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX29yYml0YWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfb3JiaXRhbCwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9wb3Nfb3JiaXRhJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3Bvc19vcmJpdGEsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfaW5jcl9hbmd1bG9SYWQnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfaW5jcl9hbmd1bG9SYWQsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfYW5ndWxvUmFkJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX2FuZ3Vsb1JhZCwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9yYWRpbycsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9yYWRpbywgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9kaXInLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfZGlyLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX2luY3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfaW5jciwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV94JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3gsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfeScsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV95LCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX3onLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfeiwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9kb3RGYWN0b3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfZG90RmFjdG9yLCAxKSk7IC8vIEVsIHB1bnRvIG1hcyBpbnRlcmlvciB0aWVuZSAxIHkgZWwgbWFzIGV4dGVyaW9yIHRpZW5lIDBcblxuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMl9wb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5NX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9wb3NpY2lvbmVzLCAzKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9yYW5kb21uZXNzJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLk1fZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3JhbmRvbW5lc3MsIDMpKTtcbiAgICAgIHRoaXMubWVzaCA9IG5ldyBUSFJFRS5Qb2ludHModGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCk7IC8vdGhpcy5tZXNoLnJvdGF0aW9uLnNldChNYXRoLlBJLCAwLCAwKVxuICAgICAgLy90aGlzLm1lc2gucm90YXRpb24uc2V0KDAsIDAsIDAuNSpNYXRoLlBJKVxuXG4gICAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLm1lc2gpO1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25Nb3VzZVVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1vdXNlVXBkYXRlKG1vdXNlTm9ybVgsIG1vdXNlTm9ybVkpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoU29sdXRpb25zMURvdHMub25Nb3VzZVVwZGF0ZSk6IFwiK3RoaXMubW9ycGhpbmdQcm9ncmVzcylcbiAgICAgIGlmICh0aGlzLm1vcnBoaW5nUHJvZ3Jlc3MgPiAwKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCIqXCIpXG4gICAgICAgIHRoaXMuX21vdXNlVXBkYXRlWChtb3VzZU5vcm1YKTtcblxuICAgICAgICB0aGlzLl9tb3VzZVVwZGF0ZVkobW91c2VOb3JtWSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZV90cmFuc2l0aW9uUHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlX3RyYW5zaXRpb25Qcm9ncmVzcyhwcm9ncmVzcykge1xuICAgICAgdGhpcy50cmFuc2l0aW9uUHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIGlmICh0aGlzLmFsbExvYWRlZCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiKFNvbHV0aW9uczFEb3RzLnJlbmRlcikhXCIpXG4gICAgICAgIC8vLS1cbiAgICAgICAgaWYgKHRoaXMuc3RhcnRUaW1lID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHRoaXMuY2xvY2suZ2V0RWxhcHNlZFRpbWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbnRyb1Byb2dyZXNzID0gV2ViR0xVdGlscy5jbGFtcCgodGhpcy5jbG9jay5nZXRFbGFwc2VkVGltZSgpIC0gdGhpcy5zdGFydFRpbWUpIC8gdGhpcy5pbnRyb1RpbWUsIDAsIDEpO1xuICAgICAgICBpbnRyb1Byb2dyZXNzID0gRWFzaW5nLlF1YXJ0aWMuT3V0KGludHJvUHJvZ3Jlc3MpO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVJbnRyb1Byb2dyZXNzLnZhbHVlID0gaW50cm9Qcm9ncmVzczsgLy8tLVxuXG4gICAgICAgIHZhciByb3RhdGlvbkVhc2VkWSA9IHRoaXMucm90YXRpb25ZICsgKHRoaXMucm90YXRpb25XYW50ZWRZIC0gdGhpcy5yb3RhdGlvblkpICogMC4wNTtcbiAgICAgICAgdGhpcy5yb3RhdGlvblkgPSByb3RhdGlvbkVhc2VkWTtcbiAgICAgICAgdGhpcy5tZXNoLnJvdGF0aW9uLnkgPSByb3RhdGlvbkVhc2VkWTsgLy8vLy0tXG5cbiAgICAgICAgdmFyIHJvdGF0aW9uRWFzZWRYID0gdGhpcy5yb3RhdGlvblggKyAodGhpcy5yb3RhdGlvbldhbnRlZFggLSB0aGlzLnJvdGF0aW9uWCkgKiAwLjA1O1xuICAgICAgICB0aGlzLnJvdGF0aW9uWCA9IHJvdGF0aW9uRWFzZWRYO1xuICAgICAgICB0aGlzLm1lc2gucm90YXRpb24ueCA9IHJvdGF0aW9uRWFzZWRYOyAvLy0tXG5cbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51VHJhbnNpdGlvblByb2dyZXNzLnZhbHVlID0gRWFzaW5nLlF1YXJ0aWMuSW5PdXQodGhpcy50cmFuc2l0aW9uUHJvZ3Jlc3MpOyAvLy0tXG4gICAgICAgIC8vY29uc3QgIG1lc2hSb3RhdGlvbiA9IE1hdGguUEkgLSAoTWF0aC5QSSp0aGlzLnRyYW5zaXRpb25Qcm9ncmVzcylcbiAgICAgICAgLy90aGlzLm1lc2gucm90YXRpb24uc2V0KG1lc2hSb3RhdGlvbiwgMCwgMClcbiAgICAgICAgLy8tLVxuICAgICAgICAvL2NvbnN0IHJvdGF0aW9uRWFzZWQgPSB0aGlzLnJvdGF0aW9uICsoKHRoaXMucm90YXRpb25XYW50ZWQgLSB0aGlzLnJvdGF0aW9uKSowLjA1KVxuICAgICAgICAvL3RoaXMucm90YXRpb24gPSByb3RhdGlvbkVhc2VkXG4gICAgICAgIC8vdGhpcy5tZXNoLnJvdGF0aW9uLnkgPSByb3RhdGlvbkVhc2VkXG4gICAgICAgIC8vLS1cblxuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVUaW1lLnZhbHVlID0gdGhpcy5jbG9jay5nZXRFbGFwc2VkVGltZSgpO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVDYW1hcmFEaXN0YW5jZS52YWx1ZSA9IHRoaXMud29ybGRHTC5jYW1lcmFEaXN0YW5jZTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51UmVzcG9uc2l2ZVNjYWxlLnZhbHVlID0gdGhpcy53b3JsZEdMLnJlc3BvbnNpdmVTY2FsZTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51U2Nyb2xsRGVsdGEudmFsdWUgPSAtdGhpcy5lYXNlZF9zY3JvbGxEZWx0YS5nZXQodGhpcy53b3JsZEdMLnNldHRpbmdzLnNjcm9sbF9ub3JtYWxpemVkRGVsdGEgKiAwLjUpO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVTY3JvbGxQcm9ncmVzcy52YWx1ZSA9IHRoaXMud29ybGRHTC5zZXR0aW5ncy5zY3JvbGxfcHJvZ3Jlc3M7XG5cbiAgICAgICAgaWYgKHRoaXMud29ybGRHTC5zZXR0aW5ncy5tb3JwaGluZ1Byb2dyZXNzIDw9IDAuNSkge1xuICAgICAgICAgIHRoaXMubW9ycGhpbmdQcm9ncmVzcyA9IDA7XG5cbiAgICAgICAgICB0aGlzLl9tb3VzZVVwZGF0ZVgoMCk7XG5cbiAgICAgICAgICB0aGlzLl9tb3VzZVVwZGF0ZVkoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tb3JwaGluZ1Byb2dyZXNzID0gKHRoaXMud29ybGRHTC5zZXR0aW5ncy5tb3JwaGluZ1Byb2dyZXNzIC0gMC41KSAqIDI7XG4gICAgICAgIH0gLy9jb25zb2xlLmxvZyhcInRoaXMubW9ycGhpbmdQcm9ncmVzczogXCIrdGhpcy5tb3JwaGluZ1Byb2dyZXNzKVxuICAgICAgICAvLy0tXG5cblxuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVNb3JwaGluZ1Byb2dyZXNzLnZhbHVlID0gdGhpcy5tb3JwaGluZ1Byb2dyZXNzO1xuICAgICAgICB2YXIgZXh0cmFTcGVlZCA9IDEgKyBNYXRoLmFicyh0aGlzLmVhc2VkX3Njcm9sbERlbHRhX2Zhc3QuZ2V0KHRoaXMud29ybGRHTC5zZXR0aW5ncy5zY3JvbGxfbm9ybWFsaXplZERlbHRhICogMC41KSAqIDEwKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5yb3RhdGlvbjEgKz0gdGhpcy5zZXR0aW5ncy5zcGVlZFJvdGF0aW9uMSAqIGV4dHJhU3BlZWQ7XG4gICAgICAgIHRoaXMuc2V0dGluZ3Mucm90YXRpb24yICs9IHRoaXMuc2V0dGluZ3Muc3BlZWRSb3RhdGlvbjIgKiBleHRyYVNwZWVkO1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJvdGF0aW9uMyArPSB0aGlzLnNldHRpbmdzLnNwZWVkUm90YXRpb24zICogZXh0cmFTcGVlZDsgLy8tLVxuXG4gICAgICAgIHRoaXMuc2V0dGluZ3Mucm90YXRpb25Jbm5lciArPSB0aGlzLnNldHRpbmdzLnNwZWVkUm90YXRpb25Jbm5lciAqIGV4dHJhU3BlZWQ7XG4gICAgICAgIHRoaXMuc2V0dGluZ3Mucm90YXRpb25PdXR0ZXIgKz0gdGhpcy5zZXR0aW5ncy5zcGVlZFJvdGF0aW9uT3V0dGVyICogZXh0cmFTcGVlZDsgLy9jb25zb2xlLmxvZyhcImV4dHJhU3BlZWQ6IFwiK2V4dHJhU3BlZWQpXG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5zZXR0aW5ncy5yb3RhdGlvbjEpXG5cbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Um90YXRpb24xLnZhbHVlID0gdGhpcy5zZXR0aW5ncy5yb3RhdGlvbjE7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVJvdGF0aW9uMi52YWx1ZSA9IC10aGlzLnNldHRpbmdzLnJvdGF0aW9uMjtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Um90YXRpb24zLnZhbHVlID0gdGhpcy5zZXR0aW5ncy5yb3RhdGlvbjM7IC8vLS1cblxuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVSb3RhdGlvbklubmVyLnZhbHVlID0gdGhpcy5zZXR0aW5ncy5yb3RhdGlvbklubmVyO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVSb3RhdGlvbk91dHRlci52YWx1ZSA9IHRoaXMuc2V0dGluZ3Mucm90YXRpb25PdXR0ZXI7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoKSB7Ly8gTkFEQVxuICAgIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBQUklWQURBUzogXG5cbiAgfSwge1xuICAgIGtleTogXCJfbW91c2VVcGRhdGVYXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3VzZVVwZGF0ZVgobW91c2VOb3JtWCkge1xuICAgICAgdmFyIG1heEFuZ2xlUmFkID0gTWF0aC5QSSAqIDAuMjU7XG4gICAgICB0aGlzLnJvdGF0aW9uV2FudGVkWSA9IG1heEFuZ2xlUmFkICogbW91c2VOb3JtWCAqIHRoaXMubW9ycGhpbmdQcm9ncmVzcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX21vdXNlVXBkYXRlWVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW91c2VVcGRhdGVZKG1vdXNlTm9ybVkpIHtcbiAgICAgIHZhciBtYXhBbmdsZVJhZCA9IE1hdGguUEkgKiAwLjE7XG4gICAgICB0aGlzLnJvdGF0aW9uV2FudGVkWCA9IG1heEFuZ2xlUmFkICogbW91c2VOb3JtWSAqIHRoaXMubW9ycGhpbmdQcm9ncmVzcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2YWxfYWxsTG9hZGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmFsX2FsbExvYWRlZCgpIHtcbiAgICAgIGlmICh0aGlzLk1fZ2VvbWV0cnkubG9hZGVkKSB7XG4gICAgICAgIHRoaXMuYWxsTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53b3JsZEdMLmV2YWxfc3RhcnQoKTsgLy90aGlzLl9jcmVhdGUoKVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0dXBfc2V0dGluZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwX3NldHRpbmdzKCkge1xuICAgICAgdmFyIF90aGlzJHNldHRpbmdzO1xuXG4gICAgICB2YXIgc3BlZWRCYXNlID0gMC4wMDI7XG4gICAgICB2YXIgc3BlZWRCYXNlMiA9IDAuMDAwMjsgLy9jb25zb2xlLmxvZyhcIihTb2x1dGlvbnMxRG90cy5fc2V0dXBfc2V0dGluZ3MpIVwiKVxuXG4gICAgICB0aGlzLnNldHRpbmdzID0gKF90aGlzJHNldHRpbmdzID0ge1xuICAgICAgICBmYWN0b3I6IDYsXG4gICAgICAgIGluY3JfcmFkaW86IDI1LFxuICAgICAgICBudW1PcmJpdHM6IDM3LFxuICAgICAgICBhcnJheU9yYml0czogWzUsIDEwLCAxNV0sXG4gICAgICAgIC8vLS1cbiAgICAgICAgcm90YXRpb25Jbm5lcjogMCxcbiAgICAgICAgc3BlZWRSb3RhdGlvbklubmVyOiAyMCAqIHNwZWVkQmFzZTIsXG4gICAgICAgIHJvdGF0aW9uT3V0dGVyOiAwLFxuICAgICAgICBzcGVlZFJvdGF0aW9uT3V0dGVyOiAxICogc3BlZWRCYXNlMixcbiAgICAgICAgLy8tLVxuICAgICAgICBzcGVlZFJvdGF0aW9uMTogMyAqIHNwZWVkQmFzZSxcbiAgICAgICAgcm90YXRpb24xOiAwXG4gICAgICB9LCBfZGVmaW5lUHJvcGVydHkoX3RoaXMkc2V0dGluZ3MsIFwic3BlZWRSb3RhdGlvbjFcIiwgMyAqIHNwZWVkQmFzZSksIF9kZWZpbmVQcm9wZXJ0eShfdGhpcyRzZXR0aW5ncywgXCJyb3RhdGlvbjJcIiwgMiksIF9kZWZpbmVQcm9wZXJ0eShfdGhpcyRzZXR0aW5ncywgXCJzcGVlZFJvdGF0aW9uMlwiLCAyICogc3BlZWRCYXNlKSwgX2RlZmluZVByb3BlcnR5KF90aGlzJHNldHRpbmdzLCBcInJvdGF0aW9uM1wiLCAwKSwgX2RlZmluZVByb3BlcnR5KF90aGlzJHNldHRpbmdzLCBcInNwZWVkUm90YXRpb24zXCIsIDEgKiBzcGVlZEJhc2UpLCBfdGhpcyRzZXR0aW5ncyk7XG4gICAgICB0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXIgPSB0aGlzLl9nZXRfYXJyYXlfdHJpYW5ndWxhcih0aGlzLnNldHRpbmdzLmZhY3RvciwgdGhpcy5zZXR0aW5ncy5udW1PcmJpdHMpO1xuICAgICAgdGhpcy5zZXR0aW5ncy5udW1Eb3RzID0gdGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyW3RoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhci5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldF9hcnJheV90cmlhbmd1bGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfYXJyYXlfdHJpYW5ndWxhcihfZmFjdG9yLCBfbnVtT2JpdHMpIHtcbiAgICAgIC8vIEdlbmVyYSB1bmEgYXJyYXkgZGUgcHJvZ3Jlc2nDs24gdHJpYW5ndWxhciAoKiBmYWN0b3IpLlxuICAgICAgLy8gVW5hIHByb2dyZXNpw7NuIHRyaWFuZ3VsYXIgZXM6IDEsIDMsIDYsIDEwLCAxNSAoaHR0cHM6Ly9zaWduaWZpY2F0aXZhLm9yZy9kaWNjaW9uYXJpb3MvbnVtZXJvcy1maWd1cmFkb3MvIzp+OnRleHQ9My4xLjEuMS4tLERlZmluaWNpJUMzJUIzbixhbnRlcmlvciUyMG5vJTIwb2J0ZW5lbW9zJTIwdW5hJTIwY29uc3RhbnRlLilcbiAgICAgIHZhciBtaUFycmF5ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IF9udW1PYml0czsgaSsrKSB7XG4gICAgICAgIC8vYXJyYXlfbnVtVHJpYWd1bGFyZXMucHVzaChpKihpKzEpLzIpXG4gICAgICAgIG1pQXJyYXkucHVzaChpICogKGkgKyAxKSAvIDIgKiBfZmFjdG9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1pQXJyYXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRfYXJyYXlfZG90UG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfYXJyYXlfZG90UG9zKF9hcnJheU9yYml0cywgX2FycmF5X3RyaWFuZ3VsYXIsIF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEpIHtcbiAgICAgIHZhciBtaUFycmF5ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2FycmF5T3JiaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvcmJpdE51bSA9IF9hcnJheU9yYml0c1tpXTtcbiAgICAgICAgdmFyIGRvdHNfeF9vcmJpdCA9IF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGFbaV07XG4gICAgICAgIHZhciBkb3ROdW1fYmFzZSA9IF9hcnJheV90cmlhbmd1bGFyW19hcnJheU9yYml0c1tpXSAtIDFdOyAvLyBjb25zb2xlLmxvZyhcIm9yYml0TnVtOiBcIitvcmJpdE51bSlcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJkb3RzX3hfb3JiaXQ6IFwiK2RvdHNfeF9vcmJpdClcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJkb3ROdW1fYmFzZTogXCIrZG90TnVtX2Jhc2UpXG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb3RzX3hfb3JiaXQ7IGorKykge1xuICAgICAgICAgIG1pQXJyYXkucHVzaChkb3ROdW1fYmFzZSArIGogKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWlBcnJheTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldF9udW1Eb3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfbnVtRG90cyhfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhKSB7XG4gICAgICB2YXIgbnVtRG90cyA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIG51bURvdHMgKz0gX2FycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YVtpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bURvdHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhKF9hcnJheV90cmlhbmd1bGFyLCBfYXJyYXlPcmJpdHMpIHtcbiAgICAgIC8vIEdlbmVyYSB1bmEgYXJyYXkgYmFzYWRhIGVuIGxhIHByb2dyZXNpw7NuIHRyaWFuZ3VsYXIgKCogZmFjdG9yKS5cbiAgICAgIC8vIC4uLiBkb25kZSBzZSBpbmRpY2EgZWwgbnVtZXJvIGRlIGRvdHMgcG9yIG9yYml0YWxcbiAgICAgIC8vIFVuYSBwcm9ncmVzacOzbiB0cmlhbmd1bGFyIGVzOiAxLCAzLCA2LCAxMCwgMTUgKGh0dHBzOi8vc2lnbmlmaWNhdGl2YS5vcmcvZGljY2lvbmFyaW9zL251bWVyb3MtZmlndXJhZG9zLyM6fjp0ZXh0PTMuMS4xLjEuLSxEZWZpbmljaSVDMyVCM24sYW50ZXJpb3IlMjBubyUyMG9idGVuZW1vcyUyMHVuYSUyMGNvbnN0YW50ZS4pXG4gICAgICB2YXIgbWlBcnJheSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBfYXJyYXlPcmJpdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIC8vYXJyYXlfbnVtVHJpYWd1bGFyZXMucHVzaChpKihpKzEpLzIpXG4gICAgICAgIHZhciBudW1Eb3RzX29yYml0YV9hY3R1YWwgPSBfYXJyYXlfdHJpYW5ndWxhcltfYXJyYXlPcmJpdHNbaV1dO1xuICAgICAgICB2YXIgbnVtRG90c19vcmJpdGFfYW50ZXJpb3IgPSBfYXJyYXlfdHJpYW5ndWxhcltfYXJyYXlPcmJpdHNbaV0gLSAxXTtcbiAgICAgICAgdmFyIG51bURvdHNfb3JiaXRhID0gbnVtRG90c19vcmJpdGFfYWN0dWFsIC0gbnVtRG90c19vcmJpdGFfYW50ZXJpb3I7XG4gICAgICAgIG1pQXJyYXkucHVzaChudW1Eb3RzX29yYml0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaUFycmF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlY3ViZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlY3ViZShfc2NlbmUpIHtcbiAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgxMDAgKiB0aGlzLndvcmxkR0wucmVzcG9uc2l2ZVNjYWxlLCAxMDAsIDEwMCk7XG4gICAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICBjb2xvcjogMHgwMGZmMDBcbiAgICAgIH0pO1xuICAgICAgdmFyIGN1YmUgPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgY3ViZS5wb3NpdGlvbi5zZXRYKHRoaXMud29ybGRHTC53aWR0aCAqIDAuNSk7XG4gICAgICBjdWJlLnBvc2l0aW9uLnNldFkodGhpcy53b3JsZEdMLmhlaWdodCAqIDAuNSk7XG4gICAgICBjdWJlLnF1YXRlcm5pb24uY29weSh0aGlzLndvcmxkR0wuY2FtZXJhLnF1YXRlcm5pb24pO1xuXG4gICAgICBfc2NlbmUuYWRkKGN1YmUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTb2x1dGlvbnMxRG90cztcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgU29sdXRpb25zMURvdHM7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vLyBGUFMtTWV0ZXI6XG4vLyhmdW5jdGlvbigpe3ZhciBzY3JpcHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7c2NyaXB0Lm9ubG9hZD1mdW5jdGlvbigpe3ZhciBzdGF0cz1uZXcgU3RhdHMoKTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXRzLmRvbSk7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGxvb3AoKXtzdGF0cy51cGRhdGUoKTtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCl9KTt9O3NjcmlwdC5zcmM9Jy8vY2RuLmpzZGVsaXZyLm5ldC9naC9LZXZuei9zdGF0cy5qcy9idWlsZC9zdGF0cy5taW4uanMnO2RvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTt9KSgpXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBPcmJpdENvbnRyb2xzIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2NvbnRyb2xzL09yYml0Q29udHJvbHMnO1xuaW1wb3J0ICogYXMgZGF0IGZyb20gXCJkYXQuZ3VpXCI7XG5pbXBvcnQgZ3NhcCBmcm9tICdnc2FwJztcbmltcG9ydCBTY3JvbGxUcmlnZ2VyIGZyb20gJ2dzYXAvU2Nyb2xsVHJpZ2dlcic7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcblxuaW1wb3J0IFdlYkdMVXRpbHMgZnJvbSAnLi4vV2ViR0xVdGlscyc7XG5pbXBvcnQgU29sdXRpb25zMURvdHMgZnJvbSAnLi9Tb2x1dGlvbnMxRG90cyc7XG5pbXBvcnQgU29sdXRpb25zMUJhY2tncm91bmQgZnJvbSAnLi9Tb2x1dGlvbnMxQmFja2dyb3VuZCc7XG5cbnZhciBTb2x1dGlvbnMxQXBwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU29sdXRpb25zMUFwcChvYmopIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvbHV0aW9uczFBcHApO1xuXG4gICAgLy9jb25zb2xlLmxvZyhcIihTb2x1dGlvbnMxQXBwLkNPTlNUUlVDVE9SQSkhXCIsIG9iaikgXG4gICAgdGhpcy5od19yZW5kZXJlciA9IG9iai5yZW5kZXJlcjsgLy8gUmVkZXJlci9wYWdpbmEgZGUgSGlnaFdheS4gTm8gY29uZnVuZGlyIGNvbiBlbCByZW5kZXIvcmVuZGVyZXIgZGUgVGhyZWUuanNcblxuICAgIHRoaXMuJGNvbnRhaW5lciA9IG9iai5kb21FbGVtZW50O1xuICAgIHRoaXMuZG90Q29sb3IgPSBvYmouZG90Q29sb3I7IC8vLS1cblxuICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpOyAvLy0tXG5cbiAgICB0aGlzLlJFRl9SRVNPTFVUSU9OID0ge1xuICAgICAgd2lkdGg6IDE5MjAsXG4gICAgICBoZWlnaHQ6IDk0N1xuICAgIH07XG4gICAgdGhpcy5SRUZfQ0FNRVJBX0RJU1RBTkNFID0gNTAwOyAvLy0tXG5cbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7IC8vLS1cblxuICAgIHRoaXMud2lkdGggPSB0aGlzLiRjb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLiRjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgIHRoaXMucmVzcG9uc2l2ZVNjYWxlID0gdGhpcy53aWR0aCAvIHRoaXMuUkVGX1JFU09MVVRJT04ud2lkdGg7XG4gICAgdGhpcy5jYW1lcmFEaXN0YW5jZSA9IHRoaXMuUkVGX0NBTUVSQV9ESVNUQU5DRSAqICh0aGlzLmhlaWdodCAvIHRoaXMuUkVGX1JFU09MVVRJT04uaGVpZ2h0KTsgLy8tLVxuICAgIC8vdGhpcy4kbWFpbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbm5lcicpXG4gICAgLy90aGlzLiRoZXJvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmhlcm8nKVxuICAgIC8vdGhpcy4kZm9vdGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZvb3RlcicpXG4gICAgLy90aGlzLiRpbWFnZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5haV9faGVybyAuaW1hZ2UnKVxuICAgIC8vdmFyIHJlY3QgPSB0aGlzLiRpbWFnZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAvL2NvbnNvbGUubG9nKHJlY3QudG9wLCByZWN0LnJpZ2h0LCByZWN0LmJvdHRvbSwgcmVjdC5sZWZ0KTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICBfdGhpcy5vbk1vdXNlVXBkYXRlKHNlbGYpO1xuICAgIH0sIGZhbHNlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICBfdGhpcy5vbk1vdXNlVXBkYXRlKHNlbGYpO1xuICAgIH0sIGZhbHNlKTsgLy8tLVxuXG4gICAgdGhpcy5NQUlOX0FDVElWRSA9IGZhbHNlO1xuICAgIHRoaXMuRk9PVEVSX0FDVElWRSA9IGZhbHNlOyAvLy0tXG5cbiAgICB0aGlzLm1vdXNlTm9ybSA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTsgLy8tLVxuICAgIC8vLS1cblxuICAgIHRoaXMuc2V0dGluZ3MgPSB7XG4gICAgICBzY3JvbGxfbGFzdElubmVyWTogMCxcbiAgICAgIC8vIFVsdGltYSBwb3NpY2nDs24gZGVsIGVsZW1lbnRvIGRlIHJlZmVyZW5jaWFcbiAgICAgIHNjcm9sbF9kZWx0YTogMCxcbiAgICAgIC8vIEluY3JlbWVudG8gZGUgcGl4ZWxzIGRlbCBzY3JvbGxcbiAgICAgIHNjcm9sbF9saW1pdGVkRGVsdGE6IDAsXG4gICAgICAvLyBMaW1pdGEgbG9zIHZhbG9yZXMgYSAtMjAgLT4gKzIwXG4gICAgICBzY3JvbGxfbm9ybWFsaXplZERlbHRhOiAwLFxuICAgICAgLy8gUGFzYSBlbCBkZWx0YSBhIC0xIC0+ICsxXG4gICAgICBzY3JvbGxfZmFjdG9yZERlbHRhOiAxLFxuICAgICAgLy8gVmFsb3JlcyBhYnNvbHV0b3MgZGUgMCAtPiAxXG4gICAgICBzY3JvbGxfZGlyZWN0aW9uOiAxLFxuICAgICAgLy8gRGlyZWNjaW9uIGRlbCBkZWx0YS4gMSBzaSBlc3TDoSBwYXJhZG9cbiAgICAgIHNjcm9sbF9oZXJvX3Byb2dyZXNzOiAwLFxuICAgICAgc2Nyb2xsX2Zvb3Rlcl9wcm9ncmVzczogMCxcbiAgICAgIG1vcnBoaW5nUHJvZ3Jlc3M6IDBcbiAgICB9OyAvLy0tXG4gICAgLy8gU2NlbmVcblxuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTsgLy90aGlzLnNjZW5lLmJhY2tncm91bmQgPSBuZXcgVEhSRUUuQ29sb3IoMHgzMzMzMzMpXG4gICAgLy8tLVxuICAgIC8vIENhbWVyYVxuICAgIC8vUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiA6IE51bWJlciwgYXNwZWN0IDogTnVtYmVyLCBuZWFyIDogTnVtYmVyLCBmYXIgOiBOdW1iZXIgKVxuXG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoMzAsIHRoaXMud2lkdGggLyB0aGlzLmhlaWdodCwgMC4xLCAyMDAwKTtcbiAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi56ID0gdGhpcy5jYW1lcmFEaXN0YW5jZTsgLy9jb25zb2xlLmxvZyhcInRoaXMuY2FtZXJhLmZvdjogXCIrdGhpcy5jYW1lcmEuZm92KVxuXG4gICAgdGhpcy5jYW1lcmEuZm92ID0gMiAqIE1hdGguYXRhbih0aGlzLmhlaWdodCAvIDIgLyB0aGlzLmNhbWVyYURpc3RhbmNlKSAqICgxODAgLyBNYXRoLlBJKTsgLy9jb25zb2xlLmxvZyhcInRoaXMuY2FtZXJhLmZvdjogXCIrdGhpcy5jYW1lcmEuZm92KVxuICAgIC8vLS1cbiAgICAvLyBSZW5kZXJlclxuXG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTDFSZW5kZXJlcih7XG4gICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICBhbHBoYTogdHJ1ZVxuICAgIH0pOyAvL3RoaXMucmVuZGVyZXIuYXV0b0NsZWFyID0gZmFsc2UgLy8gVmFtb3MgYSB1c2FyIDIgc2NlbmFzICh1bmEgcGFyYSBlbCBiYWNrZ3JvdW5kIHkgb3RyYSBwYXJhIGxvcyBwdW50b3MpIHF1ZSBpbXBsaWNhcsOhbiB1c2FyIDIgYWNjaW9uZXMgZGUgcmVuZGVyLiBDb24gYXV0b2NsZWFyIGZhbHNlIHBlcm1pdGltb3MgcXVlIGxhIHNlZ3VuZGEgbm8gYm9ycmUgbGEgcHJpbWVyYS5cblxuICAgIHRoaXMucmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyhNYXRoLm1pbih3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgMSkpOyAvLy0tXG4gICAgLy9jb25zb2xlLmxvZyhcInRoaXMuJGNvbnRhaW5lcjogXCIsdGhpcy4kY29udGFpbmVyKVxuXG4gICAgdGhpcy4kY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7IC8vLS1cbiAgICAvLy0tXG5cbiAgICAvKlxuICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ldyBTb2x1dGlvbnMxQmFja2dyb3VuZCh7XG4gICAgICAgIHdvcmxkR0w6dGhpcyxcbiAgICB9KVxuICAgICovXG4gICAgLy8tLVxuXG4gICAgdGhpcy5kb3RzID0gbmV3IFNvbHV0aW9uczFEb3RzKHtcbiAgICAgIHdvcmxkR0w6IHRoaXNcbiAgICB9KTsgLy8tLVxuXG4gICAgdGhpcy5fcmVzaXplKCk7IC8vdGhpcy5fcmVuZGVyKCk7XG4gICAgLy90aGlzLl9pbml0X3Njcm9sbExpc3RlbmVycygpXG5cbiAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQVUJMSUNBUzpcblxuXG4gIF9jcmVhdGVDbGFzcyhTb2x1dGlvbnMxQXBwLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKFNvbHV0aW9uczFBcHAuaW5pdCkhXCIpIFxuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLmV2YWxfc3RhcnQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXZhbF9zdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsX3N0YXJ0KCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihTb2x1dGlvbnMxQXBwLmV2YWxfc3RhcnQpOiBcIit0aGlzLmluaXRpYWxpemVkK1wiOlwiK3RoaXMuZG90cy5hbGxMb2FkZWQpIFxuICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQgJiYgdGhpcy5kb3RzLmFsbExvYWRlZCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiU1RBUlQhXCIpXG4gICAgICAgIC8vLS1cbiAgICAgICAgdGhpcy4kbWFpbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbm5lcicpO1xuICAgICAgICB0aGlzLiRoZXJvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmhlcm8nKTtcbiAgICAgICAgdGhpcy4kZm9vdGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZvb3RlcicpO1xuICAgICAgICB0aGlzLiRpbWFnZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5haV9faGVybyAuaW1hZ2UnKTsgLy8tLVxuXG4gICAgICAgIHRoaXMuZG90cy5jcmVhdGUoKTtcblxuICAgICAgICB0aGlzLl9yZW5kZXIoKTtcblxuICAgICAgICB0aGlzLl9pbml0X3Njcm9sbExpc3RlbmVycygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJraWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKFNvbHV0aW9uczFBcHAua2lsbCkhXCIpIFxuICAgICAgdGhpcy4kaW5uZXJfdHJpZ2dlci5raWxsKCk7XG4gICAgICB0aGlzLiRoZXJvX3RyaWdnZXIua2lsbCgpO1xuICAgICAgZ3NhcC50aWNrZXIucmVtb3ZlKHRoaXMuX2JpbmRlZF9yZW5kZXIpO1xuICAgICAgZ3NhcC50aWNrZXIucmVtb3ZlKHRoaXMuX2JpbmRlZF9ldmFsX3Njcm9sbCk7XG4gICAgICB0aGlzLmRvdHMgPSBudWxsO1xuICAgIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB9LCB7XG4gICAga2V5OiBcIm9uUmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihTb2x1dGlvbnMxQXBwLm9uUmVzaXplKSFcIilcbiAgICAgIHRoaXMuX3Jlc2l6ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbk1vdXNlVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VVcGRhdGUoZSkge1xuICAgICAgaWYgKHRoaXMuRk9PVEVSX0FDVElWRSkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiKFNvbHV0aW9uczFBcHAub25Nb3VzZVVwZGF0ZSkhXCIpXG4gICAgICAgIHRoaXMubW91c2VOb3JtLnggPSBlLnBhZ2VYIC8gdGhpcy53aWR0aCAqIDIgLSAxO1xuICAgICAgICB0aGlzLm1vdXNlTm9ybS55ID0gZS5wYWdlWSAvIHRoaXMuaGVpZ2h0ICogMiAtIDE7XG5cbiAgICAgICAgaWYgKHRoaXMuZG90cykge1xuICAgICAgICAgIHRoaXMuZG90cy5vbk1vdXNlVXBkYXRlKHRoaXMubW91c2VOb3JtLngsIHRoaXMubW91c2VOb3JtLnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFBSSVZBREFTOlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRfc2Nyb2xsTGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0X3Njcm9sbExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvL2NvbnNvbGUubG9nKFwiKFNvbHV0aW9uczFBcHAuX2luaXRfc2Nyb2xsTGlzdGVuZXJzKSFcIilcbiAgICAgIHZhciBiaW5kZWRfcmVuZGVyID0gZnVuY3Rpb24gYmluZGVkX3JlbmRlcigpIHtcbiAgICAgICAgX3RoaXMyLl9yZW5kZXIoKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2JpbmRlZF9yZW5kZXIgPSBiaW5kZWRfcmVuZGVyO1xuXG4gICAgICB2YXIgYmluZGVkX2V2YWxfc2Nyb2xsID0gZnVuY3Rpb24gYmluZGVkX2V2YWxfc2Nyb2xsKCkge1xuICAgICAgICBfdGhpczIuX2V2YWxfaW5lcnRpYV9zY3JvbGwoX3RoaXMyLiRpbm5lcl90cmlnZ2VyLnByb2dyZXNzKTtcblxuICAgICAgICBfdGhpczIuX2V2YWxfaGVyb19zY3JvbGwoX3RoaXMyLiRoZXJvX3RyaWdnZXIucHJvZ3Jlc3MpO1xuXG4gICAgICAgIF90aGlzMi5fZXZhbF9mb290ZXJfc2Nyb2xsKF90aGlzMi4kZm9vdGVyX3RyaWdnZXIucHJvZ3Jlc3MpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fYmluZGVkX2V2YWxfc2Nyb2xsID0gYmluZGVkX2V2YWxfc2Nyb2xsO1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdGhpcy4kaW5uZXJfdHJpZ2dlciA9IFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgdHJpZ2dlcjogdGhpcy4kbWFpbixcbiAgICAgICAgc3RhcnQ6ICd0b3AtPTEwIHRvcCcsXG4gICAgICAgIGVuZDogJ2JvdHRvbSBib3R0b20nLFxuICAgICAgICBzY3J1YjogdHJ1ZSxcbiAgICAgICAgLy8gU2NydWI6IEdlbmVyYSBldmVudG9zIGVuIHVuYSBmcmFuamEgbWFzIHF1ZSBlbiB1biBwdW50by5cbiAgICAgICAgLy8gbWFya2VyczogdHJ1ZSxcbiAgICAgICAgb25Ub2dnbGU6IGZ1bmN0aW9uIG9uVG9nZ2xlKHNlbGYpIHtcbiAgICAgICAgICBpZiAoc2VsZi5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIk1BSU4gQUNUSVZFXCIpXG4gICAgICAgICAgICB0aGF0Lk1BSU5fQUNUSVZFID0gdHJ1ZTtcbiAgICAgICAgICAgIGdzYXAudGlja2VyLmFkZChiaW5kZWRfcmVuZGVyKTtcbiAgICAgICAgICAgIGdzYXAudGlja2VyLmFkZChiaW5kZWRfZXZhbF9zY3JvbGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0Lk1BSU5fQUNUSVZFID0gZmFsc2U7IC8vY29uc29sZS5sb2coXCJNQUlOIE5PVCBBQ1RJVkVcIilcbiAgICAgICAgICAgIC8vZ3NhcC50aWNrZXIucmVtb3ZlKGJpbmRlZF9yZW5kZXIpIC8vIEVsIGZvbmRvIHdlYmdsIHBlcnNpc3RlIHNpZW1wcmUuIE5vIGxvIGRlc2FjdGl2YW1vcyBudW5jYS5cblxuICAgICAgICAgICAgZ3NhcC50aWNrZXIucmVtb3ZlKGJpbmRlZF9ldmFsX3Njcm9sbCk7IC8vIEVsIGZvbmRvIHdlYmdsIHBlcnNpc3RlIHNpZW1wcmUuIE5vIGxvIGRlc2FjdGl2YW1vcyBudW5jYS5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy4kaGVyb190cmlnZ2VyID0gU2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xuICAgICAgICB0cmlnZ2VyOiB0aGlzLiRoZXJvLFxuICAgICAgICBzdGFydDogJ2JvdHRvbSBib3R0b20nLFxuICAgICAgICBlbmQ6ICdib3R0b20rPTIwMDAgdG9wJyxcbiAgICAgICAgc2NydWI6IHRydWUsXG4gICAgICAgIC8vIFNjcnViOiBHZW5lcmEgZXZlbnRvcyBlbiB1bmEgZnJhbmphIG1hcyBxdWUgZW4gdW4gcHVudG8uXG4gICAgICAgIC8vIG1hcmtlcnM6IHRydWUsXG4gICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShzZWxmKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcInByb2dyZXNzOiBcIitzZWxmLnByb2dyZXNzKVxuICAgICAgICAgIGlmIChfdGhpczIuZG90cykge1xuICAgICAgICAgICAgX3RoaXMyLmRvdHMudXBkYXRlX3RyYW5zaXRpb25Qcm9ncmVzcyhzZWxmLnByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy4kaGVybzJfdHJpZ2dlciA9IFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgdHJpZ2dlcjogdGhpcy4kaGVybyxcbiAgICAgICAgc3RhcnQ6ICdib3R0b20gY2VudGVyJyxcbiAgICAgICAgZW5kOiAnYm90dG9tIHRvcCcsXG4gICAgICAgIC8vc2NydWI6IHRydWUsIC8vIFNjcnViOiBHZW5lcmEgZXZlbnRvcyBlbiB1bmEgZnJhbmphIG1hcyBxdWUgZW4gdW4gcHVudG8uXG4gICAgICAgIC8vIG1hcmtlcnM6IHRydWUsXG4gICAgICAgIG9uRW50ZXI6IGZ1bmN0aW9uIG9uRW50ZXIoc2VsZikgey8vY29uc29sZS5sb2coXCJvbkVudGVyLmlzQWN0aXZlOiBcIixzZWxmKVxuICAgICAgICAgIC8vdGhpcy5kb3RzLm9uRG9IZXJvVHJhbnNpdGlvbigpXG4gICAgICAgIH0sXG4gICAgICAgIG9uRW50ZXJCYWNrOiBmdW5jdGlvbiBvbkVudGVyQmFjayhzZWxmKSB7Ly9jb25zb2xlLmxvZyhcIm9uRW50ZXJCYWNrLmlzQWN0aXZlOiBcIixzZWxmKVxuICAgICAgICAgIC8vdGhpcy5kb3RzLm9uVW5kb0hlcm9UcmFuc2l0aW9uKClcbiAgICAgICAgfSxcbiAgICAgICAgb25MZWF2ZUJhY2s6IGZ1bmN0aW9uIG9uTGVhdmVCYWNrKHNlbGYpIHsvL2NvbnNvbGUubG9nKFwib25FbnRlckJhY2suaXNBY3RpdmU6IFwiLHNlbGYpXG4gICAgICAgICAgLy90aGlzLmRvdHMub25VbmRvSGVyb1RyYW5zaXRpb24oKVxuICAgICAgICB9IC8vIG9uVXBkYXRlOiAoc2VsZikgPT57XG4gICAgICAgIC8vICAgICAvL2NvbnNvbGUubG9nKFwicHJvZ3Jlc3M6IFwiK3NlbGYucHJvZ3Jlc3MpXG4gICAgICAgIC8vIH1cblxuICAgICAgfSk7XG4gICAgICB0aGlzLiRmb290ZXJfdHJpZ2dlciA9IFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgdHJpZ2dlcjogdGhpcy4kZm9vdGVyLFxuICAgICAgICBzdGFydDogJ3RvcCBib3R0b20nLFxuICAgICAgICBlbmQ6ICdib3R0b20rPTEwIGJvdHRvbScsXG4gICAgICAgIHNjcnViOiB0cnVlLFxuICAgICAgICAvLyBTY3J1YjogR2VuZXJhIGV2ZW50b3MgZW4gdW5hIGZyYW5qYSBtYXMgcXVlIGVuIHVuIHB1bnRvLlxuICAgICAgICAvLyBtYXJrZXJzOiB0cnVlLFxuICAgICAgICBvblRvZ2dsZTogZnVuY3Rpb24gb25Ub2dnbGUoc2VsZikge1xuICAgICAgICAgIGlmIChzZWxmLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRk9PVEVSIEFDVElWRVwiKVxuICAgICAgICAgICAgdGhhdC5GT09URVJfQUNUSVZFID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkZPT1RFUiBOT1QgQUNUSVZFXCIpXG4gICAgICAgICAgICB0aGF0LkZPT1RFUl9BQ1RJVkUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZXZhbF9pbmVydGlhX3Njcm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZhbF9pbmVydGlhX3Njcm9sbChwcm9ncmVzcykge1xuICAgICAgdmFyIGlubmVyRGF0YSA9IHRoaXMuJG1haW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgbmV3SW5uZXJZID0gaW5uZXJEYXRhLnk7XG4gICAgICB0aGlzLnNldHRpbmdzLnNjcm9sbF9wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfZGVsdGEgPSBuZXdJbm5lclkgLSB0aGlzLnNldHRpbmdzLnNjcm9sbF9sYXN0SW5uZXJZO1xuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfbGFzdElubmVyWSA9IG5ld0lubmVyWTtcbiAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX2xpbWl0ZWREZWx0YSA9IFdlYkdMVXRpbHMuY2xhbXAodGhpcy5zZXR0aW5ncy5zY3JvbGxfZGVsdGEsIC0yMCwgMjApOyAvLyBMaW1pdGEgbG9zIHZhbG9yZXMgYSAtMjAgLT4gKzIwXG5cbiAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSA9ICh0aGlzLnNldHRpbmdzLnNjcm9sbF9saW1pdGVkRGVsdGEgLyAyMCkudG9GaXhlZCgzKTsgLy8gUGFzYSBlbCBkZWx0YSBhIC0xIC0+ICsxXG5cbiAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX2ZhY3RvcmREZWx0YSA9IE1hdGguYWJzKHRoaXMuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSkgKyAwOyAvLyBWYWxvcmVzIGFic29sdXRvcyBkZSAwIC0+IDFcblxuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfZGlyZWN0aW9uID0gMTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSA8IDApIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfZGlyZWN0aW9uID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9ldmFsX2Zvb3Rlcl9zY3JvbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2YWxfZm9vdGVyX3Njcm9sbChwcm9ncmVzcykge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihTb2x1dGlvbnMxQXBwLl9ldmFsX2Zvb3Rlcl9zY3JvbGwpOiBcIitwcm9ncmVzcylcbiAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX2Zvb3Rlcl9wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgdGhpcy5zZXR0aW5ncy5tb3JwaGluZ1Byb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9ldmFsX2hlcm9fc2Nyb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmFsX2hlcm9fc2Nyb2xsKHByb2dyZXNzKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKFNvbHV0aW9uczFBcHAuX2V2YWxfaGVyb19zY3JvbGwpOiBcIitwcm9ncmVzcylcbiAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX2hlcm9fcHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihTb2x1dGlvbnMxQXBwLl9yZXNpemUpIVwiKVxuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuJGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy4kY29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICAgIHRoaXMucmVzcG9uc2l2ZVNjYWxlID0gdGhpcy53aWR0aCAvIHRoaXMuUkVGX1JFU09MVVRJT04ud2lkdGg7XG4gICAgICB0aGlzLmNhbWVyYURpc3RhbmNlID0gdGhpcy5SRUZfQ0FNRVJBX0RJU1RBTkNFICogKHRoaXMuaGVpZ2h0IC8gdGhpcy5SRUZfUkVTT0xVVElPTi5oZWlnaHQpOyAvL2NvbnNvbGUubG9nKFwidGhpcy53aWR0aDogXCIrdGhpcy53aWR0aClcbiAgICAgIC8vY29uc29sZS5sb2coXCJ0aGlzLmhlaWdodDogXCIrdGhpcy5oZWlnaHQpXG5cbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICB0aGlzLmNhbWVyYS5hc3BlY3QgPSB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQ7XG4gICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi56ID0gdGhpcy5jYW1lcmFEaXN0YW5jZTtcbiAgICAgIHRoaXMuY2FtZXJhLmZvdiA9IDIgKiBNYXRoLmF0YW4odGhpcy5oZWlnaHQgLyAyIC8gdGhpcy5jYW1lcmFEaXN0YW5jZSkgKiAoMTgwIC8gTWF0aC5QSSk7IC8vLS1cbiAgICAgIC8vIGNvbnNvbGUubG9nKFwidGhpcy53aWR0aDogXCIrdGhpcy53aWR0aClcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwidGhpcy5oZWlnaHQ6IFwiK3RoaXMuaGVpZ2h0KVxuICAgICAgLy8gY29uc29sZS5sb2coXCJ0aGlzLnJlc3BvbnNpdmVTY2FsZTogXCIrdGhpcy5yZXNwb25zaXZlU2NhbGUpXG4gICAgICAvLyBjb25zb2xlLmxvZyhcInRoaXMuY2FtZXJhLmFzcGVjdDogXCIrdGhpcy5jYW1lcmEuYXNwZWN0KVxuICAgICAgLy8gY29uc29sZS5sb2coXCJ0aGlzLmNhbWVyYS5wb3NpdGlvbi56OiBcIit0aGlzLmNhbWVyYS5wb3NpdGlvbi56KVxuICAgICAgLy8gY29uc29sZS5sb2coXCJ0aGlzLmNhbWVyYS5mb3Y6IFwiK3RoaXMuY2FtZXJhLmZvdilcbiAgICAgIC8vLS1cblxuICAgICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpOyAvLy0tXG5cbiAgICAgIC8qXG4gICAgICBpZih0aGlzLmJhY2tncm91bmQpe1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZC5yZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgKi9cblxuICAgICAgaWYgKHRoaXMuZG90cykge1xuICAgICAgICB0aGlzLmRvdHMucmVzaXplKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlcigpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoU29sdXRpb25zMUFwcC5fcmVuZGVyKTogXCIrdGhpcy5zZXR0aW5ncy5zY3JvbGxfcHJvZ3Jlc3MrXCI6XCIrdGhpcy5zZXR0aW5ncy5zY3JvbGxfZm9vdGVyX3Byb2dyZXNzKVxuICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IHRoaXMuJGNvbnRhaW5lci5vZmZzZXRIZWlnaHQgfHwgdGhpcy53aWR0aCAhPSB0aGlzLiRjb250YWluZXIub2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplKCk7XG4gICAgICB9XG4gICAgICAvKlxuICAgICAgaWYodGhpcy5iYWNrZ3JvdW5kKXtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmQucmVuZGVyKClcbiAgICAgIH1cbiAgICAgICovXG5cblxuICAgICAgaWYgKHRoaXMuZG90cykge1xuICAgICAgICB0aGlzLmRvdHMucmVuZGVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTsgLy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXIuYmluZCh0aGlzKSlcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU29sdXRpb25zMUFwcDtcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgU29sdXRpb25zMUFwcDsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vLyBHU0FQIExpYnJhcnlcbmltcG9ydCBnc2FwIGZyb20gJ2dzYXAnO1xuaW1wb3J0IFNjcm9sbFRyaWdnZXIgZnJvbSAnZ3NhcC9TY3JvbGxUcmlnZ2VyJztcbmdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVHJpZ2dlcik7XG5pbXBvcnQgRHJhd1NWR1BsdWdpbiBmcm9tICcuLi9jbGFzc2VzL0RyYXdTVkdQbHVnaW4ubWluJztcbmdzYXAucmVnaXN0ZXJQbHVnaW4oRHJhd1NWR1BsdWdpbik7IC8vIEltcG9ydCBSZW5kZXJlclxuXG5pbXBvcnQgUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlci5qcyc7IC8vIFdlYmdsXG5cbmltcG9ydCBTb2x1dGlvbnMxQXBwIGZyb20gJy4uL3dlYmdsL3NvbHV0aW9uczEvU29sdXRpb25zMUFwcCc7XG5pbXBvcnQgSG9tZTJBcHBfbSBmcm9tICcuLi93ZWJnbC9ob21lMl9tL0hvbWUyQXBwX20nOyAvLyBVdGlsaXRpZXNcblxuaW1wb3J0IERvbUV2ZW50cyBmcm9tICcuLi9jbGFzc2VzL2RvbUV2ZW50cyc7XG5pbXBvcnQgU3VwZXJTY3JvbGxlciBmcm9tICcuLi9jbGFzc2VzL3N1cGVyU2Nyb2xsZXInO1xuaW1wb3J0IFN1cGVyRHJhZ2dhYmxlIGZyb20gJy4uL2NsYXNzZXMvc3VwZXJEcmFnZ2FibGUnO1xuXG52YXIgUmVuZGVyZXJBSSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlbmRlcmVyKSB7XG4gIF9pbmhlcml0cyhSZW5kZXJlckFJLCBfUmVuZGVyZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUmVuZGVyZXJBSSk7XG5cbiAgZnVuY3Rpb24gUmVuZGVyZXJBSSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVuZGVyZXJBSSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVuZGVyZXJBSSwgW3tcbiAgICBrZXk6IFwic2VsZWN0b3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdG9ycygpIHtcbiAgICAgIC8vIFNlY3Rpb25zXG4gICAgICB0aGlzLiRoZXJvID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmFpX19oZXJvJyk7XG4gICAgICB0aGlzLiRjb250ZW50ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmFpX19jb250ZW50Jyk7IC8vIFNlbGVjdG9yc1xuXG4gICAgICBpZiAodGhpcy4kY29udGVudCkge1xuICAgICAgICB0aGlzLiRjb250ZW50TWVudSA9IHRoaXMuJGNvbnRlbnQucXVlcnlTZWxlY3RvcignLmNhdGVnb3J5Jyk7XG4gICAgICAgIHRoaXMuJGNvbnRlbnRDYXNlcyA9IHRoaXMuJGNvbnRlbnQucXVlcnlTZWxlY3RvcignLmNhc2VzJyk7XG4gICAgICAgIHRoaXMuJGNvbnRlbnRDYXJkcyA9IHRoaXMuJGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhcmQtLWxhcmdlJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGNhbnZhc19haV9zb2x1dGlvbnMxID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignI3dlYmdsX2FpX3NvbHV0aW9uczEnKTtcbiAgICAgIHRoaXMuJGNhbnZhc19haV9zb2x1dGlvbnMxX20gPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcjd2ViZ2xfYWlfc29sdXRpb25zMV9tJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy4kY29udGVudENhcmRzICYmIHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kY29udGVudENhcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5kb21FdmVudHMuYWRkKHRoaXMuJGNvbnRlbnRDYXJkc1tpXSwgJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoYSwgZSwgZWwpIHtcbiAgICAgICAgICAgIF90aGlzLmVudGVyQ2FyZHMoYSwgZSwgZWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZG9tRXZlbnRzLmFkZCh0aGlzLiRjb250ZW50Q2FyZHNbaV0sICdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKGEsIGUsIGVsKSB7XG4gICAgICAgICAgICBfdGhpcy5sZWF2ZUNhcmRzKGEsIGUsIGVsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmVsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZWxvYWQoKSB7XG4gICAgICAvLyB0aGlzLnByZWxvYWREZWxheSA9IDE7XG4gICAgICB0aGlzLnByZWxvYWRJdGVtcyA9IHtcbiAgICAgICAgbWFpbjogW10sXG4gICAgICAgIHNlY29uZGFyeTogW11cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJlZm9yZUVudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZm9yZUVudGVyKCkge1xuICAgICAgLy8gV2ViZ2xcbiAgICAgIGlmICh0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkge1xuICAgICAgICB0aGlzLnNvbHV0aW9uczEgPSBuZXcgU29sdXRpb25zMUFwcCh7XG4gICAgICAgICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgICAgICAgZG9tRWxlbWVudDogdGhpcy4kY2FudmFzX2FpX3NvbHV0aW9uczEsXG4gICAgICAgICAgZG90Q29sb3I6ICcjMDA3RUZGJ1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc29sdXRpb25zMV9tID0gbmV3IEhvbWUyQXBwX20oe1xuICAgICAgICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgICAgICAgIGRvbUVsZW1lbnQ6IHRoaXMuJGNhbnZhc19haV9zb2x1dGlvbnMxX20sXG4gICAgICAgICAgZG90Q29sb3I6ICcjMDA3RUZGJyxcbiAgICAgICAgICBpbmNyX3JhZGlvOiAxMlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW50ZXIoKSB7XG4gICAgICAvLyBTdGFydCBmdW5jdGlvbnNcbiAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgdGhpcy5pbml0UGluQ2F0ZWdvcmllc01lbnUoKTtcbiAgICAgICAgdGhpcy5pbml0VXBkYXRlQ2F0ZWdvcmllc01lbnUoKTtcbiAgICAgICAgdGhpcy5pbml0TW92ZVdlYkdMQ2FudmFzKCk7XG4gICAgICAgIHRoaXMuaW5pdFBhcmFsbGF4Q2FyZHMoKTsgLy8gV2ViR0xcblxuICAgICAgICB0aGlzLnNvbHV0aW9uczEuaW5pdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbml0RHJhZ2dhYmxlTW9iaWxlKCk7IC8vIFdlYkdMXG5cbiAgICAgICAgdGhpcy5zb2x1dGlvbnMxX20uaW5pdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0TW92ZVdlYkdMQ2FudmFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRNb3ZlV2ViR0xDYW52YXMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gTW92ZSBjYW52YXMgc28gaXQgc3RheSBmaXhlZFxuICAgICAgdGhpcy5fY2FudmFzUGluID0gU2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xuICAgICAgICB0cmlnZ2VyOiB0aGlzLiRpbm5lcixcbiAgICAgICAgc3RhcnQ6ICd0b3AgdG9wJyxcbiAgICAgICAgZW5kOiAnYm90dG9tIGJvdHRvbScsXG4gICAgICAgIHNjcnViOiB0cnVlLFxuICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoc2VsZikge1xuICAgICAgICAgIF90aGlzMi5tb3ZlV2ViR0xDYW52YXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdmVXZWJHTENhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlV2ViR0xDYW52YXMoKSB7XG4gICAgICAvLyBJdHMgY2FsbGVkIGZyb20gU2Nyb2xsVHJpZ2dlciBvblVwZGF0ZSBhbmQgb24gUmVzaXplIGNhbGxiYWNrc1xuICAgICAgdmFyIF9vZmZzZXQyID0gdGhpcy4kaW5uZXIub2Zmc2V0SGVpZ2h0IC0gdGhpcy4kY2FudmFzX2FpX3NvbHV0aW9uczEub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICBnc2FwLnNldCh0aGlzLiRjYW52YXNfYWlfc29sdXRpb25zMSwge1xuICAgICAgICB5OiBfb2Zmc2V0MiAqIHRoaXMuX2NhbnZhc1Bpbi5wcm9ncmVzcyArICdweCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0UGluQ2F0ZWdvcmllc01lbnVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFBpbkNhdGVnb3JpZXNNZW51KCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX29mZnNldCA9IDA7XG4gICAgICB0aGlzLl9waW5DYXRlZ29yaWVzID0gU2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xuICAgICAgICB0cmlnZ2VyOiB0aGlzLiRjb250ZW50Q2FzZXMsXG4gICAgICAgIHN0YXJ0OiAndG9wIDUwJScsXG4gICAgICAgIGVuZDogJ2JvdHRvbSBib3R0b20nLFxuICAgICAgICBzY3J1YjogdHJ1ZSxcbiAgICAgICAgb25SZWZyZXNoOiBmdW5jdGlvbiBvblJlZnJlc2goc2VsZikge1xuICAgICAgICAgIF90aGlzMy5fb2Zmc2V0ID0gc2VsZi5lbmQgLSBzZWxmLnN0YXJ0O1xuICAgICAgICB9LFxuICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoc2VsZikge1xuICAgICAgICAgIGdzYXAuc2V0KF90aGlzMy4kY29udGVudE1lbnUsIHtcbiAgICAgICAgICAgIHk6IHNlbGYucHJvZ3Jlc3MgKiBfdGhpczMuX29mZnNldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFVwZGF0ZUNhdGVnb3JpZXNNZW51XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRVcGRhdGVDYXRlZ29yaWVzTWVudSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAvLyBTZWxlY3RvcnNcbiAgICAgIHRoaXMuJGNvbnRlbnRNZW51TGlua3MgPSB0aGlzLiRjb250ZW50TWVudS5xdWVyeVNlbGVjdG9yQWxsKCdhJyk7XG4gICAgICB0aGlzLiRjb250ZW50TWVudUNpcmNsZXMgPSB0aGlzLiRjb250ZW50TWVudS5xdWVyeVNlbGVjdG9yQWxsKCcuaWNvLS1jaXJjbGUnKTtcbiAgICAgIHRoaXMuJGNvbnRlbnRNZW51QXJyb3dzID0gdGhpcy4kY29udGVudE1lbnUucXVlcnlTZWxlY3RvckFsbCgnLmljby0tYXJyb3cnKTsgLy8gU2V0XG5cbiAgICAgIGdzYXAuc2V0KHRoaXMuJGNvbnRlbnRNZW51TGlua3MsIHtcbiAgICAgICAgb3BhY2l0eTogMC40XG4gICAgICB9KTtcbiAgICAgIGdzYXAuc2V0KHRoaXMuJGNvbnRlbnRNZW51Q2lyY2xlcywge1xuICAgICAgICBkcmF3U1ZHOiAwXG4gICAgICB9KTtcbiAgICAgIHZhciAkY2FzZXMgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FzZXNfX2l0ZW0nKTtcbiAgICAgIHRoaXMuX3NlY3Rpb25zID0gW107XG4gICAgICAkY2FzZXMuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGluZGV4LCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBfY2FzZVRyaWdnZXIgPSBTY3JvbGxUcmlnZ2VyLmNyZWF0ZSh7XG4gICAgICAgICAgdHJpZ2dlcjogZWwsXG4gICAgICAgICAgc3RhcnQ6ICd0b3AgNTAlJyxcbiAgICAgICAgICBlbmQ6ICdib3R0b20gNTAlJyxcbiAgICAgICAgICBzY3J1YjogdHJ1ZSxcbiAgICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoc2VsZikge1xuICAgICAgICAgICAgZ3NhcC5zZXQoX3RoaXM0LiRjb250ZW50TWVudUNpcmNsZXNbaW5kZXhdLCB7XG4gICAgICAgICAgICAgIGRyYXdTVkc6IHNlbGYucHJvZ3Jlc3MgKiAxMDAgKyAnJSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25FbnRlcjogZnVuY3Rpb24gb25FbnRlcihzZWxmKSB7XG4gICAgICAgICAgICBnc2FwLnNldChfdGhpczQuJGNvbnRlbnRNZW51Q2lyY2xlc1tpbmRleF0sIHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnc2FwLnRvKF90aGlzNC4kY29udGVudE1lbnVDaXJjbGVzW2luZGV4XSwge1xuICAgICAgICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDAuNSxcbiAgICAgICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdzYXAudG8oX3RoaXM0LiRjb250ZW50TWVudUFycm93c1tpbmRleF0sIHtcbiAgICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMC41LFxuICAgICAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3NhcC50byhfdGhpczQuJGNvbnRlbnRNZW51TGlua3NbaW5kZXhdLCB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjUsXG4gICAgICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkVudGVyQmFjazogZnVuY3Rpb24gb25FbnRlckJhY2soKSB7XG4gICAgICAgICAgICBnc2FwLnRvKF90aGlzNC4kY29udGVudE1lbnVBcnJvd3NbaW5kZXhdLCB7XG4gICAgICAgICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDAuNSxcbiAgICAgICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdzYXAudG8oX3RoaXM0LiRjb250ZW50TWVudUNpcmNsZXNbaW5kZXhdLCB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjUsXG4gICAgICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnc2FwLnRvKF90aGlzNC4kY29udGVudE1lbnVMaW5rc1tpbmRleF0sIHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDAuNSxcbiAgICAgICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uTGVhdmU6IGZ1bmN0aW9uIG9uTGVhdmUoKSB7XG4gICAgICAgICAgICBnc2FwLnRvKF90aGlzNC4kY29udGVudE1lbnVMaW5rc1tpbmRleF0sIHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC40LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMC41LFxuICAgICAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3NhcC50byhfdGhpczQuJGNvbnRlbnRNZW51Q2lyY2xlc1tpbmRleF0sIHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC4wMDEsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjUsXG4gICAgICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0JyxcbiAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiAnY2VudGVyIGNlbnRlcidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3NhcC50byhfdGhpczQuJGNvbnRlbnRNZW51QXJyb3dzW2luZGV4XSwge1xuICAgICAgICAgICAgICBmaWxsOiAnIzAwMEEzMycsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjUsXG4gICAgICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkxlYXZlQmFjazogZnVuY3Rpb24gb25MZWF2ZUJhY2soKSB7XG4gICAgICAgICAgICBnc2FwLnRvKF90aGlzNC4kY29udGVudE1lbnVMaW5rc1tpbmRleF0sIHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMC40LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMC41LFxuICAgICAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3NhcC50byhfdGhpczQuJGNvbnRlbnRNZW51QXJyb3dzW2luZGV4XSwge1xuICAgICAgICAgICAgICBmaWxsOiAnIzAwMEEzMycsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjUsXG4gICAgICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpczQuX3NlY3Rpb25zLnB1c2goX2Nhc2VUcmlnZ2VyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0RHJhZ2dhYmxlTW9iaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXREcmFnZ2FibGVNb2JpbGUoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgLy8gU2VsZWN0b3JzXG4gICAgICB0aGlzLiRjYXNlc0l0ZW1zID0gdGhpcy4kY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FzZXNfX2l0ZW0nKTtcblxuICAgICAgaWYgKHRoaXMuJGNhc2VzSXRlbXMpIHtcbiAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICAgIF90aGlzNS4kY2FzZXNTbGlkZXJzID0gX3RoaXM1LiRjYXNlc0l0ZW1zW2ldLnF1ZXJ5U2VsZWN0b3IoJy5zbGlkZXInKTtcbiAgICAgICAgICBfdGhpczUuJGNhc2VzU2xpZGVyc0lubmVyID0gX3RoaXM1LiRjYXNlc0l0ZW1zW2ldLnF1ZXJ5U2VsZWN0b3IoJy5zbGlkZXJfX2lubmVyJyk7XG4gICAgICAgICAgX3RoaXM1Ll9jYXNlc0RyYWdnYWJsZSA9IG5ldyBTdXBlckRyYWdnYWJsZSh7XG4gICAgICAgICAgICBlbDogX3RoaXM1LiRjYXNlc0l0ZW1zW2ldLFxuICAgICAgICAgICAgdGFyZ2V0OiBfdGhpczUuJGNhc2VzU2xpZGVycyxcbiAgICAgICAgICAgIHNuYXA6IGZhbHNlLFxuICAgICAgICAgICAgc25hcFRvOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGRvdHM6IGZhbHNlLFxuICAgICAgICAgICAgb25SYWY6IGZ1bmN0aW9uIG9uUmFmKHBlcmNlbnQsIHByb2dyZXNzLCBwcm9ncmVzc09yaWdpbikge1xuICAgICAgICAgICAgICBnc2FwLnRvKF90aGlzNS4kY2FzZXNJdGVtc1tpXS5xdWVyeVNlbGVjdG9yKCcuc2xpZGVyX19wcm9ncmVzcycpLmNoaWxkcmVuWzBdLCB7XG4gICAgICAgICAgICAgICAgc2NhbGVYOiBwcm9ncmVzc09yaWdpbiArIHByb2dyZXNzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kY2FzZXNJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIF9sb29wKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRQYXJhbGxheENhcmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRQYXJhbGxheENhcmRzKCkge1xuICAgICAgLy8gU2VsZWN0b3JzXG4gICAgICB0aGlzLiRjYXJkcyA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXJkJyk7XG5cbiAgICAgIGlmICh0aGlzLiRjYXJkcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJGNhcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5fY2FyZHNUaW1lbGluZSA9IGdzYXAudGltZWxpbmUoe1xuICAgICAgICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgICAgICAgZWFzZTogJ25vbmUnLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjcm9sbFRyaWdnZXI6IHtcbiAgICAgICAgICAgICAgdHJpZ2dlcjogdGhpcy4kY2FyZHNbaV0sXG4gICAgICAgICAgICAgIHN0YXJ0OiAndG9wIGJvdHRvbScsXG4gICAgICAgICAgICAgIGVuZDogJ2JvdHRvbSB0b3AnLFxuICAgICAgICAgICAgICBzY3J1YjogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5fY2FyZHNUaW1lbGluZS5mcm9tVG8odGhpcy4kY2FyZHNbaV0ucXVlcnlTZWxlY3RvcignLmJhY2tncm91bmQnKS5jaGlsZHJlblswXSwge1xuICAgICAgICAgICAgeTogJy0xMDBweCcsXG4gICAgICAgICAgICBzY2FsZTogMS4xXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeTogJzEwMHB4JyxcbiAgICAgICAgICAgIHNjYWxlOiAxXG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhZigpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICB9LCB7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgaWYgKHRoaXMuX2Nhc2VzRHJhZ2dhYmxlKSB0aGlzLl9jYXNlc0RyYWdnYWJsZS5yZXNpemUoKTsgLy8gV2ViZ2xcblxuICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB7XG4gICAgICAgIGlmICh0aGlzLnNvbHV0aW9uczEpIHRoaXMuc29sdXRpb25zMS5vblJlc2l6ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZWF2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZWF2ZSgpIHtcbiAgICAgIGlmICh0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkge1xuICAgICAgICB0aGlzLnNvbHV0aW9uczEua2lsbCgpO1xuICAgICAgICB0aGlzLnNvbHV0aW9uczEgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zb2x1dGlvbnMxX20ua2lsbCgpO1xuICAgICAgICB0aGlzLnNvbHV0aW9uczFfbSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlbmRlcmVyQUk7XG59KFJlbmRlcmVyKTsgLy8gRG9uJ3QgZm9yZ2V0IHRvIGV4cG9ydCB5b3VyIHJlbmRlcmVyXG5cblxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyZXJBSTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vLyBHU0FQIExpYnJhcnlcbmltcG9ydCBnc2FwIGZyb20gJ2dzYXAnO1xuaW1wb3J0IFNjcm9sbFRyaWdnZXIgZnJvbSAnZ3NhcC9TY3JvbGxUcmlnZ2VyJztcbmdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVHJpZ2dlcik7XG5pbXBvcnQgRHJhd1NWR1BsdWdpbiBmcm9tICcuLi9jbGFzc2VzL0RyYXdTVkdQbHVnaW4ubWluJztcbmdzYXAucmVnaXN0ZXJQbHVnaW4oRHJhd1NWR1BsdWdpbik7IC8vIEltcG9ydCBSZW5kZXJlclxuXG5pbXBvcnQgUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlci5qcyc7IC8vIFdlYmdsXG5cbmltcG9ydCBTb2x1dGlvbnMxQXBwIGZyb20gJy4uL3dlYmdsL3NvbHV0aW9uczEvU29sdXRpb25zMUFwcCc7XG5pbXBvcnQgSG9tZTJBcHBfbSBmcm9tICcuLi93ZWJnbC9ob21lMl9tL0hvbWUyQXBwX20nOyAvLyBVdGlsaXRpZXNcblxuaW1wb3J0IERvbUV2ZW50cyBmcm9tICcuLi9jbGFzc2VzL2RvbUV2ZW50cyc7XG5pbXBvcnQgU3VwZXJTY3JvbGxlciBmcm9tICcuLi9jbGFzc2VzL3N1cGVyU2Nyb2xsZXInO1xuaW1wb3J0IFN1cGVyRHJhZ2dhYmxlIGZyb20gJy4uL2NsYXNzZXMvc3VwZXJEcmFnZ2FibGUnO1xuXG52YXIgUmVuZGVyZXJEYXRhID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVuZGVyZXIpIHtcbiAgX2luaGVyaXRzKFJlbmRlcmVyRGF0YSwgX1JlbmRlcmVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFJlbmRlcmVyRGF0YSk7XG5cbiAgZnVuY3Rpb24gUmVuZGVyZXJEYXRhKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZW5kZXJlckRhdGEpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlbmRlcmVyRGF0YSwgW3tcbiAgICBrZXk6IFwic2VsZWN0b3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdG9ycygpIHtcbiAgICAgIC8vIFNlY3Rpb25zXG4gICAgICB0aGlzLiRoZXJvID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLmRhdGFfX2hlcm8nKTtcbiAgICAgIHRoaXMuJGNvbnRlbnQgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcuZGF0YV9fY29udGVudCcpOyAvLyBTZWxlY3RvcnNcblxuICAgICAgaWYgKHRoaXMuJGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy4kY29udGVudE1lbnUgPSB0aGlzLiRjb250ZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYXRlZ29yeScpO1xuICAgICAgICB0aGlzLiRjb250ZW50Q2FzZXMgPSB0aGlzLiRjb250ZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYXNlcycpO1xuICAgICAgICB0aGlzLiRjb250ZW50Q2FyZHMgPSB0aGlzLiRjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXJkLS1sYXJnZScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRjYW52YXNfZGF0YV9zb2x1dGlvbnMxID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignI3dlYmdsX2RhdGFfc29sdXRpb25zMScpO1xuICAgICAgdGhpcy4kY2FudmFzX2RhdGFfc29sdXRpb25zMV9tID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignI3dlYmdsX2RhdGFfc29sdXRpb25zMV9tJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy4kY29udGVudENhcmRzICYmIHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kY29udGVudENhcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5kb21FdmVudHMuYWRkKHRoaXMuJGNvbnRlbnRDYXJkc1tpXSwgJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoYSwgZSwgZWwpIHtcbiAgICAgICAgICAgIF90aGlzLmVudGVyQ2FyZHMoYSwgZSwgZWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZG9tRXZlbnRzLmFkZCh0aGlzLiRjb250ZW50Q2FyZHNbaV0sICdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKGEsIGUsIGVsKSB7XG4gICAgICAgICAgICBfdGhpcy5sZWF2ZUNhcmRzKGEsIGUsIGVsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmVsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZWxvYWQoKSB7XG4gICAgICAvLyB0aGlzLnByZWxvYWREZWxheSA9IDE7XG4gICAgICB0aGlzLnByZWxvYWRJdGVtcyA9IHtcbiAgICAgICAgbWFpbjogW10sXG4gICAgICAgIHNlY29uZGFyeTogW11cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJlZm9yZUVudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZm9yZUVudGVyKCkge1xuICAgICAgLy8gV2ViZ2xcbiAgICAgIGlmICh0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkge1xuICAgICAgICB0aGlzLnNvbHV0aW9uczEgPSBuZXcgU29sdXRpb25zMUFwcCh7XG4gICAgICAgICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgICAgICAgZG9tRWxlbWVudDogdGhpcy4kY2FudmFzX2RhdGFfc29sdXRpb25zMSxcbiAgICAgICAgICBkb3RDb2xvcjogJyNlODQzNzEnXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zb2x1dGlvbnMxX20gPSBuZXcgSG9tZTJBcHBfbSh7XG4gICAgICAgICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgICAgICAgZG9tRWxlbWVudDogdGhpcy4kY2FudmFzX2RhdGFfc29sdXRpb25zMV9tLFxuICAgICAgICAgIGRvdENvbG9yOiAnI2U4NDM3MScsXG4gICAgICAgICAgaW5jcl9yYWRpbzogMTJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVudGVyKCkge1xuICAgICAgLy8gU3RhcnQgZnVuY3Rpb25zXG4gICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB7XG4gICAgICAgIHRoaXMuaW5pdFBpbkNhdGVnb3JpZXNNZW51KCk7XG4gICAgICAgIHRoaXMuaW5pdFVwZGF0ZUNhdGVnb3JpZXNNZW51KCk7XG4gICAgICAgIHRoaXMuaW5pdE1vdmVXZWJHTENhbnZhcygpO1xuICAgICAgICB0aGlzLmluaXRQYXJhbGxheENhcmRzKCk7IC8vIFdlYkdMXG5cbiAgICAgICAgdGhpcy5zb2x1dGlvbnMxLmluaXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5pdERyYWdnYWJsZU1vYmlsZSgpOyAvLyBXZWJHTFxuXG4gICAgICAgIHRoaXMuc29sdXRpb25zMV9tLmluaXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdE1vdmVXZWJHTENhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0TW92ZVdlYkdMQ2FudmFzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIE1vdmUgY2FudmFzIHNvIGl0IHN0YXkgZml4ZWRcbiAgICAgIHRoaXMuX2NhbnZhc1BpbiA9IFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgdHJpZ2dlcjogdGhpcy4kaW5uZXIsXG4gICAgICAgIHN0YXJ0OiAndG9wIHRvcCcsXG4gICAgICAgIGVuZDogJ2JvdHRvbSBib3R0b20nLFxuICAgICAgICBzY3J1YjogdHJ1ZSxcbiAgICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKHNlbGYpIHtcbiAgICAgICAgICBfdGhpczIubW92ZVdlYkdMQ2FudmFzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlV2ViR0xDYW52YXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVdlYkdMQ2FudmFzKCkge1xuICAgICAgLy8gSXRzIGNhbGxlZCBmcm9tIFNjcm9sbFRyaWdnZXIgb25VcGRhdGUgYW5kIG9uIFJlc2l6ZSBjYWxsYmFja3NcbiAgICAgIHZhciBfb2Zmc2V0MiA9IHRoaXMuJGlubmVyLm9mZnNldEhlaWdodCAtIHRoaXMuJGNhbnZhc19kYXRhX3NvbHV0aW9uczEub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICBnc2FwLnNldCh0aGlzLiRjYW52YXNfZGF0YV9zb2x1dGlvbnMxLCB7XG4gICAgICAgIHk6IF9vZmZzZXQyICogdGhpcy5fY2FudmFzUGluLnByb2dyZXNzICsgJ3B4J1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRQaW5DYXRlZ29yaWVzTWVudVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0UGluQ2F0ZWdvcmllc01lbnUoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICAgIHRoaXMuX3BpbkNhdGVnb3JpZXMgPSBTY3JvbGxUcmlnZ2VyLmNyZWF0ZSh7XG4gICAgICAgIHRyaWdnZXI6IHRoaXMuJGNvbnRlbnRDYXNlcyxcbiAgICAgICAgc3RhcnQ6ICd0b3AgNTAlJyxcbiAgICAgICAgZW5kOiAnYm90dG9tIGJvdHRvbScsXG4gICAgICAgIHNjcnViOiB0cnVlLFxuICAgICAgICBvblJlZnJlc2g6IGZ1bmN0aW9uIG9uUmVmcmVzaChzZWxmKSB7XG4gICAgICAgICAgX3RoaXMzLl9vZmZzZXQgPSBzZWxmLmVuZCAtIHNlbGYuc3RhcnQ7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShzZWxmKSB7XG4gICAgICAgICAgZ3NhcC5zZXQoX3RoaXMzLiRjb250ZW50TWVudSwge1xuICAgICAgICAgICAgeTogc2VsZi5wcm9ncmVzcyAqIF90aGlzMy5fb2Zmc2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0VXBkYXRlQ2F0ZWdvcmllc01lbnVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFVwZGF0ZUNhdGVnb3JpZXNNZW51KCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIC8vIFNlbGVjdG9yc1xuICAgICAgdGhpcy4kY29udGVudE1lbnVMaW5rcyA9IHRoaXMuJGNvbnRlbnRNZW51LnF1ZXJ5U2VsZWN0b3JBbGwoJ2EnKTtcbiAgICAgIHRoaXMuJGNvbnRlbnRNZW51Q2lyY2xlcyA9IHRoaXMuJGNvbnRlbnRNZW51LnF1ZXJ5U2VsZWN0b3JBbGwoJy5pY28tLWNpcmNsZScpO1xuICAgICAgdGhpcy4kY29udGVudE1lbnVBcnJvd3MgPSB0aGlzLiRjb250ZW50TWVudS5xdWVyeVNlbGVjdG9yQWxsKCcuaWNvLS1hcnJvdycpOyAvLyBTZXRcblxuICAgICAgZ3NhcC5zZXQodGhpcy4kY29udGVudE1lbnVMaW5rcywge1xuICAgICAgICBvcGFjaXR5OiAwLjRcbiAgICAgIH0pO1xuICAgICAgZ3NhcC5zZXQodGhpcy4kY29udGVudE1lbnVDaXJjbGVzLCB7XG4gICAgICAgIGRyYXdTVkc6IDBcbiAgICAgIH0pO1xuICAgICAgdmFyICRjYXNlcyA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXNlc19faXRlbScpO1xuICAgICAgdGhpcy5fc2VjdGlvbnMgPSBbXTtcbiAgICAgICRjYXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaW5kZXgsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF9jYXNlVHJpZ2dlciA9IFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgICB0cmlnZ2VyOiBlbCxcbiAgICAgICAgICBzdGFydDogJ3RvcCA1MCUnLFxuICAgICAgICAgIGVuZDogJ2JvdHRvbSA1MCUnLFxuICAgICAgICAgIHNjcnViOiB0cnVlLFxuICAgICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShzZWxmKSB7XG4gICAgICAgICAgICBnc2FwLnNldChfdGhpczQuJGNvbnRlbnRNZW51Q2lyY2xlc1tpbmRleF0sIHtcbiAgICAgICAgICAgICAgZHJhd1NWRzogc2VsZi5wcm9ncmVzcyAqIDEwMCArICclJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkVudGVyOiBmdW5jdGlvbiBvbkVudGVyKHNlbGYpIHtcbiAgICAgICAgICAgIGdzYXAuc2V0KF90aGlzNC4kY29udGVudE1lbnVDaXJjbGVzW2luZGV4XSwge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdzYXAudG8oX3RoaXM0LiRjb250ZW50TWVudUNpcmNsZXNbaW5kZXhdLCB7XG4gICAgICAgICAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMC41LFxuICAgICAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3NhcC50byhfdGhpczQuJGNvbnRlbnRNZW51QXJyb3dzW2luZGV4XSwge1xuICAgICAgICAgICAgICBmaWxsOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjUsXG4gICAgICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnc2FwLnRvKF90aGlzNC4kY29udGVudE1lbnVMaW5rc1tpbmRleF0sIHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDAuNSxcbiAgICAgICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRW50ZXJCYWNrOiBmdW5jdGlvbiBvbkVudGVyQmFjaygpIHtcbiAgICAgICAgICAgIGdzYXAudG8oX3RoaXM0LiRjb250ZW50TWVudUFycm93c1tpbmRleF0sIHtcbiAgICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMC41LFxuICAgICAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3NhcC50byhfdGhpczQuJGNvbnRlbnRNZW51Q2lyY2xlc1tpbmRleF0sIHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDAuNSxcbiAgICAgICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdzYXAudG8oX3RoaXM0LiRjb250ZW50TWVudUxpbmtzW2luZGV4XSwge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMC41LFxuICAgICAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25MZWF2ZTogZnVuY3Rpb24gb25MZWF2ZSgpIHtcbiAgICAgICAgICAgIGdzYXAudG8oX3RoaXM0LiRjb250ZW50TWVudUxpbmtzW2luZGV4XSwge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAwLjQsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjUsXG4gICAgICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnc2FwLnRvKF90aGlzNC4kY29udGVudE1lbnVDaXJjbGVzW2luZGV4XSwge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAwLjAwMSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDAuNSxcbiAgICAgICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnLFxuICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46ICdjZW50ZXIgY2VudGVyJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnc2FwLnRvKF90aGlzNC4kY29udGVudE1lbnVBcnJvd3NbaW5kZXhdLCB7XG4gICAgICAgICAgICAgIGZpbGw6ICcjMDAwQTMzJyxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDAuNSxcbiAgICAgICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uTGVhdmVCYWNrOiBmdW5jdGlvbiBvbkxlYXZlQmFjaygpIHtcbiAgICAgICAgICAgIGdzYXAudG8oX3RoaXM0LiRjb250ZW50TWVudUxpbmtzW2luZGV4XSwge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAwLjQsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjUsXG4gICAgICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnc2FwLnRvKF90aGlzNC4kY29udGVudE1lbnVBcnJvd3NbaW5kZXhdLCB7XG4gICAgICAgICAgICAgIGZpbGw6ICcjMDAwQTMzJyxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDAuNSxcbiAgICAgICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF90aGlzNC5fc2VjdGlvbnMucHVzaChfY2FzZVRyaWdnZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXREcmFnZ2FibGVNb2JpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdERyYWdnYWJsZU1vYmlsZSgpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAvLyBTZWxlY3RvcnNcbiAgICAgIHRoaXMuJGNhc2VzSXRlbXMgPSB0aGlzLiRjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXNlc19faXRlbScpO1xuXG4gICAgICBpZiAodGhpcy4kY2FzZXNJdGVtcykge1xuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICAgICAgX3RoaXM1LiRjYXNlc1NsaWRlcnMgPSBfdGhpczUuJGNhc2VzSXRlbXNbaV0ucXVlcnlTZWxlY3RvcignLnNsaWRlcicpO1xuICAgICAgICAgIF90aGlzNS4kY2FzZXNTbGlkZXJzSW5uZXIgPSBfdGhpczUuJGNhc2VzSXRlbXNbaV0ucXVlcnlTZWxlY3RvcignLnNsaWRlcl9faW5uZXInKTtcbiAgICAgICAgICBfdGhpczUuX2Nhc2VzRHJhZ2dhYmxlID0gbmV3IFN1cGVyRHJhZ2dhYmxlKHtcbiAgICAgICAgICAgIGVsOiBfdGhpczUuJGNhc2VzSXRlbXNbaV0sXG4gICAgICAgICAgICB0YXJnZXQ6IF90aGlzNS4kY2FzZXNTbGlkZXJzSW5uZXIsXG4gICAgICAgICAgICBzbmFwOiBmYWxzZSxcbiAgICAgICAgICAgIHNuYXBUbzogJ2NlbnRlcicsXG4gICAgICAgICAgICBkb3RzOiBmYWxzZSxcbiAgICAgICAgICAgIG9uUmFmOiBmdW5jdGlvbiBvblJhZihwZXJjZW50LCBwcm9ncmVzcywgcHJvZ3Jlc3NPcmlnaW4pIHtcbiAgICAgICAgICAgICAgZ3NhcC50byhfdGhpczUuJGNhc2VzSXRlbXNbaV0ucXVlcnlTZWxlY3RvcignLnNsaWRlcl9fcHJvZ3Jlc3MnKS5jaGlsZHJlblswXSwge1xuICAgICAgICAgICAgICAgIHNjYWxlWDogcHJvZ3Jlc3NPcmlnaW4gKyBwcm9ncmVzc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJGNhc2VzSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBfbG9vcChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0UGFyYWxsYXhDYXJkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0UGFyYWxsYXhDYXJkcygpIHtcbiAgICAgIC8vIFNlbGVjdG9yc1xuICAgICAgdGhpcy4kY2FyZHMgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FyZCcpO1xuXG4gICAgICBpZiAodGhpcy4kY2FyZHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRjYXJkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuX2NhcmRzVGltZWxpbmUgPSBnc2FwLnRpbWVsaW5lKHtcbiAgICAgICAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgICAgIGVhc2U6ICdub25lJyxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY3JvbGxUcmlnZ2VyOiB7XG4gICAgICAgICAgICAgIHRyaWdnZXI6IHRoaXMuJGNhcmRzW2ldLFxuICAgICAgICAgICAgICBzdGFydDogJ3RvcCBib3R0b20nLFxuICAgICAgICAgICAgICBlbmQ6ICdib3R0b20gdG9wJyxcbiAgICAgICAgICAgICAgc2NydWI6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMuX2NhcmRzVGltZWxpbmUuZnJvbVRvKHRoaXMuJGNhcmRzW2ldLnF1ZXJ5U2VsZWN0b3IoJy5iYWNrZ3JvdW5kJykuY2hpbGRyZW5bMF0sIHtcbiAgICAgICAgICAgIHk6ICctMTAwcHgnLFxuICAgICAgICAgICAgc2NhbGU6IDEuMVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHk6ICcxMDBweCcsXG4gICAgICAgICAgICBzY2FsZTogMVxuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYWYoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIGlmICh0aGlzLl9jYXNlc0RyYWdnYWJsZSkgdGhpcy5fY2FzZXNEcmFnZ2FibGUucmVzaXplKCk7IC8vIFdlYmdsXG5cbiAgICAgIGlmICh0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkge1xuICAgICAgICBpZiAodGhpcy5zb2x1dGlvbnMxKSB0aGlzLnNvbHV0aW9uczEub25SZXNpemUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGVhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVhdmUoKSB7XG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgdGhpcy5zb2x1dGlvbnMxLmtpbGwoKTtcbiAgICAgICAgdGhpcy5zb2x1dGlvbnMxID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc29sdXRpb25zMV9tLmtpbGwoKTtcbiAgICAgICAgdGhpcy5zb2x1dGlvbnMxX20gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZW5kZXJlckRhdGE7XG59KFJlbmRlcmVyKTsgLy8gRG9uJ3QgZm9yZ2V0IHRvIGV4cG9ydCB5b3VyIHJlbmRlcmVyXG5cblxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyZXJEYXRhOyIsIi8qIVxuICogcGF0aHMgMy4yLjZcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDA4LTIwMjAsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgX3N2Z1BhdGhFeHAgPSAvW2FjaGxtcXN0dnpdfCgtP1xcZCpcXC4/XFxkKig/OmVbXFwtK10/XFxkKyk/KVswLTldL2lnLFxuICAgIF9udW1iZXJzRXhwID0gLyg/OigtKT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspPylbMC05XS9pZyxcbiAgICBfc2NpZW50aWZpYyA9IC9bXFwrXFwtXT9cXGQqXFwuP1xcZCtlW1xcK1xcLV0/XFxkKy9pZyxcbiAgICBfc2VsZWN0b3JFeHAgPSAvKF5bI1xcLl1bYS16XXxbYS15XVthLXpdKS9pLFxuICAgIF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcbiAgICBfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG4gICAgX3NpbiA9IE1hdGguc2luLFxuICAgIF9jb3MgPSBNYXRoLmNvcyxcbiAgICBfYWJzID0gTWF0aC5hYnMsXG4gICAgX3NxcnQgPSBNYXRoLnNxcnQsXG4gICAgX2F0YW4yID0gTWF0aC5hdGFuMixcbiAgICBfbGFyZ2VOdW0gPSAxZTgsXG4gICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59LFxuICAgIF9pc051bWJlciA9IGZ1bmN0aW9uIF9pc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufSxcbiAgICBfaXNVbmRlZmluZWQgPSBmdW5jdGlvbiBfaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX3RlbXAgPSB7fSxcbiAgICBfdGVtcDIgPSB7fSxcbiAgICBfcm91bmRpbmdOdW0gPSAxZTUsXG4gICAgX3dyYXBQcm9ncmVzcyA9IGZ1bmN0aW9uIF93cmFwUHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoKHByb2dyZXNzICsgX2xhcmdlTnVtKSAlIDEgKiBfcm91bmRpbmdOdW0pIC8gX3JvdW5kaW5nTnVtIHx8IChwcm9ncmVzcyA8IDAgPyAwIDogMSk7XG59LFxuICAgIC8vaWYgcHJvZ3Jlc3MgbGFuZHMgb24gMSwgdGhlICUgd2lsbCBtYWtlIGl0IDAgd2hpY2ggaXMgd2h5IHdlIHx8IDEsIGJ1dCBub3QgaWYgaXQncyBuZWdhdGl2ZSBiZWNhdXNlIGl0IG1ha2VzIG1vcmUgc2Vuc2UgZm9yIG1vdGlvbiB0byBlbmQgYXQgMCBpbiB0aGF0IGNhc2UuXG5fcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBfcm91bmRpbmdOdW0pIC8gX3JvdW5kaW5nTnVtIHx8IDA7XG59LFxuICAgIF9zcGxpdFNlZ21lbnQgPSBmdW5jdGlvbiBfc3BsaXRTZWdtZW50KHJhd1BhdGgsIHNlZ0luZGV4LCBpLCB0KSB7XG4gIHZhciBzZWdtZW50ID0gcmF3UGF0aFtzZWdJbmRleF0sXG4gICAgICBzaGlmdCA9IHQgPT09IDEgPyA2IDogc3ViZGl2aWRlU2VnbWVudChzZWdtZW50LCBpLCB0KTtcblxuICBpZiAoc2hpZnQgJiYgc2hpZnQgKyBpICsgMiA8IHNlZ21lbnQubGVuZ3RoKSB7XG4gICAgcmF3UGF0aC5zcGxpY2Uoc2VnSW5kZXgsIDAsIHNlZ21lbnQuc2xpY2UoMCwgaSArIHNoaWZ0ICsgMikpO1xuICAgIHNlZ21lbnQuc3BsaWNlKDAsIGkgKyBzaGlmdCk7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn0sXG4gICAgX3JldmVyc2VSYXdQYXRoID0gZnVuY3Rpb24gX3JldmVyc2VSYXdQYXRoKHJhd1BhdGgsIHNraXBPdXRlcikge1xuICB2YXIgaSA9IHJhd1BhdGgubGVuZ3RoO1xuXG4gIGlmICghc2tpcE91dGVyKSB7XG4gICAgcmF3UGF0aC5yZXZlcnNlKCk7XG4gIH1cblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKCFyYXdQYXRoW2ldLnJldmVyc2VkKSB7XG4gICAgICByZXZlcnNlU2VnbWVudChyYXdQYXRoW2ldKTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX2NvcHlNZXRhRGF0YSA9IGZ1bmN0aW9uIF9jb3B5TWV0YURhdGEoc291cmNlLCBjb3B5KSB7XG4gIGNvcHkudG90YWxMZW5ndGggPSBzb3VyY2UudG90YWxMZW5ndGg7XG5cbiAgaWYgKHNvdXJjZS5zYW1wbGVzKSB7XG4gICAgLy9zZWdtZW50XG4gICAgY29weS5zYW1wbGVzID0gc291cmNlLnNhbXBsZXMuc2xpY2UoMCk7XG4gICAgY29weS5sb29rdXAgPSBzb3VyY2UubG9va3VwLnNsaWNlKDApO1xuICAgIGNvcHkubWluTGVuZ3RoID0gc291cmNlLm1pbkxlbmd0aDtcbiAgICBjb3B5LnJlc29sdXRpb24gPSBzb3VyY2UucmVzb2x1dGlvbjtcbiAgfSBlbHNlIHtcbiAgICAvL3Jhd1BhdGhcbiAgICBjb3B5LnRvdGFsUG9pbnRzID0gc291cmNlLnRvdGFsUG9pbnRzO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIC8vcHVzaGVzIGEgbmV3IHNlZ21lbnQgaW50byBhIHJhd1BhdGgsIGJ1dCBpZiBpdHMgc3RhcnRpbmcgdmFsdWVzIG1hdGNoIHRoZSBlbmRpbmcgdmFsdWVzIG9mIHRoZSBsYXN0IHNlZ21lbnQsIGl0J2xsIG1lcmdlIGl0IGludG8gdGhhdCBzYW1lIHNlZ21lbnQgKHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlZ21lbnRzKVxuX2FwcGVuZE9yTWVyZ2UgPSBmdW5jdGlvbiBfYXBwZW5kT3JNZXJnZShyYXdQYXRoLCBzZWdtZW50KSB7XG4gIHZhciBpbmRleCA9IHJhd1BhdGgubGVuZ3RoLFxuICAgICAgcHJldlNlZyA9IHJhd1BhdGhbaW5kZXggLSAxXSB8fCBbXSxcbiAgICAgIGwgPSBwcmV2U2VnLmxlbmd0aDtcblxuICBpZiAoc2VnbWVudFswXSA9PT0gcHJldlNlZ1tsIC0gMl0gJiYgc2VnbWVudFsxXSA9PT0gcHJldlNlZ1tsIC0gMV0pIHtcbiAgICBzZWdtZW50ID0gcHJldlNlZy5jb25jYXQoc2VnbWVudC5zbGljZSgyKSk7XG4gICAgaW5kZXgtLTtcbiAgfVxuXG4gIHJhd1BhdGhbaW5kZXhdID0gc2VnbWVudDtcbn0sXG4gICAgX2Jlc3REaXN0YW5jZTtcbi8qIFRFUk1JTk9MT0dZXG4gLSBSYXdQYXRoIC0gYW4gYXJyYXkgb2YgYXJyYXlzLCBvbmUgZm9yIGVhY2ggU2VnbWVudC4gQSBzaW5nbGUgUmF3UGF0aCBjb3VsZCBoYXZlIG11bHRpcGxlIFwiTVwiIGNvbW1hbmRzLCBkZWZpbmluZyBTZWdtZW50cyAocGF0aHMgYXJlbid0IGFsd2F5cyBjb25uZWN0ZWQpLlxuIC0gU2VnbWVudCAtIGFuIGFycmF5IGNvbnRhaW5pbmcgYSBzZXF1ZW5jZSBvZiBDdWJpYyBCZXppZXIgY29vcmRpbmF0ZXMgaW4gYWx0ZXJuYXRpbmcgeCwgeSwgeCwgeSBmb3JtYXQuIFN0YXJ0aW5nIGFuY2hvciwgdGhlbiBjb250cm9sIHBvaW50IDEsIGNvbnRyb2wgcG9pbnQgMiwgYW5kIGVuZGluZyBhbmNob3IsIHRoZW4gdGhlIG5leHQgY29udHJvbCBwb2ludCAxLCBjb250cm9sIHBvaW50IDIsIGFuY2hvciwgZXRjLiBVc2VzIGxlc3MgbWVtb3J5IHRoYW4gYW4gYXJyYXkgd2l0aCBhIGJ1bmNoIG9mIHt4LCB5fSBwb2ludHMuXG4gLSBCZXppZXIgLSBhIHNpbmdsZSBjdWJpYyBCZXppZXIgd2l0aCBhIHN0YXJ0aW5nIGFuY2hvciwgdHdvIGNvbnRyb2wgcG9pbnRzLCBhbmQgYW4gZW5kaW5nIGFuY2hvci5cbiAtIHRoZSB2YXJpYWJsZSBcInRcIiBpcyB0eXBpY2FsbHkgdGhlIHBvc2l0aW9uIGFsb25nIGFuIGluZGl2aWR1YWwgQmV6aWVyIHBhdGggKHRpbWUpIGFuZCBpdCdzIE5PVCBsaW5lYXIsIG1lYW5pbmcgaXQgY291bGQgYWNjZWxlcmF0ZS9kZWNlbGVyYXRlIGJhc2VkIG9uIHRoZSBjb250cm9sIHBvaW50cyB3aGVyZWFzIHRoZSBcInBcIiBvciBcInByb2dyZXNzXCIgdmFsdWUgaXMgbGluZWFybHkgbWFwcGVkIHRvIHRoZSB3aG9sZSBwYXRoLCBzbyBpdCBzaG91bGRuJ3QgcmVhbGx5IGFjY2VsZXJhdGUvZGVjZWxlcmF0ZSBiYXNlZCBvbiBjb250cm9sIHBvaW50cy4gU28gYSBwcm9ncmVzcyBvZiAwLjIgd291bGQgYmUgYWxtb3N0IGV4YWN0bHkgMjAlIGFsb25nIHRoZSBwYXRoLiBcInRcIiBpcyBPTkxZIGluIGFuIGluZGl2aWR1YWwgQmV6aWVyIHBpZWNlLlxuICovXG4vL2FjY2VwdHMgYmFzaWMgc2VsZWN0b3IgdGV4dCwgYSBwYXRoIGluc3RhbmNlLCBhIFJhd1BhdGggaW5zdGFuY2UsIG9yIGEgU2VnbWVudCBhbmQgcmV0dXJucyBhIFJhd1BhdGggKG1ha2VzIGl0IGVhc3kgdG8gaG9tb2dlbml6ZSB0aGluZ3MpLiBJZiBhbiBlbGVtZW50IG9yIHNlbGVjdG9yIHRleHQgaXMgcGFzc2VkIGluLCBpdCdsbCBhbHNvIGNhY2hlIHRoZSB2YWx1ZSBzbyB0aGF0IGlmIGl0J3MgcXVlcmllZCBhZ2FpbiwgaXQnbGwganVzdCB0YWtlIHRoZSBwYXRoIGRhdGEgZnJvbSB0aGVyZSBpbnN0ZWFkIG9mIHBhcnNpbmcgaXQgYWxsIG92ZXIgYWdhaW4gKGFzIGxvbmcgYXMgdGhlIHBhdGggZGF0YSBpdHNlbGYgaGFzbid0IGNoYW5nZWQgLSBpdCdsbCBjaGVjaykuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhd1BhdGgodmFsdWUpIHtcbiAgdmFsdWUgPSBfaXNTdHJpbmcodmFsdWUpICYmIF9zZWxlY3RvckV4cC50ZXN0KHZhbHVlKSA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodmFsdWUpIHx8IHZhbHVlIDogdmFsdWU7XG4gIHZhciBlID0gdmFsdWUuZ2V0QXR0cmlidXRlID8gdmFsdWUgOiAwLFxuICAgICAgcmF3UGF0aDtcblxuICBpZiAoZSAmJiAodmFsdWUgPSB2YWx1ZS5nZXRBdHRyaWJ1dGUoXCJkXCIpKSkge1xuICAgIC8vaW1wbGVtZW50cyBjYWNoaW5nXG4gICAgaWYgKCFlLl9nc1BhdGgpIHtcbiAgICAgIGUuX2dzUGF0aCA9IHt9O1xuICAgIH1cblxuICAgIHJhd1BhdGggPSBlLl9nc1BhdGhbdmFsdWVdO1xuICAgIHJldHVybiByYXdQYXRoICYmICFyYXdQYXRoLl9kaXJ0eSA/IHJhd1BhdGggOiBlLl9nc1BhdGhbdmFsdWVdID0gc3RyaW5nVG9SYXdQYXRoKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiAhdmFsdWUgPyBjb25zb2xlLndhcm4oXCJFeHBlY3RpbmcgYSA8cGF0aD4gZWxlbWVudCBvciBhbiBTVkcgcGF0aCBkYXRhIHN0cmluZ1wiKSA6IF9pc1N0cmluZyh2YWx1ZSkgPyBzdHJpbmdUb1Jhd1BhdGgodmFsdWUpIDogX2lzTnVtYmVyKHZhbHVlWzBdKSA/IFt2YWx1ZV0gOiB2YWx1ZTtcbn0gLy9jb3BpZXMgYSBSYXdQYXRoIFdJVEhPVVQgdGhlIGxlbmd0aCBtZXRhIGRhdGEgKGZvciBzcGVlZClcblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlSYXdQYXRoKHJhd1BhdGgpIHtcbiAgdmFyIGEgPSBbXSxcbiAgICAgIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgcmF3UGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGFbaV0gPSBfY29weU1ldGFEYXRhKHJhd1BhdGhbaV0sIHJhd1BhdGhbaV0uc2xpY2UoMCkpO1xuICB9XG5cbiAgcmV0dXJuIF9jb3B5TWV0YURhdGEocmF3UGF0aCwgYSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZVNlZ21lbnQoc2VnbWVudCkge1xuICB2YXIgaSA9IDAsXG4gICAgICB5O1xuICBzZWdtZW50LnJldmVyc2UoKTsgLy90aGlzIHdpbGwgaW52ZXJ0IHRoZSBvcmRlciB5LCB4LCB5LCB4IHNvIHdlIG11c3QgZmxpcCBpdCBiYWNrLlxuXG4gIGZvciAoOyBpIDwgc2VnbWVudC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHkgPSBzZWdtZW50W2ldO1xuICAgIHNlZ21lbnRbaV0gPSBzZWdtZW50W2kgKyAxXTtcbiAgICBzZWdtZW50W2kgKyAxXSA9IHk7XG4gIH1cblxuICBzZWdtZW50LnJldmVyc2VkID0gIXNlZ21lbnQucmV2ZXJzZWQ7XG59XG5cbnZhciBfY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIF9jcmVhdGVQYXRoKGUsIGlnbm9yZSkge1xuICB2YXIgcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicGF0aFwiKSxcbiAgICAgIGF0dHIgPSBbXS5zbGljZS5jYWxsKGUuYXR0cmlidXRlcyksXG4gICAgICBpID0gYXR0ci5sZW5ndGgsXG4gICAgICBuYW1lO1xuICBpZ25vcmUgPSBcIixcIiArIGlnbm9yZSArIFwiLFwiO1xuXG4gIHdoaWxlICgtLWkgPiAtMSkge1xuICAgIG5hbWUgPSBhdHRyW2ldLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7IC8vaW4gTWljcm9zb2Z0IEVkZ2UsIGlmIHlvdSBkb24ndCBzZXQgdGhlIGF0dHJpYnV0ZSB3aXRoIGEgbG93ZXJjYXNlIG5hbWUsIGl0IGRvZXNuJ3QgcmVuZGVyIGNvcnJlY3RseSEgU3VwZXIgd2VpcmQuXG5cbiAgICBpZiAoaWdub3JlLmluZGV4T2YoXCIsXCIgKyBuYW1lICsgXCIsXCIpIDwgMCkge1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBuYW1lLCBhdHRyW2ldLm5vZGVWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59LFxuICAgIF90eXBlQXR0cnMgPSB7XG4gIHJlY3Q6IFwicngscnkseCx5LHdpZHRoLGhlaWdodFwiLFxuICBjaXJjbGU6IFwicixjeCxjeVwiLFxuICBlbGxpcHNlOiBcInJ4LHJ5LGN4LGN5XCIsXG4gIGxpbmU6IFwieDEseDIseTEseTJcIlxufSxcbiAgICBfYXR0clRvT2JqID0gZnVuY3Rpb24gX2F0dHJUb09iaihlLCBhdHRycykge1xuICB2YXIgcHJvcHMgPSBhdHRycyA/IGF0dHJzLnNwbGl0KFwiLFwiKSA6IFtdLFxuICAgICAgb2JqID0ge30sXG4gICAgICBpID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgtLWkgPiAtMSkge1xuICAgIG9ialtwcm9wc1tpXV0gPSArZS5nZXRBdHRyaWJ1dGUocHJvcHNbaV0pIHx8IDA7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTsgLy9jb252ZXJ0cyBhbiBTVkcgc2hhcGUgbGlrZSA8Y2lyY2xlPiwgPHJlY3Q+LCA8cG9seWdvbj4sIDxwb2x5bGluZT4sIDxlbGxpcHNlPiwgZXRjLiB0byBhIDxwYXRoPiwgc3dhcHBpbmcgaXQgaW4gYW5kIGNvcHlpbmcgdGhlIGF0dHJpYnV0ZXMgdG8gbWF0Y2guXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb1BhdGgoZWxlbWVudCwgc3dhcCkge1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgY2lyYyA9IDAuNTUyMjg0NzQ5ODMxLFxuICAgICAgZGF0YSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcixcbiAgICAgIHJ5LFxuICAgICAgcGF0aCxcbiAgICAgIHJjaXJjLFxuICAgICAgcnljaXJjLFxuICAgICAgcG9pbnRzLFxuICAgICAgdyxcbiAgICAgIGgsXG4gICAgICB4MixcbiAgICAgIHgzLFxuICAgICAgeDQsXG4gICAgICB4NSxcbiAgICAgIHg2LFxuICAgICAgeTIsXG4gICAgICB5MyxcbiAgICAgIHk0LFxuICAgICAgeTUsXG4gICAgICB5NixcbiAgICAgIGF0dHI7XG5cbiAgaWYgKHR5cGUgPT09IFwicGF0aFwiIHx8ICFlbGVtZW50LmdldEJCb3gpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHBhdGggPSBfY3JlYXRlUGF0aChlbGVtZW50LCBcIngseSx3aWR0aCxoZWlnaHQsY3gsY3kscngscnkscix4MSx4Mix5MSx5Mixwb2ludHNcIik7XG4gIGF0dHIgPSBfYXR0clRvT2JqKGVsZW1lbnQsIF90eXBlQXR0cnNbdHlwZV0pO1xuXG4gIGlmICh0eXBlID09PSBcInJlY3RcIikge1xuICAgIHIgPSBhdHRyLnJ4O1xuICAgIHJ5ID0gYXR0ci5yeTtcbiAgICB4ID0gYXR0ci54O1xuICAgIHkgPSBhdHRyLnk7XG4gICAgdyA9IGF0dHIud2lkdGggLSByICogMjtcbiAgICBoID0gYXR0ci5oZWlnaHQgLSByeSAqIDI7XG5cbiAgICBpZiAociB8fCByeSkge1xuICAgICAgLy9pZiB0aGVyZSBhcmUgcm91bmRlZCBjb3JuZXJzLCByZW5kZXIgY3ViaWMgYmV6aWVyc1xuICAgICAgeDIgPSB4ICsgciAqICgxIC0gY2lyYyk7XG4gICAgICB4MyA9IHggKyByO1xuICAgICAgeDQgPSB4MyArIHc7XG4gICAgICB4NSA9IHg0ICsgciAqIGNpcmM7XG4gICAgICB4NiA9IHg0ICsgcjtcbiAgICAgIHkyID0geSArIHJ5ICogKDEgLSBjaXJjKTtcbiAgICAgIHkzID0geSArIHJ5O1xuICAgICAgeTQgPSB5MyArIGg7XG4gICAgICB5NSA9IHk0ICsgcnkgKiBjaXJjO1xuICAgICAgeTYgPSB5NCArIHJ5O1xuICAgICAgZGF0YSA9IFwiTVwiICsgeDYgKyBcIixcIiArIHkzICsgXCIgVlwiICsgeTQgKyBcIiBDXCIgKyBbeDYsIHk1LCB4NSwgeTYsIHg0LCB5NiwgeDQgLSAoeDQgLSB4MykgLyAzLCB5NiwgeDMgKyAoeDQgLSB4MykgLyAzLCB5NiwgeDMsIHk2LCB4MiwgeTYsIHgsIHk1LCB4LCB5NCwgeCwgeTQgLSAoeTQgLSB5MykgLyAzLCB4LCB5MyArICh5NCAtIHkzKSAvIDMsIHgsIHkzLCB4LCB5MiwgeDIsIHksIHgzLCB5LCB4MyArICh4NCAtIHgzKSAvIDMsIHksIHg0IC0gKHg0IC0geDMpIC8gMywgeSwgeDQsIHksIHg1LCB5LCB4NiwgeTIsIHg2LCB5M10uam9pbihcIixcIikgKyBcInpcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IFwiTVwiICsgKHggKyB3KSArIFwiLFwiICsgeSArIFwiIHZcIiArIGggKyBcIiBoXCIgKyAtdyArIFwiIHZcIiArIC1oICsgXCIgaFwiICsgdyArIFwielwiO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSBcImNpcmNsZVwiIHx8IHR5cGUgPT09IFwiZWxsaXBzZVwiKSB7XG4gICAgaWYgKHR5cGUgPT09IFwiY2lyY2xlXCIpIHtcbiAgICAgIHIgPSByeSA9IGF0dHIucjtcbiAgICAgIHJ5Y2lyYyA9IHIgKiBjaXJjO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gYXR0ci5yeDtcbiAgICAgIHJ5ID0gYXR0ci5yeTtcbiAgICAgIHJ5Y2lyYyA9IHJ5ICogY2lyYztcbiAgICB9XG5cbiAgICB4ID0gYXR0ci5jeDtcbiAgICB5ID0gYXR0ci5jeTtcbiAgICByY2lyYyA9IHIgKiBjaXJjO1xuICAgIGRhdGEgPSBcIk1cIiArICh4ICsgcikgKyBcIixcIiArIHkgKyBcIiBDXCIgKyBbeCArIHIsIHkgKyByeWNpcmMsIHggKyByY2lyYywgeSArIHJ5LCB4LCB5ICsgcnksIHggLSByY2lyYywgeSArIHJ5LCB4IC0gciwgeSArIHJ5Y2lyYywgeCAtIHIsIHksIHggLSByLCB5IC0gcnljaXJjLCB4IC0gcmNpcmMsIHkgLSByeSwgeCwgeSAtIHJ5LCB4ICsgcmNpcmMsIHkgLSByeSwgeCArIHIsIHkgLSByeWNpcmMsIHggKyByLCB5XS5qb2luKFwiLFwiKSArIFwielwiO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibGluZVwiKSB7XG4gICAgZGF0YSA9IFwiTVwiICsgYXR0ci54MSArIFwiLFwiICsgYXR0ci55MSArIFwiIExcIiArIGF0dHIueDIgKyBcIixcIiArIGF0dHIueTI7IC8vcHJldmlvdXNseSwgd2UganVzdCBjb252ZXJ0ZWQgdG8gXCJNeCx5IEx4LHlcIiBidXQgU2FmYXJpIGhhcyBidWdzIHRoYXQgY2F1c2UgdGhhdCBub3QgdG8gcmVuZGVyIHByb3Blcmx5IHdoZW4gdXNpbmcgYSBzdHJva2UtZGFzaGFycmF5IHRoYXQncyBub3QgZnVsbHkgdmlzaWJsZSEgVXNpbmcgYSBjdWJpYyBiZXppZXIgZml4ZXMgdGhhdCBpc3N1ZS5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBcInBvbHlsaW5lXCIgfHwgdHlwZSA9PT0gXCJwb2x5Z29uXCIpIHtcbiAgICBwb2ludHMgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJwb2ludHNcIikgKyBcIlwiKS5tYXRjaChfbnVtYmVyc0V4cCkgfHwgW107XG4gICAgeCA9IHBvaW50cy5zaGlmdCgpO1xuICAgIHkgPSBwb2ludHMuc2hpZnQoKTtcbiAgICBkYXRhID0gXCJNXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIgTFwiICsgcG9pbnRzLmpvaW4oXCIsXCIpO1xuXG4gICAgaWYgKHR5cGUgPT09IFwicG9seWdvblwiKSB7XG4gICAgICBkYXRhICs9IFwiLFwiICsgeCArIFwiLFwiICsgeSArIFwielwiO1xuICAgIH1cbiAgfVxuXG4gIHBhdGguc2V0QXR0cmlidXRlKFwiZFwiLCByYXdQYXRoVG9TdHJpbmcocGF0aC5fZ3NSYXdQYXRoID0gc3RyaW5nVG9SYXdQYXRoKGRhdGEpKSk7XG5cbiAgaWYgKHN3YXAgJiYgZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShwYXRoLCBlbGVtZW50KTtcbiAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gcGF0aDtcbn0gLy9yZXR1cm5zIHRoZSByb3RhdGlvbiAoaW4gZGVncmVlcykgYXQgYSBwYXJ0aWN1bGFyIHByb2dyZXNzIG9uIGEgcmF3UGF0aCAodGhlIHNsb3BlIG9mIHRoZSB0YW5nZW50KVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um90YXRpb25BdFByb2dyZXNzKHJhd1BhdGgsIHByb2dyZXNzKSB7XG4gIHZhciBkID0gZ2V0UHJvZ3Jlc3NEYXRhKHJhd1BhdGgsIHByb2dyZXNzID49IDEgPyAxIC0gMWUtOSA6IHByb2dyZXNzID8gcHJvZ3Jlc3MgOiAxZS05KTtcbiAgcmV0dXJuIGdldFJvdGF0aW9uQXRCZXppZXJUKGQuc2VnbWVudCwgZC5pLCBkLnQpO1xufVxuXG5mdW5jdGlvbiBnZXRSb3RhdGlvbkF0QmV6aWVyVChzZWdtZW50LCBpLCB0KSB7XG4gIHZhciBhID0gc2VnbWVudFtpXSxcbiAgICAgIGIgPSBzZWdtZW50W2kgKyAyXSxcbiAgICAgIGMgPSBzZWdtZW50W2kgKyA0XSxcbiAgICAgIHg7XG4gIGEgKz0gKGIgLSBhKSAqIHQ7XG4gIGIgKz0gKGMgLSBiKSAqIHQ7XG4gIGEgKz0gKGIgLSBhKSAqIHQ7XG4gIHggPSBiICsgKGMgKyAoc2VnbWVudFtpICsgNl0gLSBjKSAqIHQgLSBiKSAqIHQgLSBhO1xuICBhID0gc2VnbWVudFtpICsgMV07XG4gIGIgPSBzZWdtZW50W2kgKyAzXTtcbiAgYyA9IHNlZ21lbnRbaSArIDVdO1xuICBhICs9IChiIC0gYSkgKiB0O1xuICBiICs9IChjIC0gYikgKiB0O1xuICBhICs9IChiIC0gYSkgKiB0O1xuICByZXR1cm4gX3JvdW5kKF9hdGFuMihiICsgKGMgKyAoc2VnbWVudFtpICsgN10gLSBjKSAqIHQgLSBiKSAqIHQgLSBhLCB4KSAqIF9SQUQyREVHKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlUmF3UGF0aChyYXdQYXRoLCBzdGFydCwgZW5kKSB7XG4gIGlmIChfaXNVbmRlZmluZWQoZW5kKSkge1xuICAgIGVuZCA9IDE7XG4gIH1cblxuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciByZXZlcnNlID0gc3RhcnQgPiBlbmQsXG4gICAgICBsb29wcyA9IE1hdGgubWF4KDAsIH5+KF9hYnMoZW5kIC0gc3RhcnQpIC0gMWUtOCkpO1xuXG4gIGlmIChyZXZlcnNlKSB7XG4gICAgcmV2ZXJzZSA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHJldmVyc2U7XG4gICAgcmV2ZXJzZSA9IDE7XG4gICAgbG9vcHMgLT0gbG9vcHMgPyAxIDogMDtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kIDwgMCkge1xuICAgIHZhciBvZmZzZXQgPSB+fk1hdGgubWluKHN0YXJ0LCBlbmQpICsgMTtcbiAgICBzdGFydCArPSBvZmZzZXQ7XG4gICAgZW5kICs9IG9mZnNldDtcbiAgfVxuXG4gIHZhciBwYXRoID0gY29weVJhd1BhdGgocmF3UGF0aC50b3RhbExlbmd0aCA/IHJhd1BhdGggOiBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMocmF3UGF0aCkpLFxuICAgICAgd3JhcCA9IGVuZCA+IDEsXG4gICAgICBzID0gZ2V0UHJvZ3Jlc3NEYXRhKHBhdGgsIHN0YXJ0LCBfdGVtcCwgdHJ1ZSksXG4gICAgICBlID0gZ2V0UHJvZ3Jlc3NEYXRhKHBhdGgsIGVuZCwgX3RlbXAyKSxcbiAgICAgIGVTZWcgPSBlLnNlZ21lbnQsXG4gICAgICBzU2VnID0gcy5zZWdtZW50LFxuICAgICAgZVNlZ0luZGV4ID0gZS5zZWdJbmRleCxcbiAgICAgIHNTZWdJbmRleCA9IHMuc2VnSW5kZXgsXG4gICAgICBlaSA9IGUuaSxcbiAgICAgIHNpID0gcy5pLFxuICAgICAgc2FtZVNlZ21lbnQgPSBzU2VnSW5kZXggPT09IGVTZWdJbmRleCxcbiAgICAgIHNhbWVCZXppZXIgPSBlaSA9PT0gc2kgJiYgc2FtZVNlZ21lbnQsXG4gICAgICBpbnZlcnRlZE9yZGVyID0gc2FtZVNlZ21lbnQgJiYgc2kgPiBlaSB8fCBzYW1lQmV6aWVyICYmIHMudCA+IGUudCxcbiAgICAgIHNTaGlmdCxcbiAgICAgIGVTaGlmdCxcbiAgICAgIGksXG4gICAgICBjb3B5LFxuICAgICAgdG90YWxTZWdtZW50cyxcbiAgICAgIGwsXG4gICAgICBqO1xuXG4gIGlmICh3cmFwIHx8IGxvb3BzKSB7XG4gICAgaWYgKF9zcGxpdFNlZ21lbnQocGF0aCwgc1NlZ0luZGV4LCBzaSwgcy50KSkge1xuICAgICAgc1NoaWZ0ID0gMTtcbiAgICAgIHNTZWdJbmRleCsrO1xuXG4gICAgICBpZiAoc2FtZUJlemllcikge1xuICAgICAgICBpZiAoaW52ZXJ0ZWRPcmRlcikge1xuICAgICAgICAgIGUudCAvPSBzLnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZS50ID0gKGUudCAtIHMudCkgLyAoMSAtIHMudCk7XG4gICAgICAgICAgZVNlZ0luZGV4Kys7XG4gICAgICAgICAgZWkgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNTZWdJbmRleCA8PSBlU2VnSW5kZXggKyAxICYmICFpbnZlcnRlZE9yZGVyKSB7XG4gICAgICAgIGVTZWdJbmRleCsrO1xuXG4gICAgICAgIGlmIChzYW1lU2VnbWVudCkge1xuICAgICAgICAgIGVpIC09IHNpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFlLnQpIHtcbiAgICAgIGVTZWdJbmRleC0tO1xuXG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICBzU2VnSW5kZXgtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9zcGxpdFNlZ21lbnQocGF0aCwgZVNlZ0luZGV4LCBlaSwgZS50KSkge1xuICAgICAgaWYgKGludmVydGVkT3JkZXIgJiYgc1NoaWZ0KSB7XG4gICAgICAgIHNTZWdJbmRleCsrO1xuICAgICAgfVxuXG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICBlU2VnSW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb3B5ID0gW107XG4gICAgdG90YWxTZWdtZW50cyA9IHBhdGgubGVuZ3RoO1xuICAgIGwgPSAxICsgdG90YWxTZWdtZW50cyAqIGxvb3BzO1xuICAgIGogPSBzU2VnSW5kZXg7XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgZVNlZ0luZGV4ID0gKGVTZWdJbmRleCB8fCB0b3RhbFNlZ21lbnRzKSAtIDE7XG4gICAgICBsICs9ICh0b3RhbFNlZ21lbnRzIC0gZVNlZ0luZGV4ICsgc1NlZ0luZGV4KSAlIHRvdGFsU2VnbWVudHM7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgX2FwcGVuZE9yTWVyZ2UoY29weSwgcGF0aFtqXSk7XG5cbiAgICAgICAgaiA9IChqIHx8IHRvdGFsU2VnbWVudHMpIC0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbCArPSAodG90YWxTZWdtZW50cyAtIHNTZWdJbmRleCArIGVTZWdJbmRleCkgJSB0b3RhbFNlZ21lbnRzO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIF9hcHBlbmRPck1lcmdlKGNvcHksIHBhdGhbaisrICUgdG90YWxTZWdtZW50c10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhdGggPSBjb3B5O1xuICB9IGVsc2Uge1xuICAgIGVTaGlmdCA9IGUudCA9PT0gMSA/IDYgOiBzdWJkaXZpZGVTZWdtZW50KGVTZWcsIGVpLCBlLnQpO1xuXG4gICAgaWYgKHN0YXJ0ICE9PSBlbmQpIHtcbiAgICAgIHNTaGlmdCA9IHN1YmRpdmlkZVNlZ21lbnQoc1NlZywgc2ksIHNhbWVCZXppZXIgPyBzLnQgLyBlLnQgOiBzLnQpO1xuXG4gICAgICBpZiAoc2FtZVNlZ21lbnQpIHtcbiAgICAgICAgZVNoaWZ0ICs9IHNTaGlmdDtcbiAgICAgIH1cblxuICAgICAgZVNlZy5zcGxpY2UoZWkgKyBlU2hpZnQgKyAyKTtcblxuICAgICAgaWYgKHNTaGlmdCB8fCBzaSkge1xuICAgICAgICBzU2VnLnNwbGljZSgwLCBzaSArIHNTaGlmdCk7XG4gICAgICB9XG5cbiAgICAgIGkgPSBwYXRoLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAvL2Nob3Agb2ZmIGFueSBleHRyYSBzZWdtZW50c1xuICAgICAgICBpZiAoaSA8IHNTZWdJbmRleCB8fCBpID4gZVNlZ0luZGV4KSB7XG4gICAgICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZVNlZy5hbmdsZSA9IGdldFJvdGF0aW9uQXRCZXppZXJUKGVTZWcsIGVpICsgZVNoaWZ0LCAwKTsgLy9yZWNvcmQgdGhlIHZhbHVlIGJlZm9yZSB3ZSBjaG9wIGJlY2F1c2UgaXQnbGwgYmUgaW1wb3NzaWJsZSB0byBkZXRlcm1pbmUgdGhlIGFuZ2xlIGFmdGVyIGl0cyBsZW5ndGggaXMgMCFcblxuICAgICAgZWkgKz0gZVNoaWZ0O1xuICAgICAgcyA9IGVTZWdbZWldO1xuICAgICAgZSA9IGVTZWdbZWkgKyAxXTtcbiAgICAgIGVTZWcubGVuZ3RoID0gZVNlZy50b3RhbExlbmd0aCA9IDA7XG4gICAgICBlU2VnLnRvdGFsUG9pbnRzID0gcGF0aC50b3RhbFBvaW50cyA9IDg7XG4gICAgICBlU2VnLnB1c2gocywgZSwgcywgZSwgcywgZSwgcywgZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJldmVyc2UpIHtcbiAgICBfcmV2ZXJzZVJhd1BhdGgocGF0aCwgd3JhcCB8fCBsb29wcyk7XG4gIH1cblxuICBwYXRoLnRvdGFsTGVuZ3RoID0gMDtcbiAgcmV0dXJuIHBhdGg7XG59IC8vbWVhc3VyZXMgYSBTZWdtZW50IGFjY29yZGluZyB0byBpdHMgcmVzb2x1dGlvbiAoc28gaWYgc2VnbWVudC5yZXNvbHV0aW9uIGlzIDYsIGZvciBleGFtcGxlLCBpdCdsbCB0YWtlIDYgc2FtcGxlcyBlcXVhbGx5IGFjcm9zcyBlYWNoIEJlemllcikgYW5kIGNyZWF0ZS9wb3B1bGF0ZSBhIFwic2FtcGxlc1wiIGFycmF5IHRoYXQgaGFzIHRoZSBsZW5ndGggdXAgdG8gZWFjaCBvZiB0aG9zZSBzYW1wbGUgcG9pbnRzIChhbHdheXMgaW5jcmVhc2luZyBmcm9tIHRoZSBzdGFydCkgYXMgd2VsbCBhcyBhIFwibG9va3VwXCIgYXJyYXkgdGhhdCdzIGJyb2tlbiB1cCBhY2NvcmRpbmcgdG8gdGhlIHNtYWxsZXN0IGRpc3RhbmNlIGJldHdlZW4gMiBzYW1wbGVzLiBUaGlzIGdpdmVzIHVzIGEgdmVyeSBmYXN0IHdheSBvZiBsb29raW5nIHVwIGEgcHJvZ3Jlc3MgcG9zaXRpb24gcmF0aGVyIHRoYW4gbG9vcGluZyB0aHJvdWdoIGFsbCB0aGUgcG9pbnRzL0JlemllcnMuIFlvdSBjYW4gb3B0aW9uYWxseSBoYXZlIGl0IG9ubHkgbWVhc3VyZSBhIHN1YnNldCwgc3RhcnRpbmcgYXQgc3RhcnRJbmRleCBhbmQgZ29pbmcgZm9yIGEgc3BlY2lmaWMgbnVtYmVyIG9mIGJlemllcnMgKHJlbWVtYmVyLCB0aGVyZSBhcmUgMyB4L3kgcGFpcnMgZWFjaCwgZm9yIGEgdG90YWwgb2YgNiBlbGVtZW50cyBmb3IgZWFjaCBCZXppZXIpLiBJdCB3aWxsIGFsc28gcG9wdWxhdGUgYSBcInRvdGFsTGVuZ3RoXCIgcHJvcGVydHksIGJ1dCB0aGF0J3Mgbm90IGdlbmVyYWxseSBzdXBlciBhY2N1cmF0ZSBiZWNhdXNlIGJ5IGRlZmF1bHQgaXQnbGwgb25seSB0YWtlIDYgc2FtcGxlcyBwZXIgQmV6aWVyLiBCdXQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGl0J3MgcGVyZmVjdGx5IGFkZXF1YXRlIGZvciBtZWFzdXJpbmcgcHJvZ3Jlc3MgdmFsdWVzIGFsb25nIHRoZSBwYXRoLiBJZiB5b3UgbmVlZCBhIG1vcmUgYWNjdXJhdGUgdG90YWxMZW5ndGgsIGVpdGhlciBpbmNyZWFzZSB0aGUgcmVzb2x1dGlvbiBvciB1c2UgdGhlIG1vcmUgYWR2YW5jZWQgYmV6aWVyVG9Qb2ludHMoKSBtZXRob2Qgd2hpY2gga2VlcHMgYWRkaW5nIHBvaW50cyB1bnRpbCB0aGV5IGRvbid0IGRldmlhdGUgYnkgbW9yZSB0aGFuIGEgY2VydGFpbiBwcmVjaXNpb24gdmFsdWUuXG5cbmZ1bmN0aW9uIG1lYXN1cmVTZWdtZW50KHNlZ21lbnQsIHN0YXJ0SW5kZXgsIGJlemllclF0eSkge1xuICBzdGFydEluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xuXG4gIGlmICghc2VnbWVudC5zYW1wbGVzKSB7XG4gICAgc2VnbWVudC5zYW1wbGVzID0gW107XG4gICAgc2VnbWVudC5sb29rdXAgPSBbXTtcbiAgfVxuXG4gIHZhciByZXNvbHV0aW9uID0gfn5zZWdtZW50LnJlc29sdXRpb24gfHwgMTIsXG4gICAgICBpbmMgPSAxIC8gcmVzb2x1dGlvbixcbiAgICAgIGVuZEluZGV4ID0gYmV6aWVyUXR5ID8gc3RhcnRJbmRleCArIGJlemllclF0eSAqIDYgKyAxIDogc2VnbWVudC5sZW5ndGgsXG4gICAgICB4MSA9IHNlZ21lbnRbc3RhcnRJbmRleF0sXG4gICAgICB5MSA9IHNlZ21lbnRbc3RhcnRJbmRleCArIDFdLFxuICAgICAgc2FtcGxlc0luZGV4ID0gc3RhcnRJbmRleCA/IHN0YXJ0SW5kZXggLyA2ICogcmVzb2x1dGlvbiA6IDAsXG4gICAgICBzYW1wbGVzID0gc2VnbWVudC5zYW1wbGVzLFxuICAgICAgbG9va3VwID0gc2VnbWVudC5sb29rdXAsXG4gICAgICBtaW4gPSAoc3RhcnRJbmRleCA/IHNlZ21lbnQubWluTGVuZ3RoIDogX2xhcmdlTnVtKSB8fCBfbGFyZ2VOdW0sXG4gICAgICBwcmV2TGVuZ3RoID0gc2FtcGxlc1tzYW1wbGVzSW5kZXggKyBiZXppZXJRdHkgKiByZXNvbHV0aW9uIC0gMV0sXG4gICAgICBsZW5ndGggPSBzdGFydEluZGV4ID8gc2FtcGxlc1tzYW1wbGVzSW5kZXggLSAxXSA6IDAsXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIHg0LFxuICAgICAgeDMsXG4gICAgICB4MixcbiAgICAgIHhkLFxuICAgICAgeGQxLFxuICAgICAgeTQsXG4gICAgICB5MyxcbiAgICAgIHkyLFxuICAgICAgeWQsXG4gICAgICB5ZDEsXG4gICAgICBpbnYsXG4gICAgICB0LFxuICAgICAgbGVuZ3RoSW5kZXgsXG4gICAgICBsLFxuICAgICAgc2VnTGVuZ3RoO1xuICBzYW1wbGVzLmxlbmd0aCA9IGxvb2t1cC5sZW5ndGggPSAwO1xuXG4gIGZvciAoaiA9IHN0YXJ0SW5kZXggKyAyOyBqIDwgZW5kSW5kZXg7IGogKz0gNikge1xuICAgIHg0ID0gc2VnbWVudFtqICsgNF0gLSB4MTtcbiAgICB4MyA9IHNlZ21lbnRbaiArIDJdIC0geDE7XG4gICAgeDIgPSBzZWdtZW50W2pdIC0geDE7XG4gICAgeTQgPSBzZWdtZW50W2ogKyA1XSAtIHkxO1xuICAgIHkzID0gc2VnbWVudFtqICsgM10gLSB5MTtcbiAgICB5MiA9IHNlZ21lbnRbaiArIDFdIC0geTE7XG4gICAgeGQgPSB4ZDEgPSB5ZCA9IHlkMSA9IDA7XG5cbiAgICBpZiAoX2Ficyh4NCkgPCAxZS01ICYmIF9hYnMoeTQpIDwgMWUtNSAmJiBfYWJzKHgyKSArIF9hYnMoeTIpIDwgMWUtNSkge1xuICAgICAgLy9kdW1wIHBvaW50cyB0aGF0IGFyZSBzdWZmaWNpZW50bHkgY2xvc2UgKGJhc2ljYWxseSByaWdodCBvbiB0b3Agb2YgZWFjaCBvdGhlciwgbWFraW5nIGEgYmV6aWVyIHN1cGVyIHRpbnkgb3IgMCBsZW5ndGgpXG4gICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiA4KSB7XG4gICAgICAgIHNlZ21lbnQuc3BsaWNlKGosIDYpO1xuICAgICAgICBqIC09IDY7XG4gICAgICAgIGVuZEluZGV4IC09IDY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDE7IGkgPD0gcmVzb2x1dGlvbjsgaSsrKSB7XG4gICAgICAgIHQgPSBpbmMgKiBpO1xuICAgICAgICBpbnYgPSAxIC0gdDtcbiAgICAgICAgeGQgPSB4ZDEgLSAoeGQxID0gKHQgKiB0ICogeDQgKyAzICogaW52ICogKHQgKiB4MyArIGludiAqIHgyKSkgKiB0KTtcbiAgICAgICAgeWQgPSB5ZDEgLSAoeWQxID0gKHQgKiB0ICogeTQgKyAzICogaW52ICogKHQgKiB5MyArIGludiAqIHkyKSkgKiB0KTtcbiAgICAgICAgbCA9IF9zcXJ0KHlkICogeWQgKyB4ZCAqIHhkKTtcblxuICAgICAgICBpZiAobCA8IG1pbikge1xuICAgICAgICAgIG1pbiA9IGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGggKz0gbDtcbiAgICAgICAgc2FtcGxlc1tzYW1wbGVzSW5kZXgrK10gPSBsZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgeDEgKz0geDQ7XG4gICAgeTEgKz0geTQ7XG4gIH1cblxuICBpZiAocHJldkxlbmd0aCkge1xuICAgIHByZXZMZW5ndGggLT0gbGVuZ3RoO1xuXG4gICAgZm9yICg7IHNhbXBsZXNJbmRleCA8IHNhbXBsZXMubGVuZ3RoOyBzYW1wbGVzSW5kZXgrKykge1xuICAgICAgc2FtcGxlc1tzYW1wbGVzSW5kZXhdICs9IHByZXZMZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNhbXBsZXMubGVuZ3RoICYmIG1pbikge1xuICAgIHNlZ21lbnQudG90YWxMZW5ndGggPSBzZWdMZW5ndGggPSBzYW1wbGVzW3NhbXBsZXMubGVuZ3RoIC0gMV0gfHwgMDtcbiAgICBzZWdtZW50Lm1pbkxlbmd0aCA9IG1pbjtcbiAgICBsID0gbGVuZ3RoSW5kZXggPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNlZ0xlbmd0aDsgaSArPSBtaW4pIHtcbiAgICAgIGxvb2t1cFtsKytdID0gc2FtcGxlc1tsZW5ndGhJbmRleF0gPCBpID8gKytsZW5ndGhJbmRleCA6IGxlbmd0aEluZGV4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWdtZW50LnRvdGFsTGVuZ3RoID0gc2FtcGxlc1swXSA9IDA7XG4gIH1cblxuICByZXR1cm4gc3RhcnRJbmRleCA/IGxlbmd0aCAtIHNhbXBsZXNbc3RhcnRJbmRleCAvIDIgLSAxXSA6IGxlbmd0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyhyYXdQYXRoLCByZXNvbHV0aW9uKSB7XG4gIHZhciBwYXRoTGVuZ3RoLCBwb2ludHMsIGk7XG5cbiAgZm9yIChpID0gcGF0aExlbmd0aCA9IHBvaW50cyA9IDA7IGkgPCByYXdQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcmF3UGF0aFtpXS5yZXNvbHV0aW9uID0gfn5yZXNvbHV0aW9uIHx8IDEyOyAvL3N0ZXBzIHBlciBCZXppZXIgY3VydmUgKGFuY2hvciwgMiBjb250cm9sIHBvaW50cywgdG8gYW5jaG9yKVxuXG4gICAgcG9pbnRzICs9IHJhd1BhdGhbaV0ubGVuZ3RoO1xuICAgIHBhdGhMZW5ndGggKz0gbWVhc3VyZVNlZ21lbnQocmF3UGF0aFtpXSk7XG4gIH1cblxuICByYXdQYXRoLnRvdGFsUG9pbnRzID0gcG9pbnRzO1xuICByYXdQYXRoLnRvdGFsTGVuZ3RoID0gcGF0aExlbmd0aDtcbiAgcmV0dXJuIHJhd1BhdGg7XG59IC8vZGl2aWRlIHNlZ21lbnRbaV0gYXQgcG9zaXRpb24gdCAodmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBwcm9ncmVzcyBhbG9uZyB0aGF0IHBhcnRpY3VsYXIgY3ViaWMgYmV6aWVyIHNlZ21lbnQgdGhhdCBzdGFydHMgYXQgc2VnbWVudFtpXSkuIFJldHVybnMgaG93IG1hbnkgZWxlbWVudHMgd2VyZSBzcGxpY2VkIGludG8gdGhlIHNlZ21lbnQgYXJyYXkgKGVpdGhlciAwIG9yIDYpXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJkaXZpZGVTZWdtZW50KHNlZ21lbnQsIGksIHQpIHtcbiAgaWYgKHQgPD0gMCB8fCB0ID49IDEpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBheCA9IHNlZ21lbnRbaV0sXG4gICAgICBheSA9IHNlZ21lbnRbaSArIDFdLFxuICAgICAgY3AxeCA9IHNlZ21lbnRbaSArIDJdLFxuICAgICAgY3AxeSA9IHNlZ21lbnRbaSArIDNdLFxuICAgICAgY3AyeCA9IHNlZ21lbnRbaSArIDRdLFxuICAgICAgY3AyeSA9IHNlZ21lbnRbaSArIDVdLFxuICAgICAgYnggPSBzZWdtZW50W2kgKyA2XSxcbiAgICAgIGJ5ID0gc2VnbWVudFtpICsgN10sXG4gICAgICB4MWEgPSBheCArIChjcDF4IC0gYXgpICogdCxcbiAgICAgIHgyID0gY3AxeCArIChjcDJ4IC0gY3AxeCkgKiB0LFxuICAgICAgeTFhID0gYXkgKyAoY3AxeSAtIGF5KSAqIHQsXG4gICAgICB5MiA9IGNwMXkgKyAoY3AyeSAtIGNwMXkpICogdCxcbiAgICAgIHgxID0geDFhICsgKHgyIC0geDFhKSAqIHQsXG4gICAgICB5MSA9IHkxYSArICh5MiAtIHkxYSkgKiB0LFxuICAgICAgeDJhID0gY3AyeCArIChieCAtIGNwMngpICogdCxcbiAgICAgIHkyYSA9IGNwMnkgKyAoYnkgLSBjcDJ5KSAqIHQ7XG4gIHgyICs9ICh4MmEgLSB4MikgKiB0O1xuICB5MiArPSAoeTJhIC0geTIpICogdDtcbiAgc2VnbWVudC5zcGxpY2UoaSArIDIsIDQsIF9yb3VuZCh4MWEpLCAvL2ZpcnN0IGNvbnRyb2wgcG9pbnRcbiAgX3JvdW5kKHkxYSksIF9yb3VuZCh4MSksIC8vc2Vjb25kIGNvbnRyb2wgcG9pbnRcbiAgX3JvdW5kKHkxKSwgX3JvdW5kKHgxICsgKHgyIC0geDEpICogdCksIC8vbmV3IGZhYnJpY2F0ZWQgYW5jaG9yIG9uIGxpbmVcbiAgX3JvdW5kKHkxICsgKHkyIC0geTEpICogdCksIF9yb3VuZCh4MiksIC8vdGhpcmQgY29udHJvbCBwb2ludFxuICBfcm91bmQoeTIpLCBfcm91bmQoeDJhKSwgLy9mb3VydGggY29udHJvbCBwb2ludFxuICBfcm91bmQoeTJhKSk7XG5cbiAgaWYgKHNlZ21lbnQuc2FtcGxlcykge1xuICAgIHNlZ21lbnQuc2FtcGxlcy5zcGxpY2UoaSAvIDYgKiBzZWdtZW50LnJlc29sdXRpb24gfCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgfVxuXG4gIHJldHVybiA2O1xufSAvLyByZXR1cm5zIGFuIG9iamVjdCB7cGF0aCwgc2VnbWVudCwgc2VnSW5kZXgsIGksIHR9XG5cbmZ1bmN0aW9uIGdldFByb2dyZXNzRGF0YShyYXdQYXRoLCBwcm9ncmVzcywgZGVjb3JhdGVlLCBwdXNoVG9OZXh0SWZBdEVuZCkge1xuICBkZWNvcmF0ZWUgPSBkZWNvcmF0ZWUgfHwge307XG5cbiAgaWYgKCFyYXdQYXRoLnRvdGFsTGVuZ3RoKSB7XG4gICAgY2FjaGVSYXdQYXRoTWVhc3VyZW1lbnRzKHJhd1BhdGgpO1xuICB9XG5cbiAgaWYgKHByb2dyZXNzIDwgMCB8fCBwcm9ncmVzcyA+IDEpIHtcbiAgICBwcm9ncmVzcyA9IF93cmFwUHJvZ3Jlc3MocHJvZ3Jlc3MpO1xuICB9XG5cbiAgdmFyIHNlZ0luZGV4ID0gMCxcbiAgICAgIHNlZ21lbnQgPSByYXdQYXRoWzBdLFxuICAgICAgc2FtcGxlcyxcbiAgICAgIHJlc29sdXRpb24sXG4gICAgICBsZW5ndGgsXG4gICAgICBtaW4sXG4gICAgICBtYXgsXG4gICAgICBpLFxuICAgICAgdDtcblxuICBpZiAocmF3UGF0aC5sZW5ndGggPiAxKSB7XG4gICAgLy9zcGVlZCBvcHRpbWl6YXRpb246IG1vc3Qgb2YgdGhlIHRpbWUsIHRoZXJlJ3Mgb25seSBvbmUgc2VnbWVudCBzbyBza2lwIHRoZSByZWN1cnNpb24uXG4gICAgbGVuZ3RoID0gcmF3UGF0aC50b3RhbExlbmd0aCAqIHByb2dyZXNzO1xuICAgIG1heCA9IGkgPSAwO1xuXG4gICAgd2hpbGUgKChtYXggKz0gcmF3UGF0aFtpKytdLnRvdGFsTGVuZ3RoKSA8IGxlbmd0aCkge1xuICAgICAgc2VnSW5kZXggPSBpO1xuICAgIH1cblxuICAgIHNlZ21lbnQgPSByYXdQYXRoW3NlZ0luZGV4XTtcbiAgICBtaW4gPSBtYXggLSBzZWdtZW50LnRvdGFsTGVuZ3RoO1xuICAgIHByb2dyZXNzID0gKGxlbmd0aCAtIG1pbikgLyAobWF4IC0gbWluKSB8fCAwO1xuICB9XG5cbiAgc2FtcGxlcyA9IHNlZ21lbnQuc2FtcGxlcztcbiAgcmVzb2x1dGlvbiA9IHNlZ21lbnQucmVzb2x1dGlvbjsgLy9ob3cgbWFueSBzYW1wbGVzIHBlciBjdWJpYyBiZXppZXIgY2h1bmtcblxuICBsZW5ndGggPSBzZWdtZW50LnRvdGFsTGVuZ3RoICogcHJvZ3Jlc3M7XG4gIGkgPSBzZWdtZW50Lmxvb2t1cFt+fihsZW5ndGggLyBzZWdtZW50Lm1pbkxlbmd0aCldIHx8IDA7XG4gIG1pbiA9IGkgPyBzYW1wbGVzW2kgLSAxXSA6IDA7XG4gIG1heCA9IHNhbXBsZXNbaV07XG5cbiAgaWYgKG1heCA8IGxlbmd0aCkge1xuICAgIG1pbiA9IG1heDtcbiAgICBtYXggPSBzYW1wbGVzWysraV07XG4gIH1cblxuICB0ID0gMSAvIHJlc29sdXRpb24gKiAoKGxlbmd0aCAtIG1pbikgLyAobWF4IC0gbWluKSArIGkgJSByZXNvbHV0aW9uKTtcbiAgaSA9IH5+KGkgLyByZXNvbHV0aW9uKSAqIDY7XG5cbiAgaWYgKHB1c2hUb05leHRJZkF0RW5kICYmIHQgPT09IDEpIHtcbiAgICBpZiAoaSArIDYgPCBzZWdtZW50Lmxlbmd0aCkge1xuICAgICAgaSArPSA2O1xuICAgICAgdCA9IDA7XG4gICAgfSBlbHNlIGlmIChzZWdJbmRleCArIDEgPCByYXdQYXRoLmxlbmd0aCkge1xuICAgICAgaSA9IHQgPSAwO1xuICAgICAgc2VnbWVudCA9IHJhd1BhdGhbKytzZWdJbmRleF07XG4gICAgfVxuICB9XG5cbiAgZGVjb3JhdGVlLnQgPSB0O1xuICBkZWNvcmF0ZWUuaSA9IGk7XG4gIGRlY29yYXRlZS5wYXRoID0gcmF3UGF0aDtcbiAgZGVjb3JhdGVlLnNlZ21lbnQgPSBzZWdtZW50O1xuICBkZWNvcmF0ZWUuc2VnSW5kZXggPSBzZWdJbmRleDtcbiAgcmV0dXJuIGRlY29yYXRlZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBvc2l0aW9uT25QYXRoKHJhd1BhdGgsIHByb2dyZXNzLCBpbmNsdWRlQW5nbGUsIHBvaW50KSB7XG4gIHZhciBzZWdtZW50ID0gcmF3UGF0aFswXSxcbiAgICAgIHJlc3VsdCA9IHBvaW50IHx8IHt9LFxuICAgICAgc2FtcGxlcyxcbiAgICAgIHJlc29sdXRpb24sXG4gICAgICBsZW5ndGgsXG4gICAgICBtaW4sXG4gICAgICBtYXgsXG4gICAgICBpLFxuICAgICAgdCxcbiAgICAgIGEsXG4gICAgICBpbnY7XG5cbiAgaWYgKHByb2dyZXNzIDwgMCB8fCBwcm9ncmVzcyA+IDEpIHtcbiAgICBwcm9ncmVzcyA9IF93cmFwUHJvZ3Jlc3MocHJvZ3Jlc3MpO1xuICB9XG5cbiAgaWYgKHJhd1BhdGgubGVuZ3RoID4gMSkge1xuICAgIC8vc3BlZWQgb3B0aW1pemF0aW9uOiBtb3N0IG9mIHRoZSB0aW1lLCB0aGVyZSdzIG9ubHkgb25lIHNlZ21lbnQgc28gc2tpcCB0aGUgcmVjdXJzaW9uLlxuICAgIGxlbmd0aCA9IHJhd1BhdGgudG90YWxMZW5ndGggKiBwcm9ncmVzcztcbiAgICBtYXggPSBpID0gMDtcblxuICAgIHdoaWxlICgobWF4ICs9IHJhd1BhdGhbaSsrXS50b3RhbExlbmd0aCkgPCBsZW5ndGgpIHtcbiAgICAgIHNlZ21lbnQgPSByYXdQYXRoW2ldO1xuICAgIH1cblxuICAgIG1pbiA9IG1heCAtIHNlZ21lbnQudG90YWxMZW5ndGg7XG4gICAgcHJvZ3Jlc3MgPSAobGVuZ3RoIC0gbWluKSAvIChtYXggLSBtaW4pIHx8IDA7XG4gIH1cblxuICBzYW1wbGVzID0gc2VnbWVudC5zYW1wbGVzO1xuICByZXNvbHV0aW9uID0gc2VnbWVudC5yZXNvbHV0aW9uO1xuICBsZW5ndGggPSBzZWdtZW50LnRvdGFsTGVuZ3RoICogcHJvZ3Jlc3M7XG4gIGkgPSBzZWdtZW50Lmxvb2t1cFt+fihsZW5ndGggLyBzZWdtZW50Lm1pbkxlbmd0aCldIHx8IDA7XG4gIG1pbiA9IGkgPyBzYW1wbGVzW2kgLSAxXSA6IDA7XG4gIG1heCA9IHNhbXBsZXNbaV07XG5cbiAgaWYgKG1heCA8IGxlbmd0aCkge1xuICAgIG1pbiA9IG1heDtcbiAgICBtYXggPSBzYW1wbGVzWysraV07XG4gIH1cblxuICB0ID0gMSAvIHJlc29sdXRpb24gKiAoKGxlbmd0aCAtIG1pbikgLyAobWF4IC0gbWluKSArIGkgJSByZXNvbHV0aW9uKSB8fCAwO1xuICBpbnYgPSAxIC0gdDtcbiAgaSA9IH5+KGkgLyByZXNvbHV0aW9uKSAqIDY7XG4gIGEgPSBzZWdtZW50W2ldO1xuICByZXN1bHQueCA9IF9yb3VuZCgodCAqIHQgKiAoc2VnbWVudFtpICsgNl0gLSBhKSArIDMgKiBpbnYgKiAodCAqIChzZWdtZW50W2kgKyA0XSAtIGEpICsgaW52ICogKHNlZ21lbnRbaSArIDJdIC0gYSkpKSAqIHQgKyBhKTtcbiAgcmVzdWx0LnkgPSBfcm91bmQoKHQgKiB0ICogKHNlZ21lbnRbaSArIDddIC0gKGEgPSBzZWdtZW50W2kgKyAxXSkpICsgMyAqIGludiAqICh0ICogKHNlZ21lbnRbaSArIDVdIC0gYSkgKyBpbnYgKiAoc2VnbWVudFtpICsgM10gLSBhKSkpICogdCArIGEpO1xuXG4gIGlmIChpbmNsdWRlQW5nbGUpIHtcbiAgICByZXN1bHQuYW5nbGUgPSBzZWdtZW50LnRvdGFsTGVuZ3RoID8gZ2V0Um90YXRpb25BdEJlemllclQoc2VnbWVudCwgaSwgdCA+PSAxID8gMSAtIDFlLTkgOiB0ID8gdCA6IDFlLTkpIDogc2VnbWVudC5hbmdsZSB8fCAwO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0gLy9hcHBsaWVzIGEgbWF0cml4IHRyYW5zZm9ybSB0byBSYXdQYXRoIChvciBhIHNlZ21lbnQgaW4gYSBSYXdQYXRoKSBhbmQgcmV0dXJucyB3aGF0ZXZlciB3YXMgcGFzc2VkIGluIChpdCB0cmFuc2Zvcm1zIHRoZSB2YWx1ZXMgaW4gdGhlIGFycmF5KHMpLCBub3QgYSBjb3B5KS5cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVJhd1BhdGgocmF3UGF0aCwgYSwgYiwgYywgZCwgdHgsIHR5KSB7XG4gIHZhciBqID0gcmF3UGF0aC5sZW5ndGgsXG4gICAgICBzZWdtZW50LFxuICAgICAgbCxcbiAgICAgIGksXG4gICAgICB4LFxuICAgICAgeTtcblxuICB3aGlsZSAoLS1qID4gLTEpIHtcbiAgICBzZWdtZW50ID0gcmF3UGF0aFtqXTtcbiAgICBsID0gc2VnbWVudC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgICB4ID0gc2VnbWVudFtpXTtcbiAgICAgIHkgPSBzZWdtZW50W2kgKyAxXTtcbiAgICAgIHNlZ21lbnRbaV0gPSB4ICogYSArIHkgKiBjICsgdHg7XG4gICAgICBzZWdtZW50W2kgKyAxXSA9IHggKiBiICsgeSAqIGQgKyB0eTtcbiAgICB9XG4gIH1cblxuICByYXdQYXRoLl9kaXJ0eSA9IDE7XG4gIHJldHVybiByYXdQYXRoO1xufSAvLyB0cmFuc2xhdGVzIFNWRyBhcmMgZGF0YSBpbnRvIGEgc2VnbWVudCAoY3ViaWMgYmV6aWVycykuIEFuZ2xlIGlzIGluIGRlZ3JlZXMuXG5cbmZ1bmN0aW9uIGFyY1RvU2VnbWVudChsYXN0WCwgbGFzdFksIHJ4LCByeSwgYW5nbGUsIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCB4LCB5KSB7XG4gIGlmIChsYXN0WCA9PT0geCAmJiBsYXN0WSA9PT0geSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJ4ID0gX2FicyhyeCk7XG4gIHJ5ID0gX2FicyhyeSk7XG5cbiAgdmFyIGFuZ2xlUmFkID0gYW5nbGUgJSAzNjAgKiBfREVHMlJBRCxcbiAgICAgIGNvc0FuZ2xlID0gX2NvcyhhbmdsZVJhZCksXG4gICAgICBzaW5BbmdsZSA9IF9zaW4oYW5nbGVSYWQpLFxuICAgICAgUEkgPSBNYXRoLlBJLFxuICAgICAgVFdPUEkgPSBQSSAqIDIsXG4gICAgICBkeDIgPSAobGFzdFggLSB4KSAvIDIsXG4gICAgICBkeTIgPSAobGFzdFkgLSB5KSAvIDIsXG4gICAgICB4MSA9IGNvc0FuZ2xlICogZHgyICsgc2luQW5nbGUgKiBkeTIsXG4gICAgICB5MSA9IC1zaW5BbmdsZSAqIGR4MiArIGNvc0FuZ2xlICogZHkyLFxuICAgICAgeDFfc3EgPSB4MSAqIHgxLFxuICAgICAgeTFfc3EgPSB5MSAqIHkxLFxuICAgICAgcmFkaWlDaGVjayA9IHgxX3NxIC8gKHJ4ICogcngpICsgeTFfc3EgLyAocnkgKiByeSk7XG5cbiAgaWYgKHJhZGlpQ2hlY2sgPiAxKSB7XG4gICAgcnggPSBfc3FydChyYWRpaUNoZWNrKSAqIHJ4O1xuICAgIHJ5ID0gX3NxcnQocmFkaWlDaGVjaykgKiByeTtcbiAgfVxuXG4gIHZhciByeF9zcSA9IHJ4ICogcngsXG4gICAgICByeV9zcSA9IHJ5ICogcnksXG4gICAgICBzcSA9IChyeF9zcSAqIHJ5X3NxIC0gcnhfc3EgKiB5MV9zcSAtIHJ5X3NxICogeDFfc3EpIC8gKHJ4X3NxICogeTFfc3EgKyByeV9zcSAqIHgxX3NxKTtcblxuICBpZiAoc3EgPCAwKSB7XG4gICAgc3EgPSAwO1xuICB9XG5cbiAgdmFyIGNvZWYgPSAobGFyZ2VBcmNGbGFnID09PSBzd2VlcEZsYWcgPyAtMSA6IDEpICogX3NxcnQoc3EpLFxuICAgICAgY3gxID0gY29lZiAqIChyeCAqIHkxIC8gcnkpLFxuICAgICAgY3kxID0gY29lZiAqIC0ocnkgKiB4MSAvIHJ4KSxcbiAgICAgIHN4MiA9IChsYXN0WCArIHgpIC8gMixcbiAgICAgIHN5MiA9IChsYXN0WSArIHkpIC8gMixcbiAgICAgIGN4ID0gc3gyICsgKGNvc0FuZ2xlICogY3gxIC0gc2luQW5nbGUgKiBjeTEpLFxuICAgICAgY3kgPSBzeTIgKyAoc2luQW5nbGUgKiBjeDEgKyBjb3NBbmdsZSAqIGN5MSksXG4gICAgICB1eCA9ICh4MSAtIGN4MSkgLyByeCxcbiAgICAgIHV5ID0gKHkxIC0gY3kxKSAvIHJ5LFxuICAgICAgdnggPSAoLXgxIC0gY3gxKSAvIHJ4LFxuICAgICAgdnkgPSAoLXkxIC0gY3kxKSAvIHJ5LFxuICAgICAgdGVtcCA9IHV4ICogdXggKyB1eSAqIHV5LFxuICAgICAgYW5nbGVTdGFydCA9ICh1eSA8IDAgPyAtMSA6IDEpICogTWF0aC5hY29zKHV4IC8gX3NxcnQodGVtcCkpLFxuICAgICAgYW5nbGVFeHRlbnQgPSAodXggKiB2eSAtIHV5ICogdnggPCAwID8gLTEgOiAxKSAqIE1hdGguYWNvcygodXggKiB2eCArIHV5ICogdnkpIC8gX3NxcnQodGVtcCAqICh2eCAqIHZ4ICsgdnkgKiB2eSkpKTtcblxuICBpZiAoaXNOYU4oYW5nbGVFeHRlbnQpKSB7XG4gICAgLy9yYXJlIGVkZ2UgY2FzZS4gTWF0aC5jb3MoLTEpIGlzIE5hTi5cbiAgICBhbmdsZUV4dGVudCA9IFBJO1xuICB9XG5cbiAgaWYgKCFzd2VlcEZsYWcgJiYgYW5nbGVFeHRlbnQgPiAwKSB7XG4gICAgYW5nbGVFeHRlbnQgLT0gVFdPUEk7XG4gIH0gZWxzZSBpZiAoc3dlZXBGbGFnICYmIGFuZ2xlRXh0ZW50IDwgMCkge1xuICAgIGFuZ2xlRXh0ZW50ICs9IFRXT1BJO1xuICB9XG5cbiAgYW5nbGVTdGFydCAlPSBUV09QSTtcbiAgYW5nbGVFeHRlbnQgJT0gVFdPUEk7XG5cbiAgdmFyIHNlZ21lbnRzID0gTWF0aC5jZWlsKF9hYnMoYW5nbGVFeHRlbnQpIC8gKFRXT1BJIC8gNCkpLFxuICAgICAgcmF3UGF0aCA9IFtdLFxuICAgICAgYW5nbGVJbmNyZW1lbnQgPSBhbmdsZUV4dGVudCAvIHNlZ21lbnRzLFxuICAgICAgY29udHJvbExlbmd0aCA9IDQgLyAzICogX3NpbihhbmdsZUluY3JlbWVudCAvIDIpIC8gKDEgKyBfY29zKGFuZ2xlSW5jcmVtZW50IC8gMikpLFxuICAgICAgbWEgPSBjb3NBbmdsZSAqIHJ4LFxuICAgICAgbWIgPSBzaW5BbmdsZSAqIHJ4LFxuICAgICAgbWMgPSBzaW5BbmdsZSAqIC1yeSxcbiAgICAgIG1kID0gY29zQW5nbGUgKiByeSxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNlZ21lbnRzOyBpKyspIHtcbiAgICBhbmdsZSA9IGFuZ2xlU3RhcnQgKyBpICogYW5nbGVJbmNyZW1lbnQ7XG4gICAgeDEgPSBfY29zKGFuZ2xlKTtcbiAgICB5MSA9IF9zaW4oYW5nbGUpO1xuICAgIHV4ID0gX2NvcyhhbmdsZSArPSBhbmdsZUluY3JlbWVudCk7XG4gICAgdXkgPSBfc2luKGFuZ2xlKTtcbiAgICByYXdQYXRoLnB1c2goeDEgLSBjb250cm9sTGVuZ3RoICogeTEsIHkxICsgY29udHJvbExlbmd0aCAqIHgxLCB1eCArIGNvbnRyb2xMZW5ndGggKiB1eSwgdXkgLSBjb250cm9sTGVuZ3RoICogdXgsIHV4LCB1eSk7XG4gIH0gLy9ub3cgdHJhbnNmb3JtIGFjY29yZGluZyB0byB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIGVsbGlwc2UvYXJjICh0aGUgYmV6aWVycyB3ZXJlIG5vcmFtbGl6ZWQsIGJldHdlZW4gMCBhbmQgMSBvbiBhIGNpcmNsZSkuXG5cblxuICBmb3IgKGkgPSAwOyBpIDwgcmF3UGF0aC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHgxID0gcmF3UGF0aFtpXTtcbiAgICB5MSA9IHJhd1BhdGhbaSArIDFdO1xuICAgIHJhd1BhdGhbaV0gPSB4MSAqIG1hICsgeTEgKiBtYyArIGN4O1xuICAgIHJhd1BhdGhbaSArIDFdID0geDEgKiBtYiArIHkxICogbWQgKyBjeTtcbiAgfVxuXG4gIHJhd1BhdGhbaSAtIDJdID0geDsgLy9hbHdheXMgc2V0IHRoZSBlbmQgdG8gZXhhY3RseSB3aGVyZSBpdCdzIHN1cHBvc2VkIHRvIGJlXG5cbiAgcmF3UGF0aFtpIC0gMV0gPSB5O1xuICByZXR1cm4gcmF3UGF0aDtcbn0gLy9TcGl0cyBiYWNrIGEgUmF3UGF0aCB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzLiBFYWNoIHNlZ21lbnQgc3RhcnRzIHdpdGggYSBcIm1vdmVUb1wiIGNvbW1hbmQgKHggY29vcmRpbmF0ZSwgdGhlbiB5KSBhbmQgdGhlbiAyIGNvbnRyb2wgcG9pbnRzICh4LCB5LCB4LCB5KSwgdGhlbiBhbmNob3IuIFRoZSBnb2FsIGlzIHRvIG1pbmltaXplIG1lbW9yeSBhbmQgbWF4aW1pemUgc3BlZWQuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvUmF3UGF0aChkKSB7XG4gIHZhciBhID0gKGQgKyBcIlwiKS5yZXBsYWNlKF9zY2llbnRpZmljLCBmdW5jdGlvbiAobSkge1xuICAgIHZhciBuID0gK207XG4gICAgcmV0dXJuIG4gPCAwLjAwMDEgJiYgbiA+IC0wLjAwMDEgPyAwIDogbjtcbiAgfSkubWF0Y2goX3N2Z1BhdGhFeHApIHx8IFtdLFxuICAgICAgLy9zb21lIGF1dGhvcmluZyBwcm9ncmFtcyBzcGl0IG91dCB2ZXJ5IHNtYWxsIG51bWJlcnMgaW4gc2NpZW50aWZpYyBub3RhdGlvbiBsaWtlIFwiMWUtNVwiLCBzbyBtYWtlIHN1cmUgd2Ugcm91bmQgdGhhdCBkb3duIHRvIDAgZmlyc3QuXG4gIHBhdGggPSBbXSxcbiAgICAgIHJlbGF0aXZlWCA9IDAsXG4gICAgICByZWxhdGl2ZVkgPSAwLFxuICAgICAgdHdvVGhpcmRzID0gMiAvIDMsXG4gICAgICBlbGVtZW50cyA9IGEubGVuZ3RoLFxuICAgICAgcG9pbnRzID0gMCxcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiRVJST1I6IG1hbGZvcm1lZCBwYXRoOiBcIiArIGQsXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgY29tbWFuZCxcbiAgICAgIGlzUmVsYXRpdmUsXG4gICAgICBzZWdtZW50LFxuICAgICAgc3RhcnRYLFxuICAgICAgc3RhcnRZLFxuICAgICAgZGlmWCxcbiAgICAgIGRpZlksXG4gICAgICBiZXppZXJzLFxuICAgICAgcHJldkNvbW1hbmQsXG4gICAgICBmbGFnMSxcbiAgICAgIGZsYWcyLFxuICAgICAgbGluZSA9IGZ1bmN0aW9uIGxpbmUoc3gsIHN5LCBleCwgZXkpIHtcbiAgICBkaWZYID0gKGV4IC0gc3gpIC8gMztcbiAgICBkaWZZID0gKGV5IC0gc3kpIC8gMztcbiAgICBzZWdtZW50LnB1c2goc3ggKyBkaWZYLCBzeSArIGRpZlksIGV4IC0gZGlmWCwgZXkgLSBkaWZZLCBleCwgZXkpO1xuICB9O1xuXG4gIGlmICghZCB8fCAhaXNOYU4oYVswXSkgfHwgaXNOYU4oYVsxXSkpIHtcbiAgICBjb25zb2xlLmxvZyhlcnJvck1lc3NhZ2UpO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzOyBpKyspIHtcbiAgICBwcmV2Q29tbWFuZCA9IGNvbW1hbmQ7XG5cbiAgICBpZiAoaXNOYU4oYVtpXSkpIHtcbiAgICAgIGNvbW1hbmQgPSBhW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICBpc1JlbGF0aXZlID0gY29tbWFuZCAhPT0gYVtpXTsgLy9sb3dlciBjYXNlIG1lYW5zIHJlbGF0aXZlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vY29tbWFuZHMgbGlrZSBcIkNcIiBjYW4gYmUgc3RydW5nIHRvZ2V0aGVyIHdpdGhvdXQgYW55IG5ldyBjb21tYW5kIGNoYXJhY3RlcnMgYmV0d2Vlbi5cbiAgICAgIGktLTtcbiAgICB9XG5cbiAgICB4ID0gK2FbaSArIDFdO1xuICAgIHkgPSArYVtpICsgMl07XG5cbiAgICBpZiAoaXNSZWxhdGl2ZSkge1xuICAgICAgeCArPSByZWxhdGl2ZVg7XG4gICAgICB5ICs9IHJlbGF0aXZlWTtcbiAgICB9XG5cbiAgICBpZiAoIWkpIHtcbiAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICBzdGFydFkgPSB5O1xuICAgIH0gLy8gXCJNXCIgKG1vdmUpXG5cblxuICAgIGlmIChjb21tYW5kID09PSBcIk1cIikge1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoIDwgOCkge1xuICAgICAgICAgIC8vaWYgdGhlIHBhdGggZGF0YSB3YXMgZnVua3kgYW5kIGp1c3QgaGFkIGEgTSB3aXRoIG5vIGFjdHVhbCBkcmF3aW5nIGFueXdoZXJlLCBza2lwIGl0LlxuICAgICAgICAgIHBhdGgubGVuZ3RoIC09IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnRzICs9IHNlZ21lbnQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlbGF0aXZlWCA9IHN0YXJ0WCA9IHg7XG4gICAgICByZWxhdGl2ZVkgPSBzdGFydFkgPSB5O1xuICAgICAgc2VnbWVudCA9IFt4LCB5XTtcbiAgICAgIHBhdGgucHVzaChzZWdtZW50KTtcbiAgICAgIGkgKz0gMjtcbiAgICAgIGNvbW1hbmQgPSBcIkxcIjsgLy9hbiBcIk1cIiB3aXRoIG1vcmUgdGhhbiAyIHZhbHVlcyBnZXRzIGludGVycHJldGVkIGFzIFwibGluZVRvXCIgY29tbWFuZHMgKFwiTFwiKS5cbiAgICAgIC8vIFwiQ1wiIChjdWJpYyBiZXppZXIpXG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIkNcIikge1xuICAgICAgaWYgKCFzZWdtZW50KSB7XG4gICAgICAgIHNlZ21lbnQgPSBbMCwgMF07XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNSZWxhdGl2ZSkge1xuICAgICAgICByZWxhdGl2ZVggPSByZWxhdGl2ZVkgPSAwO1xuICAgICAgfSAvL25vdGU6IFwiKjFcIiBpcyBqdXN0IGEgZmFzdC9zaG9ydCB3YXkgdG8gY2FzdCB0aGUgdmFsdWUgYXMgYSBOdW1iZXIuIFdBQUFZIGZhc3RlciBpbiBDaHJvbWUsIHNsaWdodGx5IHNsb3dlciBpbiBGaXJlZm94LlxuXG5cbiAgICAgIHNlZ21lbnQucHVzaCh4LCB5LCByZWxhdGl2ZVggKyBhW2kgKyAzXSAqIDEsIHJlbGF0aXZlWSArIGFbaSArIDRdICogMSwgcmVsYXRpdmVYICs9IGFbaSArIDVdICogMSwgcmVsYXRpdmVZICs9IGFbaSArIDZdICogMSk7XG4gICAgICBpICs9IDY7IC8vIFwiU1wiIChjb250aW51YXRpb24gb2YgY3ViaWMgYmV6aWVyKVxuICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJTXCIpIHtcbiAgICAgIGRpZlggPSByZWxhdGl2ZVg7XG4gICAgICBkaWZZID0gcmVsYXRpdmVZO1xuXG4gICAgICBpZiAocHJldkNvbW1hbmQgPT09IFwiQ1wiIHx8IHByZXZDb21tYW5kID09PSBcIlNcIikge1xuICAgICAgICBkaWZYICs9IHJlbGF0aXZlWCAtIHNlZ21lbnRbc2VnbWVudC5sZW5ndGggLSA0XTtcbiAgICAgICAgZGlmWSArPSByZWxhdGl2ZVkgLSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gM107XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNSZWxhdGl2ZSkge1xuICAgICAgICByZWxhdGl2ZVggPSByZWxhdGl2ZVkgPSAwO1xuICAgICAgfVxuXG4gICAgICBzZWdtZW50LnB1c2goZGlmWCwgZGlmWSwgeCwgeSwgcmVsYXRpdmVYICs9IGFbaSArIDNdICogMSwgcmVsYXRpdmVZICs9IGFbaSArIDRdICogMSk7XG4gICAgICBpICs9IDQ7IC8vIFwiUVwiIChxdWFkcmF0aWMgYmV6aWVyKVxuICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJRXCIpIHtcbiAgICAgIGRpZlggPSByZWxhdGl2ZVggKyAoeCAtIHJlbGF0aXZlWCkgKiB0d29UaGlyZHM7XG4gICAgICBkaWZZID0gcmVsYXRpdmVZICsgKHkgLSByZWxhdGl2ZVkpICogdHdvVGhpcmRzO1xuXG4gICAgICBpZiAoIWlzUmVsYXRpdmUpIHtcbiAgICAgICAgcmVsYXRpdmVYID0gcmVsYXRpdmVZID0gMDtcbiAgICAgIH1cblxuICAgICAgcmVsYXRpdmVYICs9IGFbaSArIDNdICogMTtcbiAgICAgIHJlbGF0aXZlWSArPSBhW2kgKyA0XSAqIDE7XG4gICAgICBzZWdtZW50LnB1c2goZGlmWCwgZGlmWSwgcmVsYXRpdmVYICsgKHggLSByZWxhdGl2ZVgpICogdHdvVGhpcmRzLCByZWxhdGl2ZVkgKyAoeSAtIHJlbGF0aXZlWSkgKiB0d29UaGlyZHMsIHJlbGF0aXZlWCwgcmVsYXRpdmVZKTtcbiAgICAgIGkgKz0gNDsgLy8gXCJUXCIgKGNvbnRpbnVhdGlvbiBvZiBxdWFkcmF0aWMgYmV6aWVyKVxuICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJUXCIpIHtcbiAgICAgIGRpZlggPSByZWxhdGl2ZVggLSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gNF07XG4gICAgICBkaWZZID0gcmVsYXRpdmVZIC0gc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDNdO1xuICAgICAgc2VnbWVudC5wdXNoKHJlbGF0aXZlWCArIGRpZlgsIHJlbGF0aXZlWSArIGRpZlksIHggKyAocmVsYXRpdmVYICsgZGlmWCAqIDEuNSAtIHgpICogdHdvVGhpcmRzLCB5ICsgKHJlbGF0aXZlWSArIGRpZlkgKiAxLjUgLSB5KSAqIHR3b1RoaXJkcywgcmVsYXRpdmVYID0geCwgcmVsYXRpdmVZID0geSk7XG4gICAgICBpICs9IDI7IC8vIFwiSFwiIChob3Jpem9udGFsIGxpbmUpXG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIkhcIikge1xuICAgICAgbGluZShyZWxhdGl2ZVgsIHJlbGF0aXZlWSwgcmVsYXRpdmVYID0geCwgcmVsYXRpdmVZKTtcbiAgICAgIGkgKz0gMTsgLy8gXCJWXCIgKHZlcnRpY2FsIGxpbmUpXG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIlZcIikge1xuICAgICAgLy9hZGp1c3QgdmFsdWVzIGJlY2F1c2UgdGhlIGZpcnN0IChhbmQgb25seSBvbmUpIGlzbid0IHggaW4gdGhpcyBjYXNlLCBpdCdzIHkuXG4gICAgICBsaW5lKHJlbGF0aXZlWCwgcmVsYXRpdmVZLCByZWxhdGl2ZVgsIHJlbGF0aXZlWSA9IHggKyAoaXNSZWxhdGl2ZSA/IHJlbGF0aXZlWSAtIHJlbGF0aXZlWCA6IDApKTtcbiAgICAgIGkgKz0gMTsgLy8gXCJMXCIgKGxpbmUpIG9yIFwiWlwiIChjbG9zZSlcbiAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiTFwiIHx8IGNvbW1hbmQgPT09IFwiWlwiKSB7XG4gICAgICBpZiAoY29tbWFuZCA9PT0gXCJaXCIpIHtcbiAgICAgICAgeCA9IHN0YXJ0WDtcbiAgICAgICAgeSA9IHN0YXJ0WTtcbiAgICAgICAgc2VnbWVudC5jbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tbWFuZCA9PT0gXCJMXCIgfHwgX2FicyhyZWxhdGl2ZVggLSB4KSA+IDAuNSB8fCBfYWJzKHJlbGF0aXZlWSAtIHkpID4gMC41KSB7XG4gICAgICAgIGxpbmUocmVsYXRpdmVYLCByZWxhdGl2ZVksIHgsIHkpO1xuXG4gICAgICAgIGlmIChjb21tYW5kID09PSBcIkxcIikge1xuICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZWxhdGl2ZVggPSB4O1xuICAgICAgcmVsYXRpdmVZID0geTsgLy8gXCJBXCIgKGFyYylcbiAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiQVwiKSB7XG4gICAgICBmbGFnMSA9IGFbaSArIDRdO1xuICAgICAgZmxhZzIgPSBhW2kgKyA1XTtcbiAgICAgIGRpZlggPSBhW2kgKyA2XTtcbiAgICAgIGRpZlkgPSBhW2kgKyA3XTtcbiAgICAgIGogPSA3O1xuXG4gICAgICBpZiAoZmxhZzEubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBmb3IgY2FzZXMgd2hlbiB0aGUgZmxhZ3MgYXJlIG1lcmdlZCwgbGlrZSBcImE4IDggMCAwMTggOFwiICh0aGUgMCBhbmQgMSBmbGFncyBhcmUgV0lUSCB0aGUgeCB2YWx1ZSBvZiA4LCBidXQgaXQgY291bGQgYWxzbyBiZSBcImE4IDggMCAwMS04IDhcIiBzbyBpdCBtYXkgaW5jbHVkZSB4IG9yIG5vdClcbiAgICAgICAgaWYgKGZsYWcxLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICBkaWZZID0gZGlmWDtcbiAgICAgICAgICBkaWZYID0gZmxhZzI7XG4gICAgICAgICAgai0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZlkgPSBmbGFnMjtcbiAgICAgICAgICBkaWZYID0gZmxhZzEuc3Vic3RyKDIpO1xuICAgICAgICAgIGogLT0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsYWcyID0gZmxhZzEuY2hhckF0KDEpO1xuICAgICAgICBmbGFnMSA9IGZsYWcxLmNoYXJBdCgwKTtcbiAgICAgIH1cblxuICAgICAgYmV6aWVycyA9IGFyY1RvU2VnbWVudChyZWxhdGl2ZVgsIHJlbGF0aXZlWSwgK2FbaSArIDFdLCArYVtpICsgMl0sICthW2kgKyAzXSwgK2ZsYWcxLCArZmxhZzIsIChpc1JlbGF0aXZlID8gcmVsYXRpdmVYIDogMCkgKyBkaWZYICogMSwgKGlzUmVsYXRpdmUgPyByZWxhdGl2ZVkgOiAwKSArIGRpZlkgKiAxKTtcbiAgICAgIGkgKz0gajtcblxuICAgICAgaWYgKGJlemllcnMpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGJlemllcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50LnB1c2goYmV6aWVyc1tqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVsYXRpdmVYID0gc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDJdO1xuICAgICAgcmVsYXRpdmVZID0gc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhlcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGkgPSBzZWdtZW50Lmxlbmd0aDtcblxuICBpZiAoaSA8IDYpIHtcbiAgICAvL2luIGNhc2UgdGhlcmUncyBvZGQgU1ZHIGxpa2UgYSBNMCwwIGNvbW1hbmQgYXQgdGhlIHZlcnkgZW5kLlxuICAgIHBhdGgucG9wKCk7XG4gICAgaSA9IDA7XG4gIH0gZWxzZSBpZiAoc2VnbWVudFswXSA9PT0gc2VnbWVudFtpIC0gMl0gJiYgc2VnbWVudFsxXSA9PT0gc2VnbWVudFtpIC0gMV0pIHtcbiAgICBzZWdtZW50LmNsb3NlZCA9IHRydWU7XG4gIH1cblxuICBwYXRoLnRvdGFsUG9pbnRzID0gcG9pbnRzICsgaTtcbiAgcmV0dXJuIHBhdGg7XG59IC8vcG9wdWxhdGVzIHRoZSBwb2ludHMgYXJyYXkgaW4gYWx0ZXJuYXRpbmcgeC95IHZhbHVlcyAobGlrZSBbeCwgeSwgeCwgeS4uLl0gaW5zdGVhZCBvZiBpbmRpdmlkdWFsIHBvaW50IG9iamVjdHMgW3t4LCB5fSwge3gsIHl9Li4uXSB0byBjb25zZXJ2ZSBtZW1vcnkgYW5kIHN0YXkgaW4gbGluZSB3aXRoIGhvdyB3ZSdyZSBoYW5kbGluZyBzZWdtZW50IGFycmF5c1xuXG5leHBvcnQgZnVuY3Rpb24gYmV6aWVyVG9Qb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB0aHJlc2hvbGQsIHBvaW50cywgaW5kZXgpIHtcbiAgdmFyIHgxMiA9ICh4MSArIHgyKSAvIDIsXG4gICAgICB5MTIgPSAoeTEgKyB5MikgLyAyLFxuICAgICAgeDIzID0gKHgyICsgeDMpIC8gMixcbiAgICAgIHkyMyA9ICh5MiArIHkzKSAvIDIsXG4gICAgICB4MzQgPSAoeDMgKyB4NCkgLyAyLFxuICAgICAgeTM0ID0gKHkzICsgeTQpIC8gMixcbiAgICAgIHgxMjMgPSAoeDEyICsgeDIzKSAvIDIsXG4gICAgICB5MTIzID0gKHkxMiArIHkyMykgLyAyLFxuICAgICAgeDIzNCA9ICh4MjMgKyB4MzQpIC8gMixcbiAgICAgIHkyMzQgPSAoeTIzICsgeTM0KSAvIDIsXG4gICAgICB4MTIzNCA9ICh4MTIzICsgeDIzNCkgLyAyLFxuICAgICAgeTEyMzQgPSAoeTEyMyArIHkyMzQpIC8gMixcbiAgICAgIGR4ID0geDQgLSB4MSxcbiAgICAgIGR5ID0geTQgLSB5MSxcbiAgICAgIGQyID0gX2FicygoeDIgLSB4NCkgKiBkeSAtICh5MiAtIHk0KSAqIGR4KSxcbiAgICAgIGQzID0gX2FicygoeDMgLSB4NCkgKiBkeSAtICh5MyAtIHk0KSAqIGR4KSxcbiAgICAgIGxlbmd0aDtcblxuICBpZiAoIXBvaW50cykge1xuICAgIHBvaW50cyA9IFt4MSwgeTEsIHg0LCB5NF07XG4gICAgaW5kZXggPSAyO1xuICB9XG5cbiAgcG9pbnRzLnNwbGljZShpbmRleCB8fCBwb2ludHMubGVuZ3RoIC0gMiwgMCwgeDEyMzQsIHkxMjM0KTtcblxuICBpZiAoKGQyICsgZDMpICogKGQyICsgZDMpID4gdGhyZXNob2xkICogKGR4ICogZHggKyBkeSAqIGR5KSkge1xuICAgIGxlbmd0aCA9IHBvaW50cy5sZW5ndGg7XG4gICAgYmV6aWVyVG9Qb2ludHMoeDEsIHkxLCB4MTIsIHkxMiwgeDEyMywgeTEyMywgeDEyMzQsIHkxMjM0LCB0aHJlc2hvbGQsIHBvaW50cywgaW5kZXgpO1xuICAgIGJlemllclRvUG9pbnRzKHgxMjM0LCB5MTIzNCwgeDIzNCwgeTIzNCwgeDM0LCB5MzQsIHg0LCB5NCwgdGhyZXNob2xkLCBwb2ludHMsIGluZGV4ICsgMiArIChwb2ludHMubGVuZ3RoIC0gbGVuZ3RoKSk7XG4gIH1cblxuICByZXR1cm4gcG9pbnRzO1xufVxuLypcbmZ1bmN0aW9uIGdldEFuZ2xlQmV0d2VlblBvaW50cyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyKSB7IC8vYW5nbGUgYmV0d2VlbiAzIHBvaW50cyBpbiByYWRpYW5zXG5cdHZhciBkeDEgPSB4MSAtIHgwLFxuXHRcdGR5MSA9IHkxIC0geTAsXG5cdFx0ZHgyID0geDIgLSB4MSxcblx0XHRkeTIgPSB5MiAtIHkxLFxuXHRcdGR4MyA9IHgyIC0geDAsXG5cdFx0ZHkzID0geTIgLSB5MCxcblx0XHRhID0gZHgxICogZHgxICsgZHkxICogZHkxLFxuXHRcdGIgPSBkeDIgKiBkeDIgKyBkeTIgKiBkeTIsXG5cdFx0YyA9IGR4MyAqIGR4MyArIGR5MyAqIGR5Mztcblx0cmV0dXJuIE1hdGguYWNvcyggKGEgKyBiIC0gYykgLyBfc3FydCg0ICogYSAqIGIpICk7XG59LFxuKi9cbi8vcG9pbnRzVG9TZWdtZW50KCkgZG9lc24ndCBoYW5kbGUgZmxhdCBjb29yZGluYXRlcyAod2hlcmUgeSBpcyBhbHdheXMgMCkgdGhlIHdheSB3ZSBuZWVkICh0aGUgcmVzdWx0aW5nIGNvbnRyb2wgcG9pbnRzIGFyZSBhbHdheXMgcmlnaHQgb24gdG9wIG9mIHRoZSBhbmNob3JzKSwgc28gdGhpcyBmdW5jdGlvbiBiYXNpY2FsbHkgbWFrZXMgdGhlIGNvbnRyb2wgcG9pbnRzIGdvIGRpcmVjdGx5IHVwIGFuZCBkb3duLCB2YXJ5aW5nIGluIGxlbmd0aCBiYXNlZCBvbiB0aGUgY3VydmluZXNzIChtb3JlIGN1cnZ5LCBmdXJ0aGVyIGNvbnRyb2wgcG9pbnRzKVxuXG5leHBvcnQgZnVuY3Rpb24gZmxhdFBvaW50c1RvU2VnbWVudChwb2ludHMsIGN1cnZpbmVzcykge1xuICBpZiAoY3VydmluZXNzID09PSB2b2lkIDApIHtcbiAgICBjdXJ2aW5lc3MgPSAxO1xuICB9XG5cbiAgdmFyIHggPSBwb2ludHNbMF0sXG4gICAgICB5ID0gMCxcbiAgICAgIHNlZ21lbnQgPSBbeCwgeV0sXG4gICAgICBpID0gMjtcblxuICBmb3IgKDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHNlZ21lbnQucHVzaCh4LCB5LCBwb2ludHNbaV0sIHkgPSAocG9pbnRzW2ldIC0geCkgKiBjdXJ2aW5lc3MgLyAyLCB4ID0gcG9pbnRzW2ldLCAteSk7XG4gIH1cblxuICByZXR1cm4gc2VnbWVudDtcbn0gLy9wb2ludHMgaXMgYW4gYXJyYXkgb2YgeC95IHBvaW50cywgbGlrZSBbeCwgeSwgeCwgeSwgeCwgeV1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50c1RvU2VnbWVudChwb2ludHMsIGN1cnZpbmVzcywgY29ybmVyVGhyZXNob2xkKSB7XG4gIC8vcG9pbnRzID0gc2ltcGxpZnlQb2ludHMocG9pbnRzLCB0b2xlcmFuY2UpO1xuICB2YXIgbCA9IHBvaW50cy5sZW5ndGggLSAyLFxuICAgICAgeCA9ICtwb2ludHNbMF0sXG4gICAgICB5ID0gK3BvaW50c1sxXSxcbiAgICAgIG5leHRYID0gK3BvaW50c1syXSxcbiAgICAgIG5leHRZID0gK3BvaW50c1szXSxcbiAgICAgIHNlZ21lbnQgPSBbeCwgeSwgeCwgeV0sXG4gICAgICBkeDIgPSBuZXh0WCAtIHgsXG4gICAgICBkeTIgPSBuZXh0WSAtIHksXG4gICAgICBwcmV2WCxcbiAgICAgIHByZXZZLFxuICAgICAgYW5nbGUsXG4gICAgICBzbG9wZSxcbiAgICAgIGksXG4gICAgICBkeDEsXG4gICAgICBkeDMsXG4gICAgICBkeTEsXG4gICAgICBkeTMsXG4gICAgICBkMSxcbiAgICAgIGQyLFxuICAgICAgYSxcbiAgICAgIGIsXG4gICAgICBjO1xuXG4gIGlmIChpc05hTihjb3JuZXJUaHJlc2hvbGQpKSB7XG4gICAgY29ybmVyVGhyZXNob2xkID0gTWF0aC5QSSAvIDEwO1xuICB9XG5cbiAgY3VydmluZXNzID0gY3VydmluZXNzIHx8IGN1cnZpbmVzcyA9PT0gMCA/ICtjdXJ2aW5lc3MgOiAxO1xuXG4gIGZvciAoaSA9IDI7IGkgPCBsOyBpICs9IDIpIHtcbiAgICBwcmV2WCA9IHg7XG4gICAgcHJldlkgPSB5O1xuICAgIHggPSBuZXh0WDtcbiAgICB5ID0gbmV4dFk7XG4gICAgbmV4dFggPSArcG9pbnRzW2kgKyAyXTtcbiAgICBuZXh0WSA9ICtwb2ludHNbaSArIDNdO1xuICAgIGR4MSA9IGR4MjtcbiAgICBkeTEgPSBkeTI7XG4gICAgZHgyID0gbmV4dFggLSB4O1xuICAgIGR5MiA9IG5leHRZIC0geTtcbiAgICBkeDMgPSBuZXh0WCAtIHByZXZYO1xuICAgIGR5MyA9IG5leHRZIC0gcHJldlk7XG4gICAgYSA9IGR4MSAqIGR4MSArIGR5MSAqIGR5MTtcbiAgICBiID0gZHgyICogZHgyICsgZHkyICogZHkyO1xuICAgIGMgPSBkeDMgKiBkeDMgKyBkeTMgKiBkeTM7XG4gICAgYW5nbGUgPSBNYXRoLmFjb3MoKGEgKyBiIC0gYykgLyBfc3FydCg0ICogYSAqIGIpKTsgLy9hbmdsZSBiZXR3ZWVuIHRoZSAzIHBvaW50c1xuXG4gICAgZDIgPSBhbmdsZSAvIE1hdGguUEkgKiBjdXJ2aW5lc3M7IC8vdGVtcG9yYXJ5IHByZWNhbGN1bGF0aW9uIGZvciBzcGVlZCAocmV1c2luZyBkMiB2YXJpYWJsZSlcblxuICAgIGQxID0gX3NxcnQoYSkgKiBkMjsgLy90aGUgdGlnaHRlciB0aGUgYW5nbGUsIHRoZSBzaG9ydGVyIHdlIG1ha2UgdGhlIGhhbmRsZXMgaW4gcHJvcG9ydGlvbi5cblxuICAgIGQyICo9IF9zcXJ0KGIpO1xuXG4gICAgaWYgKHggIT09IHByZXZYIHx8IHkgIT09IHByZXZZKSB7XG4gICAgICBpZiAoYW5nbGUgPiBjb3JuZXJUaHJlc2hvbGQpIHtcbiAgICAgICAgc2xvcGUgPSBfYXRhbjIoZHkzLCBkeDMpO1xuICAgICAgICBzZWdtZW50LnB1c2goX3JvdW5kKHggLSBfY29zKHNsb3BlKSAqIGQxKSwgLy9maXJzdCBjb250cm9sIHBvaW50XG4gICAgICAgIF9yb3VuZCh5IC0gX3NpbihzbG9wZSkgKiBkMSksIF9yb3VuZCh4KSwgLy9hbmNob3JcbiAgICAgICAgX3JvdW5kKHkpLCBfcm91bmQoeCArIF9jb3Moc2xvcGUpICogZDIpLCAvL3NlY29uZCBjb250cm9sIHBvaW50XG4gICAgICAgIF9yb3VuZCh5ICsgX3NpbihzbG9wZSkgKiBkMikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvcGUgPSBfYXRhbjIoZHkxLCBkeDEpO1xuICAgICAgICBzZWdtZW50LnB1c2goX3JvdW5kKHggLSBfY29zKHNsb3BlKSAqIGQxKSwgLy9maXJzdCBjb250cm9sIHBvaW50XG4gICAgICAgIF9yb3VuZCh5IC0gX3NpbihzbG9wZSkgKiBkMSkpO1xuICAgICAgICBzbG9wZSA9IF9hdGFuMihkeTIsIGR4Mik7XG4gICAgICAgIHNlZ21lbnQucHVzaChfcm91bmQoeCksIC8vYW5jaG9yXG4gICAgICAgIF9yb3VuZCh5KSwgX3JvdW5kKHggKyBfY29zKHNsb3BlKSAqIGQyKSwgLy9zZWNvbmQgY29udHJvbCBwb2ludFxuICAgICAgICBfcm91bmQoeSArIF9zaW4oc2xvcGUpICogZDIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZWdtZW50LnB1c2goX3JvdW5kKG5leHRYKSwgX3JvdW5kKG5leHRZKSwgX3JvdW5kKG5leHRYKSwgX3JvdW5kKG5leHRZKSk7XG4gIHJldHVybiBzZWdtZW50O1xufSAvL3JldHVybnMgdGhlIHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhbiB4L3kgY29vcmRpbmF0ZSBhbmQgYSBzZWdtZW50IGJldHdlZW4geDEveTEgYW5kIHgyL3kyXG5cbmZ1bmN0aW9uIHBvaW50VG9TZWdEaXN0KHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gIHZhciBkeCA9IHgyIC0geDEsXG4gICAgICBkeSA9IHkyIC0geTEsXG4gICAgICB0O1xuXG4gIGlmIChkeCB8fCBkeSkge1xuICAgIHQgPSAoKHggLSB4MSkgKiBkeCArICh5IC0geTEpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgIGlmICh0ID4gMSkge1xuICAgICAgeDEgPSB4MjtcbiAgICAgIHkxID0geTI7XG4gICAgfSBlbHNlIGlmICh0ID4gMCkge1xuICAgICAgeDEgKz0gZHggKiB0O1xuICAgICAgeTEgKz0gZHkgKiB0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBNYXRoLnBvdyh4IC0geDEsIDIpICsgTWF0aC5wb3coeSAtIHkxLCAyKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxpZnlTdGVwKHBvaW50cywgZmlyc3QsIGxhc3QsIHRvbGVyYW5jZSwgc2ltcGxpZmllZCkge1xuICB2YXIgbWF4U3FEaXN0ID0gdG9sZXJhbmNlLFxuICAgICAgZmlyc3RYID0gcG9pbnRzW2ZpcnN0XSxcbiAgICAgIGZpcnN0WSA9IHBvaW50c1tmaXJzdCArIDFdLFxuICAgICAgbGFzdFggPSBwb2ludHNbbGFzdF0sXG4gICAgICBsYXN0WSA9IHBvaW50c1tsYXN0ICsgMV0sXG4gICAgICBpbmRleCxcbiAgICAgIGksXG4gICAgICBkO1xuXG4gIGZvciAoaSA9IGZpcnN0ICsgMjsgaSA8IGxhc3Q7IGkgKz0gMikge1xuICAgIGQgPSBwb2ludFRvU2VnRGlzdChwb2ludHNbaV0sIHBvaW50c1tpICsgMV0sIGZpcnN0WCwgZmlyc3RZLCBsYXN0WCwgbGFzdFkpO1xuXG4gICAgaWYgKGQgPiBtYXhTcURpc3QpIHtcbiAgICAgIGluZGV4ID0gaTtcbiAgICAgIG1heFNxRGlzdCA9IGQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1heFNxRGlzdCA+IHRvbGVyYW5jZSkge1xuICAgIGlmIChpbmRleCAtIGZpcnN0ID4gMikge1xuICAgICAgc2ltcGxpZnlTdGVwKHBvaW50cywgZmlyc3QsIGluZGV4LCB0b2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuICAgIH1cblxuICAgIHNpbXBsaWZpZWQucHVzaChwb2ludHNbaW5kZXhdLCBwb2ludHNbaW5kZXggKyAxXSk7XG5cbiAgICBpZiAobGFzdCAtIGluZGV4ID4gMikge1xuICAgICAgc2ltcGxpZnlTdGVwKHBvaW50cywgaW5kZXgsIGxhc3QsIHRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG4gICAgfVxuICB9XG59IC8vcG9pbnRzIGlzIGFuIGFycmF5IG9mIHgveSB2YWx1ZXMgbGlrZSBbeCwgeSwgeCwgeSwgeCwgeV1cblxuXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxpZnlQb2ludHMocG9pbnRzLCB0b2xlcmFuY2UpIHtcbiAgdmFyIHByZXZYID0gcGFyc2VGbG9hdChwb2ludHNbMF0pLFxuICAgICAgcHJldlkgPSBwYXJzZUZsb2F0KHBvaW50c1sxXSksXG4gICAgICB0ZW1wID0gW3ByZXZYLCBwcmV2WV0sXG4gICAgICBsID0gcG9pbnRzLmxlbmd0aCAtIDIsXG4gICAgICBpLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBkeCxcbiAgICAgIGR5LFxuICAgICAgcmVzdWx0LFxuICAgICAgbGFzdDtcbiAgdG9sZXJhbmNlID0gTWF0aC5wb3codG9sZXJhbmNlIHx8IDEsIDIpO1xuXG4gIGZvciAoaSA9IDI7IGkgPCBsOyBpICs9IDIpIHtcbiAgICB4ID0gcGFyc2VGbG9hdChwb2ludHNbaV0pO1xuICAgIHkgPSBwYXJzZUZsb2F0KHBvaW50c1tpICsgMV0pO1xuICAgIGR4ID0gcHJldlggLSB4O1xuICAgIGR5ID0gcHJldlkgLSB5O1xuXG4gICAgaWYgKGR4ICogZHggKyBkeSAqIGR5ID4gdG9sZXJhbmNlKSB7XG4gICAgICB0ZW1wLnB1c2goeCwgeSk7XG4gICAgICBwcmV2WCA9IHg7XG4gICAgICBwcmV2WSA9IHk7XG4gICAgfVxuICB9XG5cbiAgdGVtcC5wdXNoKHBhcnNlRmxvYXQocG9pbnRzW2xdKSwgcGFyc2VGbG9hdChwb2ludHNbbCArIDFdKSk7XG4gIGxhc3QgPSB0ZW1wLmxlbmd0aCAtIDI7XG4gIHJlc3VsdCA9IFt0ZW1wWzBdLCB0ZW1wWzFdXTtcbiAgc2ltcGxpZnlTdGVwKHRlbXAsIDAsIGxhc3QsIHRvbGVyYW5jZSwgcmVzdWx0KTtcbiAgcmVzdWx0LnB1c2godGVtcFtsYXN0XSwgdGVtcFtsYXN0ICsgMV0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRDbG9zZXN0UHJvZ3Jlc3NPbkJlemllcihpdGVyYXRpb25zLCBweCwgcHksIHN0YXJ0LCBlbmQsIHNsaWNlcywgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gIHZhciBpbmMgPSAoZW5kIC0gc3RhcnQpIC8gc2xpY2VzLFxuICAgICAgYmVzdCA9IDAsXG4gICAgICB0ID0gc3RhcnQsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGQsXG4gICAgICBkeCxcbiAgICAgIGR5LFxuICAgICAgaW52O1xuICBfYmVzdERpc3RhbmNlID0gX2xhcmdlTnVtO1xuXG4gIHdoaWxlICh0IDw9IGVuZCkge1xuICAgIGludiA9IDEgLSB0O1xuICAgIHggPSBpbnYgKiBpbnYgKiBpbnYgKiB4MCArIDMgKiBpbnYgKiBpbnYgKiB0ICogeDEgKyAzICogaW52ICogdCAqIHQgKiB4MiArIHQgKiB0ICogdCAqIHgzO1xuICAgIHkgPSBpbnYgKiBpbnYgKiBpbnYgKiB5MCArIDMgKiBpbnYgKiBpbnYgKiB0ICogeTEgKyAzICogaW52ICogdCAqIHQgKiB5MiArIHQgKiB0ICogdCAqIHkzO1xuICAgIGR4ID0geCAtIHB4O1xuICAgIGR5ID0geSAtIHB5O1xuICAgIGQgPSBkeCAqIGR4ICsgZHkgKiBkeTtcblxuICAgIGlmIChkIDwgX2Jlc3REaXN0YW5jZSkge1xuICAgICAgX2Jlc3REaXN0YW5jZSA9IGQ7XG4gICAgICBiZXN0ID0gdDtcbiAgICB9XG5cbiAgICB0ICs9IGluYztcbiAgfVxuXG4gIHJldHVybiBpdGVyYXRpb25zID4gMSA/IGdldENsb3Nlc3RQcm9ncmVzc09uQmV6aWVyKGl0ZXJhdGlvbnMgLSAxLCBweCwgcHksIE1hdGgubWF4KGJlc3QgLSBpbmMsIDApLCBNYXRoLm1pbihiZXN0ICsgaW5jLCAxKSwgc2xpY2VzLCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIDogYmVzdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENsb3Nlc3REYXRhKHJhd1BhdGgsIHgsIHksIHNsaWNlcykge1xuICAvL3JldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGNsb3Nlc3QgaiwgaSwgYW5kIHQgKGogaXMgdGhlIHNlZ21lbnQgaW5kZXgsIGkgaXMgdGhlIGluZGV4IG9mIHRoZSBwb2ludCBpbiB0aGF0IHNlZ21lbnQsIGFuZCB0IGlzIHRoZSB0aW1lL3Byb2dyZXNzIGFsb25nIHRoYXQgYmV6aWVyKVxuICB2YXIgY2xvc2VzdCA9IHtcbiAgICBqOiAwLFxuICAgIGk6IDAsXG4gICAgdDogMFxuICB9LFxuICAgICAgYmVzdERpc3RhbmNlID0gX2xhcmdlTnVtLFxuICAgICAgaSxcbiAgICAgIGosXG4gICAgICB0LFxuICAgICAgc2VnbWVudDtcblxuICBmb3IgKGogPSAwOyBqIDwgcmF3UGF0aC5sZW5ndGg7IGorKykge1xuICAgIHNlZ21lbnQgPSByYXdQYXRoW2pdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNlZ21lbnQubGVuZ3RoOyBpICs9IDYpIHtcbiAgICAgIHQgPSBnZXRDbG9zZXN0UHJvZ3Jlc3NPbkJlemllcigxLCB4LCB5LCAwLCAxLCBzbGljZXMgfHwgMjAsIHNlZ21lbnRbaV0sIHNlZ21lbnRbaSArIDFdLCBzZWdtZW50W2kgKyAyXSwgc2VnbWVudFtpICsgM10sIHNlZ21lbnRbaSArIDRdLCBzZWdtZW50W2kgKyA1XSwgc2VnbWVudFtpICsgNl0sIHNlZ21lbnRbaSArIDddKTtcblxuICAgICAgaWYgKGJlc3REaXN0YW5jZSA+IF9iZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgYmVzdERpc3RhbmNlID0gX2Jlc3REaXN0YW5jZTtcbiAgICAgICAgY2xvc2VzdC5qID0gajtcbiAgICAgICAgY2xvc2VzdC5pID0gaTtcbiAgICAgICAgY2xvc2VzdC50ID0gdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdDtcbn0gLy9zdWJkaXZpZGUgYSBTZWdtZW50IGNsb3Nlc3QgdG8gYSBzcGVjaWZpYyB4LHkgY29vcmRpbmF0ZVxuXG5leHBvcnQgZnVuY3Rpb24gc3ViZGl2aWRlU2VnbWVudE5lYXIoeCwgeSwgc2VnbWVudCwgc2xpY2VzLCBpdGVyYXRpb25zKSB7XG4gIHZhciBsID0gc2VnbWVudC5sZW5ndGgsXG4gICAgICBiZXN0RGlzdGFuY2UgPSBfbGFyZ2VOdW0sXG4gICAgICBiZXN0VCA9IDAsXG4gICAgICBiZXN0U2VnbWVudEluZGV4ID0gMCxcbiAgICAgIHQsXG4gICAgICBpO1xuICBzbGljZXMgPSBzbGljZXMgfHwgMjA7XG4gIGl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zIHx8IDM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gNikge1xuICAgIHQgPSBnZXRDbG9zZXN0UHJvZ3Jlc3NPbkJlemllcigxLCB4LCB5LCAwLCAxLCBzbGljZXMsIHNlZ21lbnRbaV0sIHNlZ21lbnRbaSArIDFdLCBzZWdtZW50W2kgKyAyXSwgc2VnbWVudFtpICsgM10sIHNlZ21lbnRbaSArIDRdLCBzZWdtZW50W2kgKyA1XSwgc2VnbWVudFtpICsgNl0sIHNlZ21lbnRbaSArIDddKTtcblxuICAgIGlmIChiZXN0RGlzdGFuY2UgPiBfYmVzdERpc3RhbmNlKSB7XG4gICAgICBiZXN0RGlzdGFuY2UgPSBfYmVzdERpc3RhbmNlO1xuICAgICAgYmVzdFQgPSB0O1xuICAgICAgYmVzdFNlZ21lbnRJbmRleCA9IGk7XG4gICAgfVxuICB9XG5cbiAgdCA9IGdldENsb3Nlc3RQcm9ncmVzc09uQmV6aWVyKGl0ZXJhdGlvbnMsIHgsIHksIGJlc3RUIC0gMC4wNSwgYmVzdFQgKyAwLjA1LCBzbGljZXMsIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleF0sIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleCArIDFdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXggKyAyXSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4ICsgM10sIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleCArIDRdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXggKyA1XSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4ICsgNl0sIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleCArIDddKTtcbiAgc3ViZGl2aWRlU2VnbWVudChzZWdtZW50LCBiZXN0U2VnbWVudEluZGV4LCB0KTtcbiAgcmV0dXJuIGJlc3RTZWdtZW50SW5kZXggKyA2O1xufVxuLypcblRha2VzIGFueSBvZiB0aGUgZm9sbG93aW5nIGFuZCBjb252ZXJ0cyBpdCB0byBhbiBhbGwgQ3ViaWMgQmV6aWVyIFNWRyBkYXRhIHN0cmluZzpcbi0gQSA8cGF0aD4gZGF0YSBzdHJpbmcgbGlrZSBcIk0wLDAgTDIsNCB2MjAsMTUgSDEwMFwiXG4tIEEgUmF3UGF0aCwgbGlrZSBbW3gsIHksIHgsIHksIHgsIHksIHgsIHldW1t4LCB5LCB4LCB5LCB4LCB5LCB4LCB5XV1cbi0gQSBTZWdtZW50LCBsaWtlIFt4LCB5LCB4LCB5LCB4LCB5LCB4LCB5XVxuXG5Ob3RlOiBhbGwgbnVtYmVycyBhcmUgcm91bmRlZCBkb3duIHRvIHRoZSBjbG9zZXN0IDAuMDAxIHRvIG1pbmltaXplIG1lbW9yeSwgbWF4aW1pemUgc3BlZWQsIGFuZCBhdm9pZCBvZGQgbnVtYmVycyBsaWtlIDFlLTEzXG4qL1xuXG5leHBvcnQgZnVuY3Rpb24gcmF3UGF0aFRvU3RyaW5nKHJhd1BhdGgpIHtcbiAgaWYgKF9pc051bWJlcihyYXdQYXRoWzBdKSkge1xuICAgIC8vaW4gY2FzZSBhIHNlZ21lbnQgaXMgcGFzc2VkIGluIGluc3RlYWRcbiAgICByYXdQYXRoID0gW3Jhd1BhdGhdO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFwiXCIsXG4gICAgICBsID0gcmF3UGF0aC5sZW5ndGgsXG4gICAgICBzbCxcbiAgICAgIHMsXG4gICAgICBpLFxuICAgICAgc2VnbWVudDtcblxuICBmb3IgKHMgPSAwOyBzIDwgbDsgcysrKSB7XG4gICAgc2VnbWVudCA9IHJhd1BhdGhbc107XG4gICAgcmVzdWx0ICs9IFwiTVwiICsgX3JvdW5kKHNlZ21lbnRbMF0pICsgXCIsXCIgKyBfcm91bmQoc2VnbWVudFsxXSkgKyBcIiBDXCI7XG4gICAgc2wgPSBzZWdtZW50Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDI7IGkgPCBzbDsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gX3JvdW5kKHNlZ21lbnRbaSsrXSkgKyBcIixcIiArIF9yb3VuZChzZWdtZW50W2krK10pICsgXCIgXCIgKyBfcm91bmQoc2VnbWVudFtpKytdKSArIFwiLFwiICsgX3JvdW5kKHNlZ21lbnRbaSsrXSkgKyBcIiBcIiArIF9yb3VuZChzZWdtZW50W2krK10pICsgXCIsXCIgKyBfcm91bmQoc2VnbWVudFtpXSkgKyBcIiBcIjtcbiAgICB9XG5cbiAgICBpZiAoc2VnbWVudC5jbG9zZWQpIHtcbiAgICAgIHJlc3VsdCArPSBcInpcIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLypcbi8vIHRha2VzIGEgc2VnbWVudCB3aXRoIGNvb3JkaW5hdGVzIFt4LCB5LCB4LCB5LCAuLi5dIGFuZCBjb252ZXJ0cyB0aGUgY29udHJvbCBwb2ludHMgaW50byBhbmdsZXMgYW5kIGxlbmd0aHMgW3gsIHksIGFuZ2xlLCBsZW5ndGgsIGFuZ2xlLCBsZW5ndGgsIHgsIHksIGFuZ2xlLCBsZW5ndGgsIC4uLl0gc28gdGhhdCBpdCBhbmltYXRlcyBtb3JlIGNsZWFubHkgYW5kIGF2b2lkcyBvZGQgYnJlYWtzL2tpbmtzLiBGb3IgZXhhbXBsZSwgaWYgeW91IGFuaW1hdGUgZnJvbSAxIG8nY2xvY2sgdG8gNiBvJ2Nsb2NrLCBpdCdkIGp1c3QgZ28gZGlyZWN0bHkvbGluZWFybHkgcmF0aGVyIHRoYW4gYXJvdW5kLiBTbyB0aGUgbGVuZ3RoIHdvdWxkIGJlIHZlcnkgc2hvcnQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdHdlZW4uXG5leHBvcnQgZnVuY3Rpb24gY3BDb29yZHNUb0FuZ2xlcyhzZWdtZW50LCBjb3B5KSB7XG5cdHZhciByZXN1bHQgPSBjb3B5ID8gc2VnbWVudC5zbGljZSgwKSA6IHNlZ21lbnQsXG5cdFx0eCwgeSwgaTtcblx0Zm9yIChpID0gMDsgaSA8IHNlZ21lbnQubGVuZ3RoOyBpKz02KSB7XG5cdFx0eCA9IHNlZ21lbnRbaSsyXSAtIHNlZ21lbnRbaV07XG5cdFx0eSA9IHNlZ21lbnRbaSszXSAtIHNlZ21lbnRbaSsxXTtcblx0XHRyZXN1bHRbaSsyXSA9IE1hdGguYXRhbjIoeSwgeCk7XG5cdFx0cmVzdWx0W2krM10gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cdFx0eCA9IHNlZ21lbnRbaSs2XSAtIHNlZ21lbnRbaSs0XTtcblx0XHR5ID0gc2VnbWVudFtpKzddIC0gc2VnbWVudFtpKzVdO1xuXHRcdHJlc3VsdFtpKzRdID0gTWF0aC5hdGFuMih5LCB4KTtcblx0XHRyZXN1bHRbaSs1XSA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vLyB0YWtlcyBhIHNlZ21lbnQgdGhhdCB3YXMgY29udmVydGVkIHdpdGggY3BDb29yZHNUb0FuZ2xlcygpIHRvIGhhdmUgYW5nbGVzIGFuZCBsZW5ndGhzIGluc3RlYWQgb2YgY29vcmRpbmF0ZXMgZm9yIHRoZSBjb250cm9sIHBvaW50cywgYW5kIGNvbnZlcnRzIGl0IEJBQ0sgaW50byBjb29yZGluYXRlcy5cbmV4cG9ydCBmdW5jdGlvbiBjcEFuZ2xlc1RvQ29vcmRzKHNlZ21lbnQsIGNvcHkpIHtcblx0dmFyIHJlc3VsdCA9IGNvcHkgPyBzZWdtZW50LnNsaWNlKDApIDogc2VnbWVudCxcblx0XHRsZW5ndGggPSBzZWdtZW50Lmxlbmd0aCxcblx0XHRybmQgPSAxMDAwLFxuXHRcdGFuZ2xlLCBsLCBpLCBqO1xuXHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKz02KSB7XG5cdFx0YW5nbGUgPSBzZWdtZW50W2krMl07XG5cdFx0bCA9IHNlZ21lbnRbaSszXTsgLy9sZW5ndGhcblx0XHRyZXN1bHRbaSsyXSA9ICgoKHNlZ21lbnRbaV0gKyBNYXRoLmNvcyhhbmdsZSkgKiBsKSAqIHJuZCkgfCAwKSAvIHJuZDtcblx0XHRyZXN1bHRbaSszXSA9ICgoKHNlZ21lbnRbaSsxXSArIE1hdGguc2luKGFuZ2xlKSAqIGwpICogcm5kKSB8IDApIC8gcm5kO1xuXHRcdGFuZ2xlID0gc2VnbWVudFtpKzRdO1xuXHRcdGwgPSBzZWdtZW50W2krNV07IC8vbGVuZ3RoXG5cdFx0cmVzdWx0W2krNF0gPSAoKChzZWdtZW50W2krNl0gLSBNYXRoLmNvcyhhbmdsZSkgKiBsKSAqIHJuZCkgfCAwKSAvIHJuZDtcblx0XHRyZXN1bHRbaSs1XSA9ICgoKHNlZ21lbnRbaSs3XSAtIE1hdGguc2luKGFuZ2xlKSAqIGwpICogcm5kKSB8IDApIC8gcm5kO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8vYWRkcyBhbiBcImlzU21vb3RoXCIgYXJyYXkgdG8gZWFjaCBzZWdtZW50IGFuZCBwb3B1bGF0ZXMgaXQgd2l0aCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNtb290aCAodGhlIGNvbnRyb2wgcG9pbnRzIGhhdmUgYmFzaWNhbGx5IHRoZSBzYW1lIHNsb3BlKS4gRm9yIGFueSBzbW9vdGggY29udHJvbCBwb2ludHMsIGl0IGNvbnZlcnRzIHRoZSBjb29yZGluYXRlcyBpbnRvIGFuZ2xlICh4LCBpbiByYWRpYW5zKSBhbmQgbGVuZ3RoICh5KSBhbmQgcHV0cyB0aGVtIGludG8gdGhlIHNhbWUgaW5kZXggdmFsdWUgaW4gYSBzbW9vdGhEYXRhIGFycmF5LlxuZXhwb3J0IGZ1bmN0aW9uIHBvcHVsYXRlU21vb3RoRGF0YShyYXdQYXRoKSB7XG5cdGxldCBqID0gcmF3UGF0aC5sZW5ndGgsXG5cdFx0c21vb3RoLCBzZWdtZW50LCB4LCB5LCB4MiwgeTIsIGksIGwsIGEsIGEyLCBpc1Ntb290aCwgc21vb3RoRGF0YTtcblx0d2hpbGUgKC0taiA+IC0xKSB7XG5cdFx0c2VnbWVudCA9IHJhd1BhdGhbal07XG5cdFx0aXNTbW9vdGggPSBzZWdtZW50LmlzU21vb3RoID0gc2VnbWVudC5pc1Ntb290aCB8fCBbMCwgMCwgMCwgMF07XG5cdFx0c21vb3RoRGF0YSA9IHNlZ21lbnQuc21vb3RoRGF0YSA9IHNlZ21lbnQuc21vb3RoRGF0YSB8fCBbMCwgMCwgMCwgMF07XG5cdFx0aXNTbW9vdGgubGVuZ3RoID0gNDtcblx0XHRsID0gc2VnbWVudC5sZW5ndGggLSAyO1xuXHRcdGZvciAoaSA9IDY7IGkgPCBsOyBpICs9IDYpIHtcblx0XHRcdHggPSBzZWdtZW50W2ldIC0gc2VnbWVudFtpIC0gMl07XG5cdFx0XHR5ID0gc2VnbWVudFtpICsgMV0gLSBzZWdtZW50W2kgLSAxXTtcblx0XHRcdHgyID0gc2VnbWVudFtpICsgMl0gLSBzZWdtZW50W2ldO1xuXHRcdFx0eTIgPSBzZWdtZW50W2kgKyAzXSAtIHNlZ21lbnRbaSArIDFdO1xuXHRcdFx0YSA9IF9hdGFuMih5LCB4KTtcblx0XHRcdGEyID0gX2F0YW4yKHkyLCB4Mik7XG5cdFx0XHRzbW9vdGggPSAoTWF0aC5hYnMoYSAtIGEyKSA8IDAuMDkpO1xuXHRcdFx0aWYgKHNtb290aCkge1xuXHRcdFx0XHRzbW9vdGhEYXRhW2kgLSAyXSA9IGE7XG5cdFx0XHRcdHNtb290aERhdGFbaSArIDJdID0gYTI7XG5cdFx0XHRcdHNtb290aERhdGFbaSAtIDFdID0gX3NxcnQoeCAqIHggKyB5ICogeSk7XG5cdFx0XHRcdHNtb290aERhdGFbaSArIDNdID0gX3NxcnQoeDIgKiB4MiArIHkyICogeTIpO1xuXHRcdFx0fVxuXHRcdFx0aXNTbW9vdGgucHVzaChzbW9vdGgsIHNtb290aCwgMCwgMCwgc21vb3RoLCBzbW9vdGgpO1xuXHRcdH1cblx0XHQvL2lmIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludHMgYXJlIGlkZW50aWNhbCwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBzbW9vdGggdHJhbnNpdGlvbi4gV2UgbXVzdCBoYW5kbGUgdGhpcyBhIGJpdCBkaWZmZXJlbnRseSBkdWUgdG8gdGhlaXIgcG9zaXRpb25zIGluIHRoZSBhcnJheS5cblx0XHRpZiAoc2VnbWVudFtsXSA9PT0gc2VnbWVudFswXSAmJiBzZWdtZW50W2wrMV0gPT09IHNlZ21lbnRbMV0pIHtcblx0XHRcdHggPSBzZWdtZW50WzBdIC0gc2VnbWVudFtsLTJdO1xuXHRcdFx0eSA9IHNlZ21lbnRbMV0gLSBzZWdtZW50W2wtMV07XG5cdFx0XHR4MiA9IHNlZ21lbnRbMl0gLSBzZWdtZW50WzBdO1xuXHRcdFx0eTIgPSBzZWdtZW50WzNdIC0gc2VnbWVudFsxXTtcblx0XHRcdGEgPSBfYXRhbjIoeSwgeCk7XG5cdFx0XHRhMiA9IF9hdGFuMih5MiwgeDIpO1xuXHRcdFx0aWYgKE1hdGguYWJzKGEgLSBhMikgPCAwLjA5KSB7XG5cdFx0XHRcdHNtb290aERhdGFbbC0yXSA9IGE7XG5cdFx0XHRcdHNtb290aERhdGFbMl0gPSBhMjtcblx0XHRcdFx0c21vb3RoRGF0YVtsLTFdID0gX3NxcnQoeCAqIHggKyB5ICogeSk7XG5cdFx0XHRcdHNtb290aERhdGFbM10gPSBfc3FydCh4MiAqIHgyICsgeTIgKiB5Mik7XG5cdFx0XHRcdGlzU21vb3RoW2wtMl0gPSBpc1Ntb290aFtsLTFdID0gdHJ1ZTsgLy9kb24ndCBjaGFuZ2UgaW5kZXhlcyAyIGFuZCAzIGJlY2F1c2Ugd2UnbGwgdHJpZ2dlciBldmVyeXRoaW5nIGZyb20gdGhlIEVORCwgYW5kIHRoaXMgd2lsbCBvcHRpbWl6ZSBmaWxlIHNpemUgYSBiaXQuXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiByYXdQYXRoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50VG9TY3JlZW4oc3ZnRWxlbWVudCwgcG9pbnQpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7IC8vYnkgZGVmYXVsdCwgdGFrZSB0aGUgZmlyc3Qgc2V0IG9mIGNvb3JkaW5hdGVzIGluIHRoZSBwYXRoIGFzIHRoZSBwb2ludFxuXHRcdGxldCByYXdQYXRoID0gZ2V0UmF3UGF0aChzdmdFbGVtZW50KTtcblx0XHRwb2ludCA9IHN2Z0VsZW1lbnQub3duZXJTVkdFbGVtZW50LmNyZWF0ZVNWR1BvaW50KCk7XG5cdFx0cG9pbnQueCA9IHJhd1BhdGhbMF1bMF07XG5cdFx0cG9pbnQueSA9IHJhd1BhdGhbMF1bMV07XG5cdH1cblx0cmV0dXJuIHBvaW50Lm1hdHJpeFRyYW5zZm9ybShzdmdFbGVtZW50LmdldFNjcmVlbkNUTSgpKTtcbn1cblxuKi8iLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIVxuICogTW9ycGhTVkdQbHVnaW4gMy4yLjZcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjAsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyBnZXRSYXdQYXRoLCByZXZlcnNlU2VnbWVudCwgc3RyaW5nVG9SYXdQYXRoLCByYXdQYXRoVG9TdHJpbmcsIGNvbnZlcnRUb1BhdGggYXMgX2NvbnZlcnRUb1BhdGggfSBmcm9tIFwiLi4vdXRpbHMvcGF0aHMuanNcIjtcblxudmFyIGdzYXAsXG4gICAgX3RvQXJyYXksXG4gICAgX2xhc3RMaW5rZWRBbmNob3IsXG4gICAgX2RvYyxcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgUGx1Z2luQ2xhc3MsXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9hdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgX2NvcyA9IE1hdGguY29zLFxuICAgIF9zaW4gPSBNYXRoLnNpbixcbiAgICBfc3FydCA9IE1hdGguc3FydCxcbiAgICBfUEkgPSBNYXRoLlBJLFxuICAgIF8yUEkgPSBfUEkgKiAyLFxuICAgIF9hbmdsZU1pbiA9IF9QSSAqIDAuMyxcbiAgICBfYW5nbGVNYXggPSBfUEkgKiAwLjcsXG4gICAgX2JpZ051bSA9IDFlMjAsXG4gICAgX251bUV4cCA9IC9bLSs9XFwuXSpcXGQrW1xcLmVcXC1cXCtdKlxcZCpbZVxcLVxcK10qXFxkKi9naSxcbiAgICAvL2ZpbmRzIGFueSBudW1iZXJzLCBpbmNsdWRpbmcgb25lcyB0aGF0IHN0YXJ0IHdpdGggKz0gb3IgLT0sIG5lZ2F0aXZlIG51bWJlcnMsIGFuZCBvbmVzIGluIHNjaWVudGlmaWMgbm90YXRpb24gbGlrZSAxZS04LlxuX3NlbGVjdG9yRXhwID0gLyheWyNcXC5dW2Etel18W2EteV1bYS16XSkvZ2ksXG4gICAgX2NvbW1hbmRzID0gL1thY2hsbXFzdHZ6XS9pZyxcbiAgICBfbG9nID0gZnVuY3Rpb24gX2xvZyhtZXNzYWdlKSB7XG4gIHJldHVybiBjb25zb2xlICYmIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbn0sXG4gICAgX2JvbnVzVmFsaWRhdGVkID0gMSxcbiAgICAvLzxuYW1lPk1vcnBoU1ZHUGx1Z2luPC9uYW1lPlxuX2dldEF2ZXJhZ2VYWSA9IGZ1bmN0aW9uIF9nZXRBdmVyYWdlWFkoc2VnbWVudCkge1xuICB2YXIgbCA9IHNlZ21lbnQubGVuZ3RoLFxuICAgICAgeCA9IDAsXG4gICAgICB5ID0gMCxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHggKz0gc2VnbWVudFtpKytdO1xuICAgIHkgKz0gc2VnbWVudFtpXTtcbiAgfVxuXG4gIHJldHVybiBbeCAvIChsIC8gMiksIHkgLyAobCAvIDIpXTtcbn0sXG4gICAgX2dldFNpemUgPSBmdW5jdGlvbiBfZ2V0U2l6ZShzZWdtZW50KSB7XG4gIC8vcm91Z2ggZXN0aW1hdGUgb2YgdGhlIGJvdW5kaW5nIGJveCAoYmFzZWQgc29sZWx5IG9uIHRoZSBhbmNob3JzKSBvZiBhIHNpbmdsZSBzZWdtZW50LiBzZXRzIFwic2l6ZVwiLCBcImNlbnRlclhcIiwgYW5kIFwiY2VudGVyWVwiIHByb3BlcnRpZXMgb24gdGhlIGJlemllciBhcnJheSBpdHNlbGYsIGFuZCByZXR1cm5zIHRoZSBzaXplICh3aWR0aCAqIGhlaWdodClcbiAgdmFyIGwgPSBzZWdtZW50Lmxlbmd0aCxcbiAgICAgIHhNYXggPSBzZWdtZW50WzBdLFxuICAgICAgeE1pbiA9IHhNYXgsXG4gICAgICB5TWF4ID0gc2VnbWVudFsxXSxcbiAgICAgIHlNaW4gPSB5TWF4LFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDY7IGkgPCBsOyBpICs9IDYpIHtcbiAgICB4ID0gc2VnbWVudFtpXTtcbiAgICB5ID0gc2VnbWVudFtpICsgMV07XG5cbiAgICBpZiAoeCA+IHhNYXgpIHtcbiAgICAgIHhNYXggPSB4O1xuICAgIH0gZWxzZSBpZiAoeCA8IHhNaW4pIHtcbiAgICAgIHhNaW4gPSB4O1xuICAgIH1cblxuICAgIGlmICh5ID4geU1heCkge1xuICAgICAgeU1heCA9IHk7XG4gICAgfSBlbHNlIGlmICh5IDwgeU1pbikge1xuICAgICAgeU1pbiA9IHk7XG4gICAgfVxuICB9XG5cbiAgc2VnbWVudC5jZW50ZXJYID0gKHhNYXggKyB4TWluKSAvIDI7XG4gIHNlZ21lbnQuY2VudGVyWSA9ICh5TWF4ICsgeU1pbikgLyAyO1xuICByZXR1cm4gc2VnbWVudC5zaXplID0gKHhNYXggLSB4TWluKSAqICh5TWF4IC0geU1pbik7XG59LFxuICAgIF9nZXRUb3RhbFNpemUgPSBmdW5jdGlvbiBfZ2V0VG90YWxTaXplKHJhd1BhdGgsIHNhbXBsZXNQZXJCZXppZXIpIHtcbiAgaWYgKHNhbXBsZXNQZXJCZXppZXIgPT09IHZvaWQgMCkge1xuICAgIHNhbXBsZXNQZXJCZXppZXIgPSAzO1xuICB9IC8vcm91Z2ggZXN0aW1hdGUgb2YgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZW50aXJlIGxpc3Qgb2YgQmV6aWVyIHNlZ21lbnRzIChiYXNlZCBzb2xlbHkgb24gdGhlIGFuY2hvcnMpLiBzZXRzIFwic2l6ZVwiLCBcImNlbnRlclhcIiwgYW5kIFwiY2VudGVyWVwiIHByb3BlcnRpZXMgb24gdGhlIGJlemllciBhcnJheSBpdHNlbGYsIGFuZCByZXR1cm5zIHRoZSBzaXplICh3aWR0aCAqIGhlaWdodClcblxuXG4gIHZhciBqID0gcmF3UGF0aC5sZW5ndGgsXG4gICAgICB4TWF4ID0gcmF3UGF0aFswXVswXSxcbiAgICAgIHhNaW4gPSB4TWF4LFxuICAgICAgeU1heCA9IHJhd1BhdGhbMF1bMV0sXG4gICAgICB5TWluID0geU1heCxcbiAgICAgIGluYyA9IDEgLyBzYW1wbGVzUGVyQmV6aWVyLFxuICAgICAgbCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaSxcbiAgICAgIHNlZ21lbnQsXG4gICAgICBrLFxuICAgICAgdCxcbiAgICAgIGludixcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MixcbiAgICAgIHgzLFxuICAgICAgeDQsXG4gICAgICB5MixcbiAgICAgIHkzLFxuICAgICAgeTQ7XG5cbiAgd2hpbGUgKC0taiA+IC0xKSB7XG4gICAgc2VnbWVudCA9IHJhd1BhdGhbal07XG4gICAgbCA9IHNlZ21lbnQubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gNjsgaSA8IGw7IGkgKz0gNikge1xuICAgICAgeDEgPSBzZWdtZW50W2ldO1xuICAgICAgeTEgPSBzZWdtZW50W2kgKyAxXTtcbiAgICAgIHgyID0gc2VnbWVudFtpICsgMl0gLSB4MTtcbiAgICAgIHkyID0gc2VnbWVudFtpICsgM10gLSB5MTtcbiAgICAgIHgzID0gc2VnbWVudFtpICsgNF0gLSB4MTtcbiAgICAgIHkzID0gc2VnbWVudFtpICsgNV0gLSB5MTtcbiAgICAgIHg0ID0gc2VnbWVudFtpICsgNl0gLSB4MTtcbiAgICAgIHk0ID0gc2VnbWVudFtpICsgN10gLSB5MTtcbiAgICAgIGsgPSBzYW1wbGVzUGVyQmV6aWVyO1xuXG4gICAgICB3aGlsZSAoLS1rID4gLTEpIHtcbiAgICAgICAgdCA9IGluYyAqIGs7XG4gICAgICAgIGludiA9IDEgLSB0O1xuICAgICAgICB4ID0gKHQgKiB0ICogeDQgKyAzICogaW52ICogKHQgKiB4MyArIGludiAqIHgyKSkgKiB0ICsgeDE7XG4gICAgICAgIHkgPSAodCAqIHQgKiB5NCArIDMgKiBpbnYgKiAodCAqIHkzICsgaW52ICogeTIpKSAqIHQgKyB5MTtcblxuICAgICAgICBpZiAoeCA+IHhNYXgpIHtcbiAgICAgICAgICB4TWF4ID0geDtcbiAgICAgICAgfSBlbHNlIGlmICh4IDwgeE1pbikge1xuICAgICAgICAgIHhNaW4gPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkgPiB5TWF4KSB7XG4gICAgICAgICAgeU1heCA9IHk7XG4gICAgICAgIH0gZWxzZSBpZiAoeSA8IHlNaW4pIHtcbiAgICAgICAgICB5TWluID0geTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJhd1BhdGguY2VudGVyWCA9ICh4TWF4ICsgeE1pbikgLyAyO1xuICByYXdQYXRoLmNlbnRlclkgPSAoeU1heCArIHlNaW4pIC8gMjtcbiAgcmF3UGF0aC5sZWZ0ID0geE1pbjtcbiAgcmF3UGF0aC53aWR0aCA9IHhNYXggLSB4TWluO1xuICByYXdQYXRoLnRvcCA9IHlNaW47XG4gIHJhd1BhdGguaGVpZ2h0ID0geU1heCAtIHlNaW47XG4gIHJldHVybiByYXdQYXRoLnNpemUgPSAoeE1heCAtIHhNaW4pICogKHlNYXggLSB5TWluKTtcbn0sXG4gICAgX3NvcnRCeUNvbXBsZXhpdHkgPSBmdW5jdGlvbiBfc29ydEJ5Q29tcGxleGl0eShhLCBiKSB7XG4gIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xufSxcbiAgICBfc29ydEJ5U2l6ZSA9IGZ1bmN0aW9uIF9zb3J0QnlTaXplKGEsIGIpIHtcbiAgdmFyIHNpemVBID0gYS5zaXplIHx8IF9nZXRTaXplKGEpLFxuICAgICAgc2l6ZUIgPSBiLnNpemUgfHwgX2dldFNpemUoYik7XG5cbiAgcmV0dXJuIE1hdGguYWJzKHNpemVCIC0gc2l6ZUEpIDwgKHNpemVBICsgc2l6ZUIpIC8gMjAgPyBiLmNlbnRlclggLSBhLmNlbnRlclggfHwgYi5jZW50ZXJZIC0gYS5jZW50ZXJZIDogc2l6ZUIgLSBzaXplQTsgLy9pZiB0aGUgc2l6ZSBpcyB3aXRoaW4gMTAlIG9mIGVhY2ggb3RoZXIsIHByaW9yaXRpemUgcG9zaXRpb24gZnJvbSBsZWZ0IHRvIHJpZ2h0LCB0aGVuIHRvcCB0byBib3R0b20uXG59LFxuICAgIF9vZmZzZXRTZWdtZW50ID0gZnVuY3Rpb24gX29mZnNldFNlZ21lbnQoc2VnbWVudCwgc2hhcGVJbmRleCkge1xuICB2YXIgYSA9IHNlZ21lbnQuc2xpY2UoMCksXG4gICAgICBsID0gc2VnbWVudC5sZW5ndGgsXG4gICAgICB3cmFwID0gbCAtIDIsXG4gICAgICBpLFxuICAgICAgaW5kZXg7XG4gIHNoYXBlSW5kZXggPSBzaGFwZUluZGV4IHwgMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgaW5kZXggPSAoaSArIHNoYXBlSW5kZXgpICUgd3JhcDtcbiAgICBzZWdtZW50W2krK10gPSBhW2luZGV4XTtcbiAgICBzZWdtZW50W2ldID0gYVtpbmRleCArIDFdO1xuICB9XG59LFxuICAgIF9nZXRUb3RhbE1vdmVtZW50ID0gZnVuY3Rpb24gX2dldFRvdGFsTW92ZW1lbnQoc2IsIGViLCBzaGFwZUluZGV4LCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gIHZhciBsID0gc2IubGVuZ3RoLFxuICAgICAgZCA9IDAsXG4gICAgICB3cmFwID0gbCAtIDIsXG4gICAgICBpbmRleCxcbiAgICAgIGksXG4gICAgICB4LFxuICAgICAgeTtcbiAgc2hhcGVJbmRleCAqPSA2O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDYpIHtcbiAgICBpbmRleCA9IChpICsgc2hhcGVJbmRleCkgJSB3cmFwO1xuICAgIHkgPSBzYltpbmRleF0gLSAoZWJbaV0gLSBvZmZzZXRYKTtcbiAgICB4ID0gc2JbaW5kZXggKyAxXSAtIChlYltpICsgMV0gLSBvZmZzZXRZKTtcbiAgICBkICs9IF9zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICB9XG5cbiAgcmV0dXJuIGQ7XG59LFxuICAgIF9nZXRDbG9zZXN0U2hhcGVJbmRleCA9IGZ1bmN0aW9uIF9nZXRDbG9zZXN0U2hhcGVJbmRleChzYiwgZWIsIGNoZWNrUmV2ZXJzZSkge1xuICAvL2ZpbmRzIHRoZSBpbmRleCBpbiBhIGNsb3NlZCBjdWJpYyBiZXppZXIgYXJyYXkgdGhhdCdzIGNsb3Nlc3QgdG8gdGhlIGFuZ2xlIHByb3ZpZGVkIChhbmdsZSBtZWFzdXJlZCBmcm9tIHRoZSBjZW50ZXIgb3IgYXZlcmFnZSB4L3kpLlxuICB2YXIgbCA9IHNiLmxlbmd0aCxcbiAgICAgIHNDZW50ZXIgPSBfZ2V0QXZlcmFnZVhZKHNiKSxcbiAgICAgIC8vd2hlbiBjb21wYXJpbmcgZGlzdGFuY2VzLCBhZGp1c3QgdGhlIGNvb3JkaW5hdGVzIGFzIGlmIHRoZSBzaGFwZXMgYXJlIGNlbnRlcmVkIHdpdGggZWFjaCBvdGhlci5cbiAgZUNlbnRlciA9IF9nZXRBdmVyYWdlWFkoZWIpLFxuICAgICAgb2Zmc2V0WCA9IGVDZW50ZXJbMF0gLSBzQ2VudGVyWzBdLFxuICAgICAgb2Zmc2V0WSA9IGVDZW50ZXJbMV0gLSBzQ2VudGVyWzFdLFxuICAgICAgbWluID0gX2dldFRvdGFsTW92ZW1lbnQoc2IsIGViLCAwLCBvZmZzZXRYLCBvZmZzZXRZKSxcbiAgICAgIG1pbkluZGV4ID0gMCxcbiAgICAgIGNvcHksXG4gICAgICBkLFxuICAgICAgaTtcblxuICBmb3IgKGkgPSA2OyBpIDwgbDsgaSArPSA2KSB7XG4gICAgZCA9IF9nZXRUb3RhbE1vdmVtZW50KHNiLCBlYiwgaSAvIDYsIG9mZnNldFgsIG9mZnNldFkpO1xuXG4gICAgaWYgKGQgPCBtaW4pIHtcbiAgICAgIG1pbiA9IGQ7XG4gICAgICBtaW5JbmRleCA9IGk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNoZWNrUmV2ZXJzZSkge1xuICAgIGNvcHkgPSBzYi5zbGljZSgwKTtcbiAgICByZXZlcnNlU2VnbWVudChjb3B5KTtcblxuICAgIGZvciAoaSA9IDY7IGkgPCBsOyBpICs9IDYpIHtcbiAgICAgIGQgPSBfZ2V0VG90YWxNb3ZlbWVudChjb3B5LCBlYiwgaSAvIDYsIG9mZnNldFgsIG9mZnNldFkpO1xuXG4gICAgICBpZiAoZCA8IG1pbikge1xuICAgICAgICBtaW4gPSBkO1xuICAgICAgICBtaW5JbmRleCA9IC1pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaW5JbmRleCAvIDY7XG59LFxuICAgIF9nZXRDbG9zZXN0QW5jaG9yID0gZnVuY3Rpb24gX2dldENsb3Nlc3RBbmNob3IocmF3UGF0aCwgeCwgeSkge1xuICAvL2ZpbmRzIHRoZSB4L3kgb2YgdGhlIGFuY2hvciB0aGF0J3MgY2xvc2VzdCB0byB0aGUgcHJvdmlkZWQgeC95IGNvb3JkaW5hdGUgKHJldHVybnMgYW4gYXJyYXksIGxpa2UgW3gsIHldKS4gVGhlIGJlemllciBzaG91bGQgYmUgdGhlIHRvcC1sZXZlbCB0eXBlIHRoYXQgY29udGFpbnMgYW4gYXJyYXkgZm9yIGVhY2ggc2VnbWVudC5cbiAgdmFyIGogPSByYXdQYXRoLmxlbmd0aCxcbiAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IF9iaWdOdW0sXG4gICAgICBjbG9zZXN0WCA9IDAsXG4gICAgICBjbG9zZXN0WSA9IDAsXG4gICAgICBzZWdtZW50LFxuICAgICAgZHgsXG4gICAgICBkeSxcbiAgICAgIGQsXG4gICAgICBpLFxuICAgICAgbDtcblxuICB3aGlsZSAoLS1qID4gLTEpIHtcbiAgICBzZWdtZW50ID0gcmF3UGF0aFtqXTtcbiAgICBsID0gc2VnbWVudC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSA2KSB7XG4gICAgICBkeCA9IHNlZ21lbnRbaV0gLSB4O1xuICAgICAgZHkgPSBzZWdtZW50W2kgKyAxXSAtIHk7XG4gICAgICBkID0gX3NxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICBpZiAoZCA8IGNsb3Nlc3REaXN0YW5jZSkge1xuICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkO1xuICAgICAgICBjbG9zZXN0WCA9IHNlZ21lbnRbaV07XG4gICAgICAgIGNsb3Nlc3RZID0gc2VnbWVudFtpICsgMV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtjbG9zZXN0WCwgY2xvc2VzdFldO1xufSxcbiAgICBfZ2V0Q2xvc2VzdFNlZ21lbnQgPSBmdW5jdGlvbiBfZ2V0Q2xvc2VzdFNlZ21lbnQoYmV6aWVyLCBwb29sLCBzdGFydEluZGV4LCBzb3J0UmF0aW8sIG9mZnNldFgsIG9mZnNldFkpIHtcbiAgLy9tYXRjaGVzIHRoZSBiZXppZXIgdG8gdGhlIGNsb3Nlc3Qgb25lIGluIGEgcG9vbCAoYXJyYXkpIG9mIGJlemllcnMsIGFzc3VtaW5nIHRoZXkgYXJlIGluIG9yZGVyIG9mIHNpemUgYW5kIHdlIHNob3VsZG4ndCBkcm9wIG1vcmUgdGhhbiAyMCUgb2YgdGhlIHNpemUsIG90aGVyd2lzZSBwcmlvcml0aXppbmcgbG9jYXRpb24gKHRvdGFsIGRpc3RhbmNlIHRvIHRoZSBjZW50ZXIpLiBFeHRyYWN0cyB0aGUgc2VnbWVudCBvdXQgb2YgdGhlIHBvb2wgYXJyYXkgYW5kIHJldHVybnMgaXQuXG4gIHZhciBsID0gcG9vbC5sZW5ndGgsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBtaW5TaXplID0gTWF0aC5taW4oYmV6aWVyLnNpemUgfHwgX2dldFNpemUoYmV6aWVyKSwgcG9vbFtzdGFydEluZGV4XS5zaXplIHx8IF9nZXRTaXplKHBvb2xbc3RhcnRJbmRleF0pKSAqIHNvcnRSYXRpbyxcbiAgICAgIC8vbGltaXQgdGhpbmdzIGJhc2VkIG9uIGEgcGVyY2VudGFnZSBvZiB0aGUgc2l6ZSBvZiBlaXRoZXIgdGhlIGJlemllciBvciB0aGUgbmV4dCBlbGVtZW50IGluIHRoZSBhcnJheSwgd2hpY2hldmVyIGlzIHNtYWxsZXIuXG4gIG1pbiA9IF9iaWdOdW0sXG4gICAgICBjeCA9IGJlemllci5jZW50ZXJYICsgb2Zmc2V0WCxcbiAgICAgIGN5ID0gYmV6aWVyLmNlbnRlclkgKyBvZmZzZXRZLFxuICAgICAgc2l6ZSxcbiAgICAgIGksXG4gICAgICBkeCxcbiAgICAgIGR5LFxuICAgICAgZDtcblxuICBmb3IgKGkgPSBzdGFydEluZGV4OyBpIDwgbDsgaSsrKSB7XG4gICAgc2l6ZSA9IHBvb2xbaV0uc2l6ZSB8fCBfZ2V0U2l6ZShwb29sW2ldKTtcblxuICAgIGlmIChzaXplIDwgbWluU2l6ZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZHggPSBwb29sW2ldLmNlbnRlclggLSBjeDtcbiAgICBkeSA9IHBvb2xbaV0uY2VudGVyWSAtIGN5O1xuICAgIGQgPSBfc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICBpZiAoZCA8IG1pbikge1xuICAgICAgaW5kZXggPSBpO1xuICAgICAgbWluID0gZDtcbiAgICB9XG4gIH1cblxuICBkID0gcG9vbFtpbmRleF07XG4gIHBvb2wuc3BsaWNlKGluZGV4LCAxKTtcbiAgcmV0dXJuIGQ7XG59LFxuICAgIF9zdWJkaXZpZGVTZWdtZW50UXR5ID0gZnVuY3Rpb24gX3N1YmRpdmlkZVNlZ21lbnRRdHkoc2VnbWVudCwgcXVhbnRpdHkpIHtcbiAgdmFyIHRhbGx5ID0gMCxcbiAgICAgIG1heCA9IDAuOTk5OTk5LFxuICAgICAgbCA9IHNlZ21lbnQubGVuZ3RoLFxuICAgICAgbmV3UG9pbnRzUGVyU2VnbWVudCA9IHF1YW50aXR5IC8gKChsIC0gMikgLyA2KSxcbiAgICAgIGF4LFxuICAgICAgYXksXG4gICAgICBjcDF4LFxuICAgICAgY3AxeSxcbiAgICAgIGNwMngsXG4gICAgICBjcDJ5LFxuICAgICAgYngsXG4gICAgICBieSxcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MixcbiAgICAgIHkyLFxuICAgICAgaSxcbiAgICAgIHQ7XG5cbiAgZm9yIChpID0gMjsgaSA8IGw7IGkgKz0gNikge1xuICAgIHRhbGx5ICs9IG5ld1BvaW50c1BlclNlZ21lbnQ7XG5cbiAgICB3aGlsZSAodGFsbHkgPiBtYXgpIHtcbiAgICAgIC8vY29tcGFyZSB3aXRoIDAuOTk5OTkgaW5zdGVhZCBvZiAxIGluIG9yZGVyIHRvIHByZXZlbnQgcm91bmRpbmcgZXJyb3JzXG4gICAgICBheCA9IHNlZ21lbnRbaSAtIDJdO1xuICAgICAgYXkgPSBzZWdtZW50W2kgLSAxXTtcbiAgICAgIGNwMXggPSBzZWdtZW50W2ldO1xuICAgICAgY3AxeSA9IHNlZ21lbnRbaSArIDFdO1xuICAgICAgY3AyeCA9IHNlZ21lbnRbaSArIDJdO1xuICAgICAgY3AyeSA9IHNlZ21lbnRbaSArIDNdO1xuICAgICAgYnggPSBzZWdtZW50W2kgKyA0XTtcbiAgICAgIGJ5ID0gc2VnbWVudFtpICsgNV07XG4gICAgICB0ID0gMSAvICgoTWF0aC5mbG9vcih0YWxseSkgfHwgMSkgKyAxKTsgLy9wcm9ncmVzcyBhbG9uZyB0aGUgYmV6aWVyICh2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEpXG5cbiAgICAgIHgxID0gYXggKyAoY3AxeCAtIGF4KSAqIHQ7XG4gICAgICB4MiA9IGNwMXggKyAoY3AyeCAtIGNwMXgpICogdDtcbiAgICAgIHgxICs9ICh4MiAtIHgxKSAqIHQ7XG4gICAgICB4MiArPSAoY3AyeCArIChieCAtIGNwMngpICogdCAtIHgyKSAqIHQ7XG4gICAgICB5MSA9IGF5ICsgKGNwMXkgLSBheSkgKiB0O1xuICAgICAgeTIgPSBjcDF5ICsgKGNwMnkgLSBjcDF5KSAqIHQ7XG4gICAgICB5MSArPSAoeTIgLSB5MSkgKiB0O1xuICAgICAgeTIgKz0gKGNwMnkgKyAoYnkgLSBjcDJ5KSAqIHQgLSB5MikgKiB0O1xuICAgICAgc2VnbWVudC5zcGxpY2UoaSwgNCwgYXggKyAoY3AxeCAtIGF4KSAqIHQsIC8vZmlyc3QgY29udHJvbCBwb2ludFxuICAgICAgYXkgKyAoY3AxeSAtIGF5KSAqIHQsIHgxLCAvL3NlY29uZCBjb250cm9sIHBvaW50XG4gICAgICB5MSwgeDEgKyAoeDIgLSB4MSkgKiB0LCAvL25ldyBmYWJyaWNhdGVkIGFuY2hvciBvbiBsaW5lXG4gICAgICB5MSArICh5MiAtIHkxKSAqIHQsIHgyLCAvL3RoaXJkIGNvbnRyb2wgcG9pbnRcbiAgICAgIHkyLCBjcDJ4ICsgKGJ4IC0gY3AyeCkgKiB0LCAvL2ZvdXJ0aCBjb250cm9sIHBvaW50XG4gICAgICBjcDJ5ICsgKGJ5IC0gY3AyeSkgKiB0KTtcbiAgICAgIGkgKz0gNjtcbiAgICAgIGwgKz0gNjtcbiAgICAgIHRhbGx5LS07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnQ7XG59LFxuICAgIF9lcXVhbGl6ZVNlZ21lbnRRdWFudGl0eSA9IGZ1bmN0aW9uIF9lcXVhbGl6ZVNlZ21lbnRRdWFudGl0eShzdGFydCwgZW5kLCBzaGFwZUluZGV4LCBtYXAsIGZpbGxTYWZlKSB7XG4gIC8vcmV0dXJucyBhbiBhcnJheSBvZiBzaGFwZSBpbmRleGVzLCAxIGZvciBlYWNoIHNlZ21lbnQuXG4gIHZhciBkaWYgPSBlbmQubGVuZ3RoIC0gc3RhcnQubGVuZ3RoLFxuICAgICAgbG9uZ2VyID0gZGlmID4gMCA/IGVuZCA6IHN0YXJ0LFxuICAgICAgc2hvcnRlciA9IGRpZiA+IDAgPyBzdGFydCA6IGVuZCxcbiAgICAgIGFkZGVkID0gMCxcbiAgICAgIHNvcnRNZXRob2QgPSBtYXAgPT09IFwiY29tcGxleGl0eVwiID8gX3NvcnRCeUNvbXBsZXhpdHkgOiBfc29ydEJ5U2l6ZSxcbiAgICAgIHNvcnRSYXRpbyA9IG1hcCA9PT0gXCJwb3NpdGlvblwiID8gMCA6IHR5cGVvZiBtYXAgPT09IFwibnVtYmVyXCIgPyBtYXAgOiAwLjgsXG4gICAgICBpID0gc2hvcnRlci5sZW5ndGgsXG4gICAgICBzaGFwZUluZGljZXMgPSBfdHlwZW9mKHNoYXBlSW5kZXgpID09PSBcIm9iamVjdFwiICYmIHNoYXBlSW5kZXgucHVzaCA/IHNoYXBlSW5kZXguc2xpY2UoMCkgOiBbc2hhcGVJbmRleF0sXG4gICAgICByZXZlcnNlID0gc2hhcGVJbmRpY2VzWzBdID09PSBcInJldmVyc2VcIiB8fCBzaGFwZUluZGljZXNbMF0gPCAwLFxuICAgICAgbG9nID0gc2hhcGVJbmRleCA9PT0gXCJsb2dcIixcbiAgICAgIGViLFxuICAgICAgc2IsXG4gICAgICBiLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WTtcblxuICBpZiAoIXNob3J0ZXJbMF0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAobG9uZ2VyLmxlbmd0aCA+IDEpIHtcbiAgICBzdGFydC5zb3J0KHNvcnRNZXRob2QpO1xuICAgIGVuZC5zb3J0KHNvcnRNZXRob2QpO1xuICAgIG9mZnNldFggPSBsb25nZXIuc2l6ZSB8fCBfZ2V0VG90YWxTaXplKGxvbmdlcik7IC8vZW5zdXJlcyBjZW50ZXJYIGFuZCBjZW50ZXJZIGFyZSBkZWZpbmVkICh1c2VkIGJlbG93KS5cblxuICAgIG9mZnNldFggPSBzaG9ydGVyLnNpemUgfHwgX2dldFRvdGFsU2l6ZShzaG9ydGVyKTtcbiAgICBvZmZzZXRYID0gbG9uZ2VyLmNlbnRlclggLSBzaG9ydGVyLmNlbnRlclg7XG4gICAgb2Zmc2V0WSA9IGxvbmdlci5jZW50ZXJZIC0gc2hvcnRlci5jZW50ZXJZO1xuXG4gICAgaWYgKHNvcnRNZXRob2QgPT09IF9zb3J0QnlTaXplKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc2hvcnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsb25nZXIuc3BsaWNlKGksIDAsIF9nZXRDbG9zZXN0U2VnbWVudChzaG9ydGVyW2ldLCBsb25nZXIsIGksIHNvcnRSYXRpbywgb2Zmc2V0WCwgb2Zmc2V0WSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaWYpIHtcbiAgICBpZiAoZGlmIDwgMCkge1xuICAgICAgZGlmID0gLWRpZjtcbiAgICB9XG5cbiAgICBpZiAobG9uZ2VyWzBdLmxlbmd0aCA+IHNob3J0ZXJbMF0ubGVuZ3RoKSB7XG4gICAgICAvL3NpbmNlIHdlIHVzZSBzaG9ydGVyWzBdIGFzIHRoZSBvbmUgdG8gbWFwIHRoZSBvcmlnaW5hdGlvbiBwb2ludCBvZiBhbnkgYnJhbmQgbmV3IGZhYnJpY2F0ZWQgc2VnbWVudHMsIGRvIGFueSBzdWJkaXZpZGluZyBmaXJzdCBzbyB0aGF0IHRoZXJlIGFyZSBtb3JlIHBvaW50cyB0byBjaG9vc2UgZnJvbSAoaWYgbmVjZXNzYXJ5KVxuICAgICAgX3N1YmRpdmlkZVNlZ21lbnRRdHkoc2hvcnRlclswXSwgKGxvbmdlclswXS5sZW5ndGggLSBzaG9ydGVyWzBdLmxlbmd0aCkgLyA2IHwgMCk7XG4gICAgfVxuXG4gICAgaSA9IHNob3J0ZXIubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGFkZGVkIDwgZGlmKSB7XG4gICAgICB4ID0gbG9uZ2VyW2ldLnNpemUgfHwgX2dldFNpemUobG9uZ2VyW2ldKTsgLy9qdXN0IHRvIGVuc3VyZSBjZW50ZXJYIGFuZCBjZW50ZXJZIGFyZSBjYWxjdWxhdGVkIHdoaWNoIHdlIHVzZSBvbiB0aGUgbmV4dCBsaW5lLlxuXG4gICAgICBiID0gX2dldENsb3Nlc3RBbmNob3Ioc2hvcnRlciwgbG9uZ2VyW2ldLmNlbnRlclgsIGxvbmdlcltpXS5jZW50ZXJZKTtcbiAgICAgIHggPSBiWzBdO1xuICAgICAgeSA9IGJbMV07XG4gICAgICBzaG9ydGVyW2krK10gPSBbeCwgeSwgeCwgeSwgeCwgeSwgeCwgeV07XG4gICAgICBzaG9ydGVyLnRvdGFsUG9pbnRzICs9IDg7XG4gICAgICBhZGRlZCsrO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBzdGFydC5sZW5ndGg7IGkrKykge1xuICAgIGViID0gZW5kW2ldO1xuICAgIHNiID0gc3RhcnRbaV07XG4gICAgZGlmID0gZWIubGVuZ3RoIC0gc2IubGVuZ3RoO1xuXG4gICAgaWYgKGRpZiA8IDApIHtcbiAgICAgIF9zdWJkaXZpZGVTZWdtZW50UXR5KGViLCAtZGlmIC8gNiB8IDApO1xuICAgIH0gZWxzZSBpZiAoZGlmID4gMCkge1xuICAgICAgX3N1YmRpdmlkZVNlZ21lbnRRdHkoc2IsIGRpZiAvIDYgfCAwKTtcbiAgICB9XG5cbiAgICBpZiAocmV2ZXJzZSAmJiBmaWxsU2FmZSAhPT0gZmFsc2UgJiYgIXNiLnJldmVyc2VkKSB7XG4gICAgICByZXZlcnNlU2VnbWVudChzYik7XG4gICAgfVxuXG4gICAgc2hhcGVJbmRleCA9IHNoYXBlSW5kaWNlc1tpXSB8fCBzaGFwZUluZGljZXNbaV0gPT09IDAgPyBzaGFwZUluZGljZXNbaV0gOiBcImF1dG9cIjtcblxuICAgIGlmIChzaGFwZUluZGV4KSB7XG4gICAgICAvL2lmIHN0YXJ0IHNoYXBlIGlzIGNsb3NlZCwgZmluZCB0aGUgY2xvc2VzdCBwb2ludCB0byB0aGUgc3RhcnQvZW5kLCBhbmQgcmUtb3JnYW5pemUgdGhlIGJlemllciBwb2ludHMgYWNjb3JkaW5nbHkgc28gdGhhdCB0aGUgc2hhcGUgbW9ycGhzIGluIGEgbW9yZSBpbnR1aXRpdmUgd2F5LlxuICAgICAgaWYgKHNiLmNsb3NlZCB8fCBNYXRoLmFicyhzYlswXSAtIHNiW3NiLmxlbmd0aCAtIDJdKSA8IDAuNSAmJiBNYXRoLmFicyhzYlsxXSAtIHNiW3NiLmxlbmd0aCAtIDFdKSA8IDAuNSkge1xuICAgICAgICBpZiAoc2hhcGVJbmRleCA9PT0gXCJhdXRvXCIgfHwgc2hhcGVJbmRleCA9PT0gXCJsb2dcIikge1xuICAgICAgICAgIHNoYXBlSW5kaWNlc1tpXSA9IHNoYXBlSW5kZXggPSBfZ2V0Q2xvc2VzdFNoYXBlSW5kZXgoc2IsIGViLCAhaSB8fCBmaWxsU2FmZSA9PT0gZmFsc2UpO1xuXG4gICAgICAgICAgaWYgKHNoYXBlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXZlcnNlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldmVyc2VTZWdtZW50KHNiKTtcbiAgICAgICAgICAgIHNoYXBlSW5kZXggPSAtc2hhcGVJbmRleDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfb2Zmc2V0U2VnbWVudChzYiwgc2hhcGVJbmRleCAqIDYpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlSW5kZXggIT09IFwicmV2ZXJzZVwiKSB7XG4gICAgICAgICAgaWYgKGkgJiYgc2hhcGVJbmRleCA8IDApIHtcbiAgICAgICAgICAgIC8vb25seSBoYXBwZW5zIGlmIGFuIGFycmF5IGlzIHBhc3NlZCBhcyBzaGFwZUluZGV4IGFuZCBhIG5lZ2F0aXZlIHZhbHVlIGlzIGRlZmluZWQgZm9yIGFuIGluZGV4IGJleW9uZCAwLiBWZXJ5IHJhcmUsIGJ1dCBoZWxwZnVsIHNvbWV0aW1lcy5cbiAgICAgICAgICAgIHJldmVyc2VTZWdtZW50KHNiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfb2Zmc2V0U2VnbWVudChzYiwgKHNoYXBlSW5kZXggPCAwID8gLXNoYXBlSW5kZXggOiBzaGFwZUluZGV4KSAqIDYpO1xuICAgICAgICB9IC8vb3RoZXJ3aXNlLCBpZiBpdCdzIG5vdCBhIGNsb3NlZCBzaGFwZSwgY29uc2lkZXIgcmV2ZXJzaW5nIGl0IGlmIHRoYXQgd291bGQgbWFrZSB0aGUgb3ZlcmFsbCB0cmF2ZWwgbGVzc1xuXG4gICAgICB9IGVsc2UgaWYgKCFyZXZlcnNlICYmIChzaGFwZUluZGV4ID09PSBcImF1dG9cIiAmJiBNYXRoLmFicyhlYlswXSAtIHNiWzBdKSArIE1hdGguYWJzKGViWzFdIC0gc2JbMV0pICsgTWF0aC5hYnMoZWJbZWIubGVuZ3RoIC0gMl0gLSBzYltzYi5sZW5ndGggLSAyXSkgKyBNYXRoLmFicyhlYltlYi5sZW5ndGggLSAxXSAtIHNiW3NiLmxlbmd0aCAtIDFdKSA+IE1hdGguYWJzKGViWzBdIC0gc2Jbc2IubGVuZ3RoIC0gMl0pICsgTWF0aC5hYnMoZWJbMV0gLSBzYltzYi5sZW5ndGggLSAxXSkgKyBNYXRoLmFicyhlYltlYi5sZW5ndGggLSAyXSAtIHNiWzBdKSArIE1hdGguYWJzKGViW2ViLmxlbmd0aCAtIDFdIC0gc2JbMV0pIHx8IHNoYXBlSW5kZXggJSAyKSkge1xuICAgICAgICByZXZlcnNlU2VnbWVudChzYik7XG4gICAgICAgIHNoYXBlSW5kaWNlc1tpXSA9IC0xO1xuICAgICAgICByZXZlcnNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVJbmRleCA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgc2hhcGVJbmRpY2VzW2ldID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoc2hhcGVJbmRleCA9PT0gXCJyZXZlcnNlXCIpIHtcbiAgICAgICAgc2hhcGVJbmRpY2VzW2ldID0gLTE7XG4gICAgICB9XG5cbiAgICAgIGlmIChzYi5jbG9zZWQgIT09IGViLmNsb3NlZCkge1xuICAgICAgICAvL2lmIG9uZSBpcyBjbG9zZWQgYW5kIG9uZSBpc24ndCwgZG9uJ3QgY2xvc2UgZWl0aGVyIG9uZSBvdGhlcndpc2UgdGhlIHR3ZWVuaW5nIHdpbGwgbG9vayB3ZWlyZCAoYnV0IHJlbWVtYmVyLCB0aGUgYmVnaW5uaW5nIGFuZCBmaW5hbCBzdGF0ZXMgd2lsbCBob25vciB0aGUgYWN0dWFsIHZhbHVlcywgc28gdGhpcyBvbmx5IGFmZmVjdHMgdGhlIGluYmV0d2VlbiBzdGF0ZSlcbiAgICAgICAgc2IuY2xvc2VkID0gZWIuY2xvc2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvZykge1xuICAgIF9sb2coXCJzaGFwZUluZGV4OltcIiArIHNoYXBlSW5kaWNlcy5qb2luKFwiLFwiKSArIFwiXVwiKTtcbiAgfVxuXG4gIHN0YXJ0LnNoYXBlSW5kZXggPSBzaGFwZUluZGljZXM7XG4gIHJldHVybiBzaGFwZUluZGljZXM7XG59LFxuICAgIF9wYXRoRmlsdGVyID0gZnVuY3Rpb24gX3BhdGhGaWx0ZXIoYSwgc2hhcGVJbmRleCwgbWFwLCBwcmVjb21waWxlLCBmaWxsU2FmZSkge1xuICB2YXIgc3RhcnQgPSBzdHJpbmdUb1Jhd1BhdGgoYVswXSksXG4gICAgICBlbmQgPSBzdHJpbmdUb1Jhd1BhdGgoYVsxXSk7XG5cbiAgaWYgKCFfZXF1YWxpemVTZWdtZW50UXVhbnRpdHkoc3RhcnQsIGVuZCwgc2hhcGVJbmRleCB8fCBzaGFwZUluZGV4ID09PSAwID8gc2hhcGVJbmRleCA6IFwiYXV0b1wiLCBtYXAsIGZpbGxTYWZlKSkge1xuICAgIHJldHVybjsgLy9tYWxmb3JtZWQgcGF0aCBkYXRhIG9yIG51bGwgdGFyZ2V0XG4gIH1cblxuICBhWzBdID0gcmF3UGF0aFRvU3RyaW5nKHN0YXJ0KTtcbiAgYVsxXSA9IHJhd1BhdGhUb1N0cmluZyhlbmQpO1xuXG4gIGlmIChwcmVjb21waWxlID09PSBcImxvZ1wiIHx8IHByZWNvbXBpbGUgPT09IHRydWUpIHtcbiAgICBfbG9nKCdwcmVjb21waWxlOltcIicgKyBhWzBdICsgJ1wiLFwiJyArIGFbMV0gKyAnXCJdJyk7XG4gIH1cbn0sXG4gICAgX29mZnNldFBvaW50cyA9IGZ1bmN0aW9uIF9vZmZzZXRQb2ludHModGV4dCwgb2Zmc2V0KSB7XG4gIGlmICghb2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICB2YXIgYSA9IHRleHQubWF0Y2goX251bUV4cCkgfHwgW10sXG4gICAgICBsID0gYS5sZW5ndGgsXG4gICAgICBzID0gXCJcIixcbiAgICAgIGluYyxcbiAgICAgIGksXG4gICAgICBqO1xuXG4gIGlmIChvZmZzZXQgPT09IFwicmV2ZXJzZVwiKSB7XG4gICAgaSA9IGwgLSAxO1xuICAgIGluYyA9IC0yO1xuICB9IGVsc2Uge1xuICAgIGkgPSAoKHBhcnNlSW50KG9mZnNldCwgMTApIHx8IDApICogMiArIDEgKyBsICogMTAwKSAlIGw7XG4gICAgaW5jID0gMjtcbiAgfVxuXG4gIGZvciAoaiA9IDA7IGogPCBsOyBqICs9IDIpIHtcbiAgICBzICs9IGFbaSAtIDFdICsgXCIsXCIgKyBhW2ldICsgXCIgXCI7XG4gICAgaSA9IChpICsgaW5jKSAlIGw7XG4gIH1cblxuICByZXR1cm4gcztcbn0sXG4gICAgLy9hZGRzIGEgY2VydGFpbiBudW1iZXIgb2YgcG9pbnRzIHdoaWxlIG1haW50YWluaW5nIHRoZSBwb2x5Z29uL3BvbHlsaW5lIHNoYXBlIChzbyB0aGF0IHRoZSBzdGFydC9lbmQgdmFsdWVzIGNhbiBoYXZlIGEgbWF0Y2hpbmcgcXVhbnRpdHkgb2YgcG9pbnRzIHRvIGFuaW1hdGUpLiBSZXR1cm5zIHRoZSByZXZpc2VkIHN0cmluZy5cbl9lcXVhbGl6ZVBvaW50UXVhbnRpdHkgPSBmdW5jdGlvbiBfZXF1YWxpemVQb2ludFF1YW50aXR5KGEsIHF1YW50aXR5KSB7XG4gIHZhciB0YWxseSA9IDAsXG4gICAgICB4ID0gcGFyc2VGbG9hdChhWzBdKSxcbiAgICAgIHkgPSBwYXJzZUZsb2F0KGFbMV0pLFxuICAgICAgcyA9IHggKyBcIixcIiArIHkgKyBcIiBcIixcbiAgICAgIG1heCA9IDAuOTk5OTk5LFxuICAgICAgbmV3UG9pbnRzUGVyU2VnbWVudCxcbiAgICAgIGksXG4gICAgICBsLFxuICAgICAgaixcbiAgICAgIGZhY3RvcixcbiAgICAgIG5leHRYLFxuICAgICAgbmV4dFk7XG4gIGwgPSBhLmxlbmd0aDtcbiAgbmV3UG9pbnRzUGVyU2VnbWVudCA9IHF1YW50aXR5ICogMC41IC8gKGwgKiAwLjUgLSAxKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbCAtIDI7IGkgKz0gMikge1xuICAgIHRhbGx5ICs9IG5ld1BvaW50c1BlclNlZ21lbnQ7XG4gICAgbmV4dFggPSBwYXJzZUZsb2F0KGFbaSArIDJdKTtcbiAgICBuZXh0WSA9IHBhcnNlRmxvYXQoYVtpICsgM10pO1xuXG4gICAgaWYgKHRhbGx5ID4gbWF4KSB7XG4gICAgICAvL2NvbXBhcmUgd2l0aCAwLjk5OTk5IGluc3RlYWQgb2YgMSBpbiBvcmRlciB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9yc1xuICAgICAgZmFjdG9yID0gMSAvIChNYXRoLmZsb29yKHRhbGx5KSArIDEpO1xuICAgICAgaiA9IDE7XG5cbiAgICAgIHdoaWxlICh0YWxseSA+IG1heCkge1xuICAgICAgICBzICs9ICh4ICsgKG5leHRYIC0geCkgKiBmYWN0b3IgKiBqKS50b0ZpeGVkKDIpICsgXCIsXCIgKyAoeSArIChuZXh0WSAtIHkpICogZmFjdG9yICogaikudG9GaXhlZCgyKSArIFwiIFwiO1xuICAgICAgICB0YWxseS0tO1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcyArPSBuZXh0WCArIFwiLFwiICsgbmV4dFkgKyBcIiBcIjtcbiAgICB4ID0gbmV4dFg7XG4gICAgeSA9IG5leHRZO1xuICB9XG5cbiAgcmV0dXJuIHM7XG59LFxuICAgIF9wb2ludHNGaWx0ZXIgPSBmdW5jdGlvbiBfcG9pbnRzRmlsdGVyKGEpIHtcbiAgdmFyIHN0YXJ0TnVtcyA9IGFbMF0ubWF0Y2goX251bUV4cCkgfHwgW10sXG4gICAgICBlbmROdW1zID0gYVsxXS5tYXRjaChfbnVtRXhwKSB8fCBbXSxcbiAgICAgIGRpZiA9IGVuZE51bXMubGVuZ3RoIC0gc3RhcnROdW1zLmxlbmd0aDtcblxuICBpZiAoZGlmID4gMCkge1xuICAgIGFbMF0gPSBfZXF1YWxpemVQb2ludFF1YW50aXR5KHN0YXJ0TnVtcywgZGlmKTtcbiAgfSBlbHNlIHtcbiAgICBhWzFdID0gX2VxdWFsaXplUG9pbnRRdWFudGl0eShlbmROdW1zLCAtZGlmKTtcbiAgfVxufSxcbiAgICBfYnVpbGRQb2ludHNGaWx0ZXIgPSBmdW5jdGlvbiBfYnVpbGRQb2ludHNGaWx0ZXIoc2hhcGVJbmRleCkge1xuICByZXR1cm4gIWlzTmFOKHNoYXBlSW5kZXgpID8gZnVuY3Rpb24gKGEpIHtcbiAgICBfcG9pbnRzRmlsdGVyKGEpO1xuXG4gICAgYVsxXSA9IF9vZmZzZXRQb2ludHMoYVsxXSwgcGFyc2VJbnQoc2hhcGVJbmRleCwgMTApKTtcbiAgfSA6IF9wb2ludHNGaWx0ZXI7XG59LFxuICAgIF9wYXJzZVNoYXBlID0gZnVuY3Rpb24gX3BhcnNlU2hhcGUoc2hhcGUsIGZvcmNlUGF0aCwgdGFyZ2V0KSB7XG4gIHZhciBpc1N0cmluZyA9IHR5cGVvZiBzaGFwZSA9PT0gXCJzdHJpbmdcIixcbiAgICAgIGUsXG4gICAgICB0eXBlO1xuXG4gIGlmICghaXNTdHJpbmcgfHwgX3NlbGVjdG9yRXhwLnRlc3Qoc2hhcGUpIHx8IChzaGFwZS5tYXRjaChfbnVtRXhwKSB8fCBbXSkubGVuZ3RoIDwgMykge1xuICAgIGUgPSBfdG9BcnJheShzaGFwZSlbMF07XG5cbiAgICBpZiAoZSkge1xuICAgICAgdHlwZSA9IChlLm5vZGVOYW1lICsgXCJcIikudG9VcHBlckNhc2UoKTtcblxuICAgICAgaWYgKGZvcmNlUGF0aCAmJiB0eXBlICE9PSBcIlBBVEhcIikge1xuICAgICAgICAvL2lmIHdlIHdlcmUgcGFzc2VkIGFuIGVsZW1lbnQgKG9yIHNlbGVjdG9yIHRleHQgZm9yIGFuIGVsZW1lbnQpIHRoYXQgaXNuJ3QgYSBwYXRoLCBjb252ZXJ0IGl0LlxuICAgICAgICBlID0gX2NvbnZlcnRUb1BhdGgoZSwgZmFsc2UpO1xuICAgICAgICB0eXBlID0gXCJQQVRIXCI7XG4gICAgICB9XG5cbiAgICAgIHNoYXBlID0gZS5nZXRBdHRyaWJ1dGUodHlwZSA9PT0gXCJQQVRIXCIgPyBcImRcIiA6IFwicG9pbnRzXCIpIHx8IFwiXCI7XG5cbiAgICAgIGlmIChlID09PSB0YXJnZXQpIHtcbiAgICAgICAgLy9pZiB0aGUgc2hhcGUgbWF0Y2hlcyB0aGUgdGFyZ2V0IGVsZW1lbnQsIHRoZSB1c2VyIHdhbnRzIHRvIHJldmVydCB0byB0aGUgb3JpZ2luYWwgd2hpY2ggc2hvdWxkIGhhdmUgYmVlbiBzdG9yZWQgaW4gdGhlIGRhdGEtb3JpZ2luYWwgYXR0cmlidXRlXG4gICAgICAgIHNoYXBlID0gZS5nZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRhdGEtb3JpZ2luYWxcIikgfHwgc2hhcGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIF9sb2coXCJXQVJOSU5HOiBpbnZhbGlkIG1vcnBoIHRvOiBcIiArIHNoYXBlKTtcblxuICAgICAgc2hhcGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2hhcGU7XG59LFxuICAgIC8vYWRkcyBhbiBcImlzU21vb3RoXCIgYXJyYXkgdG8gZWFjaCBzZWdtZW50IGFuZCBwb3B1bGF0ZXMgaXQgd2l0aCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNtb290aCAodGhlIGNvbnRyb2wgcG9pbnRzIGhhdmUgYmFzaWNhbGx5IHRoZSBzYW1lIHNsb3BlKS4gRm9yIGFueSBzbW9vdGggY29udHJvbCBwb2ludHMsIGl0IGNvbnZlcnRzIHRoZSBjb29yZGluYXRlcyBpbnRvIGFuZ2xlICh4LCBpbiByYWRpYW5zKSBhbmQgbGVuZ3RoICh5KSBhbmQgcHV0cyB0aGVtIGludG8gdGhlIHNhbWUgaW5kZXggdmFsdWUgaW4gYSBzbW9vdGhEYXRhIGFycmF5LlxuX3BvcHVsYXRlU21vb3RoRGF0YSA9IGZ1bmN0aW9uIF9wb3B1bGF0ZVNtb290aERhdGEocmF3UGF0aCwgdG9sZXJhbmNlKSB7XG4gIHZhciBqID0gcmF3UGF0aC5sZW5ndGgsXG4gICAgICBsaW1pdCA9IDAuMiAqICh0b2xlcmFuY2UgfHwgMSksXG4gICAgICBzbW9vdGgsXG4gICAgICBzZWdtZW50LFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB4MixcbiAgICAgIHkyLFxuICAgICAgaSxcbiAgICAgIGwsXG4gICAgICBhLFxuICAgICAgYTIsXG4gICAgICBpc1Ntb290aCxcbiAgICAgIHNtb290aERhdGE7XG5cbiAgd2hpbGUgKC0taiA+IC0xKSB7XG4gICAgc2VnbWVudCA9IHJhd1BhdGhbal07XG4gICAgaXNTbW9vdGggPSBzZWdtZW50LmlzU21vb3RoID0gc2VnbWVudC5pc1Ntb290aCB8fCBbMCwgMCwgMCwgMF07XG4gICAgc21vb3RoRGF0YSA9IHNlZ21lbnQuc21vb3RoRGF0YSA9IHNlZ21lbnQuc21vb3RoRGF0YSB8fCBbMCwgMCwgMCwgMF07XG4gICAgaXNTbW9vdGgubGVuZ3RoID0gNDtcbiAgICBsID0gc2VnbWVudC5sZW5ndGggLSAyO1xuXG4gICAgZm9yIChpID0gNjsgaSA8IGw7IGkgKz0gNikge1xuICAgICAgeCA9IHNlZ21lbnRbaV0gLSBzZWdtZW50W2kgLSAyXTtcbiAgICAgIHkgPSBzZWdtZW50W2kgKyAxXSAtIHNlZ21lbnRbaSAtIDFdO1xuICAgICAgeDIgPSBzZWdtZW50W2kgKyAyXSAtIHNlZ21lbnRbaV07XG4gICAgICB5MiA9IHNlZ21lbnRbaSArIDNdIC0gc2VnbWVudFtpICsgMV07XG4gICAgICBhID0gX2F0YW4yKHksIHgpO1xuICAgICAgYTIgPSBfYXRhbjIoeTIsIHgyKTtcbiAgICAgIHNtb290aCA9IE1hdGguYWJzKGEgLSBhMikgPCBsaW1pdDtcblxuICAgICAgaWYgKHNtb290aCkge1xuICAgICAgICBzbW9vdGhEYXRhW2kgLSAyXSA9IGE7XG4gICAgICAgIHNtb290aERhdGFbaSArIDJdID0gYTI7XG4gICAgICAgIHNtb290aERhdGFbaSAtIDFdID0gX3NxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgICAgIHNtb290aERhdGFbaSArIDNdID0gX3NxcnQoeDIgKiB4MiArIHkyICogeTIpO1xuICAgICAgfVxuXG4gICAgICBpc1Ntb290aC5wdXNoKHNtb290aCwgc21vb3RoLCAwLCAwLCBzbW9vdGgsIHNtb290aCk7XG4gICAgfSAvL2lmIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludHMgYXJlIGlkZW50aWNhbCwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBzbW9vdGggdHJhbnNpdGlvbi4gV2UgbXVzdCBoYW5kbGUgdGhpcyBhIGJpdCBkaWZmZXJlbnRseSBkdWUgdG8gdGhlaXIgcG9zaXRpb25zIGluIHRoZSBhcnJheS5cblxuXG4gICAgaWYgKHNlZ21lbnRbbF0gPT09IHNlZ21lbnRbMF0gJiYgc2VnbWVudFtsICsgMV0gPT09IHNlZ21lbnRbMV0pIHtcbiAgICAgIHggPSBzZWdtZW50WzBdIC0gc2VnbWVudFtsIC0gMl07XG4gICAgICB5ID0gc2VnbWVudFsxXSAtIHNlZ21lbnRbbCAtIDFdO1xuICAgICAgeDIgPSBzZWdtZW50WzJdIC0gc2VnbWVudFswXTtcbiAgICAgIHkyID0gc2VnbWVudFszXSAtIHNlZ21lbnRbMV07XG4gICAgICBhID0gX2F0YW4yKHksIHgpO1xuICAgICAgYTIgPSBfYXRhbjIoeTIsIHgyKTtcblxuICAgICAgaWYgKE1hdGguYWJzKGEgLSBhMikgPCBsaW1pdCkge1xuICAgICAgICBzbW9vdGhEYXRhW2wgLSAyXSA9IGE7XG4gICAgICAgIHNtb290aERhdGFbMl0gPSBhMjtcbiAgICAgICAgc21vb3RoRGF0YVtsIC0gMV0gPSBfc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgc21vb3RoRGF0YVszXSA9IF9zcXJ0KHgyICogeDIgKyB5MiAqIHkyKTtcbiAgICAgICAgaXNTbW9vdGhbbCAtIDJdID0gaXNTbW9vdGhbbCAtIDFdID0gdHJ1ZTsgLy9kb24ndCBjaGFuZ2UgaW5kZXhlcyAyIGFuZCAzIGJlY2F1c2Ugd2UnbGwgdHJpZ2dlciBldmVyeXRoaW5nIGZyb20gdGhlIEVORCwgYW5kIHRoaXMgd2lsbCBvcHRpbWl6ZSBmaWxlIHNpemUgYSBiaXQuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJhd1BhdGg7XG59LFxuICAgIF9wYXJzZU9yaWdpbkZhY3RvcnMgPSBmdW5jdGlvbiBfcGFyc2VPcmlnaW5GYWN0b3JzKHYpIHtcbiAgdmFyIGEgPSB2LnRyaW0oKS5zcGxpdChcIiBcIiksXG4gICAgICB4ID0gfnYuaW5kZXhPZihcImxlZnRcIikgPyAwIDogfnYuaW5kZXhPZihcInJpZ2h0XCIpID8gMTAwIDogaXNOYU4ocGFyc2VGbG9hdChhWzBdKSkgPyA1MCA6IHBhcnNlRmxvYXQoYVswXSksXG4gICAgICB5ID0gfnYuaW5kZXhPZihcInRvcFwiKSA/IDAgOiB+di5pbmRleE9mKFwiYm90dG9tXCIpID8gMTAwIDogaXNOYU4ocGFyc2VGbG9hdChhWzFdKSkgPyA1MCA6IHBhcnNlRmxvYXQoYVsxXSk7XG4gIHJldHVybiB7XG4gICAgeDogeCAvIDEwMCxcbiAgICB5OiB5IC8gMTAwXG4gIH07XG59LFxuICAgIF9zaG9ydEFuZ2xlID0gZnVuY3Rpb24gX3Nob3J0QW5nbGUoZGlmKSB7XG4gIHJldHVybiBkaWYgIT09IGRpZiAlIF9QSSA/IGRpZiArIChkaWYgPCAwID8gXzJQSSA6IC1fMlBJKSA6IGRpZjtcbn0sXG4gICAgX21vcnBoTWVzc2FnZSA9IFwiVXNlIE1vcnBoU1ZHUGx1Z2luLmNvbnZlcnRUb1BhdGgoKSB0byBjb252ZXJ0IHRvIGEgcGF0aCBiZWZvcmUgbW9ycGhpbmcuXCIsXG4gICAgX3R3ZWVuUm90YXRpb24gPSBmdW5jdGlvbiBfdHdlZW5Sb3RhdGlvbihzdGFydCwgZW5kLCBpLCBsaW5rZWRQVCkge1xuICB2YXIgc28gPSB0aGlzLl9vcmlnaW4sXG4gICAgICAvL3N0YXJ0aW5nIG9yaWdpblxuICBlbyA9IHRoaXMuX2VPcmlnaW4sXG4gICAgICAvL2VuZGluZyBvcmlnaW5cbiAgZHggPSBzdGFydFtpXSAtIHNvLngsXG4gICAgICBkeSA9IHN0YXJ0W2kgKyAxXSAtIHNvLnksXG4gICAgICBkID0gX3NxcnQoZHggKiBkeCArIGR5ICogZHkpLFxuICAgICAgLy9sZW5ndGggZnJvbSBzdGFydGluZyBvcmlnaW4gdG8gc3RhcnRpbmcgcG9pbnRcbiAgc2EgPSBfYXRhbjIoZHksIGR4KSxcbiAgICAgIGFuZ2xlRGlmLFxuICAgICAgX3Nob3J0O1xuXG4gIGR4ID0gZW5kW2ldIC0gZW8ueDtcbiAgZHkgPSBlbmRbaSArIDFdIC0gZW8ueTtcbiAgYW5nbGVEaWYgPSBfYXRhbjIoZHksIGR4KSAtIHNhO1xuICBfc2hvcnQgPSBfc2hvcnRBbmdsZShhbmdsZURpZik7IC8vaW4gdGhlIGNhc2Ugb2YgY29udHJvbCBwb2ludHMsIHdlIEFMV0FZUyBsaW5rIHRoZW0gdG8gdGhlaXIgYW5jaG9yIHNvIHRoYXQgdGhleSBkb24ndCBnZXQgdG9ybiBhcGFydCBhbmQgcm90YXRlIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uIElmIGl0J3Mgbm90IGEgY29udHJvbCBwb2ludCwgd2UgbG9vayBhdCB0aGUgbW9zdCByZWNlbnRseSBsaW5rZWQgcG9pbnQgYXMgbG9uZyBhcyB0aGV5J3JlIHdpdGhpbiBhIGNlcnRhaW4gcm90YXRpb25hbCByYW5nZSBvZiBlYWNoIG90aGVyLlxuXG4gIGlmICghbGlua2VkUFQgJiYgX2xhc3RMaW5rZWRBbmNob3IgJiYgTWF0aC5hYnMoX3Nob3J0ICsgX2xhc3RMaW5rZWRBbmNob3IuY2EpIDwgX2FuZ2xlTWluKSB7XG4gICAgbGlua2VkUFQgPSBfbGFzdExpbmtlZEFuY2hvcjtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9hbmNob3JQVCA9IF9sYXN0TGlua2VkQW5jaG9yID0ge1xuICAgIF9uZXh0OiB0aGlzLl9hbmNob3JQVCxcbiAgICB0OiBzdGFydCxcbiAgICBzYTogc2EsXG4gICAgLy9zdGFydGluZyBhbmdsZVxuICAgIGNhOiBsaW5rZWRQVCAmJiBfc2hvcnQgKiBsaW5rZWRQVC5jYSA8IDAgJiYgTWF0aC5hYnMoX3Nob3J0KSA+IF9hbmdsZU1heCA/IGFuZ2xlRGlmIDogX3Nob3J0LFxuICAgIC8vY2hhbmdlIGluIGFuZ2xlXG4gICAgc2w6IGQsXG4gICAgLy9zdGFydGluZyBsZW5ndGhcbiAgICBjbDogX3NxcnQoZHggKiBkeCArIGR5ICogZHkpIC0gZCxcbiAgICAvL2NoYW5nZSBpbiBsZW5ndGhcbiAgICBpOiBpXG4gIH07XG59LFxuICAgIF9pbml0Q29yZSA9IGZ1bmN0aW9uIF9pbml0Q29yZShyZXF1aXJlZCkge1xuICBnc2FwID0gX2dldEdTQVAoKTtcbiAgUGx1Z2luQ2xhc3MgPSBQbHVnaW5DbGFzcyB8fCBnc2FwICYmIGdzYXAucGx1Z2lucy5tb3JwaFNWRztcblxuICBpZiAoZ3NhcCAmJiBQbHVnaW5DbGFzcykge1xuICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgIF9kb2MgPSBkb2N1bWVudDtcbiAgICBQbHVnaW5DbGFzcy5wcm90b3R5cGUuX3R3ZWVuUm90YXRpb24gPSBfdHdlZW5Sb3RhdGlvbjtcbiAgICBfY29yZUluaXR0ZWQgPSAxO1xuICB9IGVsc2UgaWYgKHJlcXVpcmVkKSB7XG4gICAgX2xvZyhcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKE1vcnBoU1ZHUGx1Z2luKVwiKTtcbiAgfVxufTtcblxuZXhwb3J0IHZhciBNb3JwaFNWR1BsdWdpbiA9IHtcbiAgdmVyc2lvbjogXCIzLjIuNlwiLFxuICBuYW1lOiBcIm1vcnBoU1ZHXCIsXG4gIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3Rlcihjb3JlLCBQbHVnaW4pIHtcbiAgICBnc2FwID0gY29yZTtcbiAgICBQbHVnaW5DbGFzcyA9IFBsdWdpbjtcblxuICAgIF9pbml0Q29yZSgpO1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWUsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuICAgIHZhciBjcyA9IHRhcmdldC5ub2RlVHlwZSA/IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCkgOiB7fSxcbiAgICAgICAgZmlsbCA9IGNzLmZpbGwgKyBcIlwiLFxuICAgICAgICBmaWxsU2FmZSA9ICEoZmlsbCA9PT0gXCJub25lXCIgfHwgKGZpbGwubWF0Y2goX251bUV4cCkgfHwgW10pWzNdID09PSBcIjBcIiB8fCBjcy5maWxsUnVsZSA9PT0gXCJldmVub2RkXCIpLFxuICAgICAgICBvcmlnaW5zID0gKHZhbHVlLm9yaWdpbiB8fCBcIjUwIDUwXCIpLnNwbGl0KFwiLFwiKSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcCxcbiAgICAgICAgcHQsXG4gICAgICAgIHNoYXBlLFxuICAgICAgICBpc1BvbHksXG4gICAgICAgIHNoYXBlSW5kZXgsXG4gICAgICAgIG1hcCxcbiAgICAgICAgc3RhcnRTbW9vdGgsXG4gICAgICAgIGVuZFNtb290aCxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZCxcbiAgICAgICAgaSxcbiAgICAgICAgaixcbiAgICAgICAgbCxcbiAgICAgICAgc3RhcnRTZWcsXG4gICAgICAgIGVuZFNlZyxcbiAgICAgICAgcHJlY29tcGlsZWQsXG4gICAgICAgIHNEYXRhLFxuICAgICAgICBlRGF0YSxcbiAgICAgICAgb3JpZ2luRmFjdG9ycyxcbiAgICAgICAgdXNlUm90YXRpb24sXG4gICAgICAgIG9mZnNldDtcblxuICAgIGlmICghX2NvcmVJbml0dGVkKSB7XG4gICAgICBfaW5pdENvcmUoMSk7XG4gICAgfVxuXG4gICAgdHlwZSA9ICh0YXJnZXQubm9kZU5hbWUgKyBcIlwiKS50b1VwcGVyQ2FzZSgpO1xuICAgIGlzUG9seSA9IHR5cGUgPT09IFwiUE9MWUxJTkVcIiB8fCB0eXBlID09PSBcIlBPTFlHT05cIjtcblxuICAgIGlmICh0eXBlICE9PSBcIlBBVEhcIiAmJiAhaXNQb2x5ICYmICF2YWx1ZS5wcm9wKSB7XG4gICAgICBfbG9nKFwiQ2Fubm90IG1vcnBoIGEgPFwiICsgdHlwZSArIFwiPiBlbGVtZW50LiBcIiArIF9tb3JwaE1lc3NhZ2UpO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcCA9IHR5cGUgPT09IFwiUEFUSFwiID8gXCJkXCIgOiBcInBvaW50c1wiO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZS5nZXRCQm94IHx8IHZhbHVlWzBdKSB7XG4gICAgICB2YWx1ZSA9IHtcbiAgICAgICAgc2hhcGU6IHZhbHVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghdmFsdWUucHJvcCAmJiB0eXBlb2YgdGFyZ2V0LnNldEF0dHJpYnV0ZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc2hhcGUgPSBfcGFyc2VTaGFwZSh2YWx1ZS5zaGFwZSB8fCB2YWx1ZS5kIHx8IHZhbHVlLnBvaW50cyB8fCBcIlwiLCBwID09PSBcImRcIiwgdGFyZ2V0KTtcblxuICAgIGlmIChpc1BvbHkgJiYgX2NvbW1hbmRzLnRlc3Qoc2hhcGUpKSB7XG4gICAgICBfbG9nKFwiQSA8XCIgKyB0eXBlICsgXCI+IGNhbm5vdCBhY2NlcHQgcGF0aCBkYXRhLiBcIiArIF9tb3JwaE1lc3NhZ2UpO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc2hhcGVJbmRleCA9IHZhbHVlLnNoYXBlSW5kZXggfHwgdmFsdWUuc2hhcGVJbmRleCA9PT0gMCA/IHZhbHVlLnNoYXBlSW5kZXggOiBcImF1dG9cIjtcbiAgICBtYXAgPSB2YWx1ZS5tYXAgfHwgTW9ycGhTVkdQbHVnaW4uZGVmYXVsdE1hcDtcbiAgICB0aGlzLl9wcm9wID0gdmFsdWUucHJvcDtcbiAgICB0aGlzLl9yZW5kZXIgPSB2YWx1ZS5yZW5kZXIgfHwgTW9ycGhTVkdQbHVnaW4uZGVmYXVsdFJlbmRlcjtcbiAgICB0aGlzLl9hcHBseSA9IFwidXBkYXRlVGFyZ2V0XCIgaW4gdmFsdWUgPyB2YWx1ZS51cGRhdGVUYXJnZXQgOiBNb3JwaFNWR1BsdWdpbi5kZWZhdWx0VXBkYXRlVGFyZ2V0O1xuICAgIHRoaXMuX3JuZCA9IE1hdGgucG93KDEwLCBpc05hTih2YWx1ZS5wcmVjaXNpb24pID8gMiA6ICt2YWx1ZS5wcmVjaXNpb24pO1xuICAgIHRoaXMuX3R3ZWVuID0gdHdlZW47XG5cbiAgICBpZiAoc2hhcGUpIHtcbiAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICAgIHByZWNvbXBpbGVkID0gX3R5cGVvZih2YWx1ZS5wcmVjb21waWxlKSA9PT0gXCJvYmplY3RcIjtcbiAgICAgIHN0YXJ0ID0gdGhpcy5fcHJvcCA/IHRhcmdldFt0aGlzLl9wcm9wXSA6IHRhcmdldC5nZXRBdHRyaWJ1dGUocCk7XG5cbiAgICAgIGlmICghdGhpcy5fcHJvcCAmJiAhdGFyZ2V0LmdldEF0dHJpYnV0ZU5TKG51bGwsIFwiZGF0YS1vcmlnaW5hbFwiKSkge1xuICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJkYXRhLW9yaWdpbmFsXCIsIHN0YXJ0KTsgLy9yZWNvcmQgdGhlIG9yaWdpbmFsIHN0YXRlIGluIGEgZGF0YS1vcmlnaW5hbCBhdHRyaWJ1dGUgc28gdGhhdCB3ZSBjYW4gcmV2ZXJ0IHRvIGl0IGxhdGVyLlxuICAgICAgfVxuXG4gICAgICBpZiAocCA9PT0gXCJkXCIgfHwgdGhpcy5fcHJvcCkge1xuICAgICAgICBzdGFydCA9IHN0cmluZ1RvUmF3UGF0aChwcmVjb21waWxlZCA/IHZhbHVlLnByZWNvbXBpbGVbMF0gOiBzdGFydCk7XG4gICAgICAgIGVuZCA9IHN0cmluZ1RvUmF3UGF0aChwcmVjb21waWxlZCA/IHZhbHVlLnByZWNvbXBpbGVbMV0gOiBzaGFwZSk7XG5cbiAgICAgICAgaWYgKCFwcmVjb21waWxlZCAmJiAhX2VxdWFsaXplU2VnbWVudFF1YW50aXR5KHN0YXJ0LCBlbmQsIHNoYXBlSW5kZXgsIG1hcCwgZmlsbFNhZmUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvL21hbGZvcm1lZCBwYXRoIGRhdGEgb3IgbnVsbCB0YXJnZXRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5wcmVjb21waWxlID09PSBcImxvZ1wiIHx8IHZhbHVlLnByZWNvbXBpbGUgPT09IHRydWUpIHtcbiAgICAgICAgICBfbG9nKCdwcmVjb21waWxlOltcIicgKyByYXdQYXRoVG9TdHJpbmcoc3RhcnQpICsgJ1wiLFwiJyArIHJhd1BhdGhUb1N0cmluZyhlbmQpICsgJ1wiXScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXNlUm90YXRpb24gPSAodmFsdWUudHlwZSB8fCBNb3JwaFNWR1BsdWdpbi5kZWZhdWx0VHlwZSkgIT09IFwibGluZWFyXCI7XG5cbiAgICAgICAgaWYgKHVzZVJvdGF0aW9uKSB7XG4gICAgICAgICAgc3RhcnQgPSBfcG9wdWxhdGVTbW9vdGhEYXRhKHN0YXJ0LCB2YWx1ZS5zbW9vdGhUb2xlcmFuY2UpO1xuICAgICAgICAgIGVuZCA9IF9wb3B1bGF0ZVNtb290aERhdGEoZW5kLCB2YWx1ZS5zbW9vdGhUb2xlcmFuY2UpO1xuXG4gICAgICAgICAgaWYgKCFzdGFydC5zaXplKSB7XG4gICAgICAgICAgICBfZ2V0VG90YWxTaXplKHN0YXJ0KTsgLy9hZGRzIHRvcC9sZWZ0L3dpZHRoL2hlaWdodCB2YWx1ZXNcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZW5kLnNpemUpIHtcbiAgICAgICAgICAgIF9nZXRUb3RhbFNpemUoZW5kKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvcmlnaW5GYWN0b3JzID0gX3BhcnNlT3JpZ2luRmFjdG9ycyhvcmlnaW5zWzBdKTtcbiAgICAgICAgICB0aGlzLl9vcmlnaW4gPSBzdGFydC5vcmlnaW4gPSB7XG4gICAgICAgICAgICB4OiBzdGFydC5sZWZ0ICsgb3JpZ2luRmFjdG9ycy54ICogc3RhcnQud2lkdGgsXG4gICAgICAgICAgICB5OiBzdGFydC50b3AgKyBvcmlnaW5GYWN0b3JzLnkgKiBzdGFydC5oZWlnaHRcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKG9yaWdpbnNbMV0pIHtcbiAgICAgICAgICAgIG9yaWdpbkZhY3RvcnMgPSBfcGFyc2VPcmlnaW5GYWN0b3JzKG9yaWdpbnNbMV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2VPcmlnaW4gPSB7XG4gICAgICAgICAgICB4OiBlbmQubGVmdCArIG9yaWdpbkZhY3RvcnMueCAqIGVuZC53aWR0aCxcbiAgICAgICAgICAgIHk6IGVuZC50b3AgKyBvcmlnaW5GYWN0b3JzLnkgKiBlbmQuaGVpZ2h0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Jhd1BhdGggPSB0YXJnZXQuX2dzUmF3UGF0aCA9IHN0YXJ0O1xuICAgICAgICBqID0gc3RhcnQubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgtLWogPiAtMSkge1xuICAgICAgICAgIHN0YXJ0U2VnID0gc3RhcnRbal07XG4gICAgICAgICAgZW5kU2VnID0gZW5kW2pdO1xuICAgICAgICAgIHN0YXJ0U21vb3RoID0gc3RhcnRTZWcuaXNTbW9vdGggfHwgW107XG4gICAgICAgICAgZW5kU21vb3RoID0gZW5kU2VnLmlzU21vb3RoIHx8IFtdO1xuICAgICAgICAgIGwgPSBzdGFydFNlZy5sZW5ndGg7XG4gICAgICAgICAgX2xhc3RMaW5rZWRBbmNob3IgPSAwOyAvL3Jlc2V0OyB3ZSB1c2UgX2xhc3RMaW5rZWRBbmNob3IgaW4gdGhlIF90d2VlblJvdGF0aW9uKCkgbWV0aG9kIHRvIGhlbHAgbWFrZSBzdXJlIHRoYXQgY2xvc2UgcG9pbnRzIGRvbid0IGdldCByaXBwZWQgYXBhcnQgYW5kIHJvdGF0ZSBvcHBvc2l0ZSBkaXJlY3Rpb25zLiBUeXBpY2FsbHkgd2Ugd2FudCB0byBnbyB0aGUgc2hvcnRlc3QgZGlyZWN0aW9uLCBidXQgaWYgdGhlIHByZXZpb3VzIGFuY2hvciBpcyBnb2luZyBhIGRpZmZlcmVudCBkaXJlY3Rpb24sIHdlIG92ZXJyaWRlIHRoaXMgbG9naWMgKHdpdGhpbiBjZXJ0YWluIHRocmVzaG9sZHMpXG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgICAgICAgICBpZiAoZW5kU2VnW2ldICE9PSBzdGFydFNlZ1tpXSB8fCBlbmRTZWdbaSArIDFdICE9PSBzdGFydFNlZ1tpICsgMV0pIHtcbiAgICAgICAgICAgICAgaWYgKHVzZVJvdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0U21vb3RoW2ldICYmIGVuZFNtb290aFtpXSkge1xuICAgICAgICAgICAgICAgICAgLy9pZiBCT1RIIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIGFyZSBzbW9vdGggKG1lYW5pbmcgY29udHJvbCBwb2ludHMgaGF2ZSBiYXNpY2FsbHkgdGhlIHNhbWUgc2xvcGUpLCBpbnRlcnBvbGF0ZSB0aGUgcm90YXRpb24gYW5kIGxlbmd0aCBpbnN0ZWFkIG9mIHRoZSBjb29yZGluYXRlcyAodGhpcyBpcyB3aGF0IG1ha2VzIHRoaW5ncyBzbW9vdGgpLlxuICAgICAgICAgICAgICAgICAgc0RhdGEgPSBzdGFydFNlZy5zbW9vdGhEYXRhO1xuICAgICAgICAgICAgICAgICAgZURhdGEgPSBlbmRTZWcuc21vb3RoRGF0YTtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGkgKyAoaSA9PT0gbCAtIDQgPyA3IC0gbCA6IDUpOyAvL2hlbHBzIHVzIGFjY29tbW9kYXRlIHdyYXBwaW5nIChsaWtlIGlmIHRoZSBlbmQgYW5kIHN0YXJ0IGFuY2hvcnMgYXJlIGlkZW50aWNhbCBhbmQgdGhlIGNvbnRyb2wgcG9pbnRzIGFyZSBzbW9vdGgpLlxuXG4gICAgICAgICAgICAgICAgICB0aGlzLl9jb250cm9sUFQgPSB7XG4gICAgICAgICAgICAgICAgICAgIF9uZXh0OiB0aGlzLl9jb250cm9sUFQsXG4gICAgICAgICAgICAgICAgICAgIGk6IGksXG4gICAgICAgICAgICAgICAgICAgIGo6IGosXG4gICAgICAgICAgICAgICAgICAgIGwxczogc0RhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICBsMWM6IGVEYXRhW2kgKyAxXSAtIHNEYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgbDJzOiBzRGF0YVtvZmZzZXRdLFxuICAgICAgICAgICAgICAgICAgICBsMmM6IGVEYXRhW29mZnNldF0gLSBzRGF0YVtvZmZzZXRdXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgcHQgPSB0aGlzLl90d2VlblJvdGF0aW9uKHN0YXJ0U2VnLCBlbmRTZWcsIGkgKyAyKTtcblxuICAgICAgICAgICAgICAgICAgdGhpcy5fdHdlZW5Sb3RhdGlvbihzdGFydFNlZywgZW5kU2VnLCBpLCBwdCk7XG5cbiAgICAgICAgICAgICAgICAgIHRoaXMuX3R3ZWVuUm90YXRpb24oc3RhcnRTZWcsIGVuZFNlZywgb2Zmc2V0IC0gMSwgcHQpO1xuXG4gICAgICAgICAgICAgICAgICBpICs9IDQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3R3ZWVuUm90YXRpb24oc3RhcnRTZWcsIGVuZFNlZywgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHB0ID0gdGhpcy5hZGQoc3RhcnRTZWcsIGksIHN0YXJ0U2VnW2ldLCBlbmRTZWdbaV0pO1xuICAgICAgICAgICAgICAgIHB0ID0gdGhpcy5hZGQoc3RhcnRTZWcsIGkgKyAxLCBzdGFydFNlZ1tpICsgMV0sIGVuZFNlZ1tpICsgMV0pIHx8IHB0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdCA9IHRoaXMuYWRkKHRhcmdldCwgXCJzZXRBdHRyaWJ1dGVcIiwgdGFyZ2V0LmdldEF0dHJpYnV0ZShwKSArIFwiXCIsIHNoYXBlICsgXCJcIiwgaW5kZXgsIHRhcmdldHMsIDAsIF9idWlsZFBvaW50c0ZpbHRlcihzaGFwZUluZGV4KSwgcCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1c2VSb3RhdGlvbikge1xuICAgICAgICB0aGlzLmFkZCh0aGlzLl9vcmlnaW4sIFwieFwiLCB0aGlzLl9vcmlnaW4ueCwgdGhpcy5fZU9yaWdpbi54KTtcbiAgICAgICAgcHQgPSB0aGlzLmFkZCh0aGlzLl9vcmlnaW4sIFwieVwiLCB0aGlzLl9vcmlnaW4ueSwgdGhpcy5fZU9yaWdpbi55KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHB0KSB7XG4gICAgICAgIHRoaXMuX3Byb3BzLnB1c2goXCJtb3JwaFNWR1wiKTtcblxuICAgICAgICBwdC5lbmQgPSBzaGFwZTtcbiAgICAgICAgcHQuZW5kUHJvcCA9IHA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9ib251c1ZhbGlkYXRlZDtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocmF0aW8sIGRhdGEpIHtcbiAgICB2YXIgcmF3UGF0aCA9IGRhdGEuX3Jhd1BhdGgsXG4gICAgICAgIGNvbnRyb2xQVCA9IGRhdGEuX2NvbnRyb2xQVCxcbiAgICAgICAgYW5jaG9yUFQgPSBkYXRhLl9hbmNob3JQVCxcbiAgICAgICAgcm5kID0gZGF0YS5fcm5kLFxuICAgICAgICB0YXJnZXQgPSBkYXRhLl90YXJnZXQsXG4gICAgICAgIHB0ID0gZGF0YS5fcHQsXG4gICAgICAgIHMsXG4gICAgICAgIHNwYWNlLFxuICAgICAgICBlYXNlSW5PdXQsXG4gICAgICAgIHNlZ21lbnQsXG4gICAgICAgIGwsXG4gICAgICAgIGFuZ2xlLFxuICAgICAgICBpLFxuICAgICAgICBqLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBzaW4sXG4gICAgICAgIGNvcyxcbiAgICAgICAgb2Zmc2V0O1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuXG4gICAgaWYgKHJhdGlvID09PSAxICYmIGRhdGEuX2FwcGx5KSB7XG4gICAgICBwdCA9IGRhdGEuX3B0O1xuXG4gICAgICB3aGlsZSAocHQpIHtcbiAgICAgICAgaWYgKHB0LmVuZCkge1xuICAgICAgICAgIGlmIChkYXRhLl9wcm9wKSB7XG4gICAgICAgICAgICB0YXJnZXRbZGF0YS5fcHJvcF0gPSBwdC5lbmQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUocHQuZW5kUHJvcCwgcHQuZW5kKTsgLy9tYWtlIHN1cmUgdGhlIGVuZCB2YWx1ZSBpcyBleGFjdGx5IGFzIHNwZWNpZmllZCAoaW4gY2FzZSB3ZSBoYWQgdG8gYWRkIGZhYnJpY2F0ZWQgcG9pbnRzIGR1cmluZyB0aGUgdHdlZW4pXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJhd1BhdGgpIHtcbiAgICAgIC8vcm90YXRpb25hbGx5IHBvc2l0aW9uIHRoZSBhbmNob3JzXG4gICAgICB3aGlsZSAoYW5jaG9yUFQpIHtcbiAgICAgICAgYW5nbGUgPSBhbmNob3JQVC5zYSArIHJhdGlvICogYW5jaG9yUFQuY2E7XG4gICAgICAgIGwgPSBhbmNob3JQVC5zbCArIHJhdGlvICogYW5jaG9yUFQuY2w7IC8vbGVuZ3RoXG5cbiAgICAgICAgYW5jaG9yUFQudFthbmNob3JQVC5pXSA9IGRhdGEuX29yaWdpbi54ICsgX2NvcyhhbmdsZSkgKiBsO1xuICAgICAgICBhbmNob3JQVC50W2FuY2hvclBULmkgKyAxXSA9IGRhdGEuX29yaWdpbi55ICsgX3NpbihhbmdsZSkgKiBsO1xuICAgICAgICBhbmNob3JQVCA9IGFuY2hvclBULl9uZXh0O1xuICAgICAgfSAvL3Ntb290aCBvdXQgdGhlIGNvbnRyb2wgcG9pbnRzXG5cblxuICAgICAgZWFzZUluT3V0ID0gcmF0aW8gPCAwLjUgPyAyICogcmF0aW8gKiByYXRpbyA6ICg0IC0gMiAqIHJhdGlvKSAqIHJhdGlvIC0gMTtcblxuICAgICAgd2hpbGUgKGNvbnRyb2xQVCkge1xuICAgICAgICBpID0gY29udHJvbFBULmk7XG4gICAgICAgIHNlZ21lbnQgPSByYXdQYXRoW2NvbnRyb2xQVC5qXTtcbiAgICAgICAgb2Zmc2V0ID0gaSArIChpID09PSBzZWdtZW50Lmxlbmd0aCAtIDQgPyA3IC0gc2VnbWVudC5sZW5ndGggOiA1KTsgLy9hY2NvbW1vZGF0ZXMgd3JhcHBpbmcgYXJvdW5kIG9mIHNtb290aCBwb2ludHMsIGxpa2UgaWYgdGhlIHN0YXJ0IGFuZCBlbmQgYW5jaG9ycyBhcmUgb24gdG9wIG9mIGVhY2ggb3RoZXIgYW5kIHRoZWlyIGhhbmRsZXMgYXJlIHNtb290aC5cblxuICAgICAgICBhbmdsZSA9IF9hdGFuMihzZWdtZW50W29mZnNldF0gLSBzZWdtZW50W2kgKyAxXSwgc2VnbWVudFtvZmZzZXQgLSAxXSAtIHNlZ21lbnRbaV0pOyAvL2F2ZXJhZ2UgdGhlIGFuZ2xlc1xuXG4gICAgICAgIHNpbiA9IF9zaW4oYW5nbGUpO1xuICAgICAgICBjb3MgPSBfY29zKGFuZ2xlKTtcbiAgICAgICAgeCA9IHNlZ21lbnRbaSArIDJdO1xuICAgICAgICB5ID0gc2VnbWVudFtpICsgM107XG4gICAgICAgIGwgPSBjb250cm9sUFQubDFzICsgZWFzZUluT3V0ICogY29udHJvbFBULmwxYzsgLy9sZW5ndGhcblxuICAgICAgICBzZWdtZW50W2ldID0geCAtIGNvcyAqIGw7XG4gICAgICAgIHNlZ21lbnRbaSArIDFdID0geSAtIHNpbiAqIGw7XG4gICAgICAgIGwgPSBjb250cm9sUFQubDJzICsgZWFzZUluT3V0ICogY29udHJvbFBULmwyYztcbiAgICAgICAgc2VnbWVudFtvZmZzZXQgLSAxXSA9IHggKyBjb3MgKiBsO1xuICAgICAgICBzZWdtZW50W29mZnNldF0gPSB5ICsgc2luICogbDtcbiAgICAgICAgY29udHJvbFBUID0gY29udHJvbFBULl9uZXh0O1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQuX2dzUmF3UGF0aCA9IHJhd1BhdGg7XG5cbiAgICAgIGlmIChkYXRhLl9hcHBseSkge1xuICAgICAgICBzID0gXCJcIjtcbiAgICAgICAgc3BhY2UgPSBcIiBcIjtcblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgcmF3UGF0aC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlZ21lbnQgPSByYXdQYXRoW2pdO1xuICAgICAgICAgIGwgPSBzZWdtZW50Lmxlbmd0aDtcbiAgICAgICAgICBzICs9IFwiTVwiICsgKHNlZ21lbnRbMF0gKiBybmQgfCAwKSAvIHJuZCArIHNwYWNlICsgKHNlZ21lbnRbMV0gKiBybmQgfCAwKSAvIHJuZCArIFwiIENcIjtcblxuICAgICAgICAgIGZvciAoaSA9IDI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vdGhpcyBpcyBhY3R1YWxseSBmYXN0ZXIgdGhhbiBqdXN0IGRvaW5nIGEgam9pbigpIG9uIHRoZSBhcnJheSwgcG9zc2libHkgYmVjYXVzZSB0aGUgbnVtYmVycyBoYXZlIHNvIG1hbnkgZGVjaW1hbCBwbGFjZXNcbiAgICAgICAgICAgIHMgKz0gKHNlZ21lbnRbaV0gKiBybmQgfCAwKSAvIHJuZCArIHNwYWNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLl9wcm9wKSB7XG4gICAgICAgICAgdGFyZ2V0W2RhdGEuX3Byb3BdID0gcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwiZFwiLCBzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkYXRhLl9yZW5kZXIgJiYgcmF3UGF0aCkge1xuICAgICAgZGF0YS5fcmVuZGVyLmNhbGwoZGF0YS5fdHdlZW4sIHJhd1BhdGgsIHRhcmdldCk7XG4gICAgfVxuICB9LFxuICBraWxsOiBmdW5jdGlvbiBraWxsKHByb3BlcnR5KSB7XG4gICAgdGhpcy5fcHQgPSB0aGlzLl9yYXdQYXRoID0gMDtcbiAgfSxcbiAgZ2V0UmF3UGF0aDogZ2V0UmF3UGF0aCxcbiAgc3RyaW5nVG9SYXdQYXRoOiBzdHJpbmdUb1Jhd1BhdGgsXG4gIHJhd1BhdGhUb1N0cmluZzogcmF3UGF0aFRvU3RyaW5nLFxuICBwYXRoRmlsdGVyOiBfcGF0aEZpbHRlcixcbiAgcG9pbnRzRmlsdGVyOiBfcG9pbnRzRmlsdGVyLFxuICBnZXRUb3RhbFNpemU6IF9nZXRUb3RhbFNpemUsXG4gIGVxdWFsaXplU2VnbWVudFF1YW50aXR5OiBfZXF1YWxpemVTZWdtZW50UXVhbnRpdHksXG4gIGNvbnZlcnRUb1BhdGg6IGZ1bmN0aW9uIGNvbnZlcnRUb1BhdGgodGFyZ2V0cywgc3dhcCkge1xuICAgIHJldHVybiBfdG9BcnJheSh0YXJnZXRzKS5tYXAoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgcmV0dXJuIF9jb252ZXJ0VG9QYXRoKHRhcmdldCwgc3dhcCAhPT0gZmFsc2UpO1xuICAgIH0pO1xuICB9LFxuICBkZWZhdWx0VHlwZTogXCJsaW5lYXJcIixcbiAgZGVmYXVsdFVwZGF0ZVRhcmdldDogdHJ1ZSxcbiAgZGVmYXVsdE1hcDogXCJzaXplXCJcbn07XG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oTW9ycGhTVkdQbHVnaW4pO1xuZXhwb3J0IHsgTW9ycGhTVkdQbHVnaW4gYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8vaW1wb3J0ICogYXMgVEhSRUUgZnJvbSBcInRocmVlXCJcbi8vaW1wb3J0IGdzYXAgZnJvbSBcImdzYXBcIlxuLy9pbXBvcnQge0dMVEZMb2FkZXIsIEdMVExvYWRlcn0gZnJvbSBcInRocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0dMVEZMb2FkZXJcIlxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG52YXIgQWJvdXQxR2VvbWV0cnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKEFib3V0MUdlb21ldHJ5LCBfRXZlbnRFbWl0dGVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEFib3V0MUdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBBYm91dDFHZW9tZXRyeShvYmopIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvdXQxR2VvbWV0cnkpO1xuXG4gICAgLy9jb25zb2xlLmxvZyhcIihBYm91dDFHZW9tZXRyeS5DT05TVFJVQ1RPUkEpOiBcIiwgb2JqKVxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7IC8vLS1cblxuICAgIF90aGlzLmZhY3RvciA9IG9iai5mYWN0b3I7IC8vNlxuXG4gICAgX3RoaXMuaW5jcl9yYWRpbyA9IG9iai5pbmNyX3JhZGlvOyAvLzI1XG5cbiAgICBfdGhpcy5udW1PcmJpdHMgPSBvYmoubnVtT3JiaXRzOyAvLzM3XG5cbiAgICBfdGhpcy5hcnJheV90cmlhbmd1bGFyID0gb2JqLmFycmF5X3RyaWFuZ3VsYXI7XG4gICAgX3RoaXMubnVtRG90cyA9IG9iai5udW1Eb3RzOyAvLy0tXG5cbiAgICBfdGhpcy5hdHRyaWJ1dGVzID0ge1xuICAgICAgYV9wb3NpY2lvbmVzOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAzKSxcbiAgICAgIGFfZG90X251bTogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX29yYml0YWw6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV9wb3Nfb3JiaXRhOiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfaW5jcl9hbmd1bG9SYWQ6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV9hbmd1bG9SYWQ6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV9yYWRpbzogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX2RpcjogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX2luY3I6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpLFxuICAgICAgYV94OiBuZXcgRmxvYXQzMkFycmF5KF90aGlzLm51bURvdHMgKiAxKSxcbiAgICAgIGFfeTogbmV3IEZsb2F0MzJBcnJheShfdGhpcy5udW1Eb3RzICogMSksXG4gICAgICBhX3o6IG5ldyBGbG9hdDMyQXJyYXkoX3RoaXMubnVtRG90cyAqIDEpXG4gICAgfTsgLy8tLVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5udW1Eb3RzOyBpKyspIHtcbiAgICAgIHZhciBkb3QgPSBfdGhpcy5fZ2V0X2RvdChpKTtcblxuICAgICAgdmFyIGkzID0gaSAqIDM7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfcG9zaWNpb25lc1tpM10gPSBkb3QueDtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9wb3NpY2lvbmVzW2kzICsgMV0gPSBkb3QueTtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9wb3NpY2lvbmVzW2kzICsgMl0gPSBkb3QuejsgLy8tLVxuXG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfZG90X251bVtpXSA9IGk7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfb3JiaXRhbFtpXSA9IGRvdC5vcmJpdGFsO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3Bvc19vcmJpdGFbaV0gPSBkb3QucG9zX29yYml0YTtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9pbmNyX2FuZ3Vsb1JhZFtpXSA9IGRvdC5pbmNyX2FuZ3Vsb1JhZDtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV9hbmd1bG9SYWRbaV0gPSBkb3QuYW5ndWxvUmFkO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3JhZGlvW2ldID0gZG90LnJhZGlvO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX2RpcltpXSA9IGRvdC5kaXI7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfaW5jcltpXSA9IGRvdC5pbmNyO1xuICAgICAgX3RoaXMuYXR0cmlidXRlcy5hX3hbaV0gPSBkb3QueTtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXMuYV95W2ldID0gZG90Lnk7XG4gICAgICBfdGhpcy5hdHRyaWJ1dGVzLmFfeltpXSA9IGRvdC56O1xuICAgIH0gLy8tLVxuXG5cbiAgICBfdGhpcy5sb2FkZWQgPSBmYWxzZTsgLy9jb25zb2xlLmxvZyh0aGlzLmF0dHJpYnV0ZXMuYV9kb3RfbnVtKVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFib3V0MUdlb21ldHJ5LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEFib3V0MUdlb21ldHJ5LmluaXQpIVwiKVxuICAgICAgLy8tLVxuICAgICAgLy8tLVxuICAgICAgdGhpcy5lbWl0KFwib25NZXNoTG9hZGVkXCIsIHtcbiAgICAgICAgcmVmOiB0aGlzXG4gICAgICB9KTtcbiAgICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUFJJVkFEQVNcblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRfZG90XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfZG90KG51bSkge1xuICAgICAgLy8gRGV2dWVsdmUgdW4gb2JqZXRvIGNvbiBsYSBpbmZvcm1hY2nDrW4gZGUgdW4gcHVudG8gZGUgbGEgZ2VvbWV0cmlhIFwib3JiaXRhbCBNSU9USVwiXG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICBudW06IG51bSxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgejogMCxcbiAgICAgICAgb3JiaXRhbDogMCxcbiAgICAgICAgY29fb3JiaXRhbnRlczogMCxcbiAgICAgICAgcG9zX29yYml0YTogMCxcbiAgICAgICAgaW5jcl9hbmd1bG9SYWQ6IDAsXG4gICAgICAgIGFuZ3Vsb1JhZDogMCxcbiAgICAgICAgcmFkaW86IDBcbiAgICAgIH07IC8vLS1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdGhpcy5hcnJheV90cmlhbmd1bGFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW1TdXAgPSB0aGlzLmFycmF5X3RyaWFuZ3VsYXJbaV07IC8vY29uc29sZS5sb2coXCJsaW1TdXA6IFwiK2xpbVN1cClcblxuICAgICAgICBpZiAobnVtID4gbGltU3VwKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coXCIqXCIpXG4gICAgICAgICAgb2JqLm9yYml0YWwgPSBpICsgMTtcbiAgICAgICAgICBvYmouY29fb3JiaXRhbnRlcyA9IChpICsgMSkgKiB0aGlzLmZhY3RvcjtcbiAgICAgICAgICBvYmoucG9zX29yYml0YSA9IG51bSAtIGxpbVN1cCAtIDE7XG4gICAgICAgICAgb2JqLmluY3JfYW5ndWxvUmFkID0gMiAqIE1hdGguUEkgLyBvYmouY29fb3JiaXRhbnRlcztcblxuICAgICAgICAgIGlmIChvYmoub3JiaXRhbCAlIDIgPT0gMCkge1xuICAgICAgICAgICAgb2JqLmRpciA9IDE7XG4gICAgICAgICAgICBvYmouaW5jciA9IDA7XG4gICAgICAgICAgICBvYmouYW5ndWxvUmFkID0gb2JqLnBvc19vcmJpdGEgKiBvYmouaW5jcl9hbmd1bG9SYWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9iai5kaXIgPSAtMTtcbiAgICAgICAgICAgIG9iai5pbmNyID0gMTtcbiAgICAgICAgICAgIG9iai5hbmd1bG9SYWQgPSBvYmoucG9zX29yYml0YSAqIG9iai5pbmNyX2FuZ3Vsb1JhZCArIG9iai5pbmNyX2FuZ3Vsb1JhZCAvIDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JqLnJhZGlvID0gb2JqLm9yYml0YWwgKiB0aGlzLmluY3JfcmFkaW87IC8vLS1cblxuICAgICAgICAgIG9iai54ID0gTWF0aC5jb3Mob2JqLmFuZ3Vsb1JhZCkgKiBvYmoucmFkaW87XG4gICAgICAgICAgb2JqLnkgPSBNYXRoLnNpbihvYmouYW5ndWxvUmFkKSAqIG9iai5yYWRpbztcbiAgICAgICAgICBvYmoueiA9IDA7XG4gICAgICAgIH0gLy9icmVha1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFib3V0MUdlb21ldHJ5O1xufShFdmVudEVtaXR0ZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBBYm91dDFHZW9tZXRyeTsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8vaW1wb3J0IERhdG9zIGZyb20gJy4uL0RhdG9zJztcbnZhciBBYm91dDFEb3RQdWxzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFib3V0MURvdFB1bHNlKG9iaikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBYm91dDFEb3RQdWxzZSk7XG5cbiAgICAvL2NvbnNvbGUubG9nKFwiKEFib3V0MURvdFB1bHNlLkNPTlNUUlVDVE9SQSk6IFwiLCBvYmopXG4gICAgdGhpcy5wdWxzZXMgPSBvYmoucHVsc2VzO1xuICAgIHRoaXMuZG90R2VvbSA9IG9iai5kb3RHZW9tO1xuICAgIHRoaXMucHVsc2VQb3MgPSBvYmoucHVsc2VQb3M7XG4gICAgdGhpcy5wdWxzZUlkID0gb2JqLnB1bHNlSWQ7XG4gICAgdGhpcy5kb3RQb3MgPSBvYmouZG90UG9zOyAvLy0tXG5cbiAgICB0aGlzLmxpZmVUaW1lID0gMztcbiAgICB0aGlzLnN0YXJ0VGltZSA9IHRoaXMuZG90R2VvbS5jbG9jay5nZXRFbGFwc2VkVGltZSgpO1xuICAgIHRoaXMuZW5kVGltZSA9IHRoaXMuc3RhcnRUaW1lICsgdGhpcy5saWZlVGltZTsgLy8tLVxuICAgIC8vdGhpcy5zZXR0aW5ncyA9IHRoaXMuZG90R2VvbS5zZXR0aW5nc1xuICAgIC8vLS1cbiAgICAvL3RoaXMuc2V0dGluZ3NbXCJwdWxzZU51bV9cIit0aGlzLnB1bHNlUG9zXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoxMDAwKVxuICAgIC8vdGhpcy5zZXR0aW5nc1tcInB1bHNlSW5pdFRpbWVfXCIrdGhpcy5wdWxzZVBvc10gPSB0aGlzLmRvdEdlb20uY2xvY2suZ2V0RWxhcHNlZFRpbWUoKVxuICAgIC8vdGhpcy5zZXR0aW5nc1tcInB1bHNlUHJvZ3Jlc3NfXCIrdGhpcy5wdWxzZVBvc10gPSAwXG4gICAgLy8tLVxuICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFBVQkxJQ09TOlxuXG5cbiAgX2NyZWF0ZUNsYXNzKEFib3V0MURvdFB1bHNlLCBbe1xuICAgIGtleTogXCJnZXRfcHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0X3Byb2dyZXNzKHVUaW1lKSB7XG4gICAgICB2YXIgdCA9IHVUaW1lIC0gdGhpcy5zdGFydFRpbWU7XG4gICAgICB2YXIgdGltZVByb2dyZXNzID0gKHVUaW1lIC0gdGhpcy5zdGFydFRpbWUpIC8gdGhpcy5saWZlVGltZTtcbiAgICAgIHZhciBwcm9ncmVzcztcblxuICAgICAgaWYgKHRpbWVQcm9ncmVzcyA8IDAuNSkge1xuICAgICAgICBwcm9ncmVzcyA9IHRoaXMuX2Vhc2VJbk91dFF1YWQodCwgMCwgMSwgdGhpcy5saWZlVGltZSAvIDIpO1xuICAgICAgfSBlbHNlIGlmICh0aW1lUHJvZ3Jlc3MgPj0gMC41ICYmIHRpbWVQcm9ncmVzcyA8IDEpIHtcbiAgICAgICAgdmFyIHQyID0gdCAtIHRoaXMubGlmZVRpbWUgLyAyO1xuICAgICAgICBwcm9ncmVzcyA9IDEgLSB0aGlzLl9lYXNlSW5PdXRRdWFkKHQyLCAwLCAxLCB0aGlzLmxpZmVUaW1lIC8gMik7XG4gICAgICB9IGVsc2UgaWYgKHRpbWVQcm9ncmVzcyA+PSAxKSB7XG4gICAgICAgIHByb2dyZXNzID0gMDtcblxuICAgICAgICB0aGlzLl9pbml0S2lsbCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gICAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFBSSVZBRE9TXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdEtpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRLaWxsKCkge1xuICAgICAgdGhpcy5wdWxzZXMua2lsbFB1bHNlKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZWFzZUluT3V0UXVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZWFzZUluT3V0UXVhZCh0LCBiLCBjLCBkKSB7XG4gICAgICAvL3QgaXMgY3VycmVudCB0aW1lXG4gICAgICAvL2IgaXMgc3RhcnQgdmFsdWVcbiAgICAgIC8vYyBpcyBjaGFuZ2UgaW4gdmFsdWVcbiAgICAgIC8vZCBpcyBkdXJhdGlvblxuICAgICAgdCAvPSBkIC8gMjtcbiAgICAgIGlmICh0IDwgMSkgcmV0dXJuIGMgLyAyICogdCAqIHQgKyBiO1xuICAgICAgdC0tO1xuICAgICAgcmV0dXJuIC1jIC8gMiAqICh0ICogKHQgLSAyKSAtIDEpICsgYjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWJvdXQxRG90UHVsc2U7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IEFib3V0MURvdFB1bHNlOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuaW1wb3J0IEFib3V0MURvdFB1bHNlIGZyb20gJy4vQWJvdXQxRG90UHVsc2UnOyAvL2ltcG9ydCBEYXRvcyBmcm9tICcuL0RhdG9zJztcblxuaW1wb3J0IGdzYXAgZnJvbSBcImdzYXBcIjtcblxudmFyIEFib3V0MVB1bHNlcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFib3V0MVB1bHNlcyhvYmopIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvdXQxUHVsc2VzKTtcblxuICAgIC8vY29uc29sZS5sb2coXCIoQWJvdXQxUHVsc2VzLkNPTlNUUlVDVE9SQSkhOiBcIiwgb2JqKVxuICAgIHRoaXMuZG90R2VvbSA9IG9iai5kb3RHZW9tOyAvLy0tXG5cbiAgICB0aGlzLm1heFB1bHNlcyA9IDEwO1xuICAgIHRoaXMudGltZU1pbiA9IDA7XG4gICAgdGhpcy50aW1lTWF4ID0gMC43O1xuICAgIHRoaXMuYXV0b051bSA9IDA7XG4gICAgdGhpcy5hcnJheVB1bHNlU2xvdHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXhQdWxzZXM7IGkrKykge1xuICAgICAgdGhpcy5hcnJheVB1bHNlU2xvdHMucHVzaChudWxsKTtcbiAgICB9IC8vdGhpcy5hcnJheVB1bHNlU2xvdHMgPSBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF1cblxuXG4gICAgdGhpcy5hcnJheURvdFBvcyA9IFtdOyAvLy0tXG5cbiAgICB0aGlzLl9pbml0KCk7XG4gIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUFVCTElDT1NcblxuXG4gIF9jcmVhdGVDbGFzcyhBYm91dDFQdWxzZXMsIFt7XG4gICAga2V5OiBcImdldF9kb3RQb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0X2RvdFBvcyhwdWxzZVBvcykge1xuICAgICAgaWYgKHRoaXMuYXJyYXlQdWxzZVNsb3RzW3B1bHNlUG9zXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheVB1bHNlU2xvdHNbcHVsc2VQb3NdLmRvdFBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRfcHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0X3Byb2dyZXNzKHB1bHNlUG9zLCB1VGltZSkge1xuICAgICAgaWYgKHRoaXMuYXJyYXlQdWxzZVNsb3RzW3B1bHNlUG9zXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheVB1bHNlU2xvdHNbcHVsc2VQb3NdLmdldF9wcm9ncmVzcyh1VGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwia2lsbFB1bHNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGxQdWxzZShwdWxzZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy9jb25zb2xlLmxvZyhcIihBYm91dDFQdWxzZXMua2lsbFB1bHNlKTogXCIrcHVsc2UucHVsc2VJZClcbiAgICAgIHZhciBwb3NBcnJheSA9IHRoaXMuYXJyYXlEb3RQb3MuaW5kZXhPZihwdWxzZS5kb3RQb3MpO1xuICAgICAgdGhpcy5hcnJheURvdFBvcy5zcGxpY2UocG9zQXJyYXksIDEpO1xuICAgICAgdGhpcy5hcnJheVB1bHNlU2xvdHNbcHVsc2UucHVsc2VQb3NdID0gbnVsbDsgLy8tLVxuXG4gICAgICBnc2FwLmRlbGF5ZWRDYWxsKHRoaXMuX2dldF9yYW5kb21EZWxheSgpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl9ldmFsX2NyZWF0ZVB1bHNlKCk7XG4gICAgICB9KTtcbiAgICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUFJJVkFET1NcblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXhQdWxzZXM7IGkrKykge1xuICAgICAgICBnc2FwLmRlbGF5ZWRDYWxsKHRoaXMuX2dldF9yYW5kb21EZWxheSgpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLl9ldmFsX2NyZWF0ZVB1bHNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZXZhbF9jcmVhdGVQdWxzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZhbF9jcmVhdGVQdWxzZSgpIHtcbiAgICAgIHZhciBwdWxzZVBvcyA9IHRoaXMuX2dldF9wdWxzZVBvcygpOyAvL2NvbnNvbGUubG9nKFwicHVsc2VQb3M6IFwiK3B1bHNlUG9zKVxuXG5cbiAgICAgIGlmIChwdWxzZVBvcyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVB1bHNlKHB1bHNlUG9zKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVB1bHNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVQdWxzZShwdWxzZVBvcykge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihBYm91dDFQdWxzZXMuX2NyZWF0ZVB1bHNlKTogXCIsIHRoaXMuYXJyYXlEb3RQb3MpXG4gICAgICB2YXIgcHVsc2VJZCA9IFwicHVsc2VfXCIgKyB0aGlzLmF1dG9OdW07XG5cbiAgICAgIHZhciBkb3RQb3MgPSB0aGlzLl9nZXRfZG90UG9zKCk7XG5cbiAgICAgIHRoaXMuYXJyYXlEb3RQb3MucHVzaChkb3RQb3MpO1xuICAgICAgdGhpcy5hdXRvTnVtKys7XG4gICAgICB2YXIgcHVsc2UgPSBuZXcgQWJvdXQxRG90UHVsc2Uoe1xuICAgICAgICBwdWxzZXM6IHRoaXMsXG4gICAgICAgIGRvdEdlb206IHRoaXMuZG90R2VvbSxcbiAgICAgICAgcHVsc2VQb3M6IHB1bHNlUG9zLFxuICAgICAgICBwdWxzZUlkOiBwdWxzZUlkLFxuICAgICAgICBkb3RQb3M6IGRvdFBvc1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFycmF5UHVsc2VTbG90c1twdWxzZVBvc10gPSBwdWxzZTtcbiAgICB9IC8vLS0tLS0tXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0X3B1bHNlUG9zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRfcHVsc2VQb3MoKSB7XG4gICAgICAvLyBCdXNjYSB1biBzbG90IGxpYnJlIHkgZGV2dWVsdmUgc3UgcG9zaWNpw7NuLlxuICAgICAgLy8gU2kgbm8gaGF5IHNsb3QgbGlicmVzIGRldnVlbHZlIG51bGxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcnJheVB1bHNlU2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuYXJyYXlQdWxzZVNsb3RzW2ldID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldF9kb3RQb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9kb3RQb3MoKSB7XG4gICAgICAvLyBFc2NvamUgdW4gcHVudG8gYWwgYXphciB5IGNvbXBydWViYSBxdWUgbm8gZXN0w6EgYWN0aXZvIGVuIG90cm8gcHVsc2UgeSBsbyBkZXZ1ZWx2ZS5cbiAgICAgIC8vIFkgZWwgcHVudG8gZXNjb2dpZG8gc2kgZXN0w6EgYWN0aXZvIGxhbnphIGRlIG51ZXZvIGxvcyBkYWRvcy5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgOTk5OTsgaSsrKSB7XG4gICAgICAgIHZhciBkb3RQb3MgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAzMDAwKTtcblxuICAgICAgICBpZiAodGhpcy5hcnJheURvdFBvcy5pbmRleE9mKGRvdFBvcykgPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gZG90UG9zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRfcmFuZG9tRGVsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9yYW5kb21EZWxheSgpIHtcbiAgICAgIHZhciBybmRSYW5nZSA9IHRoaXMudGltZU1heCAtIHRoaXMudGltZU1pbjtcbiAgICAgIHJldHVybiB0aGlzLnRpbWVNaW4gKyBNYXRoLnJhbmRvbSgpICogcm5kUmFuZ2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFib3V0MVB1bHNlcztcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgQWJvdXQxUHVsc2VzOyIsImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhX3JhbmRvbW5lc3M7XFxuYXR0cmlidXRlIHZlYzMgYV9nZW8xX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfZG90X251bTtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9nZW8xX29yYml0YWw7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9wb3Nfb3JiaXRhO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfaW5jcl9hbmd1bG9SYWQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9hbmd1bG9SYWQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfZ2VvMV9pbmNyO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfZGlyO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2dlbzFfcmFkaW87XFxuXFxuYXR0cmlidXRlIHZlYzMgYV9nZW8yX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfZ2VvM19wb3NpdGlvbjtcXG5cXG51bmlmb3JtIGZsb2F0IHVUaW1lO1xcbnVuaWZvcm0gZmxvYXQgdUNhbWFyYURpc3RhbmNlO1xcbnVuaWZvcm0gZmxvYXQgdVNjcm9sbFNwZWVkO1xcbnVuaWZvcm0gZmxvYXQgdVNjYWxlO1xcbnVuaWZvcm0gZmxvYXQgdVJlc3BvbnNpdmVTY2FsZTtcXG51bmlmb3JtIGZsb2F0IHVTY3JvbGxEZWx0YTtcXG51bmlmb3JtIGZsb2F0IHVTY3JvbGxQcm9ncmVzcztcXG51bmlmb3JtIGZsb2F0IHVNb3JwaGluZ1Byb2dyZXNzO1xcbnVuaWZvcm0gZmxvYXQgdUludHJvUHJvZ3Jlc3M7XFxuXFxudW5pZm9ybSBmbG9hdCB1Um90YXRpb25Jbm5lcjtcXG51bmlmb3JtIGZsb2F0IHVSb3RhdGlvbk91dHRlcjtcXG5cXG51bmlmb3JtIGZsb2F0IHVQdWxzZU51bV8wO1xcbnVuaWZvcm0gZmxvYXQgdVB1bHNlUHJvZ3Jlc3NfMDtcXG51bmlmb3JtIGZsb2F0IHVQdWxzZU51bV8xO1xcbnVuaWZvcm0gZmxvYXQgdVB1bHNlUHJvZ3Jlc3NfMTtcXG51bmlmb3JtIGZsb2F0IHVQdWxzZU51bV8yO1xcbnVuaWZvcm0gZmxvYXQgdVB1bHNlUHJvZ3Jlc3NfMjtcXG51bmlmb3JtIGZsb2F0IHVQdWxzZU51bV8zO1xcbnVuaWZvcm0gZmxvYXQgdVB1bHNlUHJvZ3Jlc3NfMztcXG51bmlmb3JtIGZsb2F0IHVQdWxzZU51bV80O1xcbnVuaWZvcm0gZmxvYXQgdVB1bHNlUHJvZ3Jlc3NfNDtcXG51bmlmb3JtIGZsb2F0IHVQdWxzZU51bV81O1xcbnVuaWZvcm0gZmxvYXQgdVB1bHNlUHJvZ3Jlc3NfNTtcXG51bmlmb3JtIGZsb2F0IHVQdWxzZU51bV82O1xcbnVuaWZvcm0gZmxvYXQgdVB1bHNlUHJvZ3Jlc3NfNjtcXG51bmlmb3JtIGZsb2F0IHVQdWxzZU51bV83O1xcbnVuaWZvcm0gZmxvYXQgdVB1bHNlUHJvZ3Jlc3NfNztcXG51bmlmb3JtIGZsb2F0IHVQdWxzZU51bV84O1xcbnVuaWZvcm0gZmxvYXQgdVB1bHNlUHJvZ3Jlc3NfODtcXG51bmlmb3JtIGZsb2F0IHVQdWxzZU51bV85O1xcbnVuaWZvcm0gZmxvYXQgdVB1bHNlUHJvZ3Jlc3NfOTtcXG5cXG51bmlmb3JtIGZsb2F0IHVQcm9ncmVzczA7XFxudW5pZm9ybSBmbG9hdCB1UHJvZ3Jlc3MwYjtcXG5cXG51bmlmb3JtIGZsb2F0IHVQcm9ncmVzczE7XFxudW5pZm9ybSBmbG9hdCB1UHJvZ3Jlc3MyO1xcbnVuaWZvcm0gZmxvYXQgdVByb2dyZXNzMztcXG51bmlmb3JtIGZsb2F0IHVQcm9ncmVzczQ7XFxudW5pZm9ybSBmbG9hdCB1UHJvZ3Jlc3M0YjtcXG51bmlmb3JtIGZsb2F0IHVQcm9ncmVzczU7XFxudW5pZm9ybSBmbG9hdCB1UHJvZ3Jlc3M2O1xcbnVuaWZvcm0gZmxvYXQgdVByb2dyZXNzNmI7XFxuXFxuLy8gdmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcXG4vL3ZhcnlpbmcgdmVjMiB2VXY7XFxudmFyeWluZyB2ZWMzIHZfcmFuZG9tbmVzcztcXG52YXJ5aW5nIGZsb2F0IHZfY29sb3JTdHJlbmd0aDtcXG5cXG52YXJ5aW5nIGZsb2F0IHZfYWN0aXZlUHVsc2U7XFxudmFyeWluZyBmbG9hdCB2X2FjdGl2ZVB1bHNlUHJvZ3Jlc3M7XFxudmFyeWluZyBmbG9hdCB2X3Rlc3Q7XFxuXFxuLy9cXHRDbGFzc2ljIFBlcmxpbiAzRCBOb2lzZSBcXG4vL1xcdGJ5IFN0ZWZhbiBHdXN0YXZzb25cXG4vL1xcbnZlYzQgcGVybXV0ZSh2ZWM0IHgpe3JldHVybiBtb2QoKCh4KjM0LjApKzEuMCkqeCwgMjg5LjApO31cXG52ZWM0IHRheWxvckludlNxcnQodmVjNCByKXtyZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO31cXG52ZWMzIGZhZGUodmVjMyB0KSB7cmV0dXJuIHQqdCp0Kih0Kih0KjYuMC0xNS4wKSsxMC4wKTt9XFxuXFxuZmxvYXQgY25vaXNlKHZlYzMgUCl7XFxuICB2ZWMzIFBpMCA9IGZsb29yKFApOyAvLyBJbnRlZ2VyIHBhcnQgZm9yIGluZGV4aW5nXFxuICB2ZWMzIFBpMSA9IFBpMCArIHZlYzMoMS4wKTsgLy8gSW50ZWdlciBwYXJ0ICsgMVxcbiAgUGkwID0gbW9kKFBpMCwgMjg5LjApO1xcbiAgUGkxID0gbW9kKFBpMSwgMjg5LjApO1xcbiAgdmVjMyBQZjAgPSBmcmFjdChQKTsgLy8gRnJhY3Rpb25hbCBwYXJ0IGZvciBpbnRlcnBvbGF0aW9uXFxuICB2ZWMzIFBmMSA9IFBmMCAtIHZlYzMoMS4wKTsgLy8gRnJhY3Rpb25hbCBwYXJ0IC0gMS4wXFxuICB2ZWM0IGl4ID0gdmVjNChQaTAueCwgUGkxLngsIFBpMC54LCBQaTEueCk7XFxuICB2ZWM0IGl5ID0gdmVjNChQaTAueXksIFBpMS55eSk7XFxuICB2ZWM0IGl6MCA9IFBpMC56enp6O1xcbiAgdmVjNCBpejEgPSBQaTEuenp6ejtcXG5cXG4gIHZlYzQgaXh5ID0gcGVybXV0ZShwZXJtdXRlKGl4KSArIGl5KTtcXG4gIHZlYzQgaXh5MCA9IHBlcm11dGUoaXh5ICsgaXowKTtcXG4gIHZlYzQgaXh5MSA9IHBlcm11dGUoaXh5ICsgaXoxKTtcXG5cXG4gIHZlYzQgZ3gwID0gaXh5MCAvIDcuMDtcXG4gIHZlYzQgZ3kwID0gZnJhY3QoZmxvb3IoZ3gwKSAvIDcuMCkgLSAwLjU7XFxuICBneDAgPSBmcmFjdChneDApO1xcbiAgdmVjNCBnejAgPSB2ZWM0KDAuNSkgLSBhYnMoZ3gwKSAtIGFicyhneTApO1xcbiAgdmVjNCBzejAgPSBzdGVwKGd6MCwgdmVjNCgwLjApKTtcXG4gIGd4MCAtPSBzejAgKiAoc3RlcCgwLjAsIGd4MCkgLSAwLjUpO1xcbiAgZ3kwIC09IHN6MCAqIChzdGVwKDAuMCwgZ3kwKSAtIDAuNSk7XFxuXFxuICB2ZWM0IGd4MSA9IGl4eTEgLyA3LjA7XFxuICB2ZWM0IGd5MSA9IGZyYWN0KGZsb29yKGd4MSkgLyA3LjApIC0gMC41O1xcbiAgZ3gxID0gZnJhY3QoZ3gxKTtcXG4gIHZlYzQgZ3oxID0gdmVjNCgwLjUpIC0gYWJzKGd4MSkgLSBhYnMoZ3kxKTtcXG4gIHZlYzQgc3oxID0gc3RlcChnejEsIHZlYzQoMC4wKSk7XFxuICBneDEgLT0gc3oxICogKHN0ZXAoMC4wLCBneDEpIC0gMC41KTtcXG4gIGd5MSAtPSBzejEgKiAoc3RlcCgwLjAsIGd5MSkgLSAwLjUpO1xcblxcbiAgdmVjMyBnMDAwID0gdmVjMyhneDAueCxneTAueCxnejAueCk7XFxuICB2ZWMzIGcxMDAgPSB2ZWMzKGd4MC55LGd5MC55LGd6MC55KTtcXG4gIHZlYzMgZzAxMCA9IHZlYzMoZ3gwLnosZ3kwLnosZ3owLnopO1xcbiAgdmVjMyBnMTEwID0gdmVjMyhneDAudyxneTAudyxnejAudyk7XFxuICB2ZWMzIGcwMDEgPSB2ZWMzKGd4MS54LGd5MS54LGd6MS54KTtcXG4gIHZlYzMgZzEwMSA9IHZlYzMoZ3gxLnksZ3kxLnksZ3oxLnkpO1xcbiAgdmVjMyBnMDExID0gdmVjMyhneDEueixneTEueixnejEueik7XFxuICB2ZWMzIGcxMTEgPSB2ZWMzKGd4MS53LGd5MS53LGd6MS53KTtcXG5cXG4gIHZlYzQgbm9ybTAgPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KGcwMDAsIGcwMDApLCBkb3QoZzAxMCwgZzAxMCksIGRvdChnMTAwLCBnMTAwKSwgZG90KGcxMTAsIGcxMTApKSk7XFxuICBnMDAwICo9IG5vcm0wLng7XFxuICBnMDEwICo9IG5vcm0wLnk7XFxuICBnMTAwICo9IG5vcm0wLno7XFxuICBnMTEwICo9IG5vcm0wLnc7XFxuICB2ZWM0IG5vcm0xID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChnMDAxLCBnMDAxKSwgZG90KGcwMTEsIGcwMTEpLCBkb3QoZzEwMSwgZzEwMSksIGRvdChnMTExLCBnMTExKSkpO1xcbiAgZzAwMSAqPSBub3JtMS54O1xcbiAgZzAxMSAqPSBub3JtMS55O1xcbiAgZzEwMSAqPSBub3JtMS56O1xcbiAgZzExMSAqPSBub3JtMS53O1xcblxcbiAgZmxvYXQgbjAwMCA9IGRvdChnMDAwLCBQZjApO1xcbiAgZmxvYXQgbjEwMCA9IGRvdChnMTAwLCB2ZWMzKFBmMS54LCBQZjAueXopKTtcXG4gIGZsb2F0IG4wMTAgPSBkb3QoZzAxMCwgdmVjMyhQZjAueCwgUGYxLnksIFBmMC56KSk7XFxuICBmbG9hdCBuMTEwID0gZG90KGcxMTAsIHZlYzMoUGYxLnh5LCBQZjAueikpO1xcbiAgZmxvYXQgbjAwMSA9IGRvdChnMDAxLCB2ZWMzKFBmMC54eSwgUGYxLnopKTtcXG4gIGZsb2F0IG4xMDEgPSBkb3QoZzEwMSwgdmVjMyhQZjEueCwgUGYwLnksIFBmMS56KSk7XFxuICBmbG9hdCBuMDExID0gZG90KGcwMTEsIHZlYzMoUGYwLngsIFBmMS55eikpO1xcbiAgZmxvYXQgbjExMSA9IGRvdChnMTExLCBQZjEpO1xcblxcbiAgdmVjMyBmYWRlX3h5eiA9IGZhZGUoUGYwKTtcXG4gIHZlYzQgbl96ID0gbWl4KHZlYzQobjAwMCwgbjEwMCwgbjAxMCwgbjExMCksIHZlYzQobjAwMSwgbjEwMSwgbjAxMSwgbjExMSksIGZhZGVfeHl6LnopO1xcbiAgdmVjMiBuX3l6ID0gbWl4KG5fei54eSwgbl96Lnp3LCBmYWRlX3h5ei55KTtcXG4gIGZsb2F0IG5feHl6ID0gbWl4KG5feXoueCwgbl95ei55LCBmYWRlX3h5ei54KTsgXFxuICByZXR1cm4gMi4yICogbl94eXo7XFxufVxcblxcbnZlYzMgZ2V0X3BvczEoZmxvYXQgYW5ndWxvUmFkKXtcXG4gICAgLy9mbG9hdCBhbmd1bG9SYWQgPSBhX2dlbzFfcG9zX29yYml0YSphX2dlbzFfaW5jcl9hbmd1bG9SYWQrKChhX2dlbzFfaW5jcl9hbmd1bG9SYWQvMi4pKmFfZ2VvMV9pbmNyKSsoMS4qYV9nZW8xX2RpciowLjIpO1xcbiAgICBmbG9hdCB4ID0gY29zKGFuZ3Vsb1JhZCkqYV9nZW8xX3JhZGlvO1xcbiAgICBmbG9hdCB5ID0gc2luKGFuZ3Vsb1JhZCkqYV9nZW8xX3JhZGlvO1xcbiAgICBmbG9hdCB6ID0gMC4wO1xcbiAgICB2ZWMzIG5ld1BvcyA9IHZlYzMoeCwgeSwgeik7XFxuICAgIHJldHVybiBuZXdQb3M7XFxufVxcblxcbnZlYzMgZ2V0X3Bvc1Njcm9sbFNwZWVkKHZlYzMgcG9zKXtcXG4gICAgZmxvYXQgZmFjdG9yID0gbWl4KDEuMCwgMi4wLCB1U2Nyb2xsU3BlZWQpO1xcbiAgICBwb3MgPSBwb3MqZmFjdG9yO1xcbiAgICByZXR1cm4gcG9zO1xcbn1cXG5cXG5mbG9hdCBnZXRfZXNjYWxhTm9pc2UoZmxvYXQgeCwgZmxvYXQgeSwgZmxvYXQgYW1wbGl0dWRNYXBhLCBmbG9hdCBwcm9ncmVzcyl7XFxuICAgIGZsb2F0IHZhbG9yID0gY25vaXNlKHZlYzMoeC9hbXBsaXR1ZE1hcGEsIHkvYW1wbGl0dWRNYXBhLCBwcm9ncmVzcykpO1xcbiAgICB2YWxvciA9IDAuNSsodmFsb3IvMi4pO1xcbiAgICB2YWxvciAqPTIuO1xcbiAgICByZXR1cm4gdmFsb3I7XFxufVxcblxcbmZsb2F0IGdldF9lc2NhbGFPbmRhUmFkaWFsKGZsb2F0IG9yYml0YWwsIGZsb2F0IHByb2dyZXNzKXtcXG4gICAgZmxvYXQgZnJlY3VlbmNpYSA9IDAuNTsgLy8gVmFsb3JlcyBiYWpvcyBvbmRhcyBtYXMgbGFyZ2FzLCB2YWxvcmVzIGFsdG9zIG9uZGFzIG1hcyBjb3J0YXNcXG4gICAgZmxvYXQgc2VubyA9IChzaW4oKHByb2dyZXNzK29yYml0YWwpKmZyZWN1ZW5jaWEpKzEuKS8yLjtcXG5cXG4gICAgZmxvYXQgdmFsb3IgPSAwLjUrKHNlbm8qMC41KTtcXG5cXG4gICAgcmV0dXJuIHZhbG9yO1xcbn1cXG5cXG5mbG9hdCBnZXRfZXNjYWxhRWRnZShmbG9hdCBvcmJpdGFsKXtcXG4gICAgZmxvYXQgdmFsdWUgPSAxLjtcXG4gICAgZmxvYXQgb3JiaXRhbE1heCA9IDM3LjtcXG4gICAgZmxvYXQgZmFkZUxpbWl0ID0gMjIuO1xcbiAgICBmbG9hdCBmYWRlU2NhbGUgPSAxLjtcXG4gICAgZmxvYXQgcmFuZ28gPSBvcmJpdGFsTWF4IC1mYWRlTGltaXQ7XFxuICAgIGlmKG9yYml0YWwgPj0gZmFkZUxpbWl0KXtcXG4gICAgICAgIGZsb2F0IG9yYml0YWxSZWwgPSBvcmJpdGFsIC1mYWRlTGltaXQ7XFxuICAgICAgICBmbG9hdCByYXRpbyA9IG9yYml0YWxSZWwvcmFuZ287XFxuICAgICAgICBmYWRlU2NhbGUgPSBmYWRlU2NhbGUtcmF0aW87XFxuICAgIH1cXG4gICAgcmV0dXJuIGZhZGVTY2FsZTtcXG59XFxuXFxudmVjMyByYW5kb21pemVQb3NpdGlvbih2ZWMzIG9sZFBvcywgdmVjMyByYW5kb21uZXNzLCBmbG9hdCB0aW1lLCBmbG9hdCBhbXBsaXR1ZGUsIGZsb2F0IGFtb3VudCwgZmxvYXQgc3BlZWQpe1xcbiAgICB0aW1lID0gdGltZSpzcGVlZDtcXG4gICAgdmVjMyBuZXdQb3MgPSBvbGRQb3M7XFxuICAgIG5ld1Bvcy54ICs9IHNpbih0aW1lICogcmFuZG9tbmVzcy54KSAqIChhbXBsaXR1ZGUqYW1vdW50KTtcXG4gICAgbmV3UG9zLnkgKz0gY29zKHRpbWUgKiByYW5kb21uZXNzLnkpICogKGFtcGxpdHVkZSphbW91bnQpO1xcbiAgICBuZXdQb3MueiArPSBjb3ModGltZSAqIHJhbmRvbW5lc3MueikgKiAoYW1wbGl0dWRlKmFtb3VudCk7XFxuICAgIHJldHVybiBuZXdQb3M7XFxufVxcblxcbmZsb2F0IHF1aW50aWNPdXQoZmxvYXQgdCkge1xcbiAgcmV0dXJuIChwb3codCAtIDEuMCwgNS4wKSk7XFxufVxcblxcbmZsb2F0IHF1YWRyYXRpY091dChmbG9hdCB0KSB7XFxuICByZXR1cm4gLXQgKiAodCAtIDIuMCk7XFxufVxcblxcbmZsb2F0IHF1YXJ0aWNPdXQoZmxvYXQgdCkge1xcbiAgcmV0dXJuIHBvdyh0IC0gMS4wLCAzLjApICogKDEuMCAtIHQpICsgMS4wO1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIC8vIGZsb2F0IHRpbWUgPSB1VGltZSAqIDQuOyAgICBcXG5cXG4gICAgLy92ZWMzIHBvcyA9IG1peChwb3NpdGlvbiwgYV9nZW8xX3Bvc2l0aW9uLCB1UHJvZ3Jlc3MpO1xcbiAgICAvLyB2ZWMzIHBvcyA9IGFfZ2VvMl9wb3NpdGlvbjtcXG4gICAgLy92ZWMzIHBvcyA9IHBvc2l0aW9uO1xcbiAgICAvL3ZlYzMgcG9zMSA9IGdldF9wb3MxKCk7XFxuICAgIC8vcG9zMSA9IHBvczEqKHNpbigoLXVUaW1lK2FfZ2VvMV9vcmJpdGFsKSowLjUpKzIuKSowLjE7XFxuXFxuICAgIC8vZmxvYXQgc2Vub0Z4ID0gc2luKCgtdVRpbWUrYV9nZW8xX29yYml0YWwpKSowLjUqMC41O1xcbiAgICAvL2Zsb2F0IGVzY2FsYUZ4ID0gbWl4KDAuOTgsIDEuMDIsIHNlbm9GeCk7XFxuICAgIC8vcG9zMSA9IHBvczEqZXNjYWxhRng7XFxuICAgIC8vcG9zMSA9IGdldF9wb3NTY3JvbGxTcGVlZChwb3MxKTtcXG5cXG4gICAgLy92ZWMzIGVuZFBvcyA9IG1peChhX2dlbzJfcG9zaXRpb24sIGFfZ2VvM19wb3NpdGlvbiwgMC4pO1xcbiAgICAvL3ZlYzMgZW5kUG9zID0gYV9nZW8yX3Bvc2l0aW9uO1xcbiAgICAvL3ZlYzMgcG9zID0gbWl4KHBvczEsIGFfZ2VvMl9wb3NpdGlvbiwgdVByb2dyZXNzMSk7XFxuICAgIC8vcG9zID0gcmFuZG9taXplUG9zaXRpb24ocG9zLCBhX3JhbmRvbW5lc3MsIHVUaW1lLCA1LjAsIHVQcm9ncmVzczEsIDUuKTtcXG4gICAgLy8gcG9zLnggKz0gc2luKHRpbWUgKiBhX3JhbmRvbW5lc3MueCkgKjAuMDI7XFxuICAgIC8vIHBvcy55ICs9IGNvcyh0aW1lICogYV9yYW5kb21uZXNzLnkpICowLjAyO1xcbiAgICAvLyBwb3MueiArPSBjb3ModGltZSAqIGFfcmFuZG9tbmVzcy56KSAqMC4wMjtcXG4gICAgXFxuICAgIC8vIHBvcyAqPSB1U2NhbGU7XFxuICAgIC8vIHZQb3NpdGlvbiA9IHBvcztcXG5cXG4gICAgXFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyBQVUxTT1M6XFxuICAgIHZfYWN0aXZlUHVsc2VQcm9ncmVzcyA9IDAuMDtcXG4gICAgZmxvYXQgcmVzdGE7XFxuICAgIGZsb2F0IGZhY3RvcjtcXG4gICAgcmVzdGEgPSBhYnMoYV9nZW8xX2RvdF9udW0gLSB1UHVsc2VOdW1fMCk7IC8vIERldnVlbHZlIHZhbG9yZXMgcG9zaXRpdm9zIGRvbmRlIGVuIGVsIGNhc28gZGUgY29pbmNpZGlyIGVsIGZsb2F0IHNlcsOhIDwgMC41IHkgc2lubyBzZXLDoSA+MC41XFxuICAgIGZhY3RvciA9IDEuMC0oc3RlcCgwLjUsIHJlc3RhKSk7IC8vIENyZWFtb3MgdW4gdmFsb3IgcGFyYSA8MC41IEFDVElWTyBzZWEgMS4geSA+MC41IERFU0FDVElWTyBzZWEgMFxcbiAgICB2X2FjdGl2ZVB1bHNlICs9IDEuMCpmYWN0b3I7XFxuICAgIHZfYWN0aXZlUHVsc2VQcm9ncmVzcyArPSB1UHVsc2VQcm9ncmVzc18wKmZhY3RvcjtcXG4gICAgLy8tLVxcbiAgICAvLy0tXFxuICAgIHJlc3RhID0gYWJzKGFfZ2VvMV9kb3RfbnVtIC0gdVB1bHNlTnVtXzEpOyAvLyBEZXZ1ZWx2ZSB2YWxvcmVzIHBvc2l0aXZvcyBkb25kZSBlbiBlbCBjYXNvIGRlIGNvaW5jaWRpciBlbCBmbG9hdCBzZXLDoSA8IDAuNSB5IHNpbm8gc2Vyw6EgPjAuNVxcbiAgICBmYWN0b3IgPSAxLjAtKHN0ZXAoMC41LCByZXN0YSkpOyAvLyBDcmVhbW9zIHVuIHZhbG9yIHBhcmEgPDAuNSBBQ1RJVk8gc2VhIDEuIHkgPjAuNSBERVNBQ1RJVk8gc2VhIDBcXG4gICAgdl9hY3RpdmVQdWxzZSArPSAxLjAqZmFjdG9yO1xcbiAgICB2X2FjdGl2ZVB1bHNlUHJvZ3Jlc3MgKz0gdVB1bHNlUHJvZ3Jlc3NfMSpmYWN0b3I7XFxuICAgIC8vLS1cXG4gICAgcmVzdGEgPSBhYnMoYV9nZW8xX2RvdF9udW0gLSB1UHVsc2VOdW1fMik7IC8vIERldnVlbHZlIHZhbG9yZXMgcG9zaXRpdm9zIGRvbmRlIGVuIGVsIGNhc28gZGUgY29pbmNpZGlyIGVsIGZsb2F0IHNlcsOhIDwgMC41IHkgc2lubyBzZXLDoSA+MC41XFxuICAgIGZhY3RvciA9IDEuMC0oc3RlcCgwLjUsIHJlc3RhKSk7IC8vIENyZWFtb3MgdW4gdmFsb3IgcGFyYSA8MC41IEFDVElWTyBzZWEgMS4geSA+MC41IERFU0FDVElWTyBzZWEgMFxcbiAgICB2X2FjdGl2ZVB1bHNlICs9IDEuMCpmYWN0b3I7XFxuICAgIHZfYWN0aXZlUHVsc2VQcm9ncmVzcyArPSB1UHVsc2VQcm9ncmVzc18yKmZhY3RvcjtcXG4gICAgLy8tLVxcbiAgICByZXN0YSA9IGFicyhhX2dlbzFfZG90X251bSAtIHVQdWxzZU51bV8zKTsgLy8gRGV2dWVsdmUgdmFsb3JlcyBwb3NpdGl2b3MgZG9uZGUgZW4gZWwgY2FzbyBkZSBjb2luY2lkaXIgZWwgZmxvYXQgc2Vyw6EgPCAwLjUgeSBzaW5vIHNlcsOhID4wLjVcXG4gICAgZmFjdG9yID0gMS4wLShzdGVwKDAuNSwgcmVzdGEpKTsgLy8gQ3JlYW1vcyB1biB2YWxvciBwYXJhIDwwLjUgQUNUSVZPIHNlYSAxLiB5ID4wLjUgREVTQUNUSVZPIHNlYSAwXFxuICAgIHZfYWN0aXZlUHVsc2UgKz0gMS4wKmZhY3RvcjtcXG4gICAgdl9hY3RpdmVQdWxzZVByb2dyZXNzICs9IHVQdWxzZVByb2dyZXNzXzMqZmFjdG9yO1xcbiAgICAvLy0tXFxuICAgIHJlc3RhID0gYWJzKGFfZ2VvMV9kb3RfbnVtIC0gdVB1bHNlTnVtXzQpOyAvLyBEZXZ1ZWx2ZSB2YWxvcmVzIHBvc2l0aXZvcyBkb25kZSBlbiBlbCBjYXNvIGRlIGNvaW5jaWRpciBlbCBmbG9hdCBzZXLDoSA8IDAuNSB5IHNpbm8gc2Vyw6EgPjAuNVxcbiAgICBmYWN0b3IgPSAxLjAtKHN0ZXAoMC41LCByZXN0YSkpOyAvLyBDcmVhbW9zIHVuIHZhbG9yIHBhcmEgPDAuNSBBQ1RJVk8gc2VhIDEuIHkgPjAuNSBERVNBQ1RJVk8gc2VhIDBcXG4gICAgdl9hY3RpdmVQdWxzZSArPSAxLjAqZmFjdG9yO1xcbiAgICB2X2FjdGl2ZVB1bHNlUHJvZ3Jlc3MgKz0gdVB1bHNlUHJvZ3Jlc3NfNCpmYWN0b3I7XFxuICAgIC8vLS1cXG4gICAgcmVzdGEgPSBhYnMoYV9nZW8xX2RvdF9udW0gLSB1UHVsc2VOdW1fNSk7IC8vIERldnVlbHZlIHZhbG9yZXMgcG9zaXRpdm9zIGRvbmRlIGVuIGVsIGNhc28gZGUgY29pbmNpZGlyIGVsIGZsb2F0IHNlcsOhIDwgMC41IHkgc2lubyBzZXLDoSA+MC41XFxuICAgIGZhY3RvciA9IDEuMC0oc3RlcCgwLjUsIHJlc3RhKSk7IC8vIENyZWFtb3MgdW4gdmFsb3IgcGFyYSA8MC41IEFDVElWTyBzZWEgMS4geSA+MC41IERFU0FDVElWTyBzZWEgMFxcbiAgICB2X2FjdGl2ZVB1bHNlICs9IDEuMCpmYWN0b3I7XFxuICAgIHZfYWN0aXZlUHVsc2VQcm9ncmVzcyArPSB1UHVsc2VQcm9ncmVzc181KmZhY3RvcjtcXG4gICAgLy8tLVxcbiAgICByZXN0YSA9IGFicyhhX2dlbzFfZG90X251bSAtIHVQdWxzZU51bV82KTsgLy8gRGV2dWVsdmUgdmFsb3JlcyBwb3NpdGl2b3MgZG9uZGUgZW4gZWwgY2FzbyBkZSBjb2luY2lkaXIgZWwgZmxvYXQgc2Vyw6EgPCAwLjUgeSBzaW5vIHNlcsOhID4wLjVcXG4gICAgZmFjdG9yID0gMS4wLShzdGVwKDAuNSwgcmVzdGEpKTsgLy8gQ3JlYW1vcyB1biB2YWxvciBwYXJhIDwwLjUgQUNUSVZPIHNlYSAxLiB5ID4wLjUgREVTQUNUSVZPIHNlYSAwXFxuICAgIHZfYWN0aXZlUHVsc2UgKz0gMS4wKmZhY3RvcjtcXG4gICAgdl9hY3RpdmVQdWxzZVByb2dyZXNzICs9IHVQdWxzZVByb2dyZXNzXzYqZmFjdG9yO1xcbiAgICAvLy0tXFxuICAgIHJlc3RhID0gYWJzKGFfZ2VvMV9kb3RfbnVtIC0gdVB1bHNlTnVtXzcpOyAvLyBEZXZ1ZWx2ZSB2YWxvcmVzIHBvc2l0aXZvcyBkb25kZSBlbiBlbCBjYXNvIGRlIGNvaW5jaWRpciBlbCBmbG9hdCBzZXLDoSA8IDAuNSB5IHNpbm8gc2Vyw6EgPjAuNVxcbiAgICBmYWN0b3IgPSAxLjAtKHN0ZXAoMC41LCByZXN0YSkpOyAvLyBDcmVhbW9zIHVuIHZhbG9yIHBhcmEgPDAuNSBBQ1RJVk8gc2VhIDEuIHkgPjAuNSBERVNBQ1RJVk8gc2VhIDBcXG4gICAgdl9hY3RpdmVQdWxzZSArPSAxLjAqZmFjdG9yO1xcbiAgICB2X2FjdGl2ZVB1bHNlUHJvZ3Jlc3MgKz0gdVB1bHNlUHJvZ3Jlc3NfNypmYWN0b3I7XFxuICAgIC8vLS1cXG4gICAgcmVzdGEgPSBhYnMoYV9nZW8xX2RvdF9udW0gLSB1UHVsc2VOdW1fOCk7IC8vIERldnVlbHZlIHZhbG9yZXMgcG9zaXRpdm9zIGRvbmRlIGVuIGVsIGNhc28gZGUgY29pbmNpZGlyIGVsIGZsb2F0IHNlcsOhIDwgMC41IHkgc2lubyBzZXLDoSA+MC41XFxuICAgIGZhY3RvciA9IDEuMC0oc3RlcCgwLjUsIHJlc3RhKSk7IC8vIENyZWFtb3MgdW4gdmFsb3IgcGFyYSA8MC41IEFDVElWTyBzZWEgMS4geSA+MC41IERFU0FDVElWTyBzZWEgMFxcbiAgICB2X2FjdGl2ZVB1bHNlICs9IDEuMCpmYWN0b3I7XFxuICAgIHZfYWN0aXZlUHVsc2VQcm9ncmVzcyArPSB1UHVsc2VQcm9ncmVzc184KmZhY3RvcjtcXG4gICAgLy8tLVxcbiAgICByZXN0YSA9IGFicyhhX2dlbzFfZG90X251bSAtIHVQdWxzZU51bV85KTsgLy8gRGV2dWVsdmUgdmFsb3JlcyBwb3NpdGl2b3MgZG9uZGUgZW4gZWwgY2FzbyBkZSBjb2luY2lkaXIgZWwgZmxvYXQgc2Vyw6EgPCAwLjUgeSBzaW5vIHNlcsOhID4wLjVcXG4gICAgZmFjdG9yID0gMS4wLShzdGVwKDAuNSwgcmVzdGEpKTsgLy8gQ3JlYW1vcyB1biB2YWxvciBwYXJhIDwwLjUgQUNUSVZPIHNlYSAxLiB5ID4wLjUgREVTQUNUSVZPIHNlYSAwXFxuICAgIHZfYWN0aXZlUHVsc2UgKz0gMS4wKmZhY3RvcjtcXG4gICAgdl9hY3RpdmVQdWxzZVByb2dyZXNzICs9IHVQdWxzZVByb2dyZXNzXzkqZmFjdG9yO1xcbiAgICAvLyBQVUxTT1M6XFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgLy8gUE9TSVRJT046XFxuICAgIGZsb2F0IHJvdGF0aW9uID0gbWl4KHVSb3RhdGlvbklubmVyLCB1Um90YXRpb25PdXR0ZXIsICgoYV9nZW8xX29yYml0YWwpKjEuKS8zNy4pO1xcbiAgICBmbG9hdCBhbmd1bG9SYWRfdGltZSA9IChhX2dlbzFfYW5ndWxvUmFkK3JvdGF0aW9uKTtcXG4gICAgLy8gR2VvbWV0cmllcyBwcmVzZW50OlxcbiAgICAvL2Zsb2F0IGFuZ3Vsb1JhZCA9IGFfZ2VvMV9wb3Nfb3JiaXRhKmFfZ2VvMV9pbmNyX2FuZ3Vsb1JhZCsoKGFfZ2VvMV9pbmNyX2FuZ3Vsb1JhZC8yLikqYV9nZW8xX2luY3IpKyh1U2Nyb2xsUHJvZ3Jlc3MqYV9nZW8xX2RpcioyLjIpO1xcbiAgICB2ZWMzIFBPU0lUSU9OXzEgPSBnZXRfcG9zMShhbmd1bG9SYWRfdGltZSk7XFxuICAgIC8vdmVjMyBQT1NJVElPTl8xID0gcG9zaXRpb247XFxuICAgIHZlYzMgUE9TSVRJT05fMiA9IGFfZ2VvMl9wb3NpdGlvbjtcXG4gICAgUE9TSVRJT05fMiA9IHJhbmRvbWl6ZVBvc2l0aW9uKFBPU0lUSU9OXzIsIGFfcmFuZG9tbmVzcywgdVRpbWUsIDUuMCwgdU1vcnBoaW5nUHJvZ3Jlc3MsIDUuKTtcXG4gICAgLy8gWiBtb2RpZmljYXRpb25zOlxcbiAgICBcXG4gICAgLy8gT25kYXMgZGUgc2VubzpcXG4gICAgZmxvYXQgc2Vub0Z4ID0gc2luKCgtdVRpbWUrYV9nZW8xX29yYml0YWwpKSowLjUqMC41O1xcbiAgICBmbG9hdCBlc2NhbGFGeCA9IG1peCgwLjk4LCAxLjAyLCBzZW5vRngpO1xcbiAgICAvL1BPU0lUSU9OXzEgKj0gZXNjYWxhRng7XFxuICAgIC8vIE1vcnBoaW5nOlxcbiAgICBmbG9hdCBjbGFtcGVkX21vcnBpbmdQcm9ncmVzcyA9IGNsYW1wKDAuLCAwLjk1LCB1TW9ycGhpbmdQcm9ncmVzcyk7XFxuICAgIFBPU0lUSU9OXzEgPSBtaXgoUE9TSVRJT05fMSwgUE9TSVRJT05fMiwgY2xhbXBlZF9tb3JwaW5nUHJvZ3Jlc3MpO1xcbiAgICAvLyBSYW5kb21pemVkIHBvc2l0aW9uIHdoaWxlIGluIFBPU0lUSU9OXzJcXG4gICAgUE9TSVRJT05fMSA9IHJhbmRvbWl6ZVBvc2l0aW9uKFBPU0lUSU9OXzEsIGFfcmFuZG9tbmVzcyoyLiwgdVRpbWUsIDUuMCwgdU1vcnBoaW5nUHJvZ3Jlc3MsIDIuNSk7XFxuICAgIC8vIEVzY2FsYSBwb3Igc2Nyb2xsIGRlbHRhOlxcbiAgICAvL1BPU0lUSU9OXzEgKj0gMS4rKHVTY3JvbGxEZWx0YSk7XFxuICAgIC8vIEVzY2FsYWRvIGluY2lhbDpcXG4gICAgLy9QT1NJVElPTl8xICo9IG1peCg1LiwgMS4sIHF1aW50aWNPdXQodUludHJvUHJvZ3Jlc3MpKTtcXG4gICAgLy9QT1NJVElPTl8xICo9IG1peCg1LiwgMS4sIHF1YWRyYXRpY091dCh1SW50cm9Qcm9ncmVzcykpO1xcbiAgICBmbG9hdCBjbGFtcGVkX3VJbnRyb1Byb2dyZXNzO1xcbiAgICAvLyBjbGFtcGVkX3VJbnRyb1Byb2dyZXNzID0gdUludHJvUHJvZ3Jlc3M7XFxuICAgIGNsYW1wZWRfdUludHJvUHJvZ3Jlc3MgPSBjbGFtcCh1SW50cm9Qcm9ncmVzcywgMC4sIDEuKTtcXG4gICAgLy9QT1NJVElPTl8xICo9IG1peCgxMC4sIDEuLCBxdWFydGljT3V0KGNsYW1wZWRfdUludHJvUHJvZ3Jlc3MpKTtcXG4gICAgUE9TSVRJT05fMSAqPSBtaXgoMTAuLCAxLiwgdUludHJvUHJvZ3Jlc3MpO1xcbiAgICAvLyBSZXNwb25zaXZlIFNjYWxlOlxcbiAgICBQT1NJVElPTl8xICo9IHVSZXNwb25zaXZlU2NhbGU7XFxuICAgIC8vXFxuICAgIFBPU0lUSU9OXzEgPSBtaXgoUE9TSVRJT05fMSwgUE9TSVRJT05fMiwgdU1vcnBoaW5nUHJvZ3Jlc3MpO1xcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIC8vIFNJWkU6XFxuICAgIGZsb2F0IFNJWkVfMSA9IDguO1xcbiAgICAvLyBMb3MgcHVudG9zIHNvbiBtYXMgcGVxdWXDsW9zIGVuIGxvcyBvcmJpdGFsZXMgZGUgbGEgcGVyaWZlcmlhXFxuICAgIGZsb2F0IGVzY2xhRWRlZ2UgPSBnZXRfZXNjYWxhRWRnZShhX2dlbzFfb3JiaXRhbCk7IFxcbiAgICBmbG9hdCByYW5nbyA9IDEuLWVzY2xhRWRlZ2U7XFxuICAgIFNJWkVfMSAqPSAoZXNjbGFFZGVnZSArIChyYW5nbyp1UHJvZ3Jlc3MxKSk7XFxuICAgIC8vIExvcyBwdW50b3Mgc2UgZXNjYWxhbiBlbiBiYXNlIGEgdW4gbWFwYSBkZSBydWlkb1xcbiAgICBTSVpFXzEgKj0gbWl4KDEuLCBnZXRfZXNjYWxhTm9pc2UoUE9TSVRJT05fMS54LCBQT1NJVElPTl8xLnksIDUwMC4sIHVQcm9ncmVzczApLCB1UHJvZ3Jlc3MwYik7XFxuICAgIC8vIExvcyBwdW50b3Mgc2UgZXNjYWxhbiBlbiBiYXNlIGEgb25kYXMgY29uY2VudHJpY2FzIGRlIHNlbm86XFxuICAgIFNJWkVfMSAqPSBtaXgoMS4sIGdldF9lc2NhbGFPbmRhUmFkaWFsKGFfZ2VvMV9vcmJpdGFsLCAtdVRpbWUqMTAuKSwgdVByb2dyZXNzNGIpO1xcbiAgICAvLyBMb3MgcHVudG9zIHNlIGVzY2FsYW4gcG9yIHB1bHNvbiByYW5kb206XFxuICAgIFNJWkVfMSAqPSBtaXgoMS4sIDEuNSwgdl9hY3RpdmVQdWxzZVByb2dyZXNzKTtcXG4gICAgLy8gTG9zIHB1bnRvcyBzZSBlc2NhbGFuIGp1bnRvIGNvbiBsYSBnZW9tZXRyaWEgY29uIGVsIHNjcm9sbGRlbHRhXFxuICAgIFNJWkVfMSAqPSAxLisodVNjcm9sbERlbHRhKTtcXG5cXG4gICAgZmxvYXQgU0laRV8yID0gNS47IFxcbiAgICAvLyBcXG4gICAgZmxvYXQgekRlcHRoTm9ybSA9IChQT1NJVElPTl8yLnorNjAwLikvKDYwMC4qMi4pOyAvLyBkZSAtNjAwIGEgNjAwIGRlIHVuIHZhbG9yIG5vcm1hbGl6YWRvIChzaW4gY2xhbXAsIGVzIGRlY2lyIHF1ZSBwdWVkZSBzZXIgPDAgeSA+MSkgZGUgbGEgcG9zaWNpb24gelxcbiAgICBmbG9hdCB6RGVwdGhBbHBoYSA9IG1peCgwLjIsIDAuOSwgekRlcHRoTm9ybSk7XFxuICAgIGZsb2F0IHpEZXB0aFNjYWxlID0gbWl4KDAuOCwgMi41LCB6RGVwdGhOb3JtKTtcXG4gICAgZmxvYXQgcmFuZG9tU2l6ZSA9IFNJWkVfMiAqMC41KyhhX3JhbmRvbW5lc3MueCowLjkpO1xcbiAgICByYW5kb21TaXplICo9IHpEZXB0aFNjYWxlO1xcbiAgICBTSVpFXzIgPSBtaXgoU0laRV8yLCByYW5kb21TaXplLCB1TW9ycGhpbmdQcm9ncmVzcyk7XFxuICAgIFxcbiAgICBcXG4gICAgZmxvYXQgU0laRSA9IG1peChTSVpFXzEsIFNJWkVfMiwgdU1vcnBoaW5nUHJvZ3Jlc3MpO1xcbiAgICAvLyBMb3MgcHVudG9zIHNlIGVzY2FsYW4gc2kgc2UgcmVkaW1lbnNvbmEgZWwgbGllbnpvXFxuICAgIFNJWkUgKj0gdVJlc3BvbnNpdmVTY2FsZTtcXG4gICAgXFxuICAgIFxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIC8vIFZFUlRFWFxcbiAgICB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBQT1NJVElPTl8xLCAxLjAgKTtcXG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG4gICAgZ2xfUG9pbnRTaXplID0gU0laRSoodUNhbWFyYURpc3RhbmNlLy1tdlBvc2l0aW9uLnopO1xcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG4gICAgXFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyBWQVJZSU5HUzpcXG4gICAgdl9yYW5kb21uZXNzID0gYV9yYW5kb21uZXNzO1xcbiAgICB2X2NvbG9yU3RyZW5ndGggPSBnZXRfZXNjYWxhTm9pc2UoUE9TSVRJT05fMS54LCBQT1NJVElPTl8xLnksIDIwMC4sIHNpbih1VGltZSkpO1xcbiAgICB2X2NvbG9yU3RyZW5ndGggPSBtaXgoMS4sIHZfY29sb3JTdHJlbmd0aCwgdU1vcnBoaW5nUHJvZ3Jlc3MpO1xcblxcbn1cIjsiLCJleHBvcnQgZGVmYXVsdCBcIiNkZWZpbmUgR0xTTElGWSAxXFxuLy8gdmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcXG4vLyB2YXJ5aW5nIHZlYzIgdlV2O1xcblxcbnZhcnlpbmcgdmVjMyB2X3JhbmRvbW5lc3M7XFxudmFyeWluZyBmbG9hdCB2X2NvbG9yU3RyZW5ndGg7XFxuXFxudW5pZm9ybSB2ZWMzIHVDb2xvcjE7XFxudW5pZm9ybSB2ZWMzIHVDb2xvcjI7XFxudW5pZm9ybSB2ZWMzIHVDb2xvcjM7XFxuXFxudW5pZm9ybSBmbG9hdCB1UHJvZ3Jlc3MxO1xcbnVuaWZvcm0gZmxvYXQgdVByb2dyZXNzMjtcXG51bmlmb3JtIGZsb2F0IHVQcm9ncmVzczM7XFxudW5pZm9ybSBmbG9hdCB1SW50cm9Qcm9ncmVzcztcXG5cXG52YXJ5aW5nIGZsb2F0IHZfYWN0aXZlUHVsc2U7XFxudmFyeWluZyBmbG9hdCB2X2FjdGl2ZVB1bHNlUHJvZ3Jlc3M7IFxcbnZhcnlpbmcgZmxvYXQgdl90ZXN0O1xcblxcbmZsb2F0IHF1YXJ0aWNPdXQoZmxvYXQgdCkge1xcbiAgcmV0dXJuIHBvdyh0IC0gMS4wLCAzLjApICogKDEuMCAtIHQpICsgMS4wO1xcbn1cXG5cXG5mbG9hdCBjaXJjdWxpemFyKGZsb2F0IHJhZGlvKXtcXG4gICAgLy8gcmFkaW8gZXMgdW4gdmFsb3IgZW50cmUgMCB5IDEuIDAgZXMgMCBkZSByYWRpbyB5IDEgZXMgZWwgbWF4aW1vIGRlbCByYWRpbyBkZW50cm8gZGVcXG4gICAgcmFkaW8gPSAxLjAtKDAuNSpyYWRpbyk7XFxuICAgIGZsb2F0IHJlc3VsdCA9IGRpc3RhbmNlKGdsX1BvaW50Q29vcmQsIHZlYzIoMC41LCAwLjUpKTtcXG4gICAgcmVzdWx0ID0gMS4gLXJlc3VsdDtcXG4gICAgcmVzdWx0ID0gcG93KHJlc3VsdCwgMS4pO1xcbiAgICByZXN1bHQgPSBzdGVwKHJhZGlvLCByZXN1bHQpO1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIGZsb2F0IHJhbmRvbW5lc3NDaXIgPSB2X3JhbmRvbW5lc3MueCp1UHJvZ3Jlc3MxO1xcbiAgICByYW5kb21uZXNzQ2lyID0gbWl4KDEuLCByYW5kb21uZXNzQ2lyLCB1UHJvZ3Jlc3MxKTtcXG4gICAgLy9mbG9hdCBhbHBoYSA9IGNpcmN1bGl6YXIoMS4wKnJhbmRvbW5lc3NDaXIpO1xcbiAgICBmbG9hdCBhbHBoYSA9IGNpcmN1bGl6YXIoMS4wKTtcXG5cXG4gICAgLy9hbHBoYSAqPSBtaXgoLTIuLCAxLiwgcXVhcnRpY091dCh1SW50cm9Qcm9ncmVzcykpO1xcbiAgICBhbHBoYSAqPSBtaXgoMC44LCAxLiwgdUludHJvUHJvZ3Jlc3MpO1xcblxcbiAgICB2ZWMzIGZpbmFsQ29sb3IgPSBtaXgodUNvbG9yMiwgdUNvbG9yMSwgdl9jb2xvclN0cmVuZ3RoKTtcXG5cXG4gICAgdmVjMyBjb2xvcldoaXRlID0gdmVjMygxLjAsIDEuMCwgMS4wKTtcXG4gICAgdmVjMyBtaXhBY3RpdmVDb2xvciA9IG1peChmaW5hbENvbG9yLCB1Q29sb3IzLCB2X2FjdGl2ZVB1bHNlKTtcXG5cXG4gICAgdmVjMyB3aGl0ZSA9IHZlYzMoMS4sIDEuLCAxLik7XFxuXFxuICAgIGZpbmFsQ29sb3IgPSAgbWl4KGZpbmFsQ29sb3IsIHdoaXRlLCB2X2FjdGl2ZVB1bHNlUHJvZ3Jlc3MqMC4xNSk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoZmluYWxDb2xvciwgYWxwaGEpO1xcblxcbn1cIjsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IGdzYXAgZnJvbSBcImdzYXBcIjtcbmltcG9ydCBFYXNpbmcgZnJvbSAnZWFzaW5nLWZ1bmN0aW9ucyc7XG5pbXBvcnQgV2ViR0xVdGlscyBmcm9tIFwiLi4vV2ViR0xVdGlsc1wiO1xuaW1wb3J0IEVhc2VkT3V0VmFsdWUgZnJvbSAnLi4vRWFzZWRPdXRWYWx1ZSc7XG5pbXBvcnQgTG9hZGVkR2VvbWV0cnkgZnJvbSAnLi4vTG9hZGVkR2VvbWV0cnknO1xuaW1wb3J0IEFib3V0MUdlb21ldHJ5IGZyb20gJy4vQWJvdXQxR2VvbWV0cnknO1xuaW1wb3J0IEFib3V0MVB1bHNlcyBmcm9tICcuL0Fib3V0MVB1bHNlcyc7XG5pbXBvcnQgdmVydGV4IGZyb20gXCIuL3NoYWRlcnMvYWJvdXREb3RzX3ZlcnRleC5nbHNsXCI7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSBcIi4vc2hhZGVycy9hYm91dERvdHNfZnJhZ21lbnQuZ2xzbFwiO1xuXG52YXIgQWJvdXQxRG90cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFib3V0MURvdHMob2JqKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBYm91dDFEb3RzKTtcblxuICAgIC8vY29uc29sZS5sb2coXCIoQWJvdXQxRG90cy5DT05TVFJVQ1RPUkEpIVwiKVxuICAgIC8vY29uc29sZS5sb2cob2JqKVxuICAgIHRoaXMud29ybGRHTCA9IG9iai53b3JsZEdMOyAvLy0tXG5cbiAgICB0aGlzLnNjZW5lID0gdGhpcy53b3JsZEdMLnNjZW5lO1xuICAgIHRoaXMuY2FtZXJhRGlzdGFuY2UgPSB0aGlzLndvcmxkR0wuY2FtZXJhRGlzdGFuY2U7IC8vLS1cblxuICAgIHRoaXMubWF0ZXJpYWwgPSBudWxsO1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBudWxsO1xuICAgIHRoaXMubWVzaCA9IG51bGw7XG4gICAgdGhpcy5udW1QYXJ0aWNsZXMgPSBudWxsO1xuICAgIHRoaXMuYWxsTG9hZGVkID0gZmFsc2U7XG4gICAgdGhpcy5jcmVhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5jbG9jayA9IG5ldyBUSFJFRS5DbG9jaygpO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgICB0aGlzLmludHJvVGltZSA9IDEuMjtcbiAgICB0aGlzLnJvdGF0aW9uWCA9IDA7XG4gICAgdGhpcy5yb3RhdGlvblkgPSAwO1xuICAgIHRoaXMucm90YXRpb25XYW50ZWRYID0gMDtcbiAgICB0aGlzLnJvdGF0aW9uV2FudGVkWSA9IDA7XG4gICAgdGhpcy5tb3JwaGluZ1Byb2dyZXNzID0gMDsgLy8tLVxuXG4gICAgdGhpcy5lYXNlZF9yb3RhdGlvbiA9IG5ldyBFYXNlZE91dFZhbHVlKDAsIDAuMDUpO1xuICAgIHRoaXMuZWFzZWRfc2Nyb2xsRGVsdGEgPSBuZXcgRWFzZWRPdXRWYWx1ZSh0aGlzLndvcmxkR0wuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSAqIDAuMywgMC4wNSk7XG4gICAgdGhpcy5lYXNlZF9zY3JvbGxEZWx0YV9mYXN0ID0gbmV3IEVhc2VkT3V0VmFsdWUodGhpcy53b3JsZEdMLnNldHRpbmdzLnNjcm9sbF9ub3JtYWxpemVkRGVsdGEgKiAwLjUsIDAuMSk7XG4gICAgdGhpcy5lYXNlZF9zY3JvbGxQcm9ncmVzcyA9IG5ldyBFYXNlZE91dFZhbHVlKHRoaXMud29ybGRHTC5zZXR0aW5ncy5zY3JvbGxfcHJvZ3Jlc3MsIDAuMDUpOyAvLy0tXG5cbiAgICB0aGlzLl9zZXR1cF9zZXR0aW5ncygpOyAvLy0tXG5cblxuICAgIHRoaXMucHVsc2VzID0gbmV3IEFib3V0MVB1bHNlcyh7XG4gICAgICBkb3RHZW9tOiB0aGlzXG4gICAgfSk7IC8vLS1cblxuICAgIHRoaXMub3JiaXRhbF9nZW9tZXRyeSA9IG5ldyBBYm91dDFHZW9tZXRyeSh0aGlzLnNldHRpbmdzKTsgLy8tLVxuXG4gICAgdGhpcy5NX2dlb21ldHJ5ID0gbmV3IExvYWRlZEdlb21ldHJ5KHtcbiAgICAgIGlkOiBcIk1fZ2VvbWV0cnlcIixcbiAgICAgIGZpbGU6IFwid3AtY29udGVudC90aGVtZXMvbWlvdGljb25zdWx0aW5nL2ltZy9NLmdsYlwiLFxuICAgICAgaXNEcmFjbzogZmFsc2UsXG4gICAgICBzY2FsZTogNjAwIC8vcm90YXRpb25ZIDogLU1hdGguUEkqMC4yNVxuXG4gICAgfSwgdGhpcy5zZXR0aW5ncyk7XG4gICAgdGhpcy5NX2dlb21ldHJ5Lm9uKFwib25NZXNoTG9hZGVkXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBfdGhpcy5fZXZhbF9hbGxMb2FkZWQoKTtcbiAgICB9KTsgLy8tLVxuXG4gICAgdGhpcy5yZXNpemUoKTsgLy8tLVxuXG4gICAgdGhpcy5NX2dlb21ldHJ5LmluaXQoKTtcbiAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQVUJMSUNBUzogXG5cblxuICBfY3JlYXRlQ2xhc3MoQWJvdXQxRG90cywgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoQWJvdXQxRG90cy5fY3JlYXRlKSFcIilcbiAgICAgIC8vLS1cbiAgICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgICAgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcsXG4gICAgICAgIC8vYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICAgICAgICAvL2JsZW5kaW5nOiBUSFJFRS5NdWx0aXBseUJsZW5kaW5nLFxuICAgICAgICB2ZXJ0ZXhDb2xvcnM6IHRydWUsXG4gICAgICAgIHZlcnRleFNoYWRlcjogdmVydGV4LFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogZnJhZ21lbnQsXG4gICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIHVDb2xvcjE6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoXCIjMTcwZTQxXCIpXG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLzgwMWM2NVxuICAgICAgICAgIHVDb2xvcjI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoXCIjODAxYzY1XCIpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Q29sb3IzOiB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKFwiIzg4MDM2NFwiKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVRpbWU6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Q2FtYXJhRGlzdGFuY2U6IHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmNhbWVyYURpc3RhbmNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1U2Nyb2xsRGVsdGE6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1U2Nyb2xsUHJvZ3Jlc3M6IHtcbiAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UmVzcG9uc2l2ZVNjYWxlOiB7XG4gICAgICAgICAgICB2YWx1ZTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVJvdGF0aW9uMToge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVSb3RhdGlvbjI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Um90YXRpb24zOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVJvdGF0aW9uSW5uZXI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Um90YXRpb25PdXR0ZXI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1TW9ycGhpbmdQcm9ncmVzczoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVJbnRyb1Byb2dyZXNzOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVNjcm9sbFNwZWVkOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVB1bHNlTnVtXzA6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UHVsc2VQcm9ncmVzc18wOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVB1bHNlTnVtXzE6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UHVsc2VQcm9ncmVzc18xOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVB1bHNlTnVtXzI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UHVsc2VQcm9ncmVzc18yOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVB1bHNlTnVtXzM6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UHVsc2VQcm9ncmVzc18zOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVB1bHNlTnVtXzQ6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UHVsc2VQcm9ncmVzc180OiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVB1bHNlTnVtXzU6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UHVsc2VQcm9ncmVzc181OiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVB1bHNlTnVtXzY6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UHVsc2VQcm9ncmVzc182OiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVB1bHNlTnVtXzc6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UHVsc2VQcm9ncmVzc183OiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVB1bHNlTnVtXzg6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UHVsc2VQcm9ncmVzc184OiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVB1bHNlTnVtXzk6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UHVsc2VQcm9ncmVzc185OiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVByb2dyZXNzMDoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVQcm9ncmVzczBiOiB7XG4gICAgICAgICAgICB2YWx1ZTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVByb2dyZXNzMToge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVQcm9ncmVzczI6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UHJvZ3Jlc3MzOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVByb2dyZXNzNDoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVQcm9ncmVzczRiOiB7XG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVByb2dyZXNzNToge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVQcm9ncmVzczY6IHtcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1UHJvZ3Jlc3M2Yjoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9IC8vdVNjYWxlOiB7dmFsdWU6IDF9LFxuICAgICAgICAgIC8vdVNpemU6IHt2YWx1ZTogMzAgKiB0aGlzLnJlbmRlcmVyLmdldFBpeGVsUmF0aW8oKX1cblxuICAgICAgICB9XG4gICAgICB9KTsgLy8tLVxuICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXMpXG4gICAgICAvLy0tXG5cbiAgICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9wb3NpY2lvbmVzLCAzKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3Bvc2ljaW9uZXMsIDMpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfZG90X251bScsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9kb3RfbnVtLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX29yYml0YWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfb3JiaXRhbCwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9wb3Nfb3JiaXRhJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3Bvc19vcmJpdGEsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfaW5jcl9hbmd1bG9SYWQnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfaW5jcl9hbmd1bG9SYWQsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfYW5ndWxvUmFkJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX2FuZ3Vsb1JhZCwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9yYWRpbycsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9yYWRpbywgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV9kaXInLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfZGlyLCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX2luY3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfaW5jciwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMV94JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLm9yYml0YWxfZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3gsIDEpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhX2dlbzFfeScsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5vcmJpdGFsX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV95LCAxKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9nZW8xX3onLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHRoaXMub3JiaXRhbF9nZW9tZXRyeS5hdHRyaWJ1dGVzLmFfeiwgMSkpO1xuICAgICAgdGhpcy5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2FfZ2VvMl9wb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUodGhpcy5NX2dlb21ldHJ5LmF0dHJpYnV0ZXMuYV9wb3NpY2lvbmVzLCAzKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnYV9yYW5kb21uZXNzJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh0aGlzLk1fZ2VvbWV0cnkuYXR0cmlidXRlcy5hX3JhbmRvbW5lc3MsIDMpKTtcbiAgICAgIHRoaXMubWVzaCA9IG5ldyBUSFJFRS5Qb2ludHModGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCk7XG4gICAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLm1lc2gpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbk1vdXNlVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VVcGRhdGUobW91c2VOb3JtWCwgbW91c2VOb3JtWSkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lNERvdHMub25Nb3VzZVVwZGF0ZSk6IFwiK21vdXNlTm9ybVgpXG4gICAgICBpZiAodGhpcy5tb3JwaGluZ1Byb2dyZXNzID4gMCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiKlwiKVxuICAgICAgICB0aGlzLl9tb3VzZVVwZGF0ZVgobW91c2VOb3JtWCk7XG5cbiAgICAgICAgdGhpcy5fbW91c2VVcGRhdGVZKG1vdXNlTm9ybVkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgaWYgKHRoaXMuYWxsTG9hZGVkKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCIoQWJvdXQxRG90cy5yZW5kZXIpIVwiKVxuICAgICAgICAvLy0tXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSB0aGlzLmNsb2NrLmdldEVsYXBzZWRUaW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW50cm9Qcm9ncmVzcyA9IFdlYkdMVXRpbHMuY2xhbXAoKHRoaXMuY2xvY2suZ2V0RWxhcHNlZFRpbWUoKSAtIHRoaXMuc3RhcnRUaW1lKSAvIHRoaXMuaW50cm9UaW1lLCAwLCAxKTtcbiAgICAgICAgaW50cm9Qcm9ncmVzcyA9IEVhc2luZy5RdWFydGljLk91dChpbnRyb1Byb2dyZXNzKTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51SW50cm9Qcm9ncmVzcy52YWx1ZSA9IGludHJvUHJvZ3Jlc3M7IC8vLS1cblxuICAgICAgICB2YXIgcm90YXRpb25FYXNlZFkgPSB0aGlzLnJvdGF0aW9uWSArICh0aGlzLnJvdGF0aW9uV2FudGVkWSAtIHRoaXMucm90YXRpb25ZKSAqIDAuMDU7XG4gICAgICAgIHRoaXMucm90YXRpb25ZID0gcm90YXRpb25FYXNlZFk7XG4gICAgICAgIHRoaXMubWVzaC5yb3RhdGlvbi55ID0gcm90YXRpb25FYXNlZFk7IC8vLS1cblxuICAgICAgICB2YXIgcm90YXRpb25FYXNlZFggPSB0aGlzLnJvdGF0aW9uWCArICh0aGlzLnJvdGF0aW9uV2FudGVkWCAtIHRoaXMucm90YXRpb25YKSAqIDAuMDU7XG4gICAgICAgIHRoaXMucm90YXRpb25YID0gcm90YXRpb25FYXNlZFg7XG4gICAgICAgIHRoaXMubWVzaC5yb3RhdGlvbi54ID0gcm90YXRpb25FYXNlZFg7IC8vLS1cblxuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVUaW1lLnZhbHVlID0gdGhpcy5jbG9jay5nZXRFbGFwc2VkVGltZSgpO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVDYW1hcmFEaXN0YW5jZS52YWx1ZSA9IHRoaXMud29ybGRHTC5jYW1lcmFEaXN0YW5jZTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51UmVzcG9uc2l2ZVNjYWxlLnZhbHVlID0gdGhpcy53b3JsZEdMLnJlc3BvbnNpdmVTY2FsZTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51U2Nyb2xsRGVsdGEudmFsdWUgPSAtdGhpcy5lYXNlZF9zY3JvbGxEZWx0YS5nZXQodGhpcy53b3JsZEdMLnNldHRpbmdzLnNjcm9sbF9ub3JtYWxpemVkRGVsdGEgKiAwLjUpO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVTY3JvbGxQcm9ncmVzcy52YWx1ZSA9IHRoaXMud29ybGRHTC5zZXR0aW5ncy5zY3JvbGxfcHJvZ3Jlc3M7XG5cbiAgICAgICAgaWYgKHRoaXMud29ybGRHTC5zZXR0aW5ncy5tb3JwaGluZ1Byb2dyZXNzIDw9IDAuNSkge1xuICAgICAgICAgIHRoaXMubW9ycGhpbmdQcm9ncmVzcyA9IDA7XG5cbiAgICAgICAgICB0aGlzLl9tb3VzZVVwZGF0ZVgoMCk7XG5cbiAgICAgICAgICB0aGlzLl9tb3VzZVVwZGF0ZVkoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tb3JwaGluZ1Byb2dyZXNzID0gKHRoaXMud29ybGRHTC5zZXR0aW5ncy5tb3JwaGluZ1Byb2dyZXNzIC0gMC41KSAqIDI7XG4gICAgICAgIH0gLy9jb25zb2xlLmxvZyhcInRoaXMubW9ycGhpbmdQcm9ncmVzczogXCIrdGhpcy5tb3JwaGluZ1Byb2dyZXNzKVxuICAgICAgICAvLy0tXG5cblxuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVNb3JwaGluZ1Byb2dyZXNzLnZhbHVlID0gdGhpcy5tb3JwaGluZ1Byb2dyZXNzO1xuICAgICAgICB2YXIgZXh0cmFTcGVlZCA9IDEgKyBNYXRoLmFicyh0aGlzLmVhc2VkX3Njcm9sbERlbHRhX2Zhc3QuZ2V0KHRoaXMud29ybGRHTC5zZXR0aW5ncy5zY3JvbGxfbm9ybWFsaXplZERlbHRhICogMC41KSAqIDEwKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5yb3RhdGlvbjEgKz0gdGhpcy5zZXR0aW5ncy5zcGVlZFJvdGF0aW9uMSAqIGV4dHJhU3BlZWQ7XG4gICAgICAgIHRoaXMuc2V0dGluZ3Mucm90YXRpb24yICs9IHRoaXMuc2V0dGluZ3Muc3BlZWRSb3RhdGlvbjIgKiBleHRyYVNwZWVkO1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJvdGF0aW9uMyArPSB0aGlzLnNldHRpbmdzLnNwZWVkUm90YXRpb24zICogZXh0cmFTcGVlZDtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Um90YXRpb24xLnZhbHVlID0gdGhpcy5zZXR0aW5ncy5yb3RhdGlvbjE7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVJvdGF0aW9uMi52YWx1ZSA9IC10aGlzLnNldHRpbmdzLnJvdGF0aW9uMjtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Um90YXRpb24zLnZhbHVlID0gdGhpcy5zZXR0aW5ncy5yb3RhdGlvbjM7XG4gICAgICAgIHRoaXMuc2V0dGluZ3Mucm90YXRpb25Jbm5lciArPSB0aGlzLnNldHRpbmdzLnNwZWVkUm90YXRpb25Jbm5lciAqIGV4dHJhU3BlZWQ7XG4gICAgICAgIHRoaXMuc2V0dGluZ3Mucm90YXRpb25PdXR0ZXIgKz0gdGhpcy5zZXR0aW5ncy5zcGVlZFJvdGF0aW9uT3V0dGVyICogZXh0cmFTcGVlZDtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Um90YXRpb25Jbm5lci52YWx1ZSA9IHRoaXMuc2V0dGluZ3Mucm90YXRpb25Jbm5lcjtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Um90YXRpb25PdXR0ZXIudmFsdWUgPSB0aGlzLnNldHRpbmdzLnJvdGF0aW9uT3V0dGVyO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVQcm9ncmVzczAudmFsdWUgPSB0aGlzLnNldHRpbmdzLnByb2dyZXNzMDtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51UHJvZ3Jlc3MwYi52YWx1ZSA9IHRoaXMuc2V0dGluZ3MucHJvZ3Jlc3MwYjtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51UHJvZ3Jlc3MxLnZhbHVlID0gdGhpcy5zZXR0aW5ncy5wcm9ncmVzczE7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVByb2dyZXNzMi52YWx1ZSA9IHRoaXMuc2V0dGluZ3MucHJvZ3Jlc3MyO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVQcm9ncmVzczMudmFsdWUgPSB0aGlzLnNldHRpbmdzLnByb2dyZXNzMztcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51UHJvZ3Jlc3M0LnZhbHVlID0gdGhpcy5zZXR0aW5ncy5wcm9ncmVzczQ7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVByb2dyZXNzNGIudmFsdWUgPSB0aGlzLnNldHRpbmdzLnByb2dyZXNzNGI7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVByb2dyZXNzNS52YWx1ZSA9IHRoaXMuc2V0dGluZ3MucHJvZ3Jlc3M1O1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVQcm9ncmVzczYudmFsdWUgPSB0aGlzLnNldHRpbmdzLnByb2dyZXNzNjtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51UHJvZ3Jlc3M2Yi52YWx1ZSA9IHRoaXMuc2V0dGluZ3MucHJvZ3Jlc3M2YjtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51U2Nyb2xsU3BlZWQudmFsdWUgPSB0aGlzLnNldHRpbmdzLnNjcm9sbFNwZWVkRmlsdGVyZWQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnB1bHNlcy5tYXhQdWxzZXM7IGkrKykge1xuICAgICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXNbXCJ1UHVsc2VOdW1fXCIgKyBpXS52YWx1ZSA9IHRoaXMucHVsc2VzLmdldF9kb3RQb3MoaSk7XG4gICAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtc1tcInVQdWxzZVByb2dyZXNzX1wiICsgaV0udmFsdWUgPSB0aGlzLnB1bHNlcy5nZXRfcHJvZ3Jlc3MoaSwgdGhpcy5jbG9jay5nZXRFbGFwc2VkVGltZSgpKTtcbiAgICAgICAgfSAvLy0tXG5cblxuICAgICAgICB0aGlzLnNldHRpbmdzLnJvdGF0aW9uSW5uZXIgKz0gdGhpcy5zZXR0aW5ncy5zcGVlZFJvdGF0aW9uSW5uZXIgKiBleHRyYVNwZWVkO1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJvdGF0aW9uT3V0dGVyICs9IHRoaXMuc2V0dGluZ3Muc3BlZWRSb3RhdGlvbk91dHRlciAqIGV4dHJhU3BlZWQ7IC8vLS1cbiAgICAgICAgLy9jb25zb2xlLmxvZyhcInVJbnRyb1Byb2dyZXNzOiBcIit0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVJbnRyb1Byb2dyZXNzLnZhbHVlK1wiICAgdVJlc3BvbnNpdmVTY2FsZTogXCIrdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51UmVzcG9uc2l2ZVNjYWxlLnZhbHVlK1wiICAgdVRpbWU6IFwiK3RoaXMubWF0ZXJpYWwudW5pZm9ybXMudVRpbWUudmFsdWUrXCIgICB1TW9ycGhpbmdQcm9ncmVzczogXCIrdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51TW9ycGhpbmdQcm9ncmVzcy52YWx1ZStcIiAgIHVSb3RhdGlvbklubmVyL091dHRlcjogXCIrdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51Um90YXRpb25Jbm5lci52YWx1ZStcIi1cIit0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVSb3RhdGlvbk91dHRlci52YWx1ZSlcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHsvL05BREFcbiAgICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUFJJVkFEQVM6IFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21vdXNlVXBkYXRlWFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW91c2VVcGRhdGVYKG1vdXNlTm9ybVgpIHtcbiAgICAgIHZhciBtYXhBbmdsZVJhZCA9IE1hdGguUEkgKiAwLjI1O1xuICAgICAgdGhpcy5yb3RhdGlvbldhbnRlZFkgPSBtYXhBbmdsZVJhZCAqIG1vdXNlTm9ybVggKiB0aGlzLm1vcnBoaW5nUHJvZ3Jlc3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9tb3VzZVVwZGF0ZVlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdXNlVXBkYXRlWShtb3VzZU5vcm1ZKSB7XG4gICAgICB2YXIgbWF4QW5nbGVSYWQgPSBNYXRoLlBJICogMC4xO1xuICAgICAgdGhpcy5yb3RhdGlvbldhbnRlZFggPSBtYXhBbmdsZVJhZCAqIG1vdXNlTm9ybVkgKiB0aGlzLm1vcnBoaW5nUHJvZ3Jlc3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9ldmFsX2FsbExvYWRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZhbF9hbGxMb2FkZWQoKSB7XG4gICAgICBpZiAodGhpcy5NX2dlb21ldHJ5LmxvYWRlZCkge1xuICAgICAgICB0aGlzLmFsbExvYWRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMud29ybGRHTC5ldmFsX3N0YXJ0KCk7IC8vdGhpcy5fY3JlYXRlKClcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldHVwX3NldHRpbmdzM1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBfc2V0dGluZ3MzKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihIb21lNERvdHMuX3NldHVwX3NldHRpbmdzKSFcIilcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSB7XG4gICAgICAgIGZhY3RvcjogNixcbiAgICAgICAgaW5jcl9yYWRpbzogMjUsXG4gICAgICAgIG51bU9yYml0czogMjYsXG4gICAgICAgIC8vYXJyYXlPcmJpdHM6IFsxMiwgMTksIDI2XVxuICAgICAgICBhcnJheU9yYml0czogWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMCwgMjEsIDIyLCAyMywgMjQsIDI1LCAyNl0gLy9hcnJheU9yYml0czogWzEsIDNdXG5cbiAgICAgIH07XG4gICAgICB0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXIgPSB0aGlzLl9nZXRfYXJyYXlfdHJpYW5ndWxhcih0aGlzLnNldHRpbmdzLmZhY3RvciwgdGhpcy5zZXR0aW5ncy5udW1PcmJpdHMpO1xuICAgICAgdGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEgPSB0aGlzLl9nZXRfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhKHRoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhciwgdGhpcy5zZXR0aW5ncy5hcnJheU9yYml0cyk7XG4gICAgICB0aGlzLnNldHRpbmdzLmFycmF5X2RvdFBvcyA9IHRoaXMuX2dldF9hcnJheV9kb3RQb3ModGhpcy5zZXR0aW5ncy5hcnJheU9yYml0cywgdGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyLCB0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YSk7XG4gICAgICB0aGlzLnNldHRpbmdzLm51bURvdHMgPSB0aGlzLnNldHRpbmdzLmFycmF5X2RvdFBvcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zZXR1cF9zZXR0aW5nc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBfc2V0dGluZ3MoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEFib3V0MURvdHMuX3NldHVwX3NldHRpbmdzKSFcIilcbiAgICAgIHZhciBzcGVlZEJhc2UgPSAwLjAwMDA1OyAvLy0tXG5cbiAgICAgIHRoaXMuc2V0dGluZ3MgPSB7XG4gICAgICAgIC8vLS1cbiAgICAgICAgcm90YXRpb25Jbm5lcjogMCxcbiAgICAgICAgc3BlZWRSb3RhdGlvbklubmVyOiAzNyAqIHNwZWVkQmFzZSxcbiAgICAgICAgcm90YXRpb25PdXR0ZXI6IDAsXG4gICAgICAgIHNwZWVkUm90YXRpb25PdXR0ZXI6IDEgKiBzcGVlZEJhc2UsXG4gICAgICAgIC8vLS1cbiAgICAgICAgZmFjdG9yOiA2LFxuICAgICAgICBpbmNyX3JhZGlvOiAyNSxcbiAgICAgICAgbnVtT3JiaXRzOiAzNyxcbiAgICAgICAgcHVsc2VBcnJheTogW10sXG4gICAgICAgIHB1bHNlTWF4OiAxLFxuICAgICAgICBwdWxzZU51bV8wOiAwLFxuICAgICAgICBwdWxzZUluaXRUaW1lXzA6IDAsXG4gICAgICAgIHB1bHNlUHJvZ3Jlc3NfMDogMCxcbiAgICAgICAgcHJvZ3Jlc3MwOiAwLFxuICAgICAgICBwcm9ncmVzczBiOiAxLFxuICAgICAgICBwcm9ncmVzczE6IDAsXG4gICAgICAgIHByb2dyZXNzMjogMCxcbiAgICAgICAgcHJvZ3Jlc3MzOiAwLFxuICAgICAgICBwcm9ncmVzczQ6IDAsXG4gICAgICAgIHByb2dyZXNzNGI6IDEsXG4gICAgICAgIHByb2dyZXNzNTogMCxcbiAgICAgICAgcHJvZ3Jlc3M2OiAwLFxuICAgICAgICBwcm9ncmVzczZiOiAxLFxuICAgICAgICBzY3JvbGxTcGVlZDogMCxcbiAgICAgICAgc2Nyb2xsU3BlZWRGaWx0ZXJlZDogMFxuICAgICAgfTtcbiAgICAgIHRoaXMuc2V0dGluZ3MuYXJyYXlfdHJpYW5ndWxhciA9IHRoaXMuX2dldF9hcnJheV90cmlhbmd1bGFyKHRoaXMuc2V0dGluZ3MuZmFjdG9yLCB0aGlzLnNldHRpbmdzLm51bU9yYml0cyk7XG4gICAgICB0aGlzLnNldHRpbmdzLm51bURvdHMgPSB0aGlzLnNldHRpbmdzLmFycmF5X3RyaWFuZ3VsYXJbdGhpcy5zZXR0aW5ncy5hcnJheV90cmlhbmd1bGFyLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0X2FycmF5X3RyaWFuZ3VsYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9hcnJheV90cmlhbmd1bGFyKF9mYWN0b3IsIF9udW1PYml0cykge1xuICAgICAgLy8gR2VuZXJhIHVuYSBhcnJheSBkZSBwcm9ncmVzacOzbiB0cmlhbmd1bGFyICgqIGZhY3RvcikuXG4gICAgICAvLyBVbmEgcHJvZ3Jlc2nDs24gdHJpYW5ndWxhciBlczogMSwgMywgNiwgMTAsIDE1IChodHRwczovL3NpZ25pZmljYXRpdmEub3JnL2RpY2Npb25hcmlvcy9udW1lcm9zLWZpZ3VyYWRvcy8jOn46dGV4dD0zLjEuMS4xLi0sRGVmaW5pY2klQzMlQjNuLGFudGVyaW9yJTIwbm8lMjBvYnRlbmVtb3MlMjB1bmElMjBjb25zdGFudGUuKVxuICAgICAgdmFyIG1pQXJyYXkgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gX251bU9iaXRzOyBpKyspIHtcbiAgICAgICAgLy9hcnJheV9udW1UcmlhZ3VsYXJlcy5wdXNoKGkqKGkrMSkvMilcbiAgICAgICAgbWlBcnJheS5wdXNoKGkgKiAoaSArIDEpIC8gMiAqIF9mYWN0b3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWlBcnJheTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldF9hcnJheV9kb3RQb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9hcnJheV9kb3RQb3MoX2FycmF5T3JiaXRzLCBfYXJyYXlfdHJpYW5ndWxhciwgX2FycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YSkge1xuICAgICAgdmFyIG1pQXJyYXkgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYXJyYXlPcmJpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9yYml0TnVtID0gX2FycmF5T3JiaXRzW2ldO1xuICAgICAgICB2YXIgZG90c194X29yYml0ID0gX2FycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YVtpXTtcbiAgICAgICAgdmFyIGRvdE51bV9iYXNlID0gX2FycmF5X3RyaWFuZ3VsYXJbX2FycmF5T3JiaXRzW2ldIC0gMV07IC8vIGNvbnNvbGUubG9nKFwib3JiaXROdW06IFwiK29yYml0TnVtKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImRvdHNfeF9vcmJpdDogXCIrZG90c194X29yYml0KVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImRvdE51bV9iYXNlOiBcIitkb3ROdW1fYmFzZSlcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvdHNfeF9vcmJpdDsgaisrKSB7XG4gICAgICAgICAgbWlBcnJheS5wdXNoKGRvdE51bV9iYXNlICsgaiArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaUFycmF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0X251bURvdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9udW1Eb3RzKF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEpIHtcbiAgICAgIHZhciBudW1Eb3RzID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gX2FycmF5X3RyaWFuZ3VsYXJfZG90c194X29yYml0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbnVtRG90cyArPSBfYXJyYXlfdHJpYW5ndWxhcl9kb3RzX3hfb3JiaXRhW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVtRG90cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldF9hcnJheV90cmlhbmd1bGFyX2RvdHNfeF9vcmJpdGEoX2FycmF5X3RyaWFuZ3VsYXIsIF9hcnJheU9yYml0cykge1xuICAgICAgLy8gR2VuZXJhIHVuYSBhcnJheSBiYXNhZGEgZW4gbGEgcHJvZ3Jlc2nDs24gdHJpYW5ndWxhciAoKiBmYWN0b3IpLlxuICAgICAgLy8gLi4uIGRvbmRlIHNlIGluZGljYSBlbCBudW1lcm8gZGUgZG90cyBwb3Igb3JiaXRhbFxuICAgICAgLy8gVW5hIHByb2dyZXNpw7NuIHRyaWFuZ3VsYXIgZXM6IDEsIDMsIDYsIDEwLCAxNSAoaHR0cHM6Ly9zaWduaWZpY2F0aXZhLm9yZy9kaWNjaW9uYXJpb3MvbnVtZXJvcy1maWd1cmFkb3MvIzp+OnRleHQ9My4xLjEuMS4tLERlZmluaWNpJUMzJUIzbixhbnRlcmlvciUyMG5vJTIwb2J0ZW5lbW9zJTIwdW5hJTIwY29uc3RhbnRlLilcbiAgICAgIHZhciBtaUFycmF5ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IF9hcnJheU9yYml0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgLy9hcnJheV9udW1UcmlhZ3VsYXJlcy5wdXNoKGkqKGkrMSkvMilcbiAgICAgICAgdmFyIG51bURvdHNfb3JiaXRhX2FjdHVhbCA9IF9hcnJheV90cmlhbmd1bGFyW19hcnJheU9yYml0c1tpXV07XG4gICAgICAgIHZhciBudW1Eb3RzX29yYml0YV9hbnRlcmlvciA9IF9hcnJheV90cmlhbmd1bGFyW19hcnJheU9yYml0c1tpXSAtIDFdO1xuICAgICAgICB2YXIgbnVtRG90c19vcmJpdGEgPSBudW1Eb3RzX29yYml0YV9hY3R1YWwgLSBudW1Eb3RzX29yYml0YV9hbnRlcmlvcjtcbiAgICAgICAgbWlBcnJheS5wdXNoKG51bURvdHNfb3JiaXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1pQXJyYXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVjdWJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVjdWJlKF9zY2VuZSkge1xuICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KDEwMCwgMTAwLCAxMDApO1xuICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgY29sb3I6IDB4MDBmZjAwXG4gICAgICB9KTtcbiAgICAgIHZhciBjdWJlID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcblxuICAgICAgX3NjZW5lLmFkZChjdWJlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWJvdXQxRG90cztcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgQWJvdXQxRG90czsiLCJleHBvcnQgZGVmYXVsdCBcIiNkZWZpbmUgR0xTTElGWSAxXFxudW5pZm9ybSB2ZWMzIHVDb2xvcjA7XFxudW5pZm9ybSB2ZWMzIHVDb2xvcjE7XFxudW5pZm9ybSB2ZWMzIHVDb2xvcjI7XFxudW5pZm9ybSB2ZWMzIHVDb2xvcjM7XFxudW5pZm9ybSBmbG9hdCB1VGltZTtcXG51bmlmb3JtIGZsb2F0IHVTY3JvbGxQcm9ncmVzcztcXG51bmlmb3JtIGZsb2F0IHVTY3JvbGxUb3RhbFJhbmdlO1xcbnVuaWZvcm0gZmxvYXQgdUFzcGVjdFJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdVJlc3BvbnNpdmVTY2FsZTtcXG5cXG52YXJ5aW5nIHZlYzIgdlV2O1xcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uO1xcbnZhcnlpbmcgZmxvYXQgdl9ub2lzZTtcXG52YXJ5aW5nIGZsb2F0IHZfY29sb3JTdHJlbmd0aDE7XFxudmFyeWluZyBmbG9hdCB2X2NvbG9yU3RyZW5ndGgyO1xcbnZhcnlpbmcgZmxvYXQgdl9jb2xvclN0cmVuZ3RoMztcXG5cXG4vL1xcdENsYXNzaWMgUGVybGluIDNEIE5vaXNlIFxcbi8vXFx0YnkgU3RlZmFuIEd1c3RhdnNvblxcbi8vXFxudmVjNCBwZXJtdXRlKHZlYzQgeCl7cmV0dXJuIG1vZCgoKHgqMzQuMCkrMS4wKSp4LCAyODkuMCk7fVxcbnZlYzQgdGF5bG9ySW52U3FydCh2ZWM0IHIpe3JldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7fVxcbnZlYzMgZmFkZSh2ZWMzIHQpIHtyZXR1cm4gdCp0KnQqKHQqKHQqNi4wLTE1LjApKzEwLjApO31cXG5cXG5mbG9hdCBjbm9pc2UodmVjMyBQKXtcXG4gIHZlYzMgUGkwID0gZmxvb3IoUCk7IC8vIEludGVnZXIgcGFydCBmb3IgaW5kZXhpbmdcXG4gIHZlYzMgUGkxID0gUGkwICsgdmVjMygxLjApOyAvLyBJbnRlZ2VyIHBhcnQgKyAxXFxuICBQaTAgPSBtb2QoUGkwLCAyODkuMCk7XFxuICBQaTEgPSBtb2QoUGkxLCAyODkuMCk7XFxuICB2ZWMzIFBmMCA9IGZyYWN0KFApOyAvLyBGcmFjdGlvbmFsIHBhcnQgZm9yIGludGVycG9sYXRpb25cXG4gIHZlYzMgUGYxID0gUGYwIC0gdmVjMygxLjApOyAvLyBGcmFjdGlvbmFsIHBhcnQgLSAxLjBcXG4gIHZlYzQgaXggPSB2ZWM0KFBpMC54LCBQaTEueCwgUGkwLngsIFBpMS54KTtcXG4gIHZlYzQgaXkgPSB2ZWM0KFBpMC55eSwgUGkxLnl5KTtcXG4gIHZlYzQgaXowID0gUGkwLnp6eno7XFxuICB2ZWM0IGl6MSA9IFBpMS56enp6O1xcblxcbiAgdmVjNCBpeHkgPSBwZXJtdXRlKHBlcm11dGUoaXgpICsgaXkpO1xcbiAgdmVjNCBpeHkwID0gcGVybXV0ZShpeHkgKyBpejApO1xcbiAgdmVjNCBpeHkxID0gcGVybXV0ZShpeHkgKyBpejEpO1xcblxcbiAgdmVjNCBneDAgPSBpeHkwIC8gNy4wO1xcbiAgdmVjNCBneTAgPSBmcmFjdChmbG9vcihneDApIC8gNy4wKSAtIDAuNTtcXG4gIGd4MCA9IGZyYWN0KGd4MCk7XFxuICB2ZWM0IGd6MCA9IHZlYzQoMC41KSAtIGFicyhneDApIC0gYWJzKGd5MCk7XFxuICB2ZWM0IHN6MCA9IHN0ZXAoZ3owLCB2ZWM0KDAuMCkpO1xcbiAgZ3gwIC09IHN6MCAqIChzdGVwKDAuMCwgZ3gwKSAtIDAuNSk7XFxuICBneTAgLT0gc3owICogKHN0ZXAoMC4wLCBneTApIC0gMC41KTtcXG5cXG4gIHZlYzQgZ3gxID0gaXh5MSAvIDcuMDtcXG4gIHZlYzQgZ3kxID0gZnJhY3QoZmxvb3IoZ3gxKSAvIDcuMCkgLSAwLjU7XFxuICBneDEgPSBmcmFjdChneDEpO1xcbiAgdmVjNCBnejEgPSB2ZWM0KDAuNSkgLSBhYnMoZ3gxKSAtIGFicyhneTEpO1xcbiAgdmVjNCBzejEgPSBzdGVwKGd6MSwgdmVjNCgwLjApKTtcXG4gIGd4MSAtPSBzejEgKiAoc3RlcCgwLjAsIGd4MSkgLSAwLjUpO1xcbiAgZ3kxIC09IHN6MSAqIChzdGVwKDAuMCwgZ3kxKSAtIDAuNSk7XFxuXFxuICB2ZWMzIGcwMDAgPSB2ZWMzKGd4MC54LGd5MC54LGd6MC54KTtcXG4gIHZlYzMgZzEwMCA9IHZlYzMoZ3gwLnksZ3kwLnksZ3owLnkpO1xcbiAgdmVjMyBnMDEwID0gdmVjMyhneDAueixneTAueixnejAueik7XFxuICB2ZWMzIGcxMTAgPSB2ZWMzKGd4MC53LGd5MC53LGd6MC53KTtcXG4gIHZlYzMgZzAwMSA9IHZlYzMoZ3gxLngsZ3kxLngsZ3oxLngpO1xcbiAgdmVjMyBnMTAxID0gdmVjMyhneDEueSxneTEueSxnejEueSk7XFxuICB2ZWMzIGcwMTEgPSB2ZWMzKGd4MS56LGd5MS56LGd6MS56KTtcXG4gIHZlYzMgZzExMSA9IHZlYzMoZ3gxLncsZ3kxLncsZ3oxLncpO1xcblxcbiAgdmVjNCBub3JtMCA9IHRheWxvckludlNxcnQodmVjNChkb3QoZzAwMCwgZzAwMCksIGRvdChnMDEwLCBnMDEwKSwgZG90KGcxMDAsIGcxMDApLCBkb3QoZzExMCwgZzExMCkpKTtcXG4gIGcwMDAgKj0gbm9ybTAueDtcXG4gIGcwMTAgKj0gbm9ybTAueTtcXG4gIGcxMDAgKj0gbm9ybTAuejtcXG4gIGcxMTAgKj0gbm9ybTAudztcXG4gIHZlYzQgbm9ybTEgPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KGcwMDEsIGcwMDEpLCBkb3QoZzAxMSwgZzAxMSksIGRvdChnMTAxLCBnMTAxKSwgZG90KGcxMTEsIGcxMTEpKSk7XFxuICBnMDAxICo9IG5vcm0xLng7XFxuICBnMDExICo9IG5vcm0xLnk7XFxuICBnMTAxICo9IG5vcm0xLno7XFxuICBnMTExICo9IG5vcm0xLnc7XFxuXFxuICBmbG9hdCBuMDAwID0gZG90KGcwMDAsIFBmMCk7XFxuICBmbG9hdCBuMTAwID0gZG90KGcxMDAsIHZlYzMoUGYxLngsIFBmMC55eikpO1xcbiAgZmxvYXQgbjAxMCA9IGRvdChnMDEwLCB2ZWMzKFBmMC54LCBQZjEueSwgUGYwLnopKTtcXG4gIGZsb2F0IG4xMTAgPSBkb3QoZzExMCwgdmVjMyhQZjEueHksIFBmMC56KSk7XFxuICBmbG9hdCBuMDAxID0gZG90KGcwMDEsIHZlYzMoUGYwLnh5LCBQZjEueikpO1xcbiAgZmxvYXQgbjEwMSA9IGRvdChnMTAxLCB2ZWMzKFBmMS54LCBQZjAueSwgUGYxLnopKTtcXG4gIGZsb2F0IG4wMTEgPSBkb3QoZzAxMSwgdmVjMyhQZjAueCwgUGYxLnl6KSk7XFxuICBmbG9hdCBuMTExID0gZG90KGcxMTEsIFBmMSk7XFxuXFxuICB2ZWMzIGZhZGVfeHl6ID0gZmFkZShQZjApO1xcbiAgdmVjNCBuX3ogPSBtaXgodmVjNChuMDAwLCBuMTAwLCBuMDEwLCBuMTEwKSwgdmVjNChuMDAxLCBuMTAxLCBuMDExLCBuMTExKSwgZmFkZV94eXoueik7XFxuICB2ZWMyIG5feXogPSBtaXgobl96Lnh5LCBuX3ouencsIGZhZGVfeHl6LnkpO1xcbiAgZmxvYXQgbl94eXogPSBtaXgobl95ei54LCBuX3l6LnksIGZhZGVfeHl6LngpOyBcXG4gIHJldHVybiAyLjIgKiBuX3h5ejtcXG59XFxuXFxuZmxvYXQgZ2V0X2VzY2FsYU5vaXNlKGZsb2F0IHgsIGZsb2F0IHksIGZsb2F0IGFtcGxpdHVkTWFwYSwgZmxvYXQgcHJvZ3Jlc3Mpe1xcbiAgICBmbG9hdCB2YWxvciA9IGNub2lzZSh2ZWMzKHgvYW1wbGl0dWRNYXBhLCB5L2FtcGxpdHVkTWFwYSwgcHJvZ3Jlc3MpKTtcXG4gICAgdmFsb3IgPSAtMC41Kyh2YWxvcioyLik7XFxuICAgIC8vdmFsb3IgPSB2YWxvcioyLjsgLy8geDIgSW50ZXNpZmljYSBlbCBjb250cmFzdGVcXG4gICAgcmV0dXJuIHZhbG9yO1xcbn1cXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGZsb2F0IHNjcm9sbFBvcyA9IC11U2Nyb2xsVG90YWxSYW5nZSp1U2Nyb2xsUHJvZ3Jlc3MqMC4wMDE7XFxuICAgIGZsb2F0IG5ld1Bvc2l0aW9uWSA9IChwb3NpdGlvbi55K3Njcm9sbFBvcykvdUFzcGVjdFJhdGlvO1xcblxcbiAgICB2ZWM0IG1vZGVsVmlld1Bvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdQb3NpdGlvbjtcXG5cXG4gICAgZmxvYXQgdVRpbWVTbG93MCAgPSB1VGltZTsgXFxuICAgIGZsb2F0IHVUaW1lU2xvdzEgPSB1VGltZSowLjE7IC8vIE1vZGlmaWNhbW9zIGxhIHZlbG9jaWRhZCBlbiBsYSBxdWUgZXZvbHVjaW9uYW4gbG9zIGdyYWRpZW50ZXNcXG4gICAgZmxvYXQgdVRpbWVTbG93MiA9IHVUaW1lKjAuMTsgLy8gTW9kaWZpY2Ftb3MgbGEgdmVsb2NpZGFkIGVuIGxhIHF1ZSBldm9sdWNpb25hbiBsb3MgZ3JhZGllbnRlc1xcbiAgICBmbG9hdCB1VGltZVNsb3czID0gdVRpbWUqMC4yOyAvLyBNb2RpZmljYW1vcyBsYSB2ZWxvY2lkYWQgZW4gbGEgcXVlIGV2b2x1Y2lvbmFuIGxvcyBncmFkaWVudGVzXFxuXFxuICAgIC8vdl9ub2lzZSA9IGNub2lzZSh2ZWMzKHBvc2l0aW9uLngvMC4wMSwgcG9zaXRpb24ueS8wLjAxLCB1VGltZVNsb3cwKjEuKSk7XFxuXFxuICAgIHZfY29sb3JTdHJlbmd0aDEgPSBnZXRfZXNjYWxhTm9pc2UocG9zaXRpb24ueC0xMDAwLiwgbmV3UG9zaXRpb25ZKzAuLCAxLjIvdVJlc3BvbnNpdmVTY2FsZSwgdVRpbWVTbG93MSsxMDAuKSoxLjtcXG4gICAgdl9jb2xvclN0cmVuZ3RoMSA9IGNsYW1wKHZfY29sb3JTdHJlbmd0aDEsIDAuLCAxLjUgKTsgLy8gY2xhbXAodmFsb3IsIG1pbiwgbWF4KVxcblxcbiAgICB2X2NvbG9yU3RyZW5ndGgyID0gZ2V0X2VzY2FsYU5vaXNlKHBvc2l0aW9uLngtMjAwMC4sIG5ld1Bvc2l0aW9uWSsyMDAuLCAxLjIvdVJlc3BvbnNpdmVTY2FsZSwgdVRpbWVTbG93MisyMDAuKSoxLjtcXG4gICAgdl9jb2xvclN0cmVuZ3RoMiA9IGNsYW1wKHZfY29sb3JTdHJlbmd0aDIsIDAuLCAxLjUgKTsgLy8gY2xhbXAodmFsb3IsIG1pbiwgbWF4KVxcblxcbiAgICB2X2NvbG9yU3RyZW5ndGgzID0gZ2V0X2VzY2FsYU5vaXNlKHBvc2l0aW9uLngtMzAwMC4sIG5ld1Bvc2l0aW9uWSs0MDAuLCAyLjIvdVJlc3BvbnNpdmVTY2FsZSwgdVRpbWVTbG93Mys0MDAuKSoxLjtcXG4gICAgdl9jb2xvclN0cmVuZ3RoMyA9IGNsYW1wKHZfY29sb3JTdHJlbmd0aDMsIDAuLCAxLjUgKTsgLy8gY2xhbXAodmFsb3IsIG1pbiwgbWF4KVxcblxcbiAgICAvL3ZfY29sb3JTdHJlbmd0aDMgPSBnZXRfZXNjYWxhTm9pc2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgMS4sIHVUaW1lU2xvdysyMDAuKSoyLjtcXG5cXG4gICAgdlV2ID0gdXY7XFxuICAgIHZfcG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cXG59XCI7IiwiZXhwb3J0IGRlZmF1bHQgXCIjZGVmaW5lIEdMU0xJRlkgMVxcbi8vI3ByYWdtYSBnbHNsaWZ5OiBibHVyMSA9IHJlcXVpcmUoJ2dsc2wtZmFzdC1nYXVzc2lhbi1ibHVyLzEzJylcXG4vLyB2YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1xcbi8vIHZhcnlpbmcgdmVjMiB2VXY7XFxudW5pZm9ybSBmbG9hdCB1VGltZTtcXG51bmlmb3JtIHZlYzMgdUNvbG9yMDtcXG51bmlmb3JtIHZlYzMgdUNvbG9yMTtcXG51bmlmb3JtIHZlYzMgdUNvbG9yMjtcXG51bmlmb3JtIHZlYzMgdUNvbG9yMztcXG51bmlmb3JtIHZlYzMgdUNvbG9yVG91Y2g7XFxudW5pZm9ybSBmbG9hdCB1Rm9vdGVyUHJvZ3Jlc3M7XFxuXFxudmFyeWluZyB2ZWMyIHZVdjtcXG52YXJ5aW5nIHZlYzMgdl9wb3NpdGlvbjtcXG52YXJ5aW5nIGZsb2F0IHZfbm9pc2U7XFxudmFyeWluZyBmbG9hdCB2X2NvbG9yU3RyZW5ndGgxO1xcbnZhcnlpbmcgZmxvYXQgdl9jb2xvclN0cmVuZ3RoMjtcXG52YXJ5aW5nIGZsb2F0IHZfY29sb3JTdHJlbmd0aDM7XFxuXFxudmFyeWluZyBmbG9hdCB2UHVsc2VOdW1fMDtcXG52YXJ5aW5nIGZsb2F0IHZQdWxzZVByb2dyZXNzXzA7XFxuXFxuLy8jcHJhZ21hIGdsc2xpZnk6IHNub2lzZTIgPSByZXF1aXJlKGdsc2wtbm9pc2Uvc2ltcGxleC8yZClcXG5cXG5mbG9hdCByYW5kb20yKHZlYzIgYyl7XFxuICAgIHJldHVybiBmcmFjdChzaW4oZG90KGMueHkgLHZlYzIoMTIuOTg5OCw3OC4yMzMpKSkgKiA0Mzc1OC41NDUzKTtcXG59XFxuLy8gZmxvYXQgcmFuZG9tTm9pc2UodmVjMiBwKSB7XFxuLy8gICByZXR1cm4gKHJhbmRvbTIocCAtIHZlYzIoc2luKHRpbWUpKSkgKiAyLjAgLSAxLjApICogbWF4KGxlbmd0aChhY2NlbGVyYXRpb24pLCAwLjA4KTtcXG4vLyB9XFxuXFxudm9pZCBtYWluKCkge1xcblxcbiAgICBmbG9hdCBpbmNyID0gMC4wO1xcbiAgICBmbG9hdCByYW5kb20gPSByYW5kb20yKHZlYzIodl9wb3NpdGlvbi54K2luY3IsIHZfcG9zaXRpb24ueStpbmNyKSk7XFxuICAgIHZlYzMgcm5kQ29sb3IgPSB2ZWMzKHJhbmRvbS8xLiwgcmFuZG9tLzEuLCByYW5kb20vMS4pO1xcbiAgICBmbG9hdCByYW5kb21TdHJlbmd0aCA9ICh2X2NvbG9yU3RyZW5ndGgxK3ZfY29sb3JTdHJlbmd0aDIrdl9jb2xvclN0cmVuZ3RoMykvMy47XFxuXFxuICAgIHZlYzMgY29sb3JCbGFuY28gPSB2ZWMzKDEuMCwgMS4wLCAxLjApO1xcbiAgICB2ZWMzIG1peENvbG9yID0gdUNvbG9yMDtcXG4gICAgbWl4Q29sb3IgPSBtaXgobWl4Q29sb3IsIHVDb2xvcjEsIHZfY29sb3JTdHJlbmd0aDEpO1xcbiAgICBtaXhDb2xvciA9IG1peChtaXhDb2xvciwgdUNvbG9yMiwgdl9jb2xvclN0cmVuZ3RoMik7XFxuICAgIG1peENvbG9yID0gbWl4KG1peENvbG9yLCB1Q29sb3IzLCB2X2NvbG9yU3RyZW5ndGgzKjAuNSk7XFxuICAgIG1peENvbG9yID0gbWl4KG1peENvbG9yLCBybmRDb2xvciwgMC4wMysocmFuZG9tU3RyZW5ndGgqMC4zKSk7XFxuICAgIG1peENvbG9yID0gbWl4KG1peENvbG9yLCB1Q29sb3JUb3VjaCwgdUZvb3RlclByb2dyZXNzKTtcXG5cXG4gICAgLy9taXhDb2xvciA9IG1peChtaXhDb2xvciwgdmVjMyh2X25vaXNlLCB2X25vaXNlLCB2X25vaXNlKSwgMS4pO1xcblxcbiAgICAvL21peENvbG9yID0gbWl4KG1peENvbG9yLCB1Q29sb3IwLCBjZW50cmFsQ29sb3IpO1xcbiAgICAvL2dsX0ZyYWdDb2xvciA9IHZlYzQodl9ub2lzZSwgMC4wLCAwLjAsIDEuMCk7XFxuICAgIC8vZ2xfRnJhZ0NvbG9yID0gdmVjNChtaXhDb2xvciwgMS4wKTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChtaXhDb2xvciwgMS4wKTtcXG59XFxuXFxuXCI7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCBTY3JvbGxUcmlnZ2VyIGZyb20gJ2dzYXAvU2Nyb2xsVHJpZ2dlcic7XG5pbXBvcnQgdmVydGV4IGZyb20gXCIuL3NoYWRlcnMvZ3JhZGllbnRCYWNrZ3JvdW5kX3ZlcnRleC5nbHNsXCI7XG5pbXBvcnQgZnJhZ21lbnQgZnJvbSBcIi4vc2hhZGVycy9ncmFkaWVudEJhY2tncm91bmRfZnJhZ21lbnQuZ2xzbFwiO1xuXG52YXIgR3JhZGllbnRCYWNrZ3JvdW5kID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR3JhZGllbnRCYWNrZ3JvdW5kKG9iaikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmFkaWVudEJhY2tncm91bmQpO1xuXG4gICAgLy9jb25zb2xlLmxvZyhcIihHcmFkaWVudEJhY2tncm91bmQuQ09OU1RSVUNUT1JBKS0tLS0tLS0tLS0tLS0tLSBcIiwgb2JqKVxuICAgIHRoaXMud29ybGRHTCA9IG9iai53b3JsZEdMOyAvLy0tICAgICAgIFxuXG4gICAgdGhpcy5zZXR0aW5ncyA9IHtcbiAgICAgIGluaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIHNjcm9sbE5ldzogMCxcbiAgICAgIHNjcm9sbExhc3Q6IDAsXG4gICAgICAvLy0tXG4gICAgICB1U2Nyb2xsVG90YWxSYW5nZTogbnVsbCxcbiAgICAgIHVTY3JvbGxQcm9ncmVzczogMCxcbiAgICAgIHVTY3JvbGxEZWx0YTogMCxcbiAgICAgIHVUaW1lOiAwXG4gICAgfTtcbiAgfSAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFBVQkxJQ09TOyAgXG5cblxuICBfY3JlYXRlQ2xhc3MoR3JhZGllbnRCYWNrZ3JvdW5kLCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgdGhpcy5zZXR0aW5ncy5pbml0aWFsaXplZCA9IHRydWU7IC8vLS1cblxuICAgICAgdGhpcy4kc2Nyb2xsVHJpZ2dlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbm5lcicpO1xuICAgICAgdGhpcy5zY3JvbGxUb3RhbFJhbmdlID0gdGhpcy4kc2Nyb2xsVHJpZ2dlci5vZmZzZXRIZWlnaHQ7XG4gICAgICB0aGlzLnNldHRpbmdzLnVTY3JvbGxUb3RhbFJhbmdlID0gdGhpcy5zY3JvbGxUb3RhbFJhbmdlOyAvLy0tXG5cbiAgICAgIHRoaXMuY2xvY2sgPSBuZXcgVEhSRUUuQ2xvY2soKTtcbiAgICAgIHRoaXMucmVuZGVyZXIgPSB0aGlzLndvcmxkR0wucmVuZGVyZXI7IC8vLS1cblxuICAgICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKC0xLCAvLyBsZWZ0XG4gICAgICAxLCAvLyByaWdodFxuICAgICAgMSwgLy8gdG9wXG4gICAgICAtMSwgLy8gYm90dG9tXG4gICAgICAtMSwgLy8gbmVhcixcbiAgICAgIDApO1xuICAgICAgdGhpcy5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpOyAvL3RoaXMuc2NlbmUuYmFja2dyb3VuZCA9IG5ldyBUSFJFRS5Db2xvciggMHhmZjAwMDAgKTtcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBHRU9NRVRSWTpcblxuICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkoMiwgMiwgMTAwLCAxMDApOyAvLy0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gTUFURVJJQUw6XG4gICAgICAvLyBUZXN0IE5hdGVyaWFsOiAgT25seSBmb3IgZGV2IHRlc3RpbmdzXG4gICAgICAvL2NvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7Y29sb3I6IDB4MDBmZjAwfSApO1xuICAgICAgLy8tLVxuXG4gICAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgICAgLy9kZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgICAgLy9ibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyxcbiAgICAgICAgLy92ZXJ0ZXhDb2xvcnM6IHRydWUsXG4gICAgICAgIHZlcnRleFNoYWRlcjogdmVydGV4LFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogZnJhZ21lbnQsXG4gICAgICAgIC8vd2lyZWZyYW1lOnRydWUsXG4gICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgdUNvbG9yMDoge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcihcIiMwMTE1NWNcIilcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vMGYzMDdkXG4gICAgICAgICAgdUNvbG9yMToge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcihcIiMxNzZiYjNcIilcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVDb2xvcjI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoXCIjN2UwOGFjXCIpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1Q29sb3IzOiB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKFwiI2I5MTEyYVwiKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdUNvbG9yVG91Y2g6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoXCIjMDAwQTMzXCIpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1VGltZToge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVTY3JvbGxQcm9ncmVzczoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVGb290ZXJQcm9ncmVzczoge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVTY3JvbGxEZWx0YToge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVTY3JvbGxUb3RhbFJhbmdlOiB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5zZXR0aW5ncy51U2Nyb2xsVG90YWxSYW5nZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdUFzcGVjdFJhdGlvOiB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy53b3JsZEdMLndpZHRoIC8gdGhpcy53b3JsZEdMLmhlaWdodFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdVJlc3BvbnNpdmVTY2FsZToge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMud29ybGRHTC5yZXNwb25zaXZlU2NhbGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLy0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gTUVTSDpcblxuICAgICAgdGhpcy5wbGFuZSA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKTtcbiAgICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMucGxhbmUpO1xuICAgIH0gLy8tLSAgXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIihHcmFkaWVudEJhY2tncm91bmQucmVzaXplKSFcIilcbiAgICAgICAgaWYgKHRoaXMuJHNjcm9sbFRyaWdnZXIpIHtcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLnVTY3JvbGxUb3RhbFJhbmdlID0gdGhpcy4kc2Nyb2xsVHJpZ2dlci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUodGhpcy53b3JsZEdMLndpZHRoLCB0aGlzLndvcmxkR0wuaGVpZ2h0LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVUaW1lLnZhbHVlID0gdGhpcy5jbG9jay5nZXRFbGFwc2VkVGltZSgpO1xuICAgICAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnVTY3JvbGxQcm9ncmVzcy52YWx1ZSA9IHRoaXMud29ybGRHTC5zZXR0aW5ncy5zY3JvbGxfcHJvZ3Jlc3M7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudUZvb3RlclByb2dyZXNzLnZhbHVlID0gdGhpcy53b3JsZEdMLnNldHRpbmdzLnNjcm9sbF9mb290ZXJfcHJvZ3Jlc3M7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudUFzcGVjdFJhdGlvLnZhbHVlID0gdGhpcy53b3JsZEdMLndpZHRoIC8gdGhpcy53b3JsZEdMLmhlaWdodDtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy51U2Nyb2xsVG90YWxSYW5nZS52YWx1ZSA9IHRoaXMuc2V0dGluZ3MudVNjcm9sbFRvdGFsUmFuZ2U7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudVJlc3BvbnNpdmVTY2FsZS52YWx1ZSA9IHRoaXMud29ybGRHTC5yZXNwb25zaXZlU2NhbGU7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTsgLy9jb25zb2xlLmxvZyh0aGlzLm1hdGVyaWFsLnVuaWZvcm1zKVxuICAgICAgICAvL2NvbnNvbGUubG9nKFwidVNjcm9sbFByb2dyZXNzOlwiK3RoaXMubWF0ZXJpYWwudW5pZm9ybXMudVNjcm9sbFByb2dyZXNzLnZhbHVlK1wiICAtLS0gIHVTY3JvbGxUb3RhbFJhbmdlOlwiK3RoaXMubWF0ZXJpYWwudW5pZm9ybXMudVNjcm9sbFRvdGFsUmFuZ2UudmFsdWUrXCIgIC0tLSB1QXNwZWN0UmF0aW86XCIrIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMudUFzcGVjdFJhdGlvLnZhbHVlKVxuICAgICAgfVxuICAgIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFBSSVZBRE9TOlxuXG4gIH1dKTtcblxuICByZXR1cm4gR3JhZGllbnRCYWNrZ3JvdW5kO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBHcmFkaWVudEJhY2tncm91bmQ7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vLyBGUFMtTWV0ZXI6XG4vLyhmdW5jdGlvbigpe3ZhciBzY3JpcHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7c2NyaXB0Lm9ubG9hZD1mdW5jdGlvbigpe3ZhciBzdGF0cz1uZXcgU3RhdHMoKTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXRzLmRvbSk7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGxvb3AoKXtzdGF0cy51cGRhdGUoKTtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCl9KTt9O3NjcmlwdC5zcmM9Jy8vY2RuLmpzZGVsaXZyLm5ldC9naC9LZXZuei9zdGF0cy5qcy9idWlsZC9zdGF0cy5taW4uanMnO2RvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTt9KSgpXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBPcmJpdENvbnRyb2xzIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL2NvbnRyb2xzL09yYml0Q29udHJvbHMnO1xuaW1wb3J0ICogYXMgZGF0IGZyb20gXCJkYXQuZ3VpXCI7XG5pbXBvcnQgZ3NhcCBmcm9tICdnc2FwJztcbmltcG9ydCBTY3JvbGxUcmlnZ2VyIGZyb20gJ2dzYXAvU2Nyb2xsVHJpZ2dlcic7XG5pbXBvcnQgV2ViR0xVdGlscyBmcm9tICcuLi9XZWJHTFV0aWxzJztcbmltcG9ydCBBYm91dDFEb3RzIGZyb20gJy4vQWJvdXQxRG90cyc7IC8vaW1wb3J0IEFib3V0MURvdHMgZnJvbSAnLi4vaG9tZTEvSG9tZTFEb3RzJztcblxuaW1wb3J0IEFib3V0MUJhY2tncm91bmQgZnJvbSAnLi9BYm91dDFCYWNrZ3JvdW5kJztcblxudmFyIEFib3V0MUFwcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFib3V0MUFwcChvYmopIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFib3V0MUFwcCk7XG5cbiAgICAvL2NvbnNvbGUubG9nKFwiKEFib3V0MUFwcC5DT05TVFJVQ1RPUkEpIVwiLCBvYmopIFxuICAgIHRoaXMuaHdfcmVuZGVyZXIgPSBvYmoucmVuZGVyZXI7IC8vIFJlZGVyZXIvcGFnaW5hIGRlIEhpZ2hXYXkuIE5vIGNvbmZ1bmRpciBjb24gZWwgcmVuZGVyL3JlbmRlcmVyIGRlIFRocmVlLmpzXG5cbiAgICB0aGlzLiRjb250YWluZXIgPSBvYmouZG9tRWxlbWVudDtcbiAgICB0aGlzLnJlZlJlc29sdXRpb24gPSBvYmoucmVmUmVzb2x1dGlvbjsgLy8tLSBcbiAgICAvL3RoaXMuJG1haW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW5uZXInKVxuICAgIC8vdGhpcy4kZm9vdGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZvb3RlcicpXG4gICAgLy8tLVxuXG4gICAgdGhpcy5SRUZfUkVTT0xVVElPTiA9IHRoaXMucmVmUmVzb2x1dGlvbjtcbiAgICB0aGlzLlJFRl9DQU1FUkFfRElTVEFOQ0UgPSA1MDA7IC8vLS1cblxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTsgLy8tLVxuXG4gICAgdGhpcy53aWR0aDtcbiAgICB0aGlzLmhlaWdodDtcbiAgICB0aGlzLnJlc3BvbnNpdmVTY2FsZTtcbiAgICB0aGlzLmNhbWVyYURpc3RhbmNlOyAvLy0tXG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoc2VsZikge1xuICAgICAgX3RoaXMub25Nb3VzZVVwZGF0ZShzZWxmKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBmdW5jdGlvbiAoc2VsZikge1xuICAgICAgX3RoaXMub25Nb3VzZVVwZGF0ZShzZWxmKTtcbiAgICB9LCBmYWxzZSk7IC8vLS1cblxuICAgIHRoaXMuTUFJTl9BQ1RJVkUgPSBmYWxzZTtcbiAgICB0aGlzLkZPT1RFUl9BQ1RJVkUgPSBmYWxzZTsgLy8tLVxuXG4gICAgdGhpcy5tb3VzZU5vcm0gPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07IC8vLS1cbiAgICAvL3RoaXMucmVmUmVzb2x1dGlvbiA9IDE5MjA7XG4gICAgLy90aGlzLnJlZlJlc29sdXRpb24gPSA0NTA7XG4gICAgLy90aGlzLnJlc3BvbnNpdmVTY2FsZSA9IHRoaXMud2lkdGgvdGhpcy5yZWZSZXNvbHV0aW9uO1xuICAgIC8vLS1cbiAgICAvL3RoaXMuY2FtZXJhRGlzdGFuY2UgPSA1MDBcbiAgICAvLy0tXG5cbiAgICB0aGlzLnNldHRpbmdzID0ge1xuICAgICAgc2Nyb2xsX2xhc3RJbm5lclk6IDAsXG4gICAgICAvLyBVbHRpbWEgcG9zaWNpw7NuIGRlbCBlbGVtZW50byBkZSByZWZlcmVuY2lhXG4gICAgICBzY3JvbGxfZGVsdGE6IDAsXG4gICAgICAvLyBJbmNyZW1lbnRvIGRlIHBpeGVscyBkZWwgc2Nyb2xsXG4gICAgICBzY3JvbGxfbGltaXRlZERlbHRhOiAwLFxuICAgICAgLy8gTGltaXRhIGxvcyB2YWxvcmVzIGEgLTIwIC0+ICsyMFxuICAgICAgc2Nyb2xsX25vcm1hbGl6ZWREZWx0YTogMCxcbiAgICAgIC8vIFBhc2EgZWwgZGVsdGEgYSAtMSAtPiArMVxuICAgICAgc2Nyb2xsX2ZhY3RvcmREZWx0YTogMSxcbiAgICAgIC8vIFZhbG9yZXMgYWJzb2x1dG9zIGRlIDAgLT4gMVxuICAgICAgc2Nyb2xsX2RpcmVjdGlvbjogMSxcbiAgICAgIC8vIERpcmVjY2lvbiBkZWwgZGVsdGEuIDEgc2kgZXN0w6EgcGFyYWRvXG4gICAgICBzY3JvbGxfZm9vdGVyX3Byb2dyZXNzOiAwLFxuICAgICAgbW9ycGhpbmdQcm9ncmVzczogMFxuICAgIH07IC8vLS1cblxuICAgIHRoaXMuX3VwZGF0ZV9kaW1lbnNpb25zKCk7IC8vLS1cbiAgICAvLyBTY2VuZVxuXG5cbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7IC8vdGhpcy5zY2VuZS5iYWNrZ3JvdW5kID0gbmV3IFRIUkVFLkNvbG9yKDB4MzMzMzMzKVxuICAgIC8vLS1cbiAgICAvLyBDYW1lcmFcbiAgICAvL1BlcnNwZWN0aXZlQ2FtZXJhKCBmb3YgOiBOdW1iZXIsIGFzcGVjdCA6IE51bWJlciwgbmVhciA6IE51bWJlciwgZmFyIDogTnVtYmVyIClcblxuICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDMwLCB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQsIDAuMSwgMjAwMCk7XG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueiA9IHRoaXMuY2FtZXJhRGlzdGFuY2U7IC8vY29uc29sZS5sb2coXCJ0aGlzLmNhbWVyYS5mb3Y6IFwiK3RoaXMuY2FtZXJhLmZvdilcblxuICAgIHRoaXMuY2FtZXJhLmZvdiA9IDIgKiBNYXRoLmF0YW4odGhpcy5oZWlnaHQgLyAyIC8gdGhpcy5jYW1lcmFEaXN0YW5jZSkgKiAoMTgwIC8gTWF0aC5QSSk7IC8vY29uc29sZS5sb2coXCJ0aGlzLmNhbWVyYS5mb3Y6IFwiK3RoaXMuY2FtZXJhLmZvdilcbiAgICAvLy0tXG4gICAgLy8gUmVuZGVyZXJcblxuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0wxUmVuZGVyZXIoe1xuICAgICAgYW50aWFsaWFzOiB0cnVlLFxuICAgICAgYWxwaGE6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlOyAvLyBWYW1vcyBhIHVzYXIgMiBzY2VuYXMgKHVuYSBwYXJhIGVsIGJhY2tncm91bmQgeSBvdHJhIHBhcmEgbG9zIHB1bnRvcykgcXVlIGltcGxpY2Fyw6FuIHVzYXIgMiBhY2Npb25lcyBkZSByZW5kZXIuIENvbiBhdXRvY2xlYXIgZmFsc2UgcGVybWl0aW1vcyBxdWUgbGEgc2VndW5kYSBubyBib3JyZSBsYSBwcmltZXJhLlxuXG4gICAgdGhpcy5yZW5kZXJlci5zZXRQaXhlbFJhdGlvKE1hdGgubWluKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCAxKSk7IC8vLS1cblxuICAgIHRoaXMuJGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpOyAvLy0tXG4gICAgLy8tLVxuXG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3IEFib3V0MUJhY2tncm91bmQoe1xuICAgICAgd29ybGRHTDogdGhpc1xuICAgIH0pOyAvLy0tXG5cbiAgICB0aGlzLmRvdHMgPSBuZXcgQWJvdXQxRG90cyh7XG4gICAgICB3b3JsZEdMOiB0aGlzXG4gICAgfSk7IC8vLS1cblxuICAgIHRoaXMuX3Jlc2l6ZSgpOyAvL3RoaXMuX3JlbmRlcigpO1xuICAgIC8vdGhpcy5faW5pdF9zY3JvbGxMaXN0ZW5lcnMoKVxuXG4gIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUFVCTElDQVM6XG5cblxuICBfY3JlYXRlQ2xhc3MoQWJvdXQxQXBwLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEFib3V0MUFwcC5pbml0KSFcIikgXG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZXZhbF9zdGFydCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJldmFsX3N0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWxfc3RhcnQoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEFib3V0MUFwcC5ldmFsX3N0YXJ0KTogXCIrdGhpcy5pbml0aWFsaXplZCtcIjpcIit0aGlzLmRvdHMuYWxsTG9hZGVkKSBcbiAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkICYmIHRoaXMuZG90cy5hbGxMb2FkZWQpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNUQVJUIVwiKVxuICAgICAgICAvLy0tXG4gICAgICAgIHRoaXMuJG1haW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW5uZXInKTtcbiAgICAgICAgdGhpcy4kZm9vdGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZvb3RlcicpOyAvLy0tXG5cbiAgICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZCkge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZC5jcmVhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRvdHMpIHtcbiAgICAgICAgICB0aGlzLmRvdHMuY3JlYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZW5kZXIoKTtcblxuICAgICAgICB0aGlzLl9pbml0X3Njcm9sbExpc3RlbmVycygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJraWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEFib3V0MUFwcC5raWxsKSFcIikgXG4gICAgICB0aGlzLiRpbm5lcl90cmlnZ2VyLmtpbGwoKTtcbiAgICAgIHRoaXMuJGZvb3Rlcl90cmlnZ2VyLmtpbGwoKTtcbiAgICAgIGdzYXAudGlja2VyLnJlbW92ZSh0aGlzLl9iaW5kZWRfcmVuZGVyKTtcbiAgICAgIGdzYXAudGlja2VyLnJlbW92ZSh0aGlzLl9iaW5kZWRfZXZhbF9zY3JvbGwpO1xuICAgICAgdGhpcy5kb3RzID0gbnVsbDtcbiAgICB9IC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgfSwge1xuICAgIGtleTogXCJvblJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCIoQWJvdXQxQXBwLm9uUmVzaXplKSFcIilcbiAgICAgIHRoaXMuX3Jlc2l6ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbk1vdXNlVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VVcGRhdGUoZSkge1xuICAgICAgaWYgKHRoaXMuRk9PVEVSX0FDVElWRSkge1xuICAgICAgICB0aGlzLm1vdXNlTm9ybS54ID0gZS5wYWdlWCAvIHRoaXMud2lkdGggKiAyIC0gMTtcbiAgICAgICAgdGhpcy5tb3VzZU5vcm0ueSA9IGUucGFnZVkgLyB0aGlzLmhlaWdodCAqIDIgLSAxO1xuXG4gICAgICAgIGlmICh0aGlzLmRvdHMpIHtcbiAgICAgICAgICB0aGlzLmRvdHMub25Nb3VzZVVwZGF0ZSh0aGlzLm1vdXNlTm9ybS54LCB0aGlzLm1vdXNlTm9ybS55KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBQUklWQURBUzpcblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVfZGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlX2RpbWVuc2lvbnMoKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIihIb21lMkFwcF9tLl91cGRhdGVfZGltZW5zaW9ucykhXCIsIHRoaXMucmVuZGVyZXIpXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy4kY29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLiRjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgdGhpcy5yZXNwb25zaXZlU2NhbGUgPSB0aGlzLndpZHRoIC8gdGhpcy5SRUZfUkVTT0xVVElPTi53aWR0aDtcbiAgICAgIHRoaXMuY2FtZXJhRGlzdGFuY2UgPSB0aGlzLlJFRl9DQU1FUkFfRElTVEFOQ0UgKiB0aGlzLnJlc3BvbnNpdmVTY2FsZTsgLy8tLVxuXG4gICAgICBpZiAodGhpcy5yZW5kZXJlcikge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpOyAvLy0tXG5cbiAgICAgICAgdGhpcy5jYW1lcmEuYXNwZWN0ID0gdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNhbWVyYURpc3RhbmNlID0gdGhpcy5jYW1lcmEucG9zaXRpb24uejtcbiAgICAgICAgdGhpcy5jYW1lcmEuZm92ID0gMiAqIE1hdGguYXRhbih0aGlzLmhlaWdodCAvIDIgLyB0aGlzLmNhbWVyYURpc3RhbmNlKSAqICgxODAgLyBNYXRoLlBJKTtcbiAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgfSAvLy0tXG5cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRfc2Nyb2xsTGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0X3Njcm9sbExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgYmluZGVkX3JlbmRlciA9IGZ1bmN0aW9uIGJpbmRlZF9yZW5kZXIoKSB7XG4gICAgICAgIF90aGlzMi5fcmVuZGVyKCk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9iaW5kZWRfcmVuZGVyID0gYmluZGVkX3JlbmRlcjtcblxuICAgICAgdmFyIGJpbmRlZF9ldmFsX3Njcm9sbCA9IGZ1bmN0aW9uIGJpbmRlZF9ldmFsX3Njcm9sbCgpIHtcbiAgICAgICAgX3RoaXMyLl9ldmFsX2luZXJ0aWFfc2Nyb2xsKF90aGlzMi4kaW5uZXJfdHJpZ2dlci5wcm9ncmVzcyk7XG5cbiAgICAgICAgX3RoaXMyLl9ldmFsX2Zvb3Rlcl9zY3JvbGwoX3RoaXMyLiRmb290ZXJfdHJpZ2dlci5wcm9ncmVzcyk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9iaW5kZWRfZXZhbF9zY3JvbGwgPSBiaW5kZWRfZXZhbF9zY3JvbGw7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB0aGlzLiRpbm5lcl90cmlnZ2VyID0gU2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xuICAgICAgICB0cmlnZ2VyOiB0aGlzLiRtYWluLFxuICAgICAgICBzdGFydDogJ3RvcC09MTAgdG9wJyxcbiAgICAgICAgZW5kOiAnYm90dG9tIGJvdHRvbScsXG4gICAgICAgIHNjcnViOiB0cnVlLFxuICAgICAgICAvLyBTY3J1YjogR2VuZXJhIGV2ZW50b3MgZW4gdW5hIGZyYW5qYSBtYXMgcXVlIGVuIHVuIHB1bnRvLlxuICAgICAgICAvLyBtYXJrZXJzOiB0cnVlLFxuICAgICAgICBvblRvZ2dsZTogZnVuY3Rpb24gb25Ub2dnbGUoc2VsZikge1xuICAgICAgICAgIGlmIChzZWxmLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiTUFJTiBBQ1RJVkVcIilcbiAgICAgICAgICAgIHRoYXQuTUFJTl9BQ1RJVkUgPSB0cnVlO1xuICAgICAgICAgICAgZ3NhcC50aWNrZXIuYWRkKGJpbmRlZF9yZW5kZXIpO1xuICAgICAgICAgICAgZ3NhcC50aWNrZXIuYWRkKGJpbmRlZF9ldmFsX3Njcm9sbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoYXQuTUFJTl9BQ1RJVkUgPSBmYWxzZTsgLy9jb25zb2xlLmxvZyhcIk1BSU4gTk9UIEFDVElWRVwiKVxuICAgICAgICAgICAgLy9nc2FwLnRpY2tlci5yZW1vdmUoYmluZGVkX3JlbmRlcikgLy8gRWwgZm9uZG8gd2ViZ2wgcGVyc2lzdGUgc2llbXByZS4gTm8gbG8gZGVzYWN0aXZhbW9zIG51bmNhLlxuXG4gICAgICAgICAgICBnc2FwLnRpY2tlci5yZW1vdmUoYmluZGVkX2V2YWxfc2Nyb2xsKTsgLy8gRWwgZm9uZG8gd2ViZ2wgcGVyc2lzdGUgc2llbXByZS4gTm8gbG8gZGVzYWN0aXZhbW9zIG51bmNhLlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLiRmb290ZXJfdHJpZ2dlciA9IFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgdHJpZ2dlcjogdGhpcy4kZm9vdGVyLFxuICAgICAgICBzdGFydDogJ3RvcCBib3R0b20nLFxuICAgICAgICBlbmQ6ICdib3R0b20rPTEwIGJvdHRvbScsXG4gICAgICAgIHNjcnViOiB0cnVlLFxuICAgICAgICAvLyBTY3J1YjogR2VuZXJhIGV2ZW50b3MgZW4gdW5hIGZyYW5qYSBtYXMgcXVlIGVuIHVuIHB1bnRvLlxuICAgICAgICAvLyBtYXJrZXJzOiB0cnVlLFxuICAgICAgICBvblRvZ2dsZTogZnVuY3Rpb24gb25Ub2dnbGUoc2VsZikge1xuICAgICAgICAgIGlmIChzZWxmLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRk9PVEVSIEFDVElWRVwiKVxuICAgICAgICAgICAgdGhhdC5GT09URVJfQUNUSVZFID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkZPT1RFUiBOT1QgQUNUSVZFXCIpXG4gICAgICAgICAgICB0aGF0LkZPT1RFUl9BQ1RJVkUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZXZhbF9pbmVydGlhX3Njcm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZhbF9pbmVydGlhX3Njcm9sbChwcm9ncmVzcykge1xuICAgICAgdmFyIGlubmVyRGF0YSA9IHRoaXMuJG1haW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgbmV3SW5uZXJZID0gaW5uZXJEYXRhLnk7XG4gICAgICB0aGlzLnNldHRpbmdzLnNjcm9sbF9wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfZGVsdGEgPSBuZXdJbm5lclkgLSB0aGlzLnNldHRpbmdzLnNjcm9sbF9sYXN0SW5uZXJZO1xuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfbGFzdElubmVyWSA9IG5ld0lubmVyWTtcbiAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX2xpbWl0ZWREZWx0YSA9IFdlYkdMVXRpbHMuY2xhbXAodGhpcy5zZXR0aW5ncy5zY3JvbGxfZGVsdGEsIC0yMCwgMjApOyAvLyBMaW1pdGEgbG9zIHZhbG9yZXMgYSAtMjAgLT4gKzIwXG5cbiAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSA9ICh0aGlzLnNldHRpbmdzLnNjcm9sbF9saW1pdGVkRGVsdGEgLyAyMCkudG9GaXhlZCgzKTsgLy8gUGFzYSBlbCBkZWx0YSBhIC0xIC0+ICsxXG5cbiAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsX2ZhY3RvcmREZWx0YSA9IE1hdGguYWJzKHRoaXMuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSkgKyAwOyAvLyBWYWxvcmVzIGFic29sdXRvcyBkZSAwIC0+IDFcblxuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfZGlyZWN0aW9uID0gMTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2Nyb2xsX25vcm1hbGl6ZWREZWx0YSA8IDApIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfZGlyZWN0aW9uID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9ldmFsX2Zvb3Rlcl9zY3JvbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2YWxfZm9vdGVyX3Njcm9sbChwcm9ncmVzcykge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihBYm91dDFBcHAuX2V2YWxfZm9vdGVyX3Njcm9sbCk6IFwiK3Byb2dyZXNzKVxuICAgICAgdGhpcy5zZXR0aW5ncy5zY3JvbGxfZm9vdGVyX3Byb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICB0aGlzLnNldHRpbmdzLm1vcnBoaW5nUHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKCkge1xuICAgICAgLy9jb25zb2xlLmxvZyhcIihBYm91dDFEb3RzLnJlc2l6ZSkhXCIpXG4gICAgICAvLy0tXG4gICAgICB0aGlzLl91cGRhdGVfZGltZW5zaW9ucygpOyAvLy0tXG5cblxuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZCkge1xuICAgICAgICB0aGlzLmJhY2tncm91bmQucmVzaXplKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRvdHMpIHtcbiAgICAgICAgdGhpcy5kb3RzLnJlc2l6ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXIoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiKEFib3V0MUFwcC5fcmVuZGVyKTogXCIrdGhpcy5zZXR0aW5ncy5zY3JvbGxfcHJvZ3Jlc3MrXCI6XCIrdGhpcy5zZXR0aW5ncy5zY3JvbGxfZm9vdGVyX3Byb2dyZXNzKVxuICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IHRoaXMuJGNvbnRhaW5lci5vZmZzZXRIZWlnaHQgfHwgdGhpcy53aWR0aCAhPSB0aGlzLiRjb250YWluZXIub2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJhY2tncm91bmQpIHtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLnJlbmRlcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kb3RzKSB7XG4gICAgICAgIHRoaXMuZG90cy5yZW5kZXIoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpOyAvL3JlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBYm91dDFBcHA7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IEFib3V0MUFwcDsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vLyBHU0FQIExpYnJhcnlcbmltcG9ydCBnc2FwIGZyb20gJ2dzYXAnO1xuaW1wb3J0IFNjcm9sbFRyaWdnZXIgZnJvbSAnZ3NhcC9TY3JvbGxUcmlnZ2VyJztcbmdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVHJpZ2dlcik7XG5pbXBvcnQgbW9ycGhTVkdQbHVnaW4gZnJvbSAnLi4vY2xhc3Nlcy9tb3JwaFNWR1BsdWdpbic7XG5nc2FwLnJlZ2lzdGVyUGx1Z2luKG1vcnBoU1ZHUGx1Z2luKTsgLy8gV2ViZ2xcblxuaW1wb3J0IEFib3V0MUFwcCBmcm9tICcuLi93ZWJnbC9hYm91dDEvQWJvdXQxQXBwJzsgLy8gSW1wb3J0IFJlbmRlcmVyXG5cbmltcG9ydCBSZW5kZXJlciBmcm9tICcuL3JlbmRlcmVyLmpzJzsgLy8gVXRpbGl0aWVzXG5cbmltcG9ydCBEb21FdmVudHMgZnJvbSAnLi4vY2xhc3Nlcy9kb21FdmVudHMnO1xuaW1wb3J0IFN1cGVyU2Nyb2xsZXIgZnJvbSAnLi4vY2xhc3Nlcy9zdXBlclNjcm9sbGVyJztcbmltcG9ydCBTdXBlckRyYWdnYWJsZSBmcm9tICcuLi9jbGFzc2VzL3N1cGVyRHJhZ2dhYmxlJztcblxudmFyIFJlbmRlcmVyQWJvdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZW5kZXJlcikge1xuICBfaW5oZXJpdHMoUmVuZGVyZXJBYm91dCwgX1JlbmRlcmVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFJlbmRlcmVyQWJvdXQpO1xuXG4gIGZ1bmN0aW9uIFJlbmRlcmVyQWJvdXQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbmRlcmVyQWJvdXQpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlbmRlcmVyQWJvdXQsIFt7XG4gICAga2V5OiBcInNlbGVjdG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RvcnMoKSB7XG4gICAgICAvLyBTZWN0aW9uc1xuICAgICAgdGhpcy4kaGVybyA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5hYm91dF9faGVybycpO1xuICAgICAgdGhpcy4kdGVhbSA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5hYm91dF9fdGVhbScpO1xuICAgICAgdGhpcy4kY2xpZW50cyA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5hYm91dF9fY2xpZW50cycpO1xuICAgICAgdGhpcy4kY2FudmFzID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignI3dlYmdsX2JhY2tncm91bmRfYWJvdXQnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2ZW50cygpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICB9LCB7XG4gICAga2V5OiBcInByZWxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICAgIHRoaXMucHJlbG9hZEl0ZW1zID0ge1xuICAgICAgICBtYWluOiBbXSxcbiAgICAgICAgc2Vjb25kYXJ5OiBbXVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmVmb3JlRW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlRW50ZXIoKSB7XG4gICAgICAvLyBXZWJnbFxuICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB7XG4gICAgICAgIHRoaXMucmVuZGVyQmcgPSBuZXcgQWJvdXQxQXBwKHtcbiAgICAgICAgICByZW5kZXJlcjogdGhpcyxcbiAgICAgICAgICBkb21FbGVtZW50OiB0aGlzLiRjYW52YXMsXG4gICAgICAgICAgcmVmUmVzb2x1dGlvbjoge1xuICAgICAgICAgICAgd2lkdGg6IDE5MjAsXG4gICAgICAgICAgICBoZWlnaHQ6IDk0N1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbmRlckJnID0gbmV3IEFib3V0MUFwcCh7XG4gICAgICAgICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgICAgICAgZG9tRWxlbWVudDogdGhpcy4kY2FudmFzLFxuICAgICAgICAgIHJlZlJlc29sdXRpb246IHtcbiAgICAgICAgICAgIHdpZHRoOiA4NTAsXG4gICAgICAgICAgICBoZWlnaHQ6IDg1MFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVudGVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy8gU3RhcnQgZnVuY3Rpb25zXG4gICAgICB0aGlzLmluaXQoKTsgLy8gTW92ZSBjYW52YXNcblxuICAgICAgdmFyIF9vZmZzZXQyID0gdGhpcy4kaW5uZXIub2Zmc2V0SGVpZ2h0IC0gdGhpcy4kY2FudmFzLm9mZnNldEhlaWdodDtcblxuICAgICAgdGhpcy5fY2FudmFzUGluID0gU2Nyb2xsVHJpZ2dlci5jcmVhdGUoe1xuICAgICAgICB0cmlnZ2VyOiB0aGlzLiRpbm5lcixcbiAgICAgICAgc3RhcnQ6ICd0b3AgdG9wJyxcbiAgICAgICAgZW5kOiAnYm90dG9tIGJvdHRvbScsXG4gICAgICAgIHNjcnViOiB0cnVlLFxuICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoc2VsZikge1xuICAgICAgICAgIGlmIChfdGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIGdzYXAuc2V0KF90aGlzLiRjYW52YXMsIHtcbiAgICAgICAgICAgIHk6IF9vZmZzZXQyICogc2VsZi5wcm9ncmVzcyArICdweCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmluaXRIZXJvQ2FyZHMoKTtcbiAgICAgIHRoaXMucmVuZGVyQmcuaW5pdCgpO1xuXG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgZ3NhcC5kZWxheWVkQ2FsbCgxLjUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIuaW5pdEhlcm9QaW4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5pdFBhcmFsbGF4Q2FyZHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5pdFRlYW1EcmFnZ2FibGVNb2JpbGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFBhcmFsbGF4Q2FyZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFBhcmFsbGF4Q2FyZHMoKSB7XG4gICAgICB0aGlzLiRoZXJvQ2FyZHMgPSB0aGlzLiRoZXJvLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXJkJyk7XG4gICAgICB2YXIgcGFyYWxsYXhDYXJkcyA9IGdzYXAudGltZWxpbmUoe1xuICAgICAgICBkZWZhdWx0czoge1xuICAgICAgICAgIGR1cmF0aW9uOiAxLFxuICAgICAgICAgIGVhc2U6ICdub25lJ1xuICAgICAgICB9LFxuICAgICAgICBzY3JvbGxUcmlnZ2VyOiB7XG4gICAgICAgICAgdHJpZ2dlcjogdGhpcy4kaGVyby5xdWVyeVNlbGVjdG9yKCcuY29udGFpbmVyLS1sYXJnZScpLFxuICAgICAgICAgIHN0YXJ0OiAndG9wIGJvdHRvbScsXG4gICAgICAgICAgZW5kOiB0aGlzLiRoZXJvLnF1ZXJ5U2VsZWN0b3IoJy5jb250YWluZXItLWxhcmdlJykub2Zmc2V0SGVpZ2h0ICsgd2luZG93LmlubmVyV2lkdGggKiAwLjEgKyAnIHRvcCcsXG4gICAgICAgICAgc2NydWI6IHRydWUsXG4gICAgICAgICAgbWFya2VyczogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIFNldFxuXG4gICAgICBwYXJhbGxheENhcmRzLnNldChbdGhpcy4kaGVyb0NhcmRzWzBdXSwge1xuICAgICAgICB5OiAnMHZ3J1xuICAgICAgfSwgMCk7XG4gICAgICBwYXJhbGxheENhcmRzLnNldChbdGhpcy4kaGVyb0NhcmRzWzFdXSwge1xuICAgICAgICB5OiAnMi41dncnXG4gICAgICB9LCAwKTtcbiAgICAgIHBhcmFsbGF4Q2FyZHMuc2V0KFt0aGlzLiRoZXJvQ2FyZHNbMl1dLCB7XG4gICAgICAgIHk6ICcwdncnXG4gICAgICB9LCAwKTtcbiAgICAgIHBhcmFsbGF4Q2FyZHMuc2V0KFt0aGlzLiRoZXJvQ2FyZHNbM11dLCB7XG4gICAgICAgIHk6ICcyLjV2dydcbiAgICAgIH0sIDApOyAvLyBBbmltYXRpb25cblxuICAgICAgcGFyYWxsYXhDYXJkcy50byhbdGhpcy4kaGVyb0NhcmRzWzBdXSwge1xuICAgICAgICB5OiAnMi41dncnXG4gICAgICB9LCAwKTtcbiAgICAgIHBhcmFsbGF4Q2FyZHMudG8oW3RoaXMuJGhlcm9DYXJkc1sxXV0sIHtcbiAgICAgICAgeTogJzB2dydcbiAgICAgIH0sIDApO1xuICAgICAgcGFyYWxsYXhDYXJkcy50byhbdGhpcy4kaGVyb0NhcmRzWzJdXSwge1xuICAgICAgICB5OiAnMi41dncnXG4gICAgICB9LCAwKTtcbiAgICAgIHBhcmFsbGF4Q2FyZHMudG8oW3RoaXMuJGhlcm9DYXJkc1szXV0sIHtcbiAgICAgICAgeTogJzB2dydcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0SGVyb0NhcmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRIZXJvQ2FyZHMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgLy8gU2VsZWN0b3JzXG4gICAgICB0aGlzLiRoZXJvQ2FyZHMgPSB0aGlzLiRoZXJvLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXJkJyk7XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgaWYgKF90aGlzMy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgICBfdGhpczMuZG9tRXZlbnRzLmFkZChfdGhpczMuJGhlcm9DYXJkc1tpXSwgJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoYSwgZSwgZWwpIHtcbiAgICAgICAgICAgIGlmIChlbC5xdWVyeVNlbGVjdG9yKCcuaW5mbycpKSB7XG4gICAgICAgICAgICAgIGdzYXAua2lsbFR3ZWVuc09mKGVsLnF1ZXJ5U2VsZWN0b3IoJy5pbmZvJykpO1xuICAgICAgICAgICAgICBnc2FwLnNldChlbC5xdWVyeVNlbGVjdG9yKCcuaW5mbycpLCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBnc2FwLnRvKGVsLnF1ZXJ5U2VsZWN0b3IoJy5pbmZvJyksIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjYsXG4gICAgICAgICAgICAgICAgZWFzZTogJ2V4cG8ub3V0J1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBfdGhpczMuZG9tRXZlbnRzLmFkZChfdGhpczMuJGhlcm9DYXJkc1tpXSwgJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoYSwgZSwgZWwpIHtcbiAgICAgICAgICAgIGlmIChlbC5xdWVyeVNlbGVjdG9yKCcuaW5mbycpKSB7XG4gICAgICAgICAgICAgIGdzYXAua2lsbFR3ZWVuc09mKGVsLnF1ZXJ5U2VsZWN0b3IoJy5pbmZvJykpO1xuICAgICAgICAgICAgICBnc2FwLnRvKGVsLnF1ZXJ5U2VsZWN0b3IoJy5pbmZvJyksIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjAwMDEsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDAuNixcbiAgICAgICAgICAgICAgICBlYXNlOiAnZXhwby5vdXQnLFxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgICAgICAgICBnc2FwLnNldChlbC5xdWVyeVNlbGVjdG9yKCcuaW5mbycpLCB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3BlbiBhbmQgY2xvc2UgaW5mb1xuICAgICAgICAgIGlmIChfdGhpczMuJGhlcm9DYXJkc1tpXS5xdWVyeVNlbGVjdG9yKCcuaW5mbycpKSB7XG4gICAgICAgICAgICBfdGhpczMuZG9tRXZlbnRzLmFkZChfdGhpczMuJGhlcm9DYXJkc1tpXS5xdWVyeVNlbGVjdG9yKCcuaWNvbicpLCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBnc2FwLnNldChfdGhpczMuJGhlcm9DYXJkc1tpXS5xdWVyeVNlbGVjdG9yKCcuaW5mbycpLCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBnc2FwLnRvKF90aGlzMy4kaGVyb0NhcmRzW2ldLnF1ZXJ5U2VsZWN0b3IoJy5pbmZvJyksIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjgsXG4gICAgICAgICAgICAgICAgZWFzZTogJ2V4cG8ub3V0J1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoX3RoaXMzLiRoZXJvQ2FyZHNbaV0ucXVlcnlTZWxlY3RvcignLmNsb3NlcicpKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5kb21FdmVudHMuYWRkKF90aGlzMy4kaGVyb0NhcmRzW2ldLnF1ZXJ5U2VsZWN0b3IoJy5jbG9zZXInKSwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBnc2FwLnRvKF90aGlzMy4kaGVyb0NhcmRzW2ldLnF1ZXJ5U2VsZWN0b3IoJy5pbmZvJyksIHtcbiAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwLjgsXG4gICAgICAgICAgICAgICAgICBlYXNlOiAnZXhwby5vdXQnLFxuICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3NhcC5zZXQoX3RoaXMzLiRoZXJvQ2FyZHNbaV0ucXVlcnlTZWxlY3RvcignLmluZm8nKSwge1xuICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBTZWxlY3RvcnNcblxuXG4gICAgICAgICAgX3RoaXMzLiRoZXJvU2xpZGVyID0gX3RoaXMzLiRoZXJvLnF1ZXJ5U2VsZWN0b3IoJy5zbGlkZXInKTtcbiAgICAgICAgICBfdGhpczMuX2hlcm9EcmFnZ2FibGUgPSBuZXcgU3VwZXJEcmFnZ2FibGUoe1xuICAgICAgICAgICAgZWw6IF90aGlzMy4kaGVybyxcbiAgICAgICAgICAgIHNuYXA6IGZhbHNlLFxuICAgICAgICAgICAgc25hcFRvOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGRvdHM6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kaGVyb0NhcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9sb29wKGkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0SGVyb1BpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0SGVyb1BpbigpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRoZXJvV29yZHMgPSB0aGlzLiRoZXJvLnF1ZXJ5U2VsZWN0b3IoJy53b3JkcycpO1xuICAgICAgdGhpcy4kaGVyb1dvcmRzSW5uZXIgPSB0aGlzLiRoZXJvLnF1ZXJ5U2VsZWN0b3IoJy53b3Jkc19faW5uZXInKTtcbiAgICAgIHRoaXMuJGhlcm9Xb3Jkc0dyYWRpZW50ID0gdGhpcy4kaGVyby5xdWVyeVNlbGVjdG9yKCcud29yZHNfX2dyYWRpZW50Jyk7XG4gICAgICB0aGlzLiRoZXJvTGFiZWwgPSB0aGlzLiRoZXJvLnF1ZXJ5U2VsZWN0b3IoJy5sYWJlbC0tMScpO1xuXG4gICAgICB2YXIgX29mZnNldCA9IHRoaXMuJGhlcm9Xb3Jkc0lubmVyLm9mZnNldEhlaWdodCAtIHRoaXMuJGhlcm9Xb3Jkc0dyYWRpZW50Lm9mZnNldEhlaWdodDtcblxuICAgICAgdGhpcy5faGVyb1BpbiA9IFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgdHJpZ2dlcjogdGhpcy4kaGVyb1dvcmRzLFxuICAgICAgICBzdGFydDogJ3RvcCB0b3AnLFxuICAgICAgICBlbmQ6ICdib3R0b20gYm90dG9tJyxcbiAgICAgICAgc2NydWI6IHRydWUsXG4gICAgICAgIG1hcmtlcnM6IGZhbHNlLFxuICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoc2VsZikge1xuICAgICAgICAgIGdzYXAuc2V0KF90aGlzNC4kaGVyb0xhYmVsLCB7XG4gICAgICAgICAgICB5OiBfb2Zmc2V0ICogc2VsZi5wcm9ncmVzcyArICdweCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBnc2FwLnNldChfdGhpczQuJGhlcm9Xb3Jkc0dyYWRpZW50LCB7XG4gICAgICAgICAgICB5OiBfb2Zmc2V0ICogc2VsZi5wcm9ncmVzcyArICdweCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FbnRlcjogZnVuY3Rpb24gb25FbnRlcigpIHtcbiAgICAgICAgICBnc2FwLnRvKF90aGlzNC4kaGVyb1dvcmRzR3JhZGllbnQsIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICBkdXJhdGlvbjogMC40LFxuICAgICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRW50ZXJCYWNrOiBmdW5jdGlvbiBvbkVudGVyQmFjaygpIHtcbiAgICAgICAgICBnc2FwLnRvKF90aGlzNC4kaGVyb1dvcmRzR3JhZGllbnQsIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICBkdXJhdGlvbjogMC40LFxuICAgICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBNb3ZlIGNhbnZhc1xuXG4gICAgICB2YXIgX29mZnNldDIgPSB0aGlzLiRpbm5lci5vZmZzZXRIZWlnaHQgLSB0aGlzLiRjYW52YXMub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICB0aGlzLl9jYW52YXNQaW4gPSBTY3JvbGxUcmlnZ2VyLmNyZWF0ZSh7XG4gICAgICAgIHRyaWdnZXI6IHRoaXMuJGlubmVyLFxuICAgICAgICBzdGFydDogJ3RvcCB0b3AnLFxuICAgICAgICBlbmQ6ICdib3R0b20gYm90dG9tJyxcbiAgICAgICAgc2NydWI6IHRydWUsXG4gICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShzZWxmKSB7XG4gICAgICAgICAgZ3NhcC5zZXQoX3RoaXM0LiRjYW52YXMsIHtcbiAgICAgICAgICAgIHk6IF9vZmZzZXQyICogc2VsZi5wcm9ncmVzcyArICdweCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIENyZWF0ZSBhIGxpbmVhciBncmFkaWVudCB0aGF0IHdvcmtzIHdpdGggd2ViR2wgYmFja2dyb3VuZFxuXG4gICAgICB2YXIgY2FudmFzID0gdGhpcy4kaGVyb1dvcmRzR3JhZGllbnQ7XG4gICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7IC8vIFRoZSBzdGFydCBncmFkaWVudCBwb2ludCBpcyBhdCB4ID0gMjAsIHkgPSAwIC8gVGhlIGVuZCBncmFkaWVudCBwb2ludCBpcyBhdCB4ID0gMjIwLCB5ID0gMFxuXG4gICAgICB2YXIgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMjAsIDAsIDIyMCwgMCk7IC8vIFNldCB0aGUgZmlsbCBzdHlsZSBhbmQgZHJhdyBhIHJlY3RhbmdsZVxuXG4gICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICBjdHguZmlsbFJlY3QoMjAsIDIwLCAyMDAsIDEwMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRUZWFtRHJhZ2dhYmxlTW9iaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRUZWFtRHJhZ2dhYmxlTW9iaWxlKCkge1xuICAgICAgdGhpcy4kdGVhbVNsaWRlciA9IHRoaXMuJHRlYW0ucXVlcnlTZWxlY3RvcignLnNsaWRlcicpO1xuICAgICAgdGhpcy4kdGVhbVNsaWRlclByb2dyZXNzID0gdGhpcy4kdGVhbVNsaWRlci5xdWVyeVNlbGVjdG9yKCcuc2xpZGVyX19wcm9ncmVzcycpO1xuICAgICAgdGhpcy5fdGVhbURyYWdnYWJsZSA9IG5ldyBTdXBlckRyYWdnYWJsZSh7XG4gICAgICAgIGVsOiB0aGlzLiR0ZWFtLFxuICAgICAgICBzbmFwOiBmYWxzZSxcbiAgICAgICAgc25hcFRvOiAnY2VudGVyJyxcbiAgICAgICAgZG90czogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyYWZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmFmKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAoIXRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB7XG4gICAgICAgIGlmICh0aGlzLl9oZXJvRHJhZ2dhYmxlKSB0aGlzLl9oZXJvRHJhZ2dhYmxlLnJlc2l6ZSgpO1xuICAgICAgICBpZiAodGhpcy5fdGVhbURyYWdnYWJsZSkgdGhpcy5fdGVhbURyYWdnYWJsZS5yZXNpemUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGVhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVhdmUoKSB7XG4gICAgICB0aGlzLnJlbmRlckJnLmtpbGwoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVuZGVyZXJBYm91dDtcbn0oUmVuZGVyZXIpOyAvLyBEb24ndCBmb3JnZXQgdG8gZXhwb3J0IHlvdXIgcmVuZGVyZXJcblxuXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJlckFib3V0OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8vIEdTQVAgTGlicmFyeVxuaW1wb3J0IGdzYXAgZnJvbSAnZ3NhcCc7XG5pbXBvcnQgU2Nyb2xsVHJpZ2dlciBmcm9tICdnc2FwL1Njcm9sbFRyaWdnZXInO1xuZ3NhcC5yZWdpc3RlclBsdWdpbihTY3JvbGxUcmlnZ2VyKTsgLy8gSW1wb3J0IFJlbmRlcmVyXG5cbmltcG9ydCBSZW5kZXJlciBmcm9tICcuL3JlbmRlcmVyLmpzJzsgLy9XZWJHbDpcblxuaW1wb3J0IEhvbWU0QXBwIGZyb20gJy4uL3dlYmdsL2hvbWU0L0hvbWU0QXBwJzsgLy8gVXRpbGl0aWVzXG5cbmltcG9ydCBEb21FdmVudHMgZnJvbSAnLi4vY2xhc3Nlcy9kb21FdmVudHMnO1xuaW1wb3J0IFN1cGVyU2Nyb2xsZXIgZnJvbSAnLi4vY2xhc3Nlcy9zdXBlclNjcm9sbGVyJztcbmltcG9ydCBTdXBlckRyYWdnYWJsZSBmcm9tICcuLi9jbGFzc2VzL3N1cGVyRHJhZ2dhYmxlJztcblxudmFyIFJlbmRlcmVyU2luZ2xlQ2FzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlbmRlcmVyKSB7XG4gIF9pbmhlcml0cyhSZW5kZXJlclNpbmdsZUNhc2UsIF9SZW5kZXJlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihSZW5kZXJlclNpbmdsZUNhc2UpO1xuXG4gIGZ1bmN0aW9uIFJlbmRlcmVyU2luZ2xlQ2FzZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVuZGVyZXJTaW5nbGVDYXNlKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZW5kZXJlclNpbmdsZUNhc2UsIFt7XG4gICAga2V5OiBcInNlbGVjdG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RvcnMoKSB7XG4gICAgICAvLyBTZWN0aW9uc1xuICAgICAgdGhpcy4kaGVybyA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5zaW5nbGVjYXNlX19oZXJvJyk7XG4gICAgICB0aGlzLiRmbGV4aWJsZSA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5zaW5nbGVjYXNlX19mbGV4aWJsZScpO1xuICAgICAgdGhpcy4kZm9vdGVyID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLnNpbmdsZWNhc2VfX2Zvb3RlcicpO1xuICAgICAgdGhpcy4kaHVic3BvdCA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5odWJzcG90Jyk7XG4gICAgICB0aGlzLiRjYW52YXNGb290ZXIgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcjd2ViZ2xfZm9vdGVyJyk7IC8vIEZsZXhpYmxlXG5cbiAgICAgIGlmICh0aGlzLiRmbGV4aWJsZSkge1xuICAgICAgICB0aGlzLiRmbGV4aWJsZVRleHQgPSB0aGlzLiRmbGV4aWJsZS5xdWVyeVNlbGVjdG9yQWxsKCcuZmxleGlibGVfX3RleHQnKTtcbiAgICAgICAgdGhpcy4kZmxleGlibGVJbWFnZSA9IHRoaXMuJGZsZXhpYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoJy5mbGV4aWJsZV9faW1hZ2UnKTtcbiAgICAgICAgdGhpcy4kZmxleGlibGVWaWRlbyA9IHRoaXMuJGZsZXhpYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoJy5mbGV4aWJsZV9fdmlkZW8nKTtcbiAgICAgICAgdGhpcy4kZmxleGlibGVHYWxsZXJ5ID0gdGhpcy4kZmxleGlibGUucXVlcnlTZWxlY3RvckFsbCgnLmZsZXhpYmxlX19nYWxsZXJ5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLiRmbGV4aWJsZVZpZGVvKSB7XG4gICAgICAgIC8vIHRoaXMuJHZpZGVvTW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmlkZW9tb2RhbCcpO1xuICAgICAgICAvLyB0aGlzLiR2aWRlb01vZGFsQ2xvc2VyID0gdGhpcy4kdmlkZW9Nb2RhbC5xdWVyeVNlbGVjdG9yKCcuY2xvc2VyJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kZmxleGlibGVWaWRlby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuJGZsZXhpYmxlVmlkZW9Nb2RhbCA9IHRoaXMuJGZsZXhpYmxlVmlkZW9baV0ucXVlcnlTZWxlY3RvcignLnZpZGVvLS1tb2RhbCcpO1xuICAgICAgICAgIHRoaXMuJHZpZGVvTW9kYWxDbG9zZXIgPSB0aGlzLiRmbGV4aWJsZVZpZGVvTW9kYWwucXVlcnlTZWxlY3RvcignLnZpZGVvX19jbG9zZXInKTtcbiAgICAgICAgICB0aGlzLiRmbGV4aWJsZVZpZGVvVmlzaWJsZSA9IHRoaXMuJGZsZXhpYmxlVmlkZW9baV0ucXVlcnlTZWxlY3RvcignLnZpZGVvLS12aXNpYmxlJyk7XG4gICAgICAgICAgdGhpcy4kdmlkZW9WaXNpYmxlUGxheWVyID0gdGhpcy4kZmxleGlibGVWaWRlb1Zpc2libGUucXVlcnlTZWxlY3RvcignLnZpZGVvX19wbGF5ZXInKTtcbiAgICAgICAgICB0aGlzLiR2aWRlb1Zpc2libGVUcmlnZ2VyID0gdGhpcy4kZmxleGlibGVWaWRlb1Zpc2libGUucXVlcnlTZWxlY3RvcignLnZpZGVvX190cmlnZ2VyJyk7XG4gICAgICAgICAgdGhpcy4kdmlkZW9WaXNpYmxlUG9zdGVyID0gdGhpcy4kZmxleGlibGVWaWRlb1Zpc2libGUucXVlcnlTZWxlY3RvcignLnZpZGVvX19wb3N0ZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuJGZsZXhpYmxlVmlkZW8pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRmbGV4aWJsZVZpZGVvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuJGZsZXhpYmxlVmlkZW9Nb2RhbC5kYXRhc2V0LnR5cGUgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgdGhpcy5kb21FdmVudHMuYWRkKHRoaXMuJGZsZXhpYmxlVmlkZW9baV0ucXVlcnlTZWxlY3RvcignLnZpZGVvX190cmlnZ2VyJyksICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMub3BlblZpZGVvRGVmYXVsdChfdGhpcy4kZmxleGlibGVWaWRlb01vZGFsLCBfdGhpcy4kZmxleGlibGVWaWRlb01vZGFsLmRhdGFzZXQudHlwZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB0aGlzLmRvbUV2ZW50cy5hZGQodGhpcy4kdmlkZW9Nb2RhbENsb3NlciwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2xvc2VWaWRlb0RlZmF1bHQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmVsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZWxvYWQoKSB7XG4gICAgICB2YXIgX21haW4gPSBbXTtcbiAgICAgIGlmICh0aGlzLiRoZXJvLnF1ZXJ5U2VsZWN0b3IoJy5iYWNrZ3JvdW5kX19iZycpKSBfbWFpbi5wdXNoKHRoaXMuJGhlcm8ucXVlcnlTZWxlY3RvcignLmJhY2tncm91bmRfX2JnJykuc3R5bGUuYmFja2dyb3VuZEltYWdlLnN1YnN0cmluZyg1LCB0aGlzLiRoZXJvLnF1ZXJ5U2VsZWN0b3IoJy5iYWNrZ3JvdW5kX19iZycpLnN0eWxlLmJhY2tncm91bmRJbWFnZS5sZW5ndGggLSAyKSk7XG4gICAgICB0aGlzLnByZWxvYWRJdGVtcyA9IHtcbiAgICAgICAgbWFpbjogX21haW4sXG4gICAgICAgIHNlY29uZGFyeTogW11cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJlZm9yZUVudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZm9yZUVudGVyKCkge1xuICAgICAgaWYgKHRoaXMuJGh1YnNwb3QpIHtcbiAgICAgICAgdGhpcy4kaHVic3BvdENvbnRlbnQgPSB0aGlzLiRodWJzcG90LnF1ZXJ5U2VsZWN0b3IoJy5odWJzcG90X19jb250ZW50Jyk7XG4gICAgICAgIHZhciBfaWQgPSB0aGlzLiRodWJzcG90Q29udGVudC5xdWVyeVNlbGVjdG9yKCcuaHVic3BvdGZvcm0nKS5kYXRhc2V0LmlkO1xuICAgICAgICBpZiAoX2lkID09PSAnJykgdGhpcy5hcHBVaS4kcmVxdWVzdEJ1dHRvbi5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy4kZmxleGlibGVWaWRlbykge1xuICAgICAgICB0aGlzLnZpZGVvID0ge1xuICAgICAgICAgIGlzQW5pbWF0aW5nOiBmYWxzZSxcbiAgICAgICAgICBpc1BsYXlpbmc6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRmbGV4aWJsZVZpZGVvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuJGZsZXhpYmxlVmlkZW9baV0ucXVlcnlTZWxlY3RvcignLnZpZGVvLS1tb2RhbCcpLmRhdGFzZXQudHlwZSA9PT0gJ3lvdXR1YmUnKSB0aGlzLnNldFZpZGVvWW91dHViZSgpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFdlYmdsXG5cblxuICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB7XG4gICAgICAgIHRoaXMud2ViZ2xfZm9vdGVyID0gbmV3IEhvbWU0QXBwKHtcbiAgICAgICAgICByZW5kZXJlcjogdGhpcyxcbiAgICAgICAgICBkb21FbGVtZW50OiB0aGlzLiRjYW52YXNGb290ZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVudGVyKCkge1xuICAgICAgLy8gU3RhcnQgZnVuY3Rpb25zXG4gICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5pbml0R2FsbGVyeURyYWdnYWJsZSgpO1xuXG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgdGhpcy5pbml0Rm9vdGVyQ2FudmFzUGluKCk7XG4gICAgICAgIHRoaXMud2ViZ2xfZm9vdGVyLmluaXQoKTsgLy8gdGhpcy53ZWJnbF9mb290ZXIgPSBuZXcgSG9tZTRBcHAoe1xuICAgICAgICAvLyAgICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgICAgIC8vICAgICBkb21FbGVtZW50OiB0aGlzLiRjYW52YXNGb290ZXJcbiAgICAgICAgLy8gfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFZpZGVvWW91dHViZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWaWRlb1lvdXR1YmUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKCF3aW5kb3cuWVQubG9hZGVkKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5zZXRWaWRlb1lvdXR1YmUoKTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJHZpZGVvWW91dHViZSA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy52aWRlb19fcGxheWVyLS15b3V0dWJlJyk7XG5cbiAgICAgIGlmICh0aGlzLiR2aWRlb1lvdXR1YmUpIHtcbiAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICAgIHZhciBfaWQgPSBfdGhpczIuJHZpZGVvWW91dHViZVtpXS5jaGlsZHJlblswXS5pZDtcbiAgICAgICAgICB2YXIgb2JqID0gbmV3IFlULlBsYXllcihfaWQsIHtcbiAgICAgICAgICAgIHBsYXllclZhcnM6IHtcbiAgICAgICAgICAgICAgcmVsOiAwLFxuICAgICAgICAgICAgICBzaG93aW5mbzogMCxcbiAgICAgICAgICAgICAgZWN2ZXI6IDJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aWRlb0lkOiBfaWQsXG4gICAgICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgICAgb25SZWFkeTogZnVuY3Rpb24gb25SZWFkeShldmVudCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IF9yYXRpbyA9IChvYmouaS5oZWlnaHQgLyBvYmouaS53aWR0aCkgKiAxMDA7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy4kdmlkZW9Zb3V0dWJlW2ldLnF1ZXJ5U2VsZWN0b3IoJy52aWRlb19fcGxheWVyJykuc3R5bGUuc2V0UHJvcGVydHkoJy0tcmF0aW8nLCBfcmF0aW8gKyAnJScpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpczIuc3VwZXJTY3JvbGxlcikgX3RoaXMyLnN1cGVyU2Nyb2xsZXIucmVzaXplKCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9uU3RhdGVDaGFuZ2U6IGZ1bmN0aW9uIG9uU3RhdGVDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YSA9PT0gMCkgX3RoaXMyLmNsb3NlVmlkZW9Zb3V0dWJlKF90aGlzMi4kdmlkZW9Zb3V0dWJlW2ldLCBvYmopO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3RoaXMyLiR2aWRlb1lvdXR1YmVbX2lkXSA9IG9iajtcblxuICAgICAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoX2kpIHtcbiAgICAgICAgICAgIF90aGlzMi5kb21FdmVudHMuYWRkKF90aGlzMi4kdmlkZW9WaXNpYmxlVHJpZ2dlciwgJ2NsaWNrJywgZnVuY3Rpb24gKGEsIGUsIGVsKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5vcGVuVmlkZW9Zb3V0dWJlKF90aGlzMi4kdmlkZW9Zb3V0dWJlW19pXSwgb2JqKTtcbiAgICAgICAgICAgIH0sIF90aGlzMik7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfdGhpczIuJGZsZXhpYmxlVmlkZW8ubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBfbG9vcDIoX2kpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzMi5kb21FdmVudHMuYWRkKF90aGlzMi4kdmlkZW9Nb2RhbENsb3NlciwgJ2NsaWNrJywgZnVuY3Rpb24gKGEsIGUsIGVsKSB7XG4gICAgICAgICAgICBfdGhpczIuY2xvc2VWaWRlb1lvdXR1YmUoX3RoaXMyLiR2aWRlb1lvdXR1YmVbaV0sIG9iaik7XG4gICAgICAgICAgfSwgX3RoaXMyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJHZpZGVvWW91dHViZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIF9sb29wKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5WaWRlb0RlZmF1bHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlblZpZGVvRGVmYXVsdChlbGVtZW50LCB0eXBlKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMudmlkZW8uaXNBbmltYXRpbmcpIHJldHVybjtcbiAgICAgIHRoaXMudmlkZW8uaXNBbmltYXRpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgLy8gU2VsZWN0b3JzXG4gICAgICAgIHRoaXMuJHZpZGVvVmlzaWJsZUVsID0gdGhpcy4kZmxleGlibGVWaWRlb1Zpc2libGUucXVlcnlTZWxlY3RvcigndmlkZW8nKTsgLy8gQW5pbWF0ZSBpblxuXG4gICAgICAgIGdzYXAudG8odGhpcy4kdmlkZW9WaXNpYmxlUGxheWVyLCB7XG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICB9KTtcbiAgICAgICAgZ3NhcC50byh0aGlzLiR2aWRlb1Zpc2libGVUcmlnZ2VyLCB7XG4gICAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnXG4gICAgICAgIH0pO1xuICAgICAgICBnc2FwLnRvKHRoaXMuJHZpZGVvVmlzaWJsZVBvc3Rlciwge1xuICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgICBkdXJhdGlvbjogMC40LFxuICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0JyxcbiAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgICAgZ3NhcC5zZXQoW190aGlzMy4kdmlkZW9WaXNpYmxlVHJpZ2dlciwgX3RoaXMzLiR2aWRlb1Zpc2libGVQb3N0ZXJdLCB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy8gUGxheSB2aWRlb1xuXG4gICAgICAgIHRoaXMuJHZpZGVvVmlzaWJsZUVsLnBsYXkoKTtcbiAgICAgICAgdGhpcy4kdmlkZW9WaXNpYmxlRWwubXV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kb21FdmVudHMuYWRkKHRoaXMuJHZpZGVvVmlzaWJsZUVsLCAnZW5kZWQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIF90aGlzMy5jbG9zZVZpZGVvRGVmYXVsdCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFuaW1hdGUgaW5cbiAgICAgICAgZ3NhcC5zZXQodGhpcy4kdmlkZW9Nb2RhbCwge1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgekluZGV4OiA5OTk5XG4gICAgICAgIH0pO1xuICAgICAgICBnc2FwLnRvKHRoaXMuJHZpZGVvTW9kYWwsIHtcbiAgICAgICAgICB5OiAnLTUwJScsXG4gICAgICAgICAgZHVyYXRpb246IDEuMixcbiAgICAgICAgICBlYXNlOiAnZXhwby5pbk91dCdcbiAgICAgICAgfSk7XG4gICAgICAgIGdzYXAudG8odGhpcy4kdmlkZW9Nb2RhbENsb3Nlciwge1xuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgZHVyYXRpb246IDAuNCxcbiAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCcsXG4gICAgICAgICAgZGVsYXk6IDAuOFxuICAgICAgICB9KTsgLy8gRGlzYWJsZSBzY3JvbGxcblxuICAgICAgICB0aGlzLmFwcFVpLmRpc2FibGVTY3JvbGwoKTsgLy8gUGxheSB2aWRlb1xuXG4gICAgICAgIHRoaXMuJHZpZGVvTW9kYWwucXVlcnlTZWxlY3RvcigndmlkZW8nKS5wbGF5KCk7XG4gICAgICAgIHRoaXMuJHZpZGVvTW9kYWwucXVlcnlTZWxlY3RvcigndmlkZW8nKS5tdXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbUV2ZW50cy5hZGQodGhpcy4kdmlkZW9Nb2RhbC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpLCAnZW5kZWQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIF90aGlzMy5jbG9zZVZpZGVvRGVmYXVsdChlbGVtZW50LCB0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlVmlkZW9EZWZhdWx0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVmlkZW9EZWZhdWx0KGVsZW1lbnQsIHR5cGUpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAvLyBQYXVzZSB2aWRlb1xuICAgICAgdGhpcy4kdmlkZW9WaXNpYmxlRWwucGF1c2UoKTtcbiAgICAgIHRoaXMuJHZpZGVvVmlzaWJsZUVsLm11dGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB7XG4gICAgICAgIC8vIEFuaW1hdGUgb3V0XG4gICAgICAgIGdzYXAuc2V0KFt0aGlzLiR2aWRlb1Zpc2libGVUcmlnZ2VyLCB0aGlzLiR2aWRlb1Zpc2libGVQb3N0ZXJdLCB7XG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICB9KTtcbiAgICAgICAgZ3NhcC50byh0aGlzLiR2aWRlb1Zpc2libGVUcmlnZ2VyLCB7XG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICBkdXJhdGlvbjogMC40LFxuICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0J1xuICAgICAgICB9KTtcbiAgICAgICAgZ3NhcC50byh0aGlzLiR2aWRlb1Zpc2libGVQb3N0ZXIsIHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnLFxuICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgICBnc2FwLnRvKF90aGlzNC4kdmlkZW9WaXNpYmxlUGxheWVyLCB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFuaW1hdGlvbiBvdXRcbiAgICAgICAgZ3NhcC50byh0aGlzLiR2aWRlb01vZGFsQ2xvc2VyLCB7XG4gICAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnXG4gICAgICAgIH0pO1xuICAgICAgICBnc2FwLnRvKHRoaXMuJHZpZGVvTW9kYWwsIHtcbiAgICAgICAgICB5OiAnLTE1MCUnLFxuICAgICAgICAgIGR1cmF0aW9uOiAxLjIsXG4gICAgICAgICAgZWFzZTogJ2V4cG8uaW5PdXQnLFxuICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgICAvLyBFbmFibGUgc2Nyb2xsXG4gICAgICAgICAgICBfdGhpczQuYXBwVWkuZW5hYmxlU2Nyb2xsKCk7IC8vIFNldCBhbmltYXRpb25cblxuXG4gICAgICAgICAgICBnc2FwLnNldChfdGhpczQuJHZpZGVvTW9kYWwsIHtcbiAgICAgICAgICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgICAgICAgICB5OiAnMTAwJScsXG4gICAgICAgICAgICAgIHpJbmRleDogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpczQudmlkZW8uaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcGVuVmlkZW9Zb3V0dWJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5WaWRlb1lvdXR1YmUoZWxlbWVudCwgb2JqKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMudmlkZW8uaXNBbmltYXRpbmcpIHJldHVybjtcbiAgICAgIHRoaXMudmlkZW8uaXNBbmltYXRpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIHtcbiAgICAgICAgLy8gQW5pbWF0ZSBpblxuICAgICAgICBnc2FwLnRvKHRoaXMuJHZpZGVvVmlzaWJsZVBsYXllciwge1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgfSk7XG4gICAgICAgIGdzYXAudG8odGhpcy4kdmlkZW9WaXNpYmxlVHJpZ2dlciwge1xuICAgICAgICAgIG9wYWNpdHk6IDAuMDAwMSxcbiAgICAgICAgICBkdXJhdGlvbjogMC40LFxuICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0J1xuICAgICAgICB9KTtcbiAgICAgICAgZ3NhcC50byh0aGlzLiR2aWRlb1Zpc2libGVQb3N0ZXIsIHtcbiAgICAgICAgICBvcGFjaXR5OiAwLjAwMDEsXG4gICAgICAgICAgZHVyYXRpb246IDAuNCxcbiAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCcsXG4gICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAgIGdzYXAuc2V0KFtfdGhpczUuJHZpZGVvVmlzaWJsZVRyaWdnZXIsIF90aGlzNS4kdmlkZW9WaXNpYmxlUG9zdGVyXSwge1xuICAgICAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIFBsYXkgWVQgdmlkZW9cblxuICAgICAgICBvYmoucGxheVZpZGVvKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBbmltYXRlIGluXG4gICAgICAgIGdzYXAuc2V0KHRoaXMuJGZsZXhpYmxlVmlkZW9Nb2RhbCwge1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgekluZGV4OiA5OTk5XG4gICAgICAgIH0pO1xuICAgICAgICBnc2FwLnRvKHRoaXMuJGZsZXhpYmxlVmlkZW9Nb2RhbCwge1xuICAgICAgICAgIHk6ICctNTAlJyxcbiAgICAgICAgICBkdXJhdGlvbjogMS4yLFxuICAgICAgICAgIGVhc2U6ICdleHBvLmluT3V0J1xuICAgICAgICB9KTtcbiAgICAgICAgZ3NhcC50byh0aGlzLiR2aWRlb01vZGFsQ2xvc2VyLCB7XG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICBkdXJhdGlvbjogMC40LFxuICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0JyxcbiAgICAgICAgICBkZWxheTogMC44XG4gICAgICAgIH0pOyAvLyBFbmFibGUgc2Nyb2xsXG5cbiAgICAgICAgdGhpcy5hcHBVaS5kaXNhYmxlU2Nyb2xsKCk7IC8vIFBsYXkgWVQgdmlkZW8gXG5cbiAgICAgICAgZ3NhcC5kZWxheWVkQ2FsbCgwLjgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvYmoucGxheVZpZGVvKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVZpZGVvWW91dHViZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZVZpZGVvWW91dHViZShlbGVtZW50LCBvYmopIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAvLyBQbGF5IFlUIHZpZGVvIFxuICAgICAgb2JqLnBhdXNlVmlkZW8oKTtcblxuICAgICAgaWYgKHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wKSB7XG4gICAgICAgIC8vIEFuaW1hdGUgb3V0XG4gICAgICAgIGdzYXAuc2V0KFt0aGlzLiR2aWRlb1Zpc2libGVUcmlnZ2VyLCB0aGlzLiR2aWRlb1Zpc2libGVQb3N0ZXJdLCB7XG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICB9KTtcbiAgICAgICAgZ3NhcC50byh0aGlzLiR2aWRlb1Zpc2libGVUcmlnZ2VyLCB7XG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICBkdXJhdGlvbjogMC40LFxuICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0J1xuICAgICAgICB9KTtcbiAgICAgICAgZ3NhcC50byh0aGlzLiR2aWRlb1Zpc2libGVQb3N0ZXIsIHtcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnLFxuICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgICBnc2FwLnRvKF90aGlzNi4kdmlkZW9WaXNpYmxlUGxheWVyLCB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFuaW1hdGlvbiBvdXRcbiAgICAgICAgZ3NhcC50byh0aGlzLiR2aWRlb01vZGFsQ2xvc2VyLCB7XG4gICAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnXG4gICAgICAgIH0pO1xuICAgICAgICBnc2FwLnRvKHRoaXMuJGZsZXhpYmxlVmlkZW9Nb2RhbCwge1xuICAgICAgICAgIHk6ICctMTUwJScsXG4gICAgICAgICAgZHVyYXRpb246IDEuMixcbiAgICAgICAgICBlYXNlOiAnZXhwby5pbk91dCcsXG4gICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAgIC8vIEVuYWJsZSBzY3JvbGxcbiAgICAgICAgICAgIF90aGlzNi5hcHBVaS5lbmFibGVTY3JvbGwoKTsgLy8gU2V0IGFuaW1hdGlvblxuXG5cbiAgICAgICAgICAgIGdzYXAuc2V0KF90aGlzNi4kZmxleGlibGVWaWRlb01vZGFsLCB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgICAgICAgICAgeTogJzEwMCUnLFxuICAgICAgICAgICAgICB6SW5kZXg6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXM2LnZpZGVvLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdEdhbGxlcnlEcmFnZ2FibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdEdhbGxlcnlEcmFnZ2FibGUoKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuJGZsZXhpYmxlR2FsbGVyeSkge1xuICAgICAgICB2YXIgX2xvb3AzID0gZnVuY3Rpb24gX2xvb3AzKGkpIHtcbiAgICAgICAgICBfdGhpczcuJGdhbGxlcnlTbGlkZXIgPSBfdGhpczcuJGZsZXhpYmxlR2FsbGVyeVtpXS5xdWVyeVNlbGVjdG9yQWxsKCcuc2xpZGVyJyk7XG4gICAgICAgICAgX3RoaXM3LiRnYWxsZXJ5U2xpZGVySW5uZXIgPSBfdGhpczcuJGZsZXhpYmxlR2FsbGVyeVtpXS5xdWVyeVNlbGVjdG9yQWxsKCcuc2xpZGVyX19pbm5lcicpO1xuICAgICAgICAgIF90aGlzNy4kZ2FsbGVyeVNsaWRlckl0ZW1zID0gX3RoaXM3LiRmbGV4aWJsZUdhbGxlcnlbaV0ucXVlcnlTZWxlY3RvckFsbCgnLnNsaWRlcl9faXRlbScpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfdGhpczcuJGdhbGxlcnlTbGlkZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChfdGhpczcuYXBwU3RvcmUuaXNEZXNrdG9wKSB7XG4gICAgICAgICAgICAgIF90aGlzNy4kZ2FsbGVyeVNsaWRlckl0ZW1zID0gX3RoaXM3LiRnYWxsZXJ5U2xpZGVyW2pdLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zbGlkZXJfX2l0ZW0nKTtcblxuICAgICAgICAgICAgICBpZiAoX3RoaXM3LiRnYWxsZXJ5U2xpZGVySXRlbXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIF90aGlzNy5fZ2FsbGVyeURyYWdnYWJsZSA9IG5ldyBTdXBlckRyYWdnYWJsZSh7XG4gICAgICAgICAgICAgICAgICBlbDogX3RoaXM3LiRmbGV4aWJsZUdhbGxlcnlbaV0sXG4gICAgICAgICAgICAgICAgICBzbmFwOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIHNuYXBUbzogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICBkb3RzOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpczcuX2dhbGxlcnlEcmFnZ2FibGUgPSBuZXcgU3VwZXJEcmFnZ2FibGUoe1xuICAgICAgICAgICAgICAgIGVsOiBfdGhpczcuJGZsZXhpYmxlR2FsbGVyeVtpXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IF90aGlzNy4kZ2FsbGVyeVNsaWRlcklubmVyLFxuICAgICAgICAgICAgICAgIHNuYXA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNuYXBUbzogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgZG90czogZmFsc2UsXG4gICAgICAgICAgICAgICAgb25SYWY6IGZ1bmN0aW9uIG9uUmFmKHBlcmNlbnQsIHByb2dyZXNzLCBwcm9ncmVzc09yaWdpbikge1xuICAgICAgICAgICAgICAgICAgZ3NhcC50byhfdGhpczcuJGZsZXhpYmxlR2FsbGVyeVtpXS5xdWVyeVNlbGVjdG9yKCcuc2xpZGVyX19wcm9ncmVzcycpLmNoaWxkcmVuWzBdLCB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlWDogcHJvZ3Jlc3NPcmlnaW4gKyBwcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRmbGV4aWJsZUdhbGxlcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBfbG9vcDMoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdEZvb3RlckNhbnZhc1BpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0Rm9vdGVyQ2FudmFzUGluKCkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2Zvb3RlckNhbnZhc1BpbiA9IFNjcm9sbFRyaWdnZXIuY3JlYXRlKHtcbiAgICAgICAgdHJpZ2dlcjogdGhpcy4kZm9vdGVyLFxuICAgICAgICBzdGFydDogJ3RvcCBib3R0b20nLFxuICAgICAgICBlbmQ6ICdib3R0b20gYm90dG9tJyxcbiAgICAgICAgc2NydWI6IHRydWUsXG4gICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShzZWxmKSB7XG4gICAgICAgICAgdmFyIHBvc1kgPSAtX3RoaXM4LiRjYW52YXNGb290ZXIub2Zmc2V0SGVpZ2h0ICsgX3RoaXM4LiRjYW52YXNGb290ZXIub2Zmc2V0SGVpZ2h0ICogMiAqIHNlbGYucHJvZ3Jlc3M7XG4gICAgICAgICAgZ3NhcC5zZXQoX3RoaXM4LiRjYW52YXNGb290ZXIsIHtcbiAgICAgICAgICAgIHk6IHBvc1kgKyAncHgnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyYWZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmFmKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAodGhpcy5fZ2FsbGVyeURyYWdnYWJsZSkgdGhpcy5fZ2FsbGVyeURyYWdnYWJsZS5yZXNpemUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGVhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVhdmUoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwicmVuZGVyQUkubGVhdmUhLS0tLS0tLS0tLS0tLS0tLS0tLS1cIilcbiAgICAgIGlmICh0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkge1xuICAgICAgICB0aGlzLndlYmdsX2Zvb3Rlci5raWxsKCk7XG4gICAgICAgIHRoaXMud2ViZ2xfZm9vdGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVuZGVyZXJTaW5nbGVDYXNlO1xufShSZW5kZXJlcik7IC8vIERvbid0IGZvcmdldCB0byBleHBvcnQgeW91ciByZW5kZXJlclxuXG5cbmV4cG9ydCBkZWZhdWx0IFJlbmRlcmVyU2luZ2xlQ2FzZTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vLyBHU0FQIExpYnJhcnlcbmltcG9ydCBnc2FwIGZyb20gJ2dzYXAnO1xuaW1wb3J0IFNjcm9sbFRyaWdnZXIgZnJvbSAnZ3NhcC9TY3JvbGxUcmlnZ2VyJztcbmdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVHJpZ2dlcik7IC8vIEltcG9ydCBSZW5kZXJlclxuXG5pbXBvcnQgUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlci5qcyc7IC8vIFV0aWxpdGllc1xuXG5pbXBvcnQgRG9tRXZlbnRzIGZyb20gJy4uL2NsYXNzZXMvZG9tRXZlbnRzJztcbmltcG9ydCBTdXBlclNjcm9sbGVyIGZyb20gJy4uL2NsYXNzZXMvc3VwZXJTY3JvbGxlcic7XG5cbnZhciByZW5kZXJlclRoYW5rcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlbmRlcmVyKSB7XG4gIF9pbmhlcml0cyhyZW5kZXJlclRoYW5rcywgX1JlbmRlcmVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKHJlbmRlcmVyVGhhbmtzKTtcblxuICBmdW5jdGlvbiByZW5kZXJlclRoYW5rcygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgcmVuZGVyZXJUaGFua3MpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKHJlbmRlcmVyVGhhbmtzLCBbe1xuICAgIGtleTogXCJzZWxlY3RvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0b3JzKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2ZW50cygpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICB9LCB7XG4gICAga2V5OiBcInByZWxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlbG9hZCgpIHtcbiAgICAgIC8vIHRoaXMucHJlbG9hZERlbGF5ID0gMTtcbiAgICAgIHRoaXMucHJlbG9hZEl0ZW1zID0ge1xuICAgICAgICBtYWluOiBbXSxcbiAgICAgICAgc2Vjb25kYXJ5OiBbXVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmVmb3JlRW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlRW50ZXIoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgfSwge1xuICAgIGtleTogXCJlbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbnRlcigpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICB9LCB7XG4gICAga2V5OiBcInJhZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYWYoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKHdpZHRoLCBoZWlnaHQpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICB9XSk7XG5cbiAgcmV0dXJuIHJlbmRlcmVyVGhhbmtzO1xufShSZW5kZXJlcik7IC8vIERvbid0IGZvcmdldCB0byBleHBvcnQgeW91ciByZW5kZXJlclxuXG5cbmV4cG9ydCBkZWZhdWx0IHJlbmRlcmVyVGhhbmtzOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8vIEFwcFxuaW1wb3J0IGFwcENvcmUgZnJvbSAnLi4vYXBwL2FwcENvcmUnO1xuaW1wb3J0IGFwcFN0b3JlIGZyb20gJy4uL2FwcC9hcHBTdG9yZSc7XG5pbXBvcnQgYXBwVWkgZnJvbSAnLi4vYXBwL2FwcFVpJzsgLy8gSGlnaHdheVxuXG5pbXBvcnQgSGlnaHdheSBmcm9tICdAZG9nc3R1ZGlvL2hpZ2h3YXknOyAvLyBQcmVsb2FkXG5cbmltcG9ydCBQcmVsb2FkIGZyb20gJ3ByZWxvYWQtaXQnOyAvLyBHU0FQIExpYnJhcnkgTGlicmFyeVxuXG5pbXBvcnQgZ3NhcCBmcm9tICdnc2FwJzsgLy8gVHJhbnNpdGlvblxuXG52YXIgVHJhbnNpdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0hpZ2h3YXkkVHJhbnNpdGlvbikge1xuICBfaW5oZXJpdHMoVHJhbnNpdGlvbiwgX0hpZ2h3YXkkVHJhbnNpdGlvbik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihUcmFuc2l0aW9uKTtcblxuICBmdW5jdGlvbiBUcmFuc2l0aW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2l0aW9uKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUcmFuc2l0aW9uLCBbe1xuICAgIGtleTogXCJvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3V0KF9yZWYpIHtcbiAgICAgIHZhciBmcm9tID0gX3JlZi5mcm9tLFxuICAgICAgICAgIGRvbmUgPSBfcmVmLmRvbmU7XG4gICAgICAvLyBTdG9yZVxuICAgICAgdGhpcy5hcHBTdG9yZSA9IGFwcFN0b3JlOyAvLyBBcHAgcmVmZXJlbmNlc1xuXG4gICAgICB0aGlzLmFwcENvcmUgPSBuZXcgYXBwQ29yZSgpO1xuICAgICAgdGhpcy5hcHBVaSA9IG5ldyBhcHBVaSgpO1xuICAgICAgaWYgKHRoaXMucHJlbG9hZE1haW4pIHRoaXMucHJlbG9hZE1haW4uY2FuY2VsKCk7XG4gICAgICBpZiAodGhpcy5wcmVsb2FkU2Vjb25kYXJ5KSB0aGlzLnByZWxvYWRTZWNvbmRhcnkuY2FuY2VsKCk7IC8vIE91dCBhbmltYXRpb25cblxuICAgICAgdGhpcy5vdXRBbmltYXRpb24oZnJvbSwgZG9uZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm91dEFuaW1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRBbmltYXRpb24oZnJvbSwgZG9uZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luKF9yZWYyKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgZnJvbSA9IF9yZWYyLmZyb20sXG4gICAgICAgICAgdG8gPSBfcmVmMi50byxcbiAgICAgICAgICBkb25lID0gX3JlZjIuZG9uZTtcbiAgICAgIC8vIFN0b3JlXG4gICAgICB0aGlzLmFwcFN0b3JlID0gYXBwU3RvcmU7IC8vIEFwcCByZWZlcmVuY2VzXG5cbiAgICAgIHRoaXMuYXBwQ29yZSA9IG5ldyBhcHBDb3JlKCk7XG4gICAgICB0aGlzLmFwcFVpID0gbmV3IGFwcFVpKCk7IC8vIFByZWxvYWRlclxuXG4gICAgICB0aGlzLnByZWxvYWRNYWluID0gbnVsbDtcbiAgICAgIHRoaXMucHJlbG9hZFNlY29uZGFyeSA9IG51bGw7XG4gICAgICB0aGlzLnByZWxvYWREZWxheSA9IDA7IC8vIExhenkgbG9hZFxuXG4gICAgICB0aGlzLmxhenlMb2FkID0gbnVsbDsgLy8gUmVtb3ZlIE9sZCBWaWV3XG5cbiAgICAgIGZyb20ucmVtb3ZlKCk7IC8vIFJlc2V0IFNjcm9sbFxuXG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7IC8vIFNldCBhbmltYXRpb25cblxuICAgICAgdGhpcy5zZXRBbmltYXRpb24oZnJvbSwgdG8pO1xuICAgICAgdGhpcy5wcmVsb2FkSXRlbXMgPSB0aGlzLmFwcENvcmUuaGlnaHdheS5Uby5wcmVsb2FkSXRlbXM7XG5cbiAgICAgIGlmICh0aGlzLnByZWxvYWRJdGVtcy5tYWluLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIF9wcmVsb2FkT24gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICB0aGlzLnByZWxvYWRNYWluID0gUHJlbG9hZCgpO1xuICAgICAgICB0aGlzLnByZWxvYWRNYWluLmZldGNoKHRoaXMucHJlbG9hZEl0ZW1zLm1haW4pOyAvLyB0aGlzLnByZWxvYWRNYWluLm9ucHJvZ3Jlc3MgPSAoZXZlbnQpID0+IHsgY29uc29sZS5sb2coJ1ByaW1hcnk6ICcgKyBldmVudC5wcm9ncmVzcyArICclJyk7IH07XG5cbiAgICAgICAgdGhpcy5wcmVsb2FkTWFpbi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICAgICAgdmFyIF9wcmVsb2FkT2ZmID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgICB2YXIgX3ByZWxvYWREaWZmZXJlbmNlID0gKF9wcmVsb2FkT2ZmIC0gX3ByZWxvYWRPbikgLyAxMDAwO1xuXG4gICAgICAgICAgdmFyIF9wcmVsb2FkRGVsYXkgPSBNYXRoLm1heCgwLCBfdGhpcy5wcmVsb2FkRGVsYXkgLSBfcHJlbG9hZERpZmZlcmVuY2UpO1xuXG4gICAgICAgICAgZ3NhcC5kZWxheWVkQ2FsbChfcHJlbG9hZERlbGF5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJbiBhbmltYXRpb25cbiAgICAgICAgICAgIGRvbmUoKTtcblxuICAgICAgICAgICAgX3RoaXMuaW5BbmltYXRpb24oZnJvbSwgdG8sIGRvbmUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLnByZWxvYWRJdGVtcy5zZWNvbmRhcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMucHJlbG9hZFNlY29uZGFyeSA9IFByZWxvYWQoKTtcbiAgICAgICAgICB0aGlzLnByZWxvYWRTZWNvbmRhcnkuZmV0Y2godGhpcy5wcmVsb2FkSXRlbXMuc2Vjb25kYXJ5KTtcblxuICAgICAgICAgIHRoaXMucHJlbG9hZFNlY29uZGFyeS5vbnByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU2Vjb25kYXJ5OiAnICsgZXZlbnQucHJvZ3Jlc3MgKyAnJScpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdzYXAuZGVsYXllZENhbGwodGhpcy5wcmVsb2FkRGVsYXksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBJbiBhbmltYXRpb25cbiAgICAgICAgICBkb25lKCk7XG5cbiAgICAgICAgICBfdGhpcy5pbkFuaW1hdGlvbihmcm9tLCB0bywgZG9uZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRBbmltYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QW5pbWF0aW9uKGZyb20sIHRvKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgfSwge1xuICAgIGtleTogXCJpbkFuaW1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbkFuaW1hdGlvbihmcm9tLCB0bywgZG9uZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIH1dKTtcblxuICByZXR1cm4gVHJhbnNpdGlvbjtcbn0oSGlnaHdheS5UcmFuc2l0aW9uKTtcblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNpdGlvbjsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vLyBJbXBvcnQgVHJhbnNpdGlvblxuaW1wb3J0IFRyYW5zaXRpb24gZnJvbSAnLi90cmFuc2l0aW9uLmpzJzsgLy8gR1NBUCBMaWJyYXJ5IExpYnJhcnlcblxuaW1wb3J0IGdzYXAgZnJvbSAnZ3NhcCc7IC8vIEZhZGVcblxudmFyIFRyYW5zaXRpb25GYWRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVHJhbnNpdGlvbikge1xuICBfaW5oZXJpdHMoVHJhbnNpdGlvbkZhZGUsIF9UcmFuc2l0aW9uKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFRyYW5zaXRpb25GYWRlKTtcblxuICBmdW5jdGlvbiBUcmFuc2l0aW9uRmFkZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNpdGlvbkZhZGUpO1xuXG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRyYW5zaXRpb25GYWRlLCBbe1xuICAgIGtleTogXCJvdXRBbmltYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3V0QW5pbWF0aW9uKGZyb20sIGRvbmUpIHtcbiAgICAgIHRoaXMub3V0RHVyYXRpb24gPSAxLjI7XG4gICAgICBnc2FwLmZyb21Ubyhmcm9tLCB7XG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICAgIH0sIHtcbiAgICAgICAgb3BhY2l0eTogMC4wMDAxLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5vdXREdXJhdGlvbixcbiAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbkFuaW1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbkFuaW1hdGlvbihmcm9tLCB0bywgZG9uZSkge1xuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgICB0aGlzLmluRHVyYXRpb24gPSAwLjY7XG4gICAgICBnc2FwLnRvKHRvLCB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmluRHVyYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmFuc2l0aW9uRmFkZTtcbn0oVHJhbnNpdGlvbik7XG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zaXRpb25GYWRlOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8vIEltcG9ydCBUcmFuc2l0aW9uXG5pbXBvcnQgVHJhbnNpdGlvbiBmcm9tICcuL3RyYW5zaXRpb24uanMnOyAvLyBHU0FQIExpYnJhcnkgTGlicmFyeVxuXG5pbXBvcnQgZ3NhcCBmcm9tICdnc2FwJzsgLy8gTWFza1xuXG52YXIgVHJhbnNpdGlvbk1hc2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UcmFuc2l0aW9uKSB7XG4gIF9pbmhlcml0cyhUcmFuc2l0aW9uTWFzaywgX1RyYW5zaXRpb24pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVHJhbnNpdGlvbk1hc2spO1xuXG4gIGZ1bmN0aW9uIFRyYW5zaXRpb25NYXNrKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2l0aW9uTWFzayk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVHJhbnNpdGlvbk1hc2ssIFt7XG4gICAga2V5OiBcIm91dEFuaW1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRBbmltYXRpb24oZnJvbSwgZG9uZSkge1xuICAgICAgdGhpcy5vdXREdXJhdGlvbiA9IDE7XG4gICAgICBnc2FwLnNldCh0aGlzLmFwcFVpLiRtYXNrLCB7XG4gICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgIH0pO1xuICAgICAgZ3NhcC5mcm9tVG8odGhpcy5hcHBVaS4kbWFzay5jaGlsZHJlblswXSwge1xuICAgICAgICB5OiAnMTAwJSdcbiAgICAgIH0sIHtcbiAgICAgICAgeTogJzAlJyxcbiAgICAgICAgZHVyYXRpb246IHRoaXMub3V0RHVyYXRpb24sXG4gICAgICAgIGVhc2U6ICdwb3dlcjQuaW4nLFxuICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCctLSBvdXQgRG9uZScpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluQW5pbWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluQW5pbWF0aW9uKGZyb20sIHRvLCBkb25lKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmluRHVyYXRpb24gPSAxO1xuICAgICAgZ3NhcC50byh0aGlzLmFwcFVpLiRtYXNrLmNoaWxkcmVuWzBdLCB7XG4gICAgICAgIHk6ICctMTAwJScsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmluRHVyYXRpb24sXG4gICAgICAgIGVhc2U6ICdwb3dlcjQub3V0JyxcbiAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnLS0gaW4gRG9uZScpO1xuICAgICAgICAgIGdzYXAuc2V0KF90aGlzLmFwcFVpLiRtYXNrLCB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyYW5zaXRpb25NYXNrO1xufShUcmFuc2l0aW9uKTtcblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNpdGlvbk1hc2s7IiwiZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vLyBBcHBcbmltcG9ydCBhcHBTdG9yZSBmcm9tICcuL2FwcFN0b3JlJztcbmltcG9ydCBhcHBVaSBmcm9tICcuL2FwcFVpJzsgLy8gQ2xhc3Nlc1xuXG5pbXBvcnQgZG9tRXZlbnRzIGZyb20gJy4uL2NsYXNzZXMvZG9tRXZlbnRzJzsgLy8gSGlnaHdheVxuXG5pbXBvcnQgSGlnaHdheSBmcm9tICdAZG9nc3R1ZGlvL2hpZ2h3YXknOyAvLyBJbXBvcnQgUmVuZGVyZXJzXG5cbmltcG9ydCBSZW5kZXJlciBmcm9tICcuLi9yZW5kZXJlcnMvcmVuZGVyZXInO1xuaW1wb3J0IFJlbmRlcmVyRGVmYXVsdCBmcm9tICcuLi9yZW5kZXJlcnMvcmVuZGVyZXJEZWZhdWx0JztcbmltcG9ydCBSZW5kZXJlckhvbWUgZnJvbSAnLi4vcmVuZGVyZXJzL3JlbmRlcmVySG9tZSc7XG5pbXBvcnQgUmVuZGVyZXJBSSBmcm9tICcuLi9yZW5kZXJlcnMvcmVuZGVyZXJBSSc7XG5pbXBvcnQgUmVuZGVyZXJEYXRhIGZyb20gJy4uL3JlbmRlcmVycy9yZW5kZXJlckRhdGEnO1xuaW1wb3J0IFJlbmRlcmVyQWJvdXQgZnJvbSAnLi4vcmVuZGVyZXJzL3JlbmRlcmVyQWJvdXQnO1xuaW1wb3J0IFJlbmRlcmVyU2luZ2xlQ2FzZSBmcm9tICcuLi9yZW5kZXJlcnMvcmVuZGVyZXJTaW5nbGVDYXNlJztcbmltcG9ydCBSZW5kZXJlclRoYW5rcyBmcm9tICcuLi9yZW5kZXJlcnMvcmVuZGVyZXJUaGFua3MnOyAvLyBJbXBvcnQgVHJhbnNpdGlvbnNcblxuaW1wb3J0IFRyYW5zaXRpb25GYWRlIGZyb20gJy4uL3RyYW5zaXRpb25zL3RyYW5zaXRpb25GYWRlJztcbmltcG9ydCBUcmFuc2l0aW9uTWFzayBmcm9tICcuLi90cmFuc2l0aW9ucy90cmFuc2l0aW9uTWFzayc7IC8vIEdTQVAgTGlicmFyeVxuXG5pbXBvcnQgZ3NhcCBmcm9tICdnc2FwJztcbnZhciBfc2luZ2xldG9uID0gbnVsbDtcblxudmFyIGFwcENvcmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBhcHBDb3JlKGRhdGEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgYXBwQ29yZSk7XG5cbiAgICBpZiAoIV9zaW5nbGV0b24pIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICBfc2luZ2xldG9uID0gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9zaW5nbGV0b247XG4gICAgfSAvLyBTdG9yZVxuXG5cbiAgICB0aGlzLmFwcFN0b3JlID0gYXBwU3RvcmU7IC8vIEFwcCByZWZlcmVuY2VzXG5cbiAgICB0aGlzLmFwcFVpID0gbmV3IGFwcFVpKCk7IC8vIEV2ZW50c1xuXG4gICAgdGhpcy5kb21FdmVudHMgPSBuZXcgZG9tRXZlbnRzKCk7IC8vIEhpZ2h3YXkgY29yZVxuXG4gICAgdGhpcy5oaWdod2F5ID0gbnVsbDsgLy8gR2xvYmFsIHZhcnNcblxuICAgIHRoaXMuYXBwU3RvcmUuaXNEZXNrdG9wID0gd2luZG93LmlubmVyV2lkdGggPiAxMTAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKGFwcENvcmUsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIENhbGwgSGlnaHdheS5Db3JlIG9uY2UuXG4gICAgICB0aGlzLmhpZ2h3YXkgPSBuZXcgSGlnaHdheS5Db3JlKHtcbiAgICAgICAgcmVuZGVyZXJzOiB7XG4gICAgICAgICAgXCJkZWZhdWx0XCI6IFJlbmRlcmVyRGVmYXVsdCxcbiAgICAgICAgICBob21lOiBSZW5kZXJlckhvbWUsXG4gICAgICAgICAgYWk6IFJlbmRlcmVyQUksXG4gICAgICAgICAgZGF0YTogUmVuZGVyZXJEYXRhLFxuICAgICAgICAgIGFib3V0OiBSZW5kZXJlckFib3V0LFxuICAgICAgICAgIHNpbmdsZWNhc2U6IFJlbmRlcmVyU2luZ2xlQ2FzZSxcbiAgICAgICAgICB0aGFua3M6IFJlbmRlcmVyVGhhbmtzXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zaXRpb25zOiB7XG4gICAgICAgICAgXCJkZWZhdWx0XCI6IFRyYW5zaXRpb25GYWRlLFxuICAgICAgICAgIGNvbnRleHR1YWw6IHtcbiAgICAgICAgICAgIG1hc2s6IFRyYW5zaXRpb25NYXNrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTsgLy8gT24gbG9hZDpcbiAgICAgIC8vIFF1ZXJ5IGFkbWluIGJhciBsaW5rcyBhbmQgZGV0YWNoIHRoZW0gZnJvbSBIaWdod2F5IHRyYW5zaXRpb25zXG5cbiAgICAgIHZhciBhZG1pbkJhckxpbmtzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3dwYWRtaW5iYXIgYScpO1xuICAgICAgaWYgKGFkbWluQmFyTGlua3MpIHRoaXMuaGlnaHdheS5kZXRhY2goYWRtaW5CYXJMaW5rcyk7IC8vIFVuc2V0IGNvb2tpZXMgYmFyIGxpbmtzIHRvIHByZXZlbnQgcmVsb2FkIHRoZSBwYWdlXG5cbiAgICAgIHZhciBjb29raWVzTGlua3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjY29va2llLWxhdy1pbmZvLWJhciBhJyk7XG4gICAgICBpZiAoY29va2llc0xpbmtzKSB0aGlzLmhpZ2h3YXkuZGV0YWNoKGNvb2tpZXNMaW5rcyk7XG4gICAgICB0aGlzLmhpZ2h3YXkub24oJ05BVklHQVRFX0lOJywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHRvID0gX3JlZi50byxcbiAgICAgICAgICAgIHRyaWdnZXIgPSBfcmVmLnRyaWdnZXIsXG4gICAgICAgICAgICBsb2NhdGlvbiA9IF9yZWYubG9jYXRpb247XG5cbiAgICAgICAgX3RoaXMubmF2aWdhdGVJbih0bywgdHJpZ2dlciwgbG9jYXRpb24pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhpZ2h3YXkub24oJ05BVklHQVRFX09VVCcsIGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgZnJvbSA9IF9yZWYyLmZyb20sXG4gICAgICAgICAgICB0cmlnZ2VyID0gX3JlZjIudHJpZ2dlcixcbiAgICAgICAgICAgIGxvY2F0aW9uID0gX3JlZjIubG9jYXRpb247XG5cbiAgICAgICAgX3RoaXMubmF2aWdhdGVPdXQoZnJvbSwgdHJpZ2dlciwgbG9jYXRpb24pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhpZ2h3YXkub24oJ05BVklHQVRFX0VORCcsIGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgdG8gPSBfcmVmMy50byxcbiAgICAgICAgICAgIGZyb20gPSBfcmVmMy5mcm9tLFxuICAgICAgICAgICAgdHJpZ2dlciA9IF9yZWYzLnRyaWdnZXIsXG4gICAgICAgICAgICBsb2NhdGlvbiA9IF9yZWYzLmxvY2F0aW9uO1xuXG4gICAgICAgIF90aGlzLm5hdmlnYXRlRW5kKHRvLCBmcm9tLCB0cmlnZ2VyLCBsb2NhdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmF2aWdhdGVTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuYXZpZ2F0ZVN0YXJ0KCkge1xuICAgICAgLy8gU3RhcnQgbmF2aWdhdGlvbiBvbiAwXG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgICAgIGlmICh3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbikgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmF2aWdhdGVPdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmF2aWdhdGVPdXQoZnJvbSwgdHJpZ2dlciwgbG9jYXRpb24pIHtcbiAgICAgIHRoaXMuYXBwU3RvcmUuZnJvbSA9IGZyb20udmlldy5kYXRhc2V0LnJvdXRlclZpZXc7XG4gICAgICB0aGlzLmFwcFVpLmNsb3NlTWVudSgpOyAvLyBIaWRlIGhlYWRlclxuXG4gICAgICB0aGlzLmFwcFVpLmhpZGVIZWFkZXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmF2aWdhdGVJblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuYXZpZ2F0ZUluKHRvLCB0cmlnZ2VyLCBsb2NhdGlvbikge1xuICAgICAgdGhpcy5hcHBTdG9yZS50byA9IHRvLnZpZXcuZGF0YXNldC5yb3V0ZXJWaWV3O1xuICAgICAgaWYgKCF0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA9IDA7IC8vIEFkZCBiYWNrZ3JvdW5kIGNvbG9yXG5cbiAgICAgIGlmICh0aGlzLmFwcFN0b3JlLnRvID09PSAnaG9tZScgfHwgdGhpcy5hcHBTdG9yZS50byA9PT0gJ3NpbmdsZWNhc2UnIHx8IHRoaXMuYXBwU3RvcmUudG8gPT09ICdkZWZhdWx0JykgdGhpcy5hcHBVaS5nb0xpZ2h0KCk7ZWxzZSB0aGlzLmFwcFVpLmdvRGFyaygpOyAvLyBSZW1vdmUgYWN0aXZlIGl0ZW1cblxuICAgICAgaWYgKHRoaXMuYXBwVWkuJG1lbnUucXVlcnlTZWxlY3RvcignLmlzLWFjdGl2ZScpKSB0aGlzLmFwcFVpLiRtZW51LnF1ZXJ5U2VsZWN0b3IoJy5pcy1hY3RpdmUnKS5jbGFzc0xpc3QucmVtb3ZlKCdpcy1hY3RpdmUnKTsgLy8gQWRkIGFjdGl2ZSBpdGVtXG5cbiAgICAgIGlmICh0aGlzLmFwcFVpLiRtZW51LnF1ZXJ5U2VsZWN0b3IoJy5tZW51LWl0ZW0tLScgKyB0aGlzLmFwcFN0b3JlLnRvKSkgdGhpcy5hcHBVaS4kbWVudS5xdWVyeVNlbGVjdG9yKCcubWVudS1pdGVtLS0nICsgdGhpcy5hcHBTdG9yZS50bykuY2xhc3NMaXN0LmFkZCgnaXMtYWN0aXZlJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5hdmlnYXRlRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5hdmlnYXRlRW5kKHRvLCBmcm9tLCB0cmlnZ2VyLCBsb2NhdGlvbikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuYXBwU3RvcmUudG8gPSB0by52aWV3LmRhdGFzZXQucm91dGVyVmlldztcbiAgICAgIGlmICghdGhpcy5hcHBTdG9yZS5pc0Rlc2t0b3ApIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgPSAwOyAvLyBTZXQgY2xhc3Nlc1xuXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5Jykuc2V0QXR0cmlidXRlKCdjbGFzcycsIHRvLnBhZ2UuYm9keS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpO1xuICAgICAgaWYgKHRoaXMuYXBwU3RvcmUudG8gIT09ICdob21lJykgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdsaWdodCcpO2Vsc2UgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdsaWdodCcpO1xuICAgICAgaWYgKHRoaXMuYXBwU3RvcmUudG8gPT09ICdkZWZhdWx0JykgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdsaWdodCcpOyAvLyBTaG93IGhlYWRlclxuXG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS50byAhPT0gJ2hvbWUnKSBnc2FwLmRlbGF5ZWRDYWxsKDEuMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuYXBwVWkuc2hvd0hlYWRlcigpO1xuICAgICAgfSk7IC8vIEFkZCBiYWNrZ3JvdW5kIGNvbG9yXG5cbiAgICAgIGlmICh0aGlzLmFwcFN0b3JlLnRvID09PSAnaG9tZScgfHwgdGhpcy5hcHBTdG9yZS50byA9PT0gJ3NpbmdsZWNhc2UnIHx8IHRoaXMuYXBwU3RvcmUudG8gPT09ICdkZWZhdWx0JykgdGhpcy5hcHBVaS5nb0xpZ2h0KCk7ZWxzZSB0aGlzLmFwcFVpLmdvRGFyaygpOyAvLyBRdWVyeSBhZG1pbiBiYXIgbGlua3MsIGFuZCBuZXcgcGFnZSdzIGFkbWluIGJhciBsaW5rc1xuXG4gICAgICB2YXIgYWRtaW5CYXJMaW5rcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyN3cGFkbWluYmFyIGEnKTtcbiAgICAgIHZhciBuZXdBZG1pbkJhckxpbmtzID0gdG8ucGFnZS5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJyN3cGFkbWluYmFyIGEnKTsgLy8gUmVwbGFjZSBldmVyeSBhZG1pbiBiYXIgbGluaydzIGhyZWYgdmFsdWUgd2l0aCBuZXcgdmFsdWVcblxuICAgICAgaWYgKGFkbWluQmFyTGlua3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdBZG1pbkJhckxpbmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYWRtaW5CYXJMaW5rc1tpXS5ocmVmID0gbmV3QWRtaW5CYXJMaW5rc1tpXS5ocmVmO1xuICAgICAgICB9IC8vIERldGFjaCBhZG1pbiBiYXIgbGlua3MgZnJvbSBIaWdod2F5IHRyYW5zaXRpb25zXG5cblxuICAgICAgICB0aGlzLmhpZ2h3YXkuZGV0YWNoKGFkbWluQmFyTGlua3MpO1xuICAgICAgfSAvLyB0aGlzLm1hbmFnZVNjcmlwdHModG8pO1xuXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hbmFnZVNjcmlwdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFuYWdlU2NyaXB0cyh0bykge1xuICAgICAgLy8gWW91ciBtYWluIEpTIGZpbGUsIHVzZWQgdG8gcHJlcGVuZCBvdGhlciBzY3JpcHRzXG4gICAgICB2YXIgbWFpbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtYWluLXNjcmlwdCcpO1xuXG4gICAgICB2YXIgYSA9IF90b0NvbnN1bWFibGVBcnJheSh0by5wYWdlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdDpub3QoW2RhdGEtbm8tcmVsb2FkXSknKSk7XG5cbiAgICAgIHZhciBiID0gX3RvQ29uc3VtYWJsZUFycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdDpub3QoW2RhdGEtbm8tcmVsb2FkXSknKSk7IC8vIENvbXBhcmUgU2NyaXB0c1xuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IGJbaV07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGQgPSBhW2pdO1xuXG4gICAgICAgICAgaWYgKGMub3V0ZXJIVE1MID09PSBkLm91dGVySFRNTCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIFNoYWRvdyBTY3JpcHRcbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGMudGFnTmFtZSk7IC8vIExvb3AgT3ZlciBBdHRyaWJ1dGVzXG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYy5hdHRyaWJ1dGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgIC8vIEdldCBBdHRyaWJ1dGVcbiAgICAgICAgICAgICAgdmFyIGF0dHIgPSBjLmF0dHJpYnV0ZXNba107IC8vIFNldCBBdHRyaWJ1dGVcblxuICAgICAgICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKGF0dHIubm9kZU5hbWUsIGF0dHIubm9kZVZhbHVlKTtcbiAgICAgICAgICAgIH0gLy8gSW5saW5lIFNjcmlwdFxuXG5cbiAgICAgICAgICAgIGlmIChjLmlubmVySFRNTCkgc2NyaXB0LmlubmVySFRNTCA9IGMuaW5uZXJIVE1MOyAvLyBSZXBsYWNlXG5cbiAgICAgICAgICAgIGMucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoc2NyaXB0LCBjKTsgLy8gQ2xlYW4gQXJyYXlzXG5cbiAgICAgICAgICAgIGIuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYS5zcGxpY2UoaiwgMSk7IC8vIEV4aXQgTG9vcFxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmVtb3ZlIFVzZWxlc3NcblxuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYiksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zY3JpcHQgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIC8vIFJlbW92ZVxuICAgICAgICAgIF9zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfc2NyaXB0KTtcbiAgICAgICAgfSAvLyBBZGQgU2NyaXB0c1xuXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYSksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc2NyaXB0MiA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICB2YXIgbG9jID0gX3NjcmlwdDIucGFyZW50Tm9kZS50YWdOYW1lO1xuICAgICAgICAgIGlmIChsb2MgPT09ICdIRUFEJykgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChfc2NyaXB0Mik7XG4gICAgICAgICAgaWYgKGxvYyA9PT0gJ0JPRFknKSBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShfc2NyaXB0MiwgbWFpbik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0b3JzKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2ZW50cygpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICB9LCB7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUod2lkdGgsIGhlaWdodCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIH1dKTtcblxuICByZXR1cm4gYXBwQ29yZTtcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgYXBwQ29yZTsiLCIvL0NvcHlyaWdodCAyMDE4IFZpY2VudGUgTHVjZW5kbyAtIHZpY2VuQHZsdWNlbmRvLmNvbVxuLy9zaW1wbGUgZGVib3VuY2Ugd2l0aCBjYWxsYmFja1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGNhbGxiYWNrLCBkZWxheSkge1xuICB2YXIgdGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5KTtcbiAgfTtcbn1cbjsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8vIGNzc1xuaW1wb3J0IGNzcyBmcm9tICcuLi8uLi9jc3Mvc3R5bGVzLmNzcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbi8vIEFwcFxuXG5pbXBvcnQgYXBwU3RvcmUgZnJvbSAnLi9hcHBTdG9yZSc7XG5pbXBvcnQgYXBwQ29yZSBmcm9tICcuL2FwcENvcmUnO1xuaW1wb3J0IGFwcFVpIGZyb20gJy4vYXBwVWknOyAvLyBDbGFzc2VzXG5cbmltcG9ydCBkb21FdmVudHMgZnJvbSAnLi4vY2xhc3Nlcy9kb21FdmVudHMnOyAvLyBHU0FQIExpYnJhcnlcbi8vIGltcG9ydCBnc2FwIGZyb20gJ2dzYXAnO1xuLy8gVXRpbHNcblxuaW1wb3J0IERlYm91bmNlIGZyb20gJy4uL3V0aWxzL2RlYm91bmNlJztcbmltcG9ydCBCb3dzZXIgZnJvbSAnYm93c2VyJztcblxudmFyIEFwcGxpY2F0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXBwbGljYXRpb24ob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBcHBsaWNhdGlvbik7XG5cbiAgICAvLyBTdG9yZVxuICAgIHRoaXMuYXBwU3RvcmUgPSBhcHBTdG9yZTsgLy8gQXBwIHJlZmVyZW5jZXNcblxuICAgIHRoaXMuYXBwQ29yZSA9IG5ldyBhcHBDb3JlKCk7XG4gICAgdGhpcy5hcHBVaSA9IG5ldyBhcHBVaSgpOyAvLyBFdmVudHNcblxuICAgIHRoaXMuZG9tRXZlbnRzID0gbmV3IGRvbUV2ZW50cygpOyAvLyBHZXQgY3VycmVudCB1cmxcblxuICAgIHRoaXMuYXBwU3RvcmUucm9vdFVybCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArICcvLyAnICsgd2luZG93LmxvY2F0aW9uLmhvc3Q7IC8vIEdldCBjbGllbnQgaW5mb1xuXG4gICAgdmFyIGNsaWVudEluZm8gPSBCb3dzZXIuZ2V0UGFyc2VyKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KS5wYXJzZWRSZXN1bHQ7XG4gICAgdGhpcy5zZXRPUyhjbGllbnRJbmZvKTtcbiAgICB0aGlzLnNldERldmljZShjbGllbnRJbmZvKTtcbiAgICB0aGlzLmNoZWNrRWxlbWVudHMoKTtcbiAgICB0aGlzLmFkZENsYXNzZXMoKTtcbiAgICB0aGlzLnNheUhlbGxvKCk7XG4gICAgdGhpcy5zZWxlY3RvcnMoKTtcbiAgICB0aGlzLmV2ZW50cygpO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFwcGxpY2F0aW9uLCBbe1xuICAgIGtleTogXCJzZXRPU1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPUyhjbGllbnRJbmZvKSB7XG4gICAgICB2YXIgb3MgPSBjbGllbnRJbmZvLm9zLm5hbWUudG9Mb3dlckNhc2UoKTsgLy8gRGV0ZWN0IG1hYyBhbmQgaW9zLCBkZWZhdWx0IHdpbmRvd3NcblxuICAgICAgc3dpdGNoIChvcykge1xuICAgICAgICBjYXNlICdtYWNvcyc6XG4gICAgICAgICAgdGhpcy5hcHBTdG9yZS5jbGllbnQub3MgPSAnbWFjJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdpb3MnOlxuICAgICAgICAgIHRoaXMuYXBwU3RvcmUuY2xpZW50Lm9zID0gJ2lvcyc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLmFwcFN0b3JlLmNsaWVudC5vcyA9ICd3aW5kb3dzJztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RGV2aWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERldmljZShjbGllbnRJbmZvKSB7XG4gICAgICAvLyBHZXQgZGV2aWNlXG4gICAgICB0aGlzLmFwcFN0b3JlLmNsaWVudC5kZXZpY2UgPSBjbGllbnRJbmZvLnBsYXRmb3JtLnR5cGUgPT09ICdkZXNrdG9wJyA/ICdkZXNrdG9wJyA6ICdtb2JpbGUnOyAvLyBEZXRlY3QgYnJvd3NlciAob25seSB0aGUgbWFqb3Igb25lcywgZGVmYXVsdCBpcyBjaHJvbWUpXG5cbiAgICAgIHN3aXRjaCAoY2xpZW50SW5mby5icm93c2VyLm5hbWUpIHtcbiAgICAgICAgY2FzZSAnSW50ZXJuZXQgRXhwbG9yZXInOlxuICAgICAgICAgIHRoaXMuYXBwU3RvcmUuY2xpZW50LmJyb3dzZXIgPSAnZXhwbG9yZXInO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ01pY3Jvc29mdCBFZGdlJzpcbiAgICAgICAgICB0aGlzLmFwcFN0b3JlLmNsaWVudC5icm93c2VyID0gJ2VkZ2UnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0ZpcmVmb3gnOlxuICAgICAgICAgIHRoaXMuYXBwU3RvcmUuY2xpZW50LmJyb3dzZXIgPSAnZmlyZWZveCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnU2FmYXJpJzpcbiAgICAgICAgICB0aGlzLmFwcFN0b3JlLmNsaWVudC5icm93c2VyID0gJ3NhZmFyaSc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLmFwcFN0b3JlLmNsaWVudC5icm93c2VyID0gJ2Nocm9tZSc7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tFbGVtZW50cygpIHtcbiAgICAgIGlmICh0aGlzLmFwcFN0b3JlLmlzRGVza3RvcCkge1xuICAgICAgICB0aGlzLiRlbGVtZW50c01vYmlsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW1vYmlsZV0nKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuJGVsZW1lbnRzTW9iaWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudHNNb2JpbGVbaV0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnRzRGVza3RvcCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWRlc2t0b3BdJyk7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuJGVsZW1lbnRzRGVza3RvcC5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50c0Rlc2t0b3BbX2ldLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZENsYXNzZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ2xhc3NlcygpIHtcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMuYXBwU3RvcmUuY2xpZW50LmRldmljZSk7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGlzLmFwcFN0b3JlLmNsaWVudC5vcyk7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGlzLmFwcFN0b3JlLmNsaWVudC5icm93c2VyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2F5SGVsbG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2F5SGVsbG8oKSB7XG4gICAgICBpZiAodGhpcy5hcHBTdG9yZS5jbGllbnQuYnJvd3NlciA9PT0gJ2Nocm9tZScgfHwgdGhpcy5hcHBTdG9yZS5jbGllbnQuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnKSB7XG4gICAgICAgIHZhciBhcmdzID0gWydcXG4lYyBEZXZlbG9wZWQgd2l0aCDimaUgYnkgRGdyZWVzwq4gLSBodHRwczovLyBkZ3JlZXMuc3R1ZGlvICVjXFxuJywgJ2Rpc3BsYXk6IGJsb2NrOyBwYWRkaW5nOiA1cHggMTBweDsgYmFja2dyb3VuZDogIzAwMDAyMjsgbGluZS1oZWlnaHQ6IDQwcHg7IGNvbG9yOiAjZmZmZmZmOycsICdiYWNrZ3JvdW5kOiAjZmZmOyddO1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coJ0RldmVsb3BlZCBieSBEZ3JlZXPCricpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0b3JzKCkge1xuICAgICAgdGhpcy5hcHBDb3JlLnNlbGVjdG9ycygpO1xuICAgICAgdGhpcy5hcHBVaS5zZWxlY3RvcnMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIEJpbmQgZGVib3VuY2VkIHJlc2l6ZVxuICAgICAgdGhpcy5kb21FdmVudHMuYWRkKHdpbmRvdywgJ3Jlc2l6ZScsIERlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucmVzaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgfSwgMTUwKSk7XG4gICAgICB0aGlzLmFwcENvcmUuZXZlbnRzKCk7XG4gICAgICB0aGlzLmFwcFVpLmV2ZW50cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLmFwcENvcmUuaW5pdCgpO1xuICAgICAgdGhpcy5hcHBVaS5pbml0KCk7IC8vIEZpcnN0IHdlIGdldCB0aGUgdmlld3BvcnQgaGVpZ2h0IGFuZCB3ZSBtdWx0aXBsZSBpdCBieSAxJSB0byBnZXQgYSB2YWx1ZSBmb3IgYSB2aCB1bml0XG5cbiAgICAgIHZhciB2aCA9IHdpbmRvdy5pbm5lckhlaWdodCAqIDAuMDE7XG4gICAgICB0aGlzLmFwcFN0b3JlLnZhcnMudmggPSB2aCAqIDEwMDtcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS12aCcsIFwiXCIuY29uY2F0KHZoLCBcInB4XCIpKTtcbiAgICAgIHZhciB2aG8gPSB3aW5kb3cub3V0ZXJIZWlnaHQgKiAwLjAxO1xuICAgICAgdGhpcy5hcHBTdG9yZS52YXJzLnZobyA9IHZobyAqIDEwMDtcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS12aG8nLCBcIlwiLmNvbmNhdCh2aG8sIFwicHhcIikpO1xuICAgICAgdmFyIHZociA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aHInKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgKiAwLjAxO1xuICAgICAgdGhpcy5hcHBTdG9yZS52YXJzLnZociA9IHZociAqIDEwMDtcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS12aHInLCBcIlwiLmNvbmNhdCh2aHIsIFwicHhcIikpO1xuICAgICAgdmFyIHZoZCA9IHZociAtIHZoO1xuICAgICAgdGhpcy5hcHBTdG9yZS52YXJzLnZoZCA9IHZoZCAqIDEwMDtcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS12aGQnLCBcIlwiLmNvbmNhdCh2aGQsIFwicHhcIikpO1xuICAgICAgdGhpcy5yZXNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgLy8gRmlyc3Qgd2UgZ2V0IHRoZSB2aWV3cG9ydCBoZWlnaHQgYW5kIHdlIG11bHRpcGxlIGl0IGJ5IDElIHRvIGdldCBhIHZhbHVlIGZvciBhIHZoIHVuaXRcbiAgICAgIHZhciB2aCA9IHdpbmRvdy5pbm5lckhlaWdodCAqIDAuMDE7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJy0tdmgnLCBcIlwiLmNvbmNhdCh2aCwgXCJweFwiKSk7IC8vIFNldCBzaXplIHZhcnNcblxuICAgICAgdGhpcy5hcHBTdG9yZS5jbGllbnQuc2l6ZXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuYXBwU3RvcmUuY2xpZW50LnNpemVzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuYXBwQ29yZS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmFwcFVpLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGlmICh0aGlzLmFwcFN0b3JlLmN1cnJlbnRTZWN0aW9uICE9PSBudWxsKSB0aGlzLmFwcFN0b3JlLmN1cnJlbnRTZWN0aW9uLmJlZm9yZVJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgLyogX2NoZWNrT3JpZW50YXRpb24oKVxuICAgIHtcbiAgICAgICAgLy8gaWYgaXQncyBub3QgYWZmZWN0ZWQgYnkgb3JpZW50YXRpb24gcGFzcyB0aGUgY3VycmVudCBvbmUgKDA6IGhvcml6b250YWwsIDE6IHZlcnRpY2FsKVxuICAgICAgICBpZih0aGlzLm9yaWVudGF0aW9uID09PSBvcmllbnRhdGlvbnMuTk9ORSlcbiAgICAgICAgICAgIHRoaXMuLy8gKHRoaXMuYXBwU3RvcmUuY2xpZW50LnNpemVzLndpZHRoID4gdGhpcy5hcHBTdG9yZS5jbGllbnQuc2l6ZXMuaGVpZ2h0ID8gMCA6IDEpO1xuICAgICAgICAgaWYodGhpcy5vcmllbnRhdGlvbiA9PT0gb3JpZW50YXRpb25zLlZFUlRJQ0FMKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBpZiB3aWR0aCBpcyBiaWdnZXIgdGhhbiBoZWlnaHRcbiAgICAgICAgICAgIGlmKHRoaXMuYXBwU3RvcmUuY2xpZW50LnNpemVzLndpZHRoID4gdGhpcy5hcHBTdG9yZS5jbGllbnQuc2l6ZXMuaGVpZ2h0KVxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlRGV2aWNlKHRydWUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlRGV2aWNlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHRoaXMub3JpZW50YXRpb24gPT09IG9yaWVudGF0aW9ucy5IT1JJWk9OVEFMKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBpZiBoZWlnaHQgaXMgYmlnZ2VyIHRoYW4gd2lkdGhcbiAgICAgICAgICAgIGlmKHRoaXMuYXBwU3RvcmUuY2xpZW50LnNpemVzLmhlaWdodCA+IHRoaXMuYXBwU3RvcmUuY2xpZW50LnNpemVzLndpZHRoKVxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlRGV2aWNlKHRydWUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlRGV2aWNlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0gKi9cbiAgICAvLyByb3RhdGVEZXZpY2UoYWN0aW9uKXt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICB9XSk7XG5cbiAgcmV0dXJuIEFwcGxpY2F0aW9uO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBBcHBsaWNhdGlvbjsiLCIvLyBhcHBzXG5pbXBvcnQgQXBwbGljYXRpb24gZnJvbSAnLi9hcHAvYXBwJzsgLy8gb24gZG9jdW1lbnQgcmVhZHkgY3JlYXRlIGxvYWRlclxuXG5pZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2xvYWRpbmcnKSB7XG4gIHZhciBhcHAgPSBuZXcgQXBwbGljYXRpb24oKTtcbn0gZWxzZSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFwcCA9IG5ldyBBcHBsaWNhdGlvbigpO1xuICB9LCBmYWxzZSk7IC8vZXNsaW50LWRpc2FibGUtbGluZVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6495\n'
            );
        },
    },
        __webpack_module_cache__ = {},
        deferred;
    function __webpack_require__(g) {
        var t = __webpack_module_cache__[g];
        if (void 0 !== t) return t.exports;
        var I = (__webpack_module_cache__[g] = { exports: {} });
        return __webpack_modules__[g].call(I.exports, I, I.exports, __webpack_require__), I.exports;
    }
    (__webpack_require__.m = __webpack_modules__),
        (__webpack_require__.amdO = {}),
        (deferred = []),
        (__webpack_require__.O = (g, t, I, n) => {
            if (!t) {
                var e = 1 / 0;
                for (C = 0; C < deferred.length; C++) {
                    for (var [t, I, n] = deferred[C], l = !0, c = 0; c < t.length; c++) (!1 & n || e >= n) && Object.keys(__webpack_require__.O).every((g) => __webpack_require__.O[g](t[c])) ? t.splice(c--, 1) : ((l = !1), n < e && (e = n));
                    if (l) {
                        deferred.splice(C--, 1);
                        var i = I();
                        void 0 !== i && (g = i);
                    }
                }
                return g;
            }
            n = n || 0;
            for (var C = deferred.length; C > 0 && deferred[C - 1][2] > n; C--) deferred[C] = deferred[C - 1];
            deferred[C] = [t, I, n];
        }),
        (__webpack_require__.n = (g) => {
            var t = g && g.__esModule ? () => g.default : () => g;
            return __webpack_require__.d(t, { a: t }), t;
        }),
        (__webpack_require__.d = (g, t) => {
            for (var I in t) __webpack_require__.o(t, I) && !__webpack_require__.o(g, I) && Object.defineProperty(g, I, { enumerable: !0, get: t[I] });
        }),
        (__webpack_require__.g = (function () {
            if ("object" == typeof globalThis) return globalThis;
            try {
                return this || new Function("return this")();
            } catch (g) {
                if ("object" == typeof window) return window;
            }
        })()),
        (__webpack_require__.o = (g, t) => Object.prototype.hasOwnProperty.call(g, t)),
        (() => {
            var g = { 143: 0 };
            __webpack_require__.O.j = (t) => 0 === g[t];
            var t = (t, I) => {
                var n,
                    e,
                    [l, c, i] = I,
                    C = 0;
                if (l.some((t) => 0 !== g[t])) {
                    for (n in c) __webpack_require__.o(c, n) && (__webpack_require__.m[n] = c[n]);
                    if (i) var o = i(__webpack_require__);
                }
                for (t && t(I); C < l.length; C++) (e = l[C]), __webpack_require__.o(g, e) && g[e] && g[e][0](), (g[l[C]] = 0);
                return __webpack_require__.O(o);
            },
                I = (self.webpackChunkmioticonsulting = self.webpackChunkmioticonsulting || []);
            I.forEach(t.bind(null, 0)), (I.push = t.bind(null, I.push.bind(I)));
        })();
    var __webpack_exports__ = __webpack_require__.O(void 0, [736], () => __webpack_require__(6495));
    __webpack_exports__ = __webpack_require__.O(__webpack_exports__);
})();
