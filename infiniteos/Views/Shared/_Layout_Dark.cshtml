<!DOCTYPE html>
<html lang="en">
<head>

    <meta name="google" content="notranslate">
    <meta charset="UTF-8">
    <title>Infinite Outsourcing System</title>
    <link href="~/favicon.ico" rel="shortcut icon">
    <link href="~/css/style.css" rel="stylesheet">
    <link href="~/css/site.css" rel="stylesheet" />
    <style>
        .words .words__gradient {
            background: rgb(0,0,0);
            background: -moz-linear-gradient(180deg, rgba(0,0,0,1) 0%,rgba(0,0,0,0.95) 20%, rgba(0,0,0,0.90) 25%,rgba(0,0,0,0.85) 30%,rgba(0,0,0,0.80) 35%, rgba(0,0,0,0) 45%, rgba(0,0,0,0) 55%, rgba(0,0,0,0.80) 65%,rgba(0,0,0,0.85) 70%, rgba(0,0,0,0.90) 75%,rgba(0,0,0,0.95) 80%, rgba(0,0,0,1) 100%);
            background: -webkit-linear-gradient(180deg, rgba(0,0,0,1) 0%,rgba(0,0,0,0.95) 20%, rgba(0,0,0,0.90) 25%,rgba(0,0,0,0.85) 30%,rgba(0,0,0,0.80) 35%, rgba(0,0,0,0) 45%, rgba(0,0,0,0) 55%, rgba(0,0,0,0.80) 65%,rgba(0,0,0,0.85) 70%, rgba(0,0,0,0.90) 75%,rgba(0,0,0,0.95) 80%, rgba(0,0,0,1) 100%);
            background: linear-gradient(180deg, rgba(0,0,0,1) 0%,rgba(0,0,0,0.95) 20%, rgba(0,0,0,0.90) 25%,rgba(0,0,0,0.85) 30%,rgba(0,0,0,0.80) 35%, rgba(0,0,0,0) 45%, rgba(0,0,0,0) 55%, rgba(0,0,0,0.80) 65%,rgba(0,0,0,0.85) 70%, rgba(0,0,0,0.90) 75%,rgba(0,0,0,0.95) 80%, rgba(0,0,0,1) 100%);
            filter: progid:DXImageTransform.Microsoft.gradient(startColorstr="#000000",endColorstr="#000000",GradientType=1);
        }
    </style>
</head>
<body class="page-template page-template-template-data page-template-template-data-php page page-id-13 page-data-strategy">


    @RenderBody()


    @Html.Partial("_MenuBar")



    <script charset="utf-8" type="text/javascript" src="~/js/v2.js"></script>
    <script type="text/javascript" src="~/js/vendor.min.js" id="vendor-script" data-no-reload></script>
    <script type="text/javascript" src="~/js/app.min.js" id="main-script" data-no-reload></script>
    @await RenderSectionAsync("Scripts", required: false)
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- WebGL footer dots animation ---
        const canvas = document.getElementById('webgl-canvas');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / document.querySelector('footer').clientHeight,
          0.1,
          1000
        );
        camera.position.z = 7;

               const renderer = new THREE.WebGLRenderer({
          canvas,          // An existing <canvas> element to use
          alpha: true,     // Makes the background transparent (default: false)
          antialias: true, // Enables MSAA anti-aliasing (default: false)
          precision: 'lowp', // Shader precision: 'highp', 'mediump', or 'lowp'
          premultipliedAlpha: true, // Controls how alpha blending is handled
          preserveDrawingBuffer: false, // If true, the drawing buffer won't be cleared after rendering (useful for screenshots)
          powerPreference: 'default', // Can be 'default', 'high-performance', or 'low-power'
          stencil: true,   // Enable stencil buffer (default: true)
          depth: true,     // Enable depth buffer (default: true)
          logarithmicDepthBuffer: false, // Useful for very large scenes (default: false)
          failIfMajorPerformanceCaveat: false // Prevents fallback to software rendering (default: false)
        });
        renderer.setClearColor(0x111111, 0);
        resizeRenderer();

        const particlesCount = 500;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particlesCount * 3);

        for (let i = 0; i < particlesCount; i++) {
          positions[i * 3] = (Math.random() - 0.5) * 20;
          positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
          color: 0x007eff,
          size: 0.05,
          sizeAttenuation: true,
          transparent: true,
          opacity: 0.7,
          map: createCircleTexture(),  // <-- add this line
          alphaTest: 0.5
              });

        const points = new THREE.Points(geometry, material);
        scene.add(points);

        let rotationSpeedX = 0.0008;
        let rotationSpeedY = 0.0012;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let currentRotationX = 0;
        let currentRotationY = 0;

        function animate() {
          requestAnimationFrame(animate);
          currentRotationX += (targetRotationX - currentRotationX) * 0.05;
          currentRotationY += (targetRotationY - currentRotationY) * 0.05;
          points.rotation.x += rotationSpeedX + currentRotationX;
          points.rotation.y += rotationSpeedY + currentRotationY;
          renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', resizeRenderer);
        function resizeRenderer() {
          const footer = document.querySelector('footer');
          const width = window.innerWidth;
          const height = footer.clientHeight;
          renderer.setSize(width, height);
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
        }

        let lastScrollY = window.scrollY;
        window.addEventListener('scroll', () => {
          const currentScrollY = window.scrollY;
          const delta = currentScrollY - lastScrollY;
          lastScrollY = currentScrollY;

          rotationSpeedX += delta * 0.00001;
          rotationSpeedY += delta * 0.000015;

          rotationSpeedX = Math.min(Math.max(rotationSpeedX, 0.0001), 0.01);
          rotationSpeedY = Math.min(Math.max(rotationSpeedY, 0.0001), 0.015);
        });

        window.addEventListener('mousemove', (event) => {
          const footer = document.querySelector('footer');
          const rect = footer.getBoundingClientRect();
          const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          const mouseY = ((event.clientY - rect.top) / rect.height) * 2 - 1;
          targetRotationY = mouseX * 0.02;
          targetRotationX = mouseY * 0.01;
        });





        window.addEventListener('scroll', () => {
          const currentScroll = window.scrollY;
          const delta = currentScroll - lastScrollPos;
          lastScrollPos = currentScroll;

          if (delta !== 0) {
            updateVisibleWords(delta);
          }
        });

                function createCircleTexture() {
          const size = 56;
          const canvas = document.createElement('canvas');
          canvas.width = size;
          canvas.height = size;

          const ctx = canvas.getContext('2d');
          const center = size / 2;
          const radius = size / 2;

          ctx.clearRect(0, 0, size, size);
          ctx.beginPath();
          ctx.arc(center, center, radius, 0, 2 * Math.PI, false);
          ctx.fillStyle = 'white';
          ctx.fill();

          const texture = new THREE.CanvasTexture(canvas);
          return texture;
        }
    </script>
</body>
</html>
