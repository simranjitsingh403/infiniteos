<!DOCTYPE html>
<html lang="en">
<head>

    <meta name="google" content="notranslate">
    <meta charset="UTF-8">
    <title>Infinite Outsourcing System</title>
    <link href="~/favicon.ico" rel="shortcut icon">
    <link href="~/css/style.css" rel="stylesheet">
    <link href="~/css/site.css" rel="stylesheet" />
    <style>
        .words .words__gradient {
            background: rgb(0,0,0);
            background: -moz-linear-gradient(180deg, rgba(0,0,0,1) 0%,rgba(0,0,0,0.95) 20%, rgba(0,0,0,0.90) 25%,rgba(0,0,0,0.85) 30%,rgba(0,0,0,0.80) 35%, rgba(0,0,0,0) 45%, rgba(0,0,0,0) 55%, rgba(0,0,0,0.80) 65%,rgba(0,0,0,0.85) 70%, rgba(0,0,0,0.90) 75%,rgba(0,0,0,0.95) 80%, rgba(0,0,0,1) 100%);
            background: -webkit-linear-gradient(180deg, rgba(0,0,0,1) 0%,rgba(0,0,0,0.95) 20%, rgba(0,0,0,0.90) 25%,rgba(0,0,0,0.85) 30%,rgba(0,0,0,0.80) 35%, rgba(0,0,0,0) 45%, rgba(0,0,0,0) 55%, rgba(0,0,0,0.80) 65%,rgba(0,0,0,0.85) 70%, rgba(0,0,0,0.90) 75%,rgba(0,0,0,0.95) 80%, rgba(0,0,0,1) 100%);
            background: linear-gradient(180deg, rgba(0,0,0,1) 0%,rgba(0,0,0,0.95) 20%, rgba(0,0,0,0.90) 25%,rgba(0,0,0,0.85) 30%,rgba(0,0,0,0.80) 35%, rgba(0,0,0,0) 45%, rgba(0,0,0,0) 55%, rgba(0,0,0,0.80) 65%,rgba(0,0,0,0.85) 70%, rgba(0,0,0,0.90) 75%,rgba(0,0,0,0.95) 80%, rgba(0,0,0,1) 100%);
            filter: progid:DXImageTransform.Microsoft.gradient(startColorstr="#000000",endColorstr="#000000",GradientType=1);
        }
    </style>
</head>
<body class="page-template page-template-template-data page-template-template-data-php page page-id-13 page-data-strategy">


    @RenderBody()


    @Html.Partial("_MenuBar")



    <script charset="utf-8" type="text/javascript" src="~/js/v2.js"></script>
    <script type="text/javascript" src="~/js/vendor.min.js" id="vendor-script" data-no-reload></script>
    @* <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.6.1/gsap.min.js"></script> *@
    <script type="text/javascript" src="~/js/app.min.js" id="main-script" data-no-reload></script>
    @await RenderSectionAsync("Scripts", required: false)
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const canvas = document.getElementById('webgl-canvas');
        const ctx = canvas.getContext('2d');
        const footer = document.getElementById('footer');

        let time = 0;
        const rings = [];

        function resizeCanvas() {
          const rect = footer.getBoundingClientRect();
          canvas.width = rect.width;
          canvas.height = rect.height;
          setupRings();
        }

        function setupRings() {
          rings.length = 0; // clear old
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          const maxRadius = Math.sqrt(centerX ** 2 + centerY ** 2);
          const ringSpacing = 45;

          for (let r = ringSpacing; r < maxRadius; r += ringSpacing) {
            rings.push({
              radius: r,
              rotation: Math.random() * Math.PI * 2,
              speed: 0.001 + Math.random() * 0.002, // static speed per ring
            });
          }
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function draw() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          const dotsPerRing = 80;

          time += 0.01;

          rings.forEach((ring, index) => {
            const dynamicRadius = ring.radius + Math.sin(time + index) * 2;
            ring.rotation += ring.speed;

            for (let i = 0; i < dotsPerRing; i++) {
              const angle = (i / dotsPerRing) * Math.PI * 2 + ring.rotation;

              const x = centerX + Math.cos(angle) * dynamicRadius;
              const y = centerY + Math.sin(angle) * dynamicRadius;

              const flicker = Math.sin(time * 2 + i + index);
              const size = 1.5 + flicker * 0.5;
              const opacity = 0.4 + 0.6 * Math.abs(flicker);

              ctx.beginPath();
              ctx.arc(x, y, size, 0, Math.PI * 2);
              ctx.fillStyle = `rgba(6, 147, 227, ${opacity})`;
              ctx.fill();
            }
          });

          requestAnimationFrame(draw);
        }

        draw();
    </script>
    <script type="module">
        document.addEventListener("DOMContentLoaded", () => {
            const canvas = document.getElementById("webgl-canvas-About-us");
            const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;

            const group = new THREE.Group();
            scene.add(group);

            const ringCount = 1000;            // Number of rings
            const dotsPerRing = 50;          // Dots per ring
            const ringSpacing = 0.1;          // Distance between rings
            const dotSize = 0.05;

            const rings = [];

            for (let r = 1; r <= ringCount; r++) {
                const radius = r * ringSpacing;
                const positions = [];
                for (let i = 0; i < dotsPerRing; i++) {
                    const angle = (i / dotsPerRing) * Math.PI * 2;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    positions.push(x, y, 0);
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));

                const material = new THREE.PointsMaterial({
                    color: new THREE.Color(`hsl(${(r * 5) % 360}, 100%, 70%)`),
                    size: dotSize,
                    transparent: true,
                    opacity: 0.5 + Math.random() * 0.3,
                    depthWrite: false
                });

                const ring = new THREE.Points(geometry, material);
                ring.userData = { speed: 0.001 + Math.random() * 0.003 };
                rings.push(ring);
                group.add(ring);
            }

            // Animate
            function animate(time) {
                requestAnimationFrame(animate);

                rings.forEach((ring, i) => {
                    ring.rotation.z += ring.userData.speed;

                    // Shift color hue over time
                    const hue = (time * 0.0001 + i * 0.005) % 1;
                    ring.material.color.setHSL(hue, 1, 0.6);
                });

                renderer.render(scene, camera);
            }

            animate();

            // Handle resize
            window.addEventListener("resize", () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        });
    </script>

</body>
</html>
